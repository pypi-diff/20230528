# Comparing `tmp/parsetypes-0.1.1.tar.gz` & `tmp/parsetypes-0.2.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "parsetypes-0.1.1.tar", last modified: Sun May 28 04:42:49 2023, max compression
+gzip compressed data, was "parsetypes-0.2.tar", last modified: Sun May 28 04:50:28 2023, max compression
```

## Comparing `parsetypes-0.1.1.tar` & `parsetypes-0.2.tar`

### file list

```diff
@@ -1,28 +1,29 @@
-drwxrwxrwx   0        0        0        0 2023-05-28 04:42:49.626609 parsetypes-0.1.1/
--rw-rw-rw-   0        0        0      648 2023-05-28 04:42:14.000000 parsetypes-0.1.1/CHANGELOG.md
--rw-rw-rw-   0        0        0       22 2023-05-28 02:54:36.000000 parsetypes-0.1.1/MANIFEST.in
--rw-rw-rw-   0        0        0     6408 2023-05-28 04:42:49.626609 parsetypes-0.1.1/PKG-INFO
--rw-rw-rw-   0        0        0     4105 2023-05-28 04:40:52.000000 parsetypes-0.1.1/README.md
-drwxrwxrwx   0        0        0        0 2023-05-28 04:42:49.612610 parsetypes-0.1.1/docs/
-drwxrwxrwx   0        0        0        0 2023-05-28 04:42:49.618610 parsetypes-0.1.1/docs/html/
--rw-rw-rw-   0        0        0     1729 2023-05-28 04:42:40.000000 parsetypes-0.1.1/docs/html/favicon.png
--rw-rw-rw-   0        0        0      141 2023-05-28 04:42:39.000000 parsetypes-0.1.1/docs/html/index.html
--rw-rw-rw-   0        0        0   535827 2023-05-28 04:42:39.000000 parsetypes-0.1.1/docs/html/parsetypes.html
--rw-rw-rw-   0        0        0   245337 2023-05-28 04:42:40.000000 parsetypes-0.1.1/docs/html/search.js
--rw-rw-rw-   0        0        0     2255 2023-05-28 04:40:52.000000 parsetypes-0.1.1/pyproject.toml
--rw-rw-rw-   0        0        0       42 2023-05-28 04:42:49.626609 parsetypes-0.1.1/setup.cfg
-drwxrwxrwx   0        0        0        0 2023-05-28 04:42:49.612610 parsetypes-0.1.1/src/
-drwxrwxrwx   0        0        0        0 2023-05-28 04:42:49.621610 parsetypes-0.1.1/src/parsetypes/
--rw-rw-rw-   0        0        0      621 2023-05-28 04:42:23.000000 parsetypes-0.1.1/src/parsetypes/__init__.py
--rw-rw-rw-   0        0        0     1772 2023-05-28 04:40:39.000000 parsetypes-0.1.1/src/parsetypes/_common.py
--rw-rw-rw-   0        0        0    34461 2023-05-28 04:40:39.000000 parsetypes-0.1.1/src/parsetypes/_parser.py
--rw-rw-rw-   0        0        0     5272 2023-05-28 04:40:39.000000 parsetypes-0.1.1/src/parsetypes/_reduce_types.py
-drwxrwxrwx   0        0        0        0 2023-05-28 04:42:49.624608 parsetypes-0.1.1/src/parsetypes.egg-info/
--rw-rw-rw-   0        0        0     6408 2023-05-28 04:42:49.000000 parsetypes-0.1.1/src/parsetypes.egg-info/PKG-INFO
--rw-rw-rw-   0        0        0      486 2023-05-28 04:42:49.000000 parsetypes-0.1.1/src/parsetypes.egg-info/SOURCES.txt
--rw-rw-rw-   0        0        0        1 2023-05-28 04:42:49.000000 parsetypes-0.1.1/src/parsetypes.egg-info/dependency_links.txt
--rw-rw-rw-   0        0        0      296 2023-05-28 04:42:49.000000 parsetypes-0.1.1/src/parsetypes.egg-info/requires.txt
--rw-rw-rw-   0        0        0       11 2023-05-28 04:42:49.000000 parsetypes-0.1.1/src/parsetypes.egg-info/top_level.txt
-drwxrwxrwx   0        0        0        0 2023-05-28 04:42:49.625609 parsetypes-0.1.1/tests/
--rw-rw-rw-   0        0        0    60035 2023-05-28 04:40:39.000000 parsetypes-0.1.1/tests/test_parser.py
--rw-rw-rw-   0        0        0     8822 2023-05-28 04:40:39.000000 parsetypes-0.1.1/tests/test_reduce_types.py
+drwxrwxrwx   0        0        0        0 2023-05-28 04:50:28.710326 parsetypes-0.2/
+-rw-rw-rw-   0        0        0      747 2023-05-28 04:49:12.000000 parsetypes-0.2/CHANGELOG.md
+-rw-rw-rw-   0        0        0       22 2023-05-28 02:54:36.000000 parsetypes-0.2/MANIFEST.in
+-rw-rw-rw-   0        0        0     6555 2023-05-28 04:50:28.709037 parsetypes-0.2/PKG-INFO
+-rw-rw-rw-   0        0        0     4105 2023-05-28 04:40:52.000000 parsetypes-0.2/README.md
+drwxrwxrwx   0        0        0        0 2023-05-28 04:50:28.694493 parsetypes-0.2/docs/
+drwxrwxrwx   0        0        0        0 2023-05-28 04:50:28.702037 parsetypes-0.2/docs/html/
+-rw-rw-rw-   0        0        0     1729 2023-05-28 04:50:19.000000 parsetypes-0.2/docs/html/favicon.png
+-rw-rw-rw-   0        0        0      141 2023-05-28 04:50:19.000000 parsetypes-0.2/docs/html/index.html
+-rw-rw-rw-   0        0        0   514563 2023-05-28 04:50:19.000000 parsetypes-0.2/docs/html/parsetypes.html
+-rw-rw-rw-   0        0        0   222085 2023-05-28 04:50:19.000000 parsetypes-0.2/docs/html/search.js
+-rw-rw-rw-   0        0        0     2297 2023-05-28 04:48:55.000000 parsetypes-0.2/pyproject.toml
+-rw-rw-rw-   0        0        0       42 2023-05-28 04:50:28.710326 parsetypes-0.2/setup.cfg
+drwxrwxrwx   0        0        0        0 2023-05-28 04:50:28.694493 parsetypes-0.2/src/
+drwxrwxrwx   0        0        0        0 2023-05-28 04:50:28.705036 parsetypes-0.2/src/parsetypes/
+-rw-rw-rw-   0        0        0      619 2023-05-28 04:49:41.000000 parsetypes-0.2/src/parsetypes/__init__.py
+-rw-rw-rw-   0        0        0     1759 2023-05-28 04:48:55.000000 parsetypes-0.2/src/parsetypes/_common.py
+-rw-rw-rw-   0        0        0      348 2023-05-28 04:48:55.000000 parsetypes-0.2/src/parsetypes/_compat.py
+-rw-rw-rw-   0        0        0    34450 2023-05-28 04:48:55.000000 parsetypes-0.2/src/parsetypes/_parser.py
+-rw-rw-rw-   0        0        0     5345 2023-05-28 04:48:55.000000 parsetypes-0.2/src/parsetypes/_reduce_types.py
+drwxrwxrwx   0        0        0        0 2023-05-28 04:50:28.708037 parsetypes-0.2/src/parsetypes.egg-info/
+-rw-rw-rw-   0        0        0     6555 2023-05-28 04:50:28.000000 parsetypes-0.2/src/parsetypes.egg-info/PKG-INFO
+-rw-rw-rw-   0        0        0      512 2023-05-28 04:50:28.000000 parsetypes-0.2/src/parsetypes.egg-info/SOURCES.txt
+-rw-rw-rw-   0        0        0        1 2023-05-28 04:50:28.000000 parsetypes-0.2/src/parsetypes.egg-info/dependency_links.txt
+-rw-rw-rw-   0        0        0      296 2023-05-28 04:50:28.000000 parsetypes-0.2/src/parsetypes.egg-info/requires.txt
+-rw-rw-rw-   0        0        0       11 2023-05-28 04:50:28.000000 parsetypes-0.2/src/parsetypes.egg-info/top_level.txt
+drwxrwxrwx   0        0        0        0 2023-05-28 04:50:28.709037 parsetypes-0.2/tests/
+-rw-rw-rw-   0        0        0    60176 2023-05-28 04:48:55.000000 parsetypes-0.2/tests/test_parser.py
+-rw-rw-rw-   0        0        0     8837 2023-05-28 04:48:55.000000 parsetypes-0.2/tests/test_reduce_types.py
```

### Comparing `parsetypes-0.1.1/CHANGELOG.md` & `parsetypes-0.2/CHANGELOG.md`

 * *Files 10% similar despite different names*

```diff
@@ -1,13 +1,17 @@
 ## Changelog
 
 This project follows [PEP 440](https://peps.python.org/pep-0440/) and [Semantic Versioning (SemVer)](https://semver.org/spec/v2.0.0.html). In addition to the guarantees specified by SemVer, for versions before 1.0, this project guarantees backwards compatibility of the API for patch version updates (0.<var>y</var>.<b><var>z</var></b>).
 
 The recommended version specifier is <code>generic-path ~= <var>x</var>.<var>y</var></code> for version 1.0 and later, and <code>generic-path ~= <var>0</var>.<var>y</var>.<var>z</var></code> for versions prior to 1.0.
 
+### 0.2
+
+- Added support for Python version 3.9; previously only 3.10 and 3.11 were supported
+
 ### 0.1.1
 
 - Updated documentation
 
 ### 0.1
 
 - Initial version
```

### Comparing `parsetypes-0.1.1/PKG-INFO` & `parsetypes-0.2/PKG-INFO`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: parsetypes
-Version: 0.1.1
+Version: 0.2
 Summary: Parse serialised data to recover their original underlying types
 Author-email: Yu Shiyang <yu.shiyang@gnayihs.uy>
 License: MPL-2.0
 Project-URL: Homepage, https://github.com/yushiyangk/parsetypes
 Project-URL: Documentation, https://parsetypes.gnayihs.uy/
 Project-URL: Issues, https://github.com/yushiyangk/parsetypes/issues
 Keywords: python,str,string,types,conversion
@@ -12,25 +12,26 @@
 Classifier: Intended Audience :: Developers
 Classifier: Intended Audience :: Information Technology
 Classifier: Intended Audience :: Science/Research
 Classifier: Intended Audience :: System Administrators
 Classifier: License :: OSI Approved :: Mozilla Public License 2.0 (MPL 2.0)
 Classifier: Operating System :: OS Independent
 Classifier: Programming Language :: Python :: 3 :: Only
+Classifier: Programming Language :: Python :: 3.9
 Classifier: Programming Language :: Python :: 3.10
 Classifier: Programming Language :: Python :: 3.11
 Classifier: Programming Language :: Python :: 3.12
 Classifier: Topic :: File Formats
 Classifier: Topic :: Office/Business
 Classifier: Topic :: Scientific/Engineering :: Information Analysis
 Classifier: Topic :: Scientific/Engineering :: Interface Engine/Protocol Translator
 Classifier: Topic :: Software Development :: Libraries :: Python Modules
 Classifier: Topic :: Utilities
 Classifier: Typing :: Typed
-Requires-Python: >=3.10
+Requires-Python: >=3.9
 Description-Content-Type: text/markdown
 Provides-Extra: dev
 Provides-Extra: test
 Provides-Extra: docs
 Provides-Extra: metadata
 Provides-Extra: package
 Provides-Extra: packagetest
@@ -157,14 +158,18 @@
 
 ## Changelog
 
 This project follows [PEP 440](https://peps.python.org/pep-0440/) and [Semantic Versioning (SemVer)](https://semver.org/spec/v2.0.0.html). In addition to the guarantees specified by SemVer, for versions before 1.0, this project guarantees backwards compatibility of the API for patch version updates (0.<var>y</var>.<b><var>z</var></b>).
 
 The recommended version specifier is <code>generic-path ~= <var>x</var>.<var>y</var></code> for version 1.0 and later, and <code>generic-path ~= <var>0</var>.<var>y</var>.<var>z</var></code> for versions prior to 1.0.
 
+### 0.2
+
+- Added support for Python version 3.9; previously only 3.10 and 3.11 were supported
+
 ### 0.1.1
 
 - Updated documentation
 
 ### 0.1
 
 - Initial version
```

### Comparing `parsetypes-0.1.1/README.md` & `parsetypes-0.2/README.md`

 * *Files identical despite different names*

### Comparing `parsetypes-0.1.1/docs/html/favicon.png` & `parsetypes-0.2/docs/html/favicon.png`

 * *Files identical despite different names*

### Comparing `parsetypes-0.1.1/docs/html/parsetypes.html` & `parsetypes-0.2/docs/html/parsetypes.html`

 * *Files 1% similar despite different names*

```diff
@@ -201,15 +201,15 @@
 </span><span id="L-4"><a href="#L-4"><span class="linenos"> 4</span></a><span class="sd">	The `TypeParser` class provides configurable type inference and parsing. This can be initialised with different settings to, for example:</span>
 </span><span id="L-5"><a href="#L-5"><span class="linenos"> 5</span></a><span class="sd">	- treat `inf` as either a float or a normal string</span>
 </span><span id="L-6"><a href="#L-6"><span class="linenos"> 6</span></a><span class="sd">	- give exact Decimal values instead of floats</span>
 </span><span id="L-7"><a href="#L-7"><span class="linenos"> 7</span></a><span class="sd">	- detect inline lists</span>
 </span><span id="L-8"><a href="#L-8"><span class="linenos"> 8</span></a><span class="sd">&quot;&quot;&quot;</span>
 </span><span id="L-9"><a href="#L-9"><span class="linenos"> 9</span></a>
 </span><span id="L-10"><a href="#L-10"><span class="linenos">10</span></a>
-</span><span id="L-11"><a href="#L-11"><span class="linenos">11</span></a><span class="n">__version__</span> <span class="o">=</span> <span class="s2">&quot;0.1.1&quot;</span>
+</span><span id="L-11"><a href="#L-11"><span class="linenos">11</span></a><span class="n">__version__</span> <span class="o">=</span> <span class="s2">&quot;0.2&quot;</span>
 </span><span id="L-12"><a href="#L-12"><span class="linenos">12</span></a>
 </span><span id="L-13"><a href="#L-13"><span class="linenos">13</span></a><span class="kn">from</span> <span class="nn">._common</span> <span class="kn">import</span> <span class="n">AnyScalar</span><span class="p">,</span> <span class="n">AnyScalarType</span><span class="p">,</span> <span class="n">AnyValue</span><span class="p">,</span> <span class="n">AnyValueType</span><span class="p">,</span> <span class="n">GenericValue</span><span class="p">,</span> <span class="n">Nullable</span>
 </span><span id="L-14"><a href="#L-14"><span class="linenos">14</span></a><span class="kn">from</span> <span class="nn">._parser</span> <span class="kn">import</span> <span class="n">TypeParser</span>
 </span><span id="L-15"><a href="#L-15"><span class="linenos">15</span></a><span class="kn">from</span> <span class="nn">._reduce_types</span> <span class="kn">import</span> <span class="n">reduce_types</span>
 </span><span id="L-16"><a href="#L-16"><span class="linenos">16</span></a>
 </span><span id="L-17"><a href="#L-17"><span class="linenos">17</span></a><span class="n">__all__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;TypeParser&#39;</span><span class="p">,</span> <span class="s1">&#39;reduce_types&#39;</span><span class="p">)</span>
 </span></pre></div>
@@ -224,1128 +224,1128 @@
     <span class="name">TypeParser</span>:
 
 
                 <label class="view-source-button" for="TypeParser-view-source"><span>View Source</span></label>
 
     </div>
     <a class="headerlink" href="#TypeParser"></a>
-            <div class="pdoc-code codehilite"><pre><span></span><span id="TypeParser-61"><a href="#TypeParser-61"><span class="linenos"> 61</span></a><span class="k">class</span> <span class="nc">TypeParser</span><span class="p">:</span>
-</span><span id="TypeParser-62"><a href="#TypeParser-62"><span class="linenos"> 62</span></a><span class="w">	</span><span class="sd">&quot;&quot;&quot;</span>
-</span><span id="TypeParser-63"><a href="#TypeParser-63"><span class="linenos"> 63</span></a><span class="sd">		A parser that can be used to infer the underlying types of data serialised as strings, and to convert them into their original underlying types.</span>
-</span><span id="TypeParser-64"><a href="#TypeParser-64"><span class="linenos"> 64</span></a>
-</span><span id="TypeParser-65"><a href="#TypeParser-65"><span class="linenos"> 65</span></a><span class="sd">		Instances of this class can be configured with different settings for the parser and inferrer. See the constructor for more details about the available options.</span>
-</span><span id="TypeParser-66"><a href="#TypeParser-66"><span class="linenos"> 66</span></a><span class="sd">	&quot;&quot;&quot;</span>
-</span><span id="TypeParser-67"><a href="#TypeParser-67"><span class="linenos"> 67</span></a>
-</span><span id="TypeParser-68"><a href="#TypeParser-68"><span class="linenos"> 68</span></a>	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
-</span><span id="TypeParser-69"><a href="#TypeParser-69"><span class="linenos"> 69</span></a>	    <span class="o">*</span><span class="p">,</span>
-</span><span id="TypeParser-70"><a href="#TypeParser-70"><span class="linenos"> 70</span></a>		<span class="n">trim</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
-</span><span id="TypeParser-71"><a href="#TypeParser-71"><span class="linenos"> 71</span></a>		<span class="n">use_decimal</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
-</span><span id="TypeParser-72"><a href="#TypeParser-72"><span class="linenos"> 72</span></a>		<span class="n">list_delimiter</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
-</span><span id="TypeParser-73"><a href="#TypeParser-73"><span class="linenos"> 73</span></a>		<span class="n">none_values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">],</span>
-</span><span id="TypeParser-74"><a href="#TypeParser-74"><span class="linenos"> 74</span></a>		<span class="n">none_case_sensitive</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
-</span><span id="TypeParser-75"><a href="#TypeParser-75"><span class="linenos"> 75</span></a>		<span class="n">true_values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;true&quot;</span><span class="p">],</span>
-</span><span id="TypeParser-76"><a href="#TypeParser-76"><span class="linenos"> 76</span></a>		<span class="n">false_values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;false&quot;</span><span class="p">],</span>
-</span><span id="TypeParser-77"><a href="#TypeParser-77"><span class="linenos"> 77</span></a>		<span class="n">bool_case_sensitive</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
-</span><span id="TypeParser-78"><a href="#TypeParser-78"><span class="linenos"> 78</span></a>		<span class="n">int_case_sensitive</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
-</span><span id="TypeParser-79"><a href="#TypeParser-79"><span class="linenos"> 79</span></a>		<span class="n">inf_values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="p">[],</span>
-</span><span id="TypeParser-80"><a href="#TypeParser-80"><span class="linenos"> 80</span></a>		<span class="n">nan_values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="p">[],</span>
-</span><span id="TypeParser-81"><a href="#TypeParser-81"><span class="linenos"> 81</span></a>		<span class="n">float_case_sensitive</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
-</span><span id="TypeParser-82"><a href="#TypeParser-82"><span class="linenos"> 82</span></a>		<span class="n">case_sensitive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
-</span><span id="TypeParser-83"><a href="#TypeParser-83"><span class="linenos"> 83</span></a>	<span class="p">):</span>
-</span><span id="TypeParser-84"><a href="#TypeParser-84"><span class="linenos"> 84</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
-</span><span id="TypeParser-85"><a href="#TypeParser-85"><span class="linenos"> 85</span></a><span class="sd">			Initialise a new parser</span>
-</span><span id="TypeParser-86"><a href="#TypeParser-86"><span class="linenos"> 86</span></a>
-</span><span id="TypeParser-87"><a href="#TypeParser-87"><span class="linenos"> 87</span></a><span class="sd">			Parameters</span>
-</span><span id="TypeParser-88"><a href="#TypeParser-88"><span class="linenos"> 88</span></a><span class="sd">			----------</span>
-</span><span id="TypeParser-89"><a href="#TypeParser-89"><span class="linenos"> 89</span></a><span class="sd">			`trim`</span>
-</span><span id="TypeParser-90"><a href="#TypeParser-90"><span class="linenos"> 90</span></a><span class="sd">			: whether leading and trailing whitespace should be stripped from strings</span>
-</span><span id="TypeParser-91"><a href="#TypeParser-91"><span class="linenos"> 91</span></a>
-</span><span id="TypeParser-92"><a href="#TypeParser-92"><span class="linenos"> 92</span></a><span class="sd">			`use_decimal`</span>
-</span><span id="TypeParser-93"><a href="#TypeParser-93"><span class="linenos"> 93</span></a><span class="sd">			: whether non-integer numeric values should be inferred as Decimal (exact values) instead of float (non-exact values). Note that this only applies to methods that attempt to infer type (`infer()` and `infer_*()`), and does not affect methods where the type is explicitly specified (`is_float()`, `is_decimal()`, `parse_float()`, `parse_decimal()`).</span>
-</span><span id="TypeParser-94"><a href="#TypeParser-94"><span class="linenos"> 94</span></a>
-</span><span id="TypeParser-95"><a href="#TypeParser-95"><span class="linenos"> 95</span></a><span class="sd">			`list_delimiter`</span>
-</span><span id="TypeParser-96"><a href="#TypeParser-96"><span class="linenos"> 96</span></a><span class="sd">			: the delimiter used for identifying lists and for separating list items. If set to None, the parser will not attempt to identify lists when inferring types, which usually causes the value to be treated as a str instead.</span>
-</span><span id="TypeParser-97"><a href="#TypeParser-97"><span class="linenos"> 97</span></a>
-</span><span id="TypeParser-98"><a href="#TypeParser-98"><span class="linenos"> 98</span></a><span class="sd">			`none_values`</span>
-</span><span id="TypeParser-99"><a href="#TypeParser-99"><span class="linenos"> 99</span></a><span class="sd">			: list of strings that represent the value None</span>
-</span><span id="TypeParser-100"><a href="#TypeParser-100"><span class="linenos">100</span></a>
-</span><span id="TypeParser-101"><a href="#TypeParser-101"><span class="linenos">101</span></a><span class="sd">			`none_case_sensitive`</span>
-</span><span id="TypeParser-102"><a href="#TypeParser-102"><span class="linenos">102</span></a><span class="sd">			: whether matches against `none_values` should be made in a case-sensitive manner</span>
-</span><span id="TypeParser-103"><a href="#TypeParser-103"><span class="linenos">103</span></a>
-</span><span id="TypeParser-104"><a href="#TypeParser-104"><span class="linenos">104</span></a><span class="sd">			`true_values`</span>
-</span><span id="TypeParser-105"><a href="#TypeParser-105"><span class="linenos">105</span></a><span class="sd">			: list of strings that represent the bool value True</span>
-</span><span id="TypeParser-106"><a href="#TypeParser-106"><span class="linenos">106</span></a>
-</span><span id="TypeParser-107"><a href="#TypeParser-107"><span class="linenos">107</span></a><span class="sd">			`false_values`</span>
-</span><span id="TypeParser-108"><a href="#TypeParser-108"><span class="linenos">108</span></a><span class="sd">			: list of strings that represent the bool value False</span>
-</span><span id="TypeParser-109"><a href="#TypeParser-109"><span class="linenos">109</span></a>
-</span><span id="TypeParser-110"><a href="#TypeParser-110"><span class="linenos">110</span></a><span class="sd">			`bool_case_sensitive`</span>
-</span><span id="TypeParser-111"><a href="#TypeParser-111"><span class="linenos">111</span></a><span class="sd">			: whether matches against `true_values` and `false_values` should be made in a case-sensitive manner</span>
-</span><span id="TypeParser-112"><a href="#TypeParser-112"><span class="linenos">112</span></a>
-</span><span id="TypeParser-113"><a href="#TypeParser-113"><span class="linenos">113</span></a><span class="sd">			`int_case_sensitive`</span>
-</span><span id="TypeParser-114"><a href="#TypeParser-114"><span class="linenos">114</span></a><span class="sd">			: whether checks for int should be done in a case-sensitive manner. This usually only applies to values given in scientific notation, where the mantissa and exponent usually are separated by `e`.</span>
-</span><span id="TypeParser-115"><a href="#TypeParser-115"><span class="linenos">115</span></a>
-</span><span id="TypeParser-116"><a href="#TypeParser-116"><span class="linenos">116</span></a><span class="sd">			`inf_values`</span>
-</span><span id="TypeParser-117"><a href="#TypeParser-117"><span class="linenos">117</span></a><span class="sd">			: list of strings that represent the float or Decimal value of infinity. Each of the strings can be prepended with a negative sign to represent negative infinity also.</span>
-</span><span id="TypeParser-118"><a href="#TypeParser-118"><span class="linenos">118</span></a>
-</span><span id="TypeParser-119"><a href="#TypeParser-119"><span class="linenos">119</span></a><span class="sd">			`nan_values`</span>
-</span><span id="TypeParser-120"><a href="#TypeParser-120"><span class="linenos">120</span></a><span class="sd">			: list of strings that represent a float or Decimal that is NaN (not a number)</span>
-</span><span id="TypeParser-121"><a href="#TypeParser-121"><span class="linenos">121</span></a>
-</span><span id="TypeParser-122"><a href="#TypeParser-122"><span class="linenos">122</span></a><span class="sd">			`float_case_sensitive`</span>
-</span><span id="TypeParser-123"><a href="#TypeParser-123"><span class="linenos">123</span></a><span class="sd">			: whether checks for float should be done in a case-sensitive manner. This applies to matches against `inf_values` and `nan_values`, as well as to values given in scientific notation, where the mantissa and exponent are usually separated by `e`.</span>
-</span><span id="TypeParser-124"><a href="#TypeParser-124"><span class="linenos">124</span></a>
-</span><span id="TypeParser-125"><a href="#TypeParser-125"><span class="linenos">125</span></a><span class="sd">			`case_sensitive`</span>
-</span><span id="TypeParser-126"><a href="#TypeParser-126"><span class="linenos">126</span></a><span class="sd">			: whether all matches should be made in a case-sensitive manner. Sets all of `none_case_sensitive`, `bool_case_sensitive`, `int_case_sensitive`, `float_case_sensitive` to the same value, ignoring any individual settings.</span>
-</span><span id="TypeParser-127"><a href="#TypeParser-127"><span class="linenos">127</span></a>
-</span><span id="TypeParser-128"><a href="#TypeParser-128"><span class="linenos">128</span></a><span class="sd">			Raises</span>
-</span><span id="TypeParser-129"><a href="#TypeParser-129"><span class="linenos">129</span></a><span class="sd">			------</span>
-</span><span id="TypeParser-130"><a href="#TypeParser-130"><span class="linenos">130</span></a><span class="sd">			`ValueError` if any of the options would lead to ambiguities during parsing</span>
-</span><span id="TypeParser-131"><a href="#TypeParser-131"><span class="linenos">131</span></a><span class="sd">		&quot;&quot;&quot;</span>
-</span><span id="TypeParser-132"><a href="#TypeParser-132"><span class="linenos">132</span></a>
-</span><span id="TypeParser-133"><a href="#TypeParser-133"><span class="linenos">133</span></a>		<span class="k">if</span> <span class="n">case_sensitive</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
-</span><span id="TypeParser-134"><a href="#TypeParser-134"><span class="linenos">134</span></a>			<span class="n">none_case_sensitive</span> <span class="o">=</span> <span class="n">case_sensitive</span>
-</span><span id="TypeParser-135"><a href="#TypeParser-135"><span class="linenos">135</span></a>			<span class="n">int_case_sensitive</span> <span class="o">=</span> <span class="n">case_sensitive</span>
-</span><span id="TypeParser-136"><a href="#TypeParser-136"><span class="linenos">136</span></a>			<span class="n">bool_case_sensitive</span> <span class="o">=</span> <span class="n">case_sensitive</span>
-</span><span id="TypeParser-137"><a href="#TypeParser-137"><span class="linenos">137</span></a>			<span class="n">float_case_sensitive</span> <span class="o">=</span> <span class="n">case_sensitive</span>
-</span><span id="TypeParser-138"><a href="#TypeParser-138"><span class="linenos">138</span></a>
-</span><span id="TypeParser-139"><a href="#TypeParser-139"><span class="linenos">139</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">trim</span> <span class="o">=</span> <span class="n">trim</span>
-</span><span id="TypeParser-140"><a href="#TypeParser-140"><span class="linenos">140</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trim</span><span class="p">:</span>
-</span><span id="TypeParser-141"><a href="#TypeParser-141"><span class="linenos">141</span></a>			<span class="n">none_values</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">none_values</span><span class="p">)</span>
-</span><span id="TypeParser-142"><a href="#TypeParser-142"><span class="linenos">142</span></a>			<span class="n">true_values</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">true_values</span><span class="p">)</span>
-</span><span id="TypeParser-143"><a href="#TypeParser-143"><span class="linenos">143</span></a>			<span class="n">false_values</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">false_values</span><span class="p">)</span>
-</span><span id="TypeParser-144"><a href="#TypeParser-144"><span class="linenos">144</span></a>			<span class="n">inf_values</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">inf_values</span><span class="p">)</span>
-</span><span id="TypeParser-145"><a href="#TypeParser-145"><span class="linenos">145</span></a>			<span class="n">nan_values</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">nan_values</span><span class="p">)</span>
-</span><span id="TypeParser-146"><a href="#TypeParser-146"><span class="linenos">146</span></a>
-</span><span id="TypeParser-147"><a href="#TypeParser-147"><span class="linenos">147</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">use_decimal</span> <span class="o">=</span> <span class="n">use_decimal</span>
-</span><span id="TypeParser-148"><a href="#TypeParser-148"><span class="linenos">148</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">list_delimiter</span> <span class="o">=</span> <span class="n">list_delimiter</span>
-</span><span id="TypeParser-149"><a href="#TypeParser-149"><span class="linenos">149</span></a>
-</span><span id="TypeParser-150"><a href="#TypeParser-150"><span class="linenos">150</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">none_case_sensitive</span> <span class="o">=</span> <span class="n">none_case_sensitive</span>
-</span><span id="TypeParser-151"><a href="#TypeParser-151"><span class="linenos">151</span></a>		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">none_case_sensitive</span><span class="p">:</span>
-</span><span id="TypeParser-152"><a href="#TypeParser-152"><span class="linenos">152</span></a>			<span class="n">none_values</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">none_values</span><span class="p">)</span>
-</span><span id="TypeParser-153"><a href="#TypeParser-153"><span class="linenos">153</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">none_values</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">none_values</span><span class="p">)</span>
-</span><span id="TypeParser-154"><a href="#TypeParser-154"><span class="linenos">154</span></a>
-</span><span id="TypeParser-155"><a href="#TypeParser-155"><span class="linenos">155</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">bool_case_sensitive</span> <span class="o">=</span> <span class="n">bool_case_sensitive</span>
-</span><span id="TypeParser-156"><a href="#TypeParser-156"><span class="linenos">156</span></a>		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">bool_case_sensitive</span><span class="p">:</span>
-</span><span id="TypeParser-157"><a href="#TypeParser-157"><span class="linenos">157</span></a>			<span class="n">true_values</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">true_values</span><span class="p">)</span>
-</span><span id="TypeParser-158"><a href="#TypeParser-158"><span class="linenos">158</span></a>			<span class="n">false_values</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">false_values</span><span class="p">)</span>
-</span><span id="TypeParser-159"><a href="#TypeParser-159"><span class="linenos">159</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">true_values</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">true_values</span><span class="p">)</span>
-</span><span id="TypeParser-160"><a href="#TypeParser-160"><span class="linenos">160</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">false_values</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">false_values</span><span class="p">)</span>
-</span><span id="TypeParser-161"><a href="#TypeParser-161"><span class="linenos">161</span></a>
-</span><span id="TypeParser-162"><a href="#TypeParser-162"><span class="linenos">162</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">int_case_sensitive</span> <span class="o">=</span> <span class="n">int_case_sensitive</span>
-</span><span id="TypeParser-163"><a href="#TypeParser-163"><span class="linenos">163</span></a>
-</span><span id="TypeParser-164"><a href="#TypeParser-164"><span class="linenos">164</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">float_case_sensitive</span> <span class="o">=</span> <span class="n">float_case_sensitive</span>
-</span><span id="TypeParser-165"><a href="#TypeParser-165"><span class="linenos">165</span></a>		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">float_case_sensitive</span><span class="p">:</span>
-</span><span id="TypeParser-166"><a href="#TypeParser-166"><span class="linenos">166</span></a>			<span class="n">inf_values</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">inf_values</span><span class="p">)</span>
-</span><span id="TypeParser-167"><a href="#TypeParser-167"><span class="linenos">167</span></a>			<span class="n">nan_values</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">nan_values</span><span class="p">)</span>
-</span><span id="TypeParser-168"><a href="#TypeParser-168"><span class="linenos">168</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">inf_values</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">inf_values</span><span class="p">)</span>
-</span><span id="TypeParser-169"><a href="#TypeParser-169"><span class="linenos">169</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">nan_values</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">nan_values</span><span class="p">)</span>
-</span><span id="TypeParser-170"><a href="#TypeParser-170"><span class="linenos">170</span></a>
-</span><span id="TypeParser-171"><a href="#TypeParser-171"><span class="linenos">171</span></a>		<span class="c1"># Unconfigurable default values</span>
-</span><span id="TypeParser-172"><a href="#TypeParser-172"><span class="linenos">172</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_negative_char</span> <span class="o">=</span> <span class="s2">&quot;-&quot;</span>
-</span><span id="TypeParser-173"><a href="#TypeParser-173"><span class="linenos">173</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_negative_chars</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_negative_char</span><span class="p">,</span> <span class="s2">&quot;−&quot;</span><span class="p">}</span>
-</span><span id="TypeParser-174"><a href="#TypeParser-174"><span class="linenos">174</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_sign_chars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_negative_chars</span> <span class="o">|</span> <span class="p">{</span><span class="s2">&quot;+&quot;</span><span class="p">}</span>
-</span><span id="TypeParser-175"><a href="#TypeParser-175"><span class="linenos">175</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_digit_chars</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">,</span> <span class="s2">&quot;3&quot;</span><span class="p">,</span> <span class="s2">&quot;4&quot;</span><span class="p">,</span> <span class="s2">&quot;5&quot;</span><span class="p">,</span> <span class="s2">&quot;6&quot;</span><span class="p">,</span> <span class="s2">&quot;7&quot;</span><span class="p">,</span> <span class="s2">&quot;8&quot;</span><span class="p">,</span> <span class="s2">&quot;9&quot;</span><span class="p">}</span>  <span class="c1"># Because isdigit(&quot;²&quot;) == True, but int(&quot;²&quot;) is invalid</span>
-</span><span id="TypeParser-176"><a href="#TypeParser-176"><span class="linenos">176</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_digit_separators</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;_&quot;</span><span class="p">}</span>
-</span><span id="TypeParser-177"><a href="#TypeParser-177"><span class="linenos">177</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_scientific_char</span> <span class="o">=</span> <span class="s2">&quot;e&quot;</span>
-</span><span id="TypeParser-178"><a href="#TypeParser-178"><span class="linenos">178</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_float_separator</span> <span class="o">=</span> <span class="s2">&quot;.&quot;</span>
-</span><span id="TypeParser-179"><a href="#TypeParser-179"><span class="linenos">179</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_reserved_chars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sign_chars</span> <span class="o">|</span> <span class="bp">self</span><span class="o">.</span><span class="n">_digit_chars</span> <span class="o">|</span> <span class="bp">self</span><span class="o">.</span><span class="n">_digit_separators</span> <span class="o">|</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_scientific_char</span><span class="p">}</span> <span class="o">|</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_float_separator</span><span class="p">}</span>
-</span><span id="TypeParser-180"><a href="#TypeParser-180"><span class="linenos">180</span></a>		<span class="c1"># special_chars = self._reserved_chars | self.list_delimiter</span>
-</span><span id="TypeParser-181"><a href="#TypeParser-181"><span class="linenos">181</span></a>
-</span><span id="TypeParser-182"><a href="#TypeParser-182"><span class="linenos">182</span></a>		<span class="c1"># Check if any special values conflict</span>
-</span><span id="TypeParser-183"><a href="#TypeParser-183"><span class="linenos">183</span></a>		<span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">special_values</span> <span class="ow">in</span> <span class="p">[</span>
-</span><span id="TypeParser-184"><a href="#TypeParser-184"><span class="linenos">184</span></a>			<span class="p">(</span><span class="n">_SpecialValue</span><span class="o">.</span><span class="n">LIST</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">list_delimiter</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_delimiter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[]),</span>
-</span><span id="TypeParser-185"><a href="#TypeParser-185"><span class="linenos">185</span></a>			<span class="p">(</span><span class="n">_SpecialValue</span><span class="o">.</span><span class="n">NONE</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">none_values</span><span class="p">),</span>
-</span><span id="TypeParser-186"><a href="#TypeParser-186"><span class="linenos">186</span></a>			<span class="p">(</span><span class="n">_SpecialValue</span><span class="o">.</span><span class="n">TRUE</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">true_values</span><span class="p">),</span>
-</span><span id="TypeParser-187"><a href="#TypeParser-187"><span class="linenos">187</span></a>			<span class="p">(</span><span class="n">_SpecialValue</span><span class="o">.</span><span class="n">FALSE</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">false_values</span><span class="p">),</span>
-</span><span id="TypeParser-188"><a href="#TypeParser-188"><span class="linenos">188</span></a>			<span class="p">(</span><span class="n">_SpecialValue</span><span class="o">.</span><span class="n">INF</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inf_values</span><span class="p">),</span>
-</span><span id="TypeParser-189"><a href="#TypeParser-189"><span class="linenos">189</span></a>			<span class="p">(</span><span class="n">_SpecialValue</span><span class="o">.</span><span class="n">NAN</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nan_values</span><span class="p">),</span>
-</span><span id="TypeParser-190"><a href="#TypeParser-190"><span class="linenos">190</span></a>		<span class="p">]:</span>
-</span><span id="TypeParser-191"><a href="#TypeParser-191"><span class="linenos">191</span></a>			<span class="k">for</span> <span class="n">special_value</span> <span class="ow">in</span> <span class="n">special_values</span><span class="p">:</span>
-</span><span id="TypeParser-192"><a href="#TypeParser-192"><span class="linenos">192</span></a>				<span class="k">if</span> <span class="n">special_value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reserved_chars</span><span class="p">:</span>
-</span><span id="TypeParser-193"><a href="#TypeParser-193"><span class="linenos">193</span></a>					<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cannot use reserved char as </span><span class="si">{</span><span class="n">name</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">special_value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
-</span><span id="TypeParser-194"><a href="#TypeParser-194"><span class="linenos">194</span></a>
-</span><span id="TypeParser-195"><a href="#TypeParser-195"><span class="linenos">195</span></a>				<span class="k">if</span> <span class="n">name</span> <span class="o">!=</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">NONE</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_none</span><span class="p">(</span><span class="n">special_value</span><span class="p">):</span>
-</span><span id="TypeParser-196"><a href="#TypeParser-196"><span class="linenos">196</span></a>					<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cannot use None value as </span><span class="si">{</span><span class="n">name</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">special_value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
-</span><span id="TypeParser-197"><a href="#TypeParser-197"><span class="linenos">197</span></a>
-</span><span id="TypeParser-198"><a href="#TypeParser-198"><span class="linenos">198</span></a>				<span class="k">if</span> <span class="p">(</span>
-</span><span id="TypeParser-199"><a href="#TypeParser-199"><span class="linenos">199</span></a>					<span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">TRUE</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_bool</span><span class="p">(</span><span class="n">special_value</span><span class="p">)</span> <span class="o">!=</span> <span class="kc">True</span><span class="p">)</span> <span class="ow">or</span>
-</span><span id="TypeParser-200"><a href="#TypeParser-200"><span class="linenos">200</span></a>					<span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">FALSE</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_bool</span><span class="p">(</span><span class="n">special_value</span><span class="p">)</span> <span class="o">!=</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">or</span>
-</span><span id="TypeParser-201"><a href="#TypeParser-201"><span class="linenos">201</span></a>					<span class="p">(</span><span class="n">name</span> <span class="o">!=</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">TRUE</span> <span class="ow">and</span> <span class="n">name</span> <span class="o">!=</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">FALSE</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_bool</span><span class="p">(</span><span class="n">special_value</span><span class="p">))</span>
-</span><span id="TypeParser-202"><a href="#TypeParser-202"><span class="linenos">202</span></a>				<span class="p">):</span>
-</span><span id="TypeParser-203"><a href="#TypeParser-203"><span class="linenos">203</span></a>					<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cannot use bool value as </span><span class="si">{</span><span class="n">name</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">special_value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
-</span><span id="TypeParser-204"><a href="#TypeParser-204"><span class="linenos">204</span></a>
-</span><span id="TypeParser-205"><a href="#TypeParser-205"><span class="linenos">205</span></a>				<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_int</span><span class="p">(</span><span class="n">special_value</span><span class="p">):</span>
-</span><span id="TypeParser-206"><a href="#TypeParser-206"><span class="linenos">206</span></a>					<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cannot use int value as </span><span class="si">{</span><span class="n">name</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">special_value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
-</span><span id="TypeParser-207"><a href="#TypeParser-207"><span class="linenos">207</span></a>
-</span><span id="TypeParser-208"><a href="#TypeParser-208"><span class="linenos">208</span></a>				<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_decimal</span><span class="p">:</span>
-</span><span id="TypeParser-209"><a href="#TypeParser-209"><span class="linenos">209</span></a>					<span class="k">if</span> <span class="p">(</span>
-</span><span id="TypeParser-210"><a href="#TypeParser-210"><span class="linenos">210</span></a>						<span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">INF</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_decimal</span><span class="p">(</span><span class="n">special_value</span><span class="p">)</span> <span class="o">!=</span> <span class="n">Decimal</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">))</span> <span class="ow">or</span>
-</span><span id="TypeParser-211"><a href="#TypeParser-211"><span class="linenos">211</span></a>						<span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">NAN</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_decimal</span><span class="p">(</span><span class="n">special_value</span><span class="p">)</span><span class="o">.</span><span class="n">is_nan</span><span class="p">())</span> <span class="ow">or</span>
-</span><span id="TypeParser-212"><a href="#TypeParser-212"><span class="linenos">212</span></a>						<span class="p">(</span><span class="n">name</span> <span class="o">!=</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">INF</span> <span class="ow">and</span> <span class="n">name</span> <span class="o">!=</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">NAN</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_float</span><span class="p">(</span><span class="n">special_value</span><span class="p">))</span>
-</span><span id="TypeParser-213"><a href="#TypeParser-213"><span class="linenos">213</span></a>					<span class="p">):</span>
-</span><span id="TypeParser-214"><a href="#TypeParser-214"><span class="linenos">214</span></a>						<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cannot use Decimal value as </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">special_value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
-</span><span id="TypeParser-215"><a href="#TypeParser-215"><span class="linenos">215</span></a>				<span class="k">else</span><span class="p">:</span>
-</span><span id="TypeParser-216"><a href="#TypeParser-216"><span class="linenos">216</span></a>					<span class="k">if</span> <span class="p">(</span>
-</span><span id="TypeParser-217"><a href="#TypeParser-217"><span class="linenos">217</span></a>						<span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">INF</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_float</span><span class="p">(</span><span class="n">special_value</span><span class="p">)</span> <span class="o">!=</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span> <span class="ow">or</span>
-</span><span id="TypeParser-218"><a href="#TypeParser-218"><span class="linenos">218</span></a>						<span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">NAN</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_float</span><span class="p">(</span><span class="n">special_value</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">math</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span> <span class="ow">or</span>
-</span><span id="TypeParser-219"><a href="#TypeParser-219"><span class="linenos">219</span></a>						<span class="p">(</span><span class="n">name</span> <span class="o">!=</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">INF</span> <span class="ow">and</span> <span class="n">name</span> <span class="o">!=</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">NAN</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_float</span><span class="p">(</span><span class="n">special_value</span><span class="p">))</span>
-</span><span id="TypeParser-220"><a href="#TypeParser-220"><span class="linenos">220</span></a>					<span class="p">):</span>
-</span><span id="TypeParser-221"><a href="#TypeParser-221"><span class="linenos">221</span></a>						<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cannot use float value as </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">special_value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
+            <div class="pdoc-code codehilite"><pre><span></span><span id="TypeParser-60"><a href="#TypeParser-60"><span class="linenos"> 60</span></a><span class="k">class</span> <span class="nc">TypeParser</span><span class="p">:</span>
+</span><span id="TypeParser-61"><a href="#TypeParser-61"><span class="linenos"> 61</span></a><span class="w">	</span><span class="sd">&quot;&quot;&quot;</span>
+</span><span id="TypeParser-62"><a href="#TypeParser-62"><span class="linenos"> 62</span></a><span class="sd">		A parser that can be used to infer the underlying types of data serialised as strings, and to convert them into their original underlying types.</span>
+</span><span id="TypeParser-63"><a href="#TypeParser-63"><span class="linenos"> 63</span></a>
+</span><span id="TypeParser-64"><a href="#TypeParser-64"><span class="linenos"> 64</span></a><span class="sd">		Instances of this class can be configured with different settings for the parser and inferrer. See the constructor for more details about the available options.</span>
+</span><span id="TypeParser-65"><a href="#TypeParser-65"><span class="linenos"> 65</span></a><span class="sd">	&quot;&quot;&quot;</span>
+</span><span id="TypeParser-66"><a href="#TypeParser-66"><span class="linenos"> 66</span></a>
+</span><span id="TypeParser-67"><a href="#TypeParser-67"><span class="linenos"> 67</span></a>	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
+</span><span id="TypeParser-68"><a href="#TypeParser-68"><span class="linenos"> 68</span></a>	    <span class="o">*</span><span class="p">,</span>
+</span><span id="TypeParser-69"><a href="#TypeParser-69"><span class="linenos"> 69</span></a>		<span class="n">trim</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
+</span><span id="TypeParser-70"><a href="#TypeParser-70"><span class="linenos"> 70</span></a>		<span class="n">use_decimal</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
+</span><span id="TypeParser-71"><a href="#TypeParser-71"><span class="linenos"> 71</span></a>		<span class="n">list_delimiter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
+</span><span id="TypeParser-72"><a href="#TypeParser-72"><span class="linenos"> 72</span></a>		<span class="n">none_values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">],</span>
+</span><span id="TypeParser-73"><a href="#TypeParser-73"><span class="linenos"> 73</span></a>		<span class="n">none_case_sensitive</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
+</span><span id="TypeParser-74"><a href="#TypeParser-74"><span class="linenos"> 74</span></a>		<span class="n">true_values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;true&quot;</span><span class="p">],</span>
+</span><span id="TypeParser-75"><a href="#TypeParser-75"><span class="linenos"> 75</span></a>		<span class="n">false_values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;false&quot;</span><span class="p">],</span>
+</span><span id="TypeParser-76"><a href="#TypeParser-76"><span class="linenos"> 76</span></a>		<span class="n">bool_case_sensitive</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
+</span><span id="TypeParser-77"><a href="#TypeParser-77"><span class="linenos"> 77</span></a>		<span class="n">int_case_sensitive</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
+</span><span id="TypeParser-78"><a href="#TypeParser-78"><span class="linenos"> 78</span></a>		<span class="n">inf_values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="p">[],</span>
+</span><span id="TypeParser-79"><a href="#TypeParser-79"><span class="linenos"> 79</span></a>		<span class="n">nan_values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="p">[],</span>
+</span><span id="TypeParser-80"><a href="#TypeParser-80"><span class="linenos"> 80</span></a>		<span class="n">float_case_sensitive</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
+</span><span id="TypeParser-81"><a href="#TypeParser-81"><span class="linenos"> 81</span></a>		<span class="n">case_sensitive</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
+</span><span id="TypeParser-82"><a href="#TypeParser-82"><span class="linenos"> 82</span></a>	<span class="p">):</span>
+</span><span id="TypeParser-83"><a href="#TypeParser-83"><span class="linenos"> 83</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
+</span><span id="TypeParser-84"><a href="#TypeParser-84"><span class="linenos"> 84</span></a><span class="sd">			Initialise a new parser</span>
+</span><span id="TypeParser-85"><a href="#TypeParser-85"><span class="linenos"> 85</span></a>
+</span><span id="TypeParser-86"><a href="#TypeParser-86"><span class="linenos"> 86</span></a><span class="sd">			Parameters</span>
+</span><span id="TypeParser-87"><a href="#TypeParser-87"><span class="linenos"> 87</span></a><span class="sd">			----------</span>
+</span><span id="TypeParser-88"><a href="#TypeParser-88"><span class="linenos"> 88</span></a><span class="sd">			`trim`</span>
+</span><span id="TypeParser-89"><a href="#TypeParser-89"><span class="linenos"> 89</span></a><span class="sd">			: whether leading and trailing whitespace should be stripped from strings</span>
+</span><span id="TypeParser-90"><a href="#TypeParser-90"><span class="linenos"> 90</span></a>
+</span><span id="TypeParser-91"><a href="#TypeParser-91"><span class="linenos"> 91</span></a><span class="sd">			`use_decimal`</span>
+</span><span id="TypeParser-92"><a href="#TypeParser-92"><span class="linenos"> 92</span></a><span class="sd">			: whether non-integer numeric values should be inferred as Decimal (exact values) instead of float (non-exact values). Note that this only applies to methods that attempt to infer type (`infer()` and `infer_*()`), and does not affect methods where the type is explicitly specified (`is_float()`, `is_decimal()`, `parse_float()`, `parse_decimal()`).</span>
+</span><span id="TypeParser-93"><a href="#TypeParser-93"><span class="linenos"> 93</span></a>
+</span><span id="TypeParser-94"><a href="#TypeParser-94"><span class="linenos"> 94</span></a><span class="sd">			`list_delimiter`</span>
+</span><span id="TypeParser-95"><a href="#TypeParser-95"><span class="linenos"> 95</span></a><span class="sd">			: the delimiter used for identifying lists and for separating list items. If set to None, the parser will not attempt to identify lists when inferring types, which usually causes the value to be treated as a str instead.</span>
+</span><span id="TypeParser-96"><a href="#TypeParser-96"><span class="linenos"> 96</span></a>
+</span><span id="TypeParser-97"><a href="#TypeParser-97"><span class="linenos"> 97</span></a><span class="sd">			`none_values`</span>
+</span><span id="TypeParser-98"><a href="#TypeParser-98"><span class="linenos"> 98</span></a><span class="sd">			: list of strings that represent the value None</span>
+</span><span id="TypeParser-99"><a href="#TypeParser-99"><span class="linenos"> 99</span></a>
+</span><span id="TypeParser-100"><a href="#TypeParser-100"><span class="linenos">100</span></a><span class="sd">			`none_case_sensitive`</span>
+</span><span id="TypeParser-101"><a href="#TypeParser-101"><span class="linenos">101</span></a><span class="sd">			: whether matches against `none_values` should be made in a case-sensitive manner</span>
+</span><span id="TypeParser-102"><a href="#TypeParser-102"><span class="linenos">102</span></a>
+</span><span id="TypeParser-103"><a href="#TypeParser-103"><span class="linenos">103</span></a><span class="sd">			`true_values`</span>
+</span><span id="TypeParser-104"><a href="#TypeParser-104"><span class="linenos">104</span></a><span class="sd">			: list of strings that represent the bool value True</span>
+</span><span id="TypeParser-105"><a href="#TypeParser-105"><span class="linenos">105</span></a>
+</span><span id="TypeParser-106"><a href="#TypeParser-106"><span class="linenos">106</span></a><span class="sd">			`false_values`</span>
+</span><span id="TypeParser-107"><a href="#TypeParser-107"><span class="linenos">107</span></a><span class="sd">			: list of strings that represent the bool value False</span>
+</span><span id="TypeParser-108"><a href="#TypeParser-108"><span class="linenos">108</span></a>
+</span><span id="TypeParser-109"><a href="#TypeParser-109"><span class="linenos">109</span></a><span class="sd">			`bool_case_sensitive`</span>
+</span><span id="TypeParser-110"><a href="#TypeParser-110"><span class="linenos">110</span></a><span class="sd">			: whether matches against `true_values` and `false_values` should be made in a case-sensitive manner</span>
+</span><span id="TypeParser-111"><a href="#TypeParser-111"><span class="linenos">111</span></a>
+</span><span id="TypeParser-112"><a href="#TypeParser-112"><span class="linenos">112</span></a><span class="sd">			`int_case_sensitive`</span>
+</span><span id="TypeParser-113"><a href="#TypeParser-113"><span class="linenos">113</span></a><span class="sd">			: whether checks for int should be done in a case-sensitive manner. This usually only applies to values given in scientific notation, where the mantissa and exponent usually are separated by `e`.</span>
+</span><span id="TypeParser-114"><a href="#TypeParser-114"><span class="linenos">114</span></a>
+</span><span id="TypeParser-115"><a href="#TypeParser-115"><span class="linenos">115</span></a><span class="sd">			`inf_values`</span>
+</span><span id="TypeParser-116"><a href="#TypeParser-116"><span class="linenos">116</span></a><span class="sd">			: list of strings that represent the float or Decimal value of infinity. Each of the strings can be prepended with a negative sign to represent negative infinity also.</span>
+</span><span id="TypeParser-117"><a href="#TypeParser-117"><span class="linenos">117</span></a>
+</span><span id="TypeParser-118"><a href="#TypeParser-118"><span class="linenos">118</span></a><span class="sd">			`nan_values`</span>
+</span><span id="TypeParser-119"><a href="#TypeParser-119"><span class="linenos">119</span></a><span class="sd">			: list of strings that represent a float or Decimal that is NaN (not a number)</span>
+</span><span id="TypeParser-120"><a href="#TypeParser-120"><span class="linenos">120</span></a>
+</span><span id="TypeParser-121"><a href="#TypeParser-121"><span class="linenos">121</span></a><span class="sd">			`float_case_sensitive`</span>
+</span><span id="TypeParser-122"><a href="#TypeParser-122"><span class="linenos">122</span></a><span class="sd">			: whether checks for float should be done in a case-sensitive manner. This applies to matches against `inf_values` and `nan_values`, as well as to values given in scientific notation, where the mantissa and exponent are usually separated by `e`.</span>
+</span><span id="TypeParser-123"><a href="#TypeParser-123"><span class="linenos">123</span></a>
+</span><span id="TypeParser-124"><a href="#TypeParser-124"><span class="linenos">124</span></a><span class="sd">			`case_sensitive`</span>
+</span><span id="TypeParser-125"><a href="#TypeParser-125"><span class="linenos">125</span></a><span class="sd">			: whether all matches should be made in a case-sensitive manner. Sets all of `none_case_sensitive`, `bool_case_sensitive`, `int_case_sensitive`, `float_case_sensitive` to the same value, ignoring any individual settings.</span>
+</span><span id="TypeParser-126"><a href="#TypeParser-126"><span class="linenos">126</span></a>
+</span><span id="TypeParser-127"><a href="#TypeParser-127"><span class="linenos">127</span></a><span class="sd">			Raises</span>
+</span><span id="TypeParser-128"><a href="#TypeParser-128"><span class="linenos">128</span></a><span class="sd">			------</span>
+</span><span id="TypeParser-129"><a href="#TypeParser-129"><span class="linenos">129</span></a><span class="sd">			`ValueError` if any of the options would lead to ambiguities during parsing</span>
+</span><span id="TypeParser-130"><a href="#TypeParser-130"><span class="linenos">130</span></a><span class="sd">		&quot;&quot;&quot;</span>
+</span><span id="TypeParser-131"><a href="#TypeParser-131"><span class="linenos">131</span></a>
+</span><span id="TypeParser-132"><a href="#TypeParser-132"><span class="linenos">132</span></a>		<span class="k">if</span> <span class="n">case_sensitive</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
+</span><span id="TypeParser-133"><a href="#TypeParser-133"><span class="linenos">133</span></a>			<span class="n">none_case_sensitive</span> <span class="o">=</span> <span class="n">case_sensitive</span>
+</span><span id="TypeParser-134"><a href="#TypeParser-134"><span class="linenos">134</span></a>			<span class="n">int_case_sensitive</span> <span class="o">=</span> <span class="n">case_sensitive</span>
+</span><span id="TypeParser-135"><a href="#TypeParser-135"><span class="linenos">135</span></a>			<span class="n">bool_case_sensitive</span> <span class="o">=</span> <span class="n">case_sensitive</span>
+</span><span id="TypeParser-136"><a href="#TypeParser-136"><span class="linenos">136</span></a>			<span class="n">float_case_sensitive</span> <span class="o">=</span> <span class="n">case_sensitive</span>
+</span><span id="TypeParser-137"><a href="#TypeParser-137"><span class="linenos">137</span></a>
+</span><span id="TypeParser-138"><a href="#TypeParser-138"><span class="linenos">138</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">trim</span> <span class="o">=</span> <span class="n">trim</span>
+</span><span id="TypeParser-139"><a href="#TypeParser-139"><span class="linenos">139</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trim</span><span class="p">:</span>
+</span><span id="TypeParser-140"><a href="#TypeParser-140"><span class="linenos">140</span></a>			<span class="n">none_values</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">none_values</span><span class="p">)</span>
+</span><span id="TypeParser-141"><a href="#TypeParser-141"><span class="linenos">141</span></a>			<span class="n">true_values</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">true_values</span><span class="p">)</span>
+</span><span id="TypeParser-142"><a href="#TypeParser-142"><span class="linenos">142</span></a>			<span class="n">false_values</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">false_values</span><span class="p">)</span>
+</span><span id="TypeParser-143"><a href="#TypeParser-143"><span class="linenos">143</span></a>			<span class="n">inf_values</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">inf_values</span><span class="p">)</span>
+</span><span id="TypeParser-144"><a href="#TypeParser-144"><span class="linenos">144</span></a>			<span class="n">nan_values</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">nan_values</span><span class="p">)</span>
+</span><span id="TypeParser-145"><a href="#TypeParser-145"><span class="linenos">145</span></a>
+</span><span id="TypeParser-146"><a href="#TypeParser-146"><span class="linenos">146</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">use_decimal</span> <span class="o">=</span> <span class="n">use_decimal</span>
+</span><span id="TypeParser-147"><a href="#TypeParser-147"><span class="linenos">147</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">list_delimiter</span> <span class="o">=</span> <span class="n">list_delimiter</span>
+</span><span id="TypeParser-148"><a href="#TypeParser-148"><span class="linenos">148</span></a>
+</span><span id="TypeParser-149"><a href="#TypeParser-149"><span class="linenos">149</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">none_case_sensitive</span> <span class="o">=</span> <span class="n">none_case_sensitive</span>
+</span><span id="TypeParser-150"><a href="#TypeParser-150"><span class="linenos">150</span></a>		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">none_case_sensitive</span><span class="p">:</span>
+</span><span id="TypeParser-151"><a href="#TypeParser-151"><span class="linenos">151</span></a>			<span class="n">none_values</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">none_values</span><span class="p">)</span>
+</span><span id="TypeParser-152"><a href="#TypeParser-152"><span class="linenos">152</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">none_values</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">none_values</span><span class="p">)</span>
+</span><span id="TypeParser-153"><a href="#TypeParser-153"><span class="linenos">153</span></a>
+</span><span id="TypeParser-154"><a href="#TypeParser-154"><span class="linenos">154</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">bool_case_sensitive</span> <span class="o">=</span> <span class="n">bool_case_sensitive</span>
+</span><span id="TypeParser-155"><a href="#TypeParser-155"><span class="linenos">155</span></a>		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">bool_case_sensitive</span><span class="p">:</span>
+</span><span id="TypeParser-156"><a href="#TypeParser-156"><span class="linenos">156</span></a>			<span class="n">true_values</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">true_values</span><span class="p">)</span>
+</span><span id="TypeParser-157"><a href="#TypeParser-157"><span class="linenos">157</span></a>			<span class="n">false_values</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">false_values</span><span class="p">)</span>
+</span><span id="TypeParser-158"><a href="#TypeParser-158"><span class="linenos">158</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">true_values</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">true_values</span><span class="p">)</span>
+</span><span id="TypeParser-159"><a href="#TypeParser-159"><span class="linenos">159</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">false_values</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">false_values</span><span class="p">)</span>
+</span><span id="TypeParser-160"><a href="#TypeParser-160"><span class="linenos">160</span></a>
+</span><span id="TypeParser-161"><a href="#TypeParser-161"><span class="linenos">161</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">int_case_sensitive</span> <span class="o">=</span> <span class="n">int_case_sensitive</span>
+</span><span id="TypeParser-162"><a href="#TypeParser-162"><span class="linenos">162</span></a>
+</span><span id="TypeParser-163"><a href="#TypeParser-163"><span class="linenos">163</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">float_case_sensitive</span> <span class="o">=</span> <span class="n">float_case_sensitive</span>
+</span><span id="TypeParser-164"><a href="#TypeParser-164"><span class="linenos">164</span></a>		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">float_case_sensitive</span><span class="p">:</span>
+</span><span id="TypeParser-165"><a href="#TypeParser-165"><span class="linenos">165</span></a>			<span class="n">inf_values</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">inf_values</span><span class="p">)</span>
+</span><span id="TypeParser-166"><a href="#TypeParser-166"><span class="linenos">166</span></a>			<span class="n">nan_values</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">nan_values</span><span class="p">)</span>
+</span><span id="TypeParser-167"><a href="#TypeParser-167"><span class="linenos">167</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">inf_values</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">inf_values</span><span class="p">)</span>
+</span><span id="TypeParser-168"><a href="#TypeParser-168"><span class="linenos">168</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">nan_values</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">nan_values</span><span class="p">)</span>
+</span><span id="TypeParser-169"><a href="#TypeParser-169"><span class="linenos">169</span></a>
+</span><span id="TypeParser-170"><a href="#TypeParser-170"><span class="linenos">170</span></a>		<span class="c1"># Unconfigurable default values</span>
+</span><span id="TypeParser-171"><a href="#TypeParser-171"><span class="linenos">171</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_negative_char</span> <span class="o">=</span> <span class="s2">&quot;-&quot;</span>
+</span><span id="TypeParser-172"><a href="#TypeParser-172"><span class="linenos">172</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_negative_chars</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_negative_char</span><span class="p">,</span> <span class="s2">&quot;−&quot;</span><span class="p">}</span>
+</span><span id="TypeParser-173"><a href="#TypeParser-173"><span class="linenos">173</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_sign_chars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_negative_chars</span> <span class="o">|</span> <span class="p">{</span><span class="s2">&quot;+&quot;</span><span class="p">}</span>
+</span><span id="TypeParser-174"><a href="#TypeParser-174"><span class="linenos">174</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_digit_chars</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">,</span> <span class="s2">&quot;3&quot;</span><span class="p">,</span> <span class="s2">&quot;4&quot;</span><span class="p">,</span> <span class="s2">&quot;5&quot;</span><span class="p">,</span> <span class="s2">&quot;6&quot;</span><span class="p">,</span> <span class="s2">&quot;7&quot;</span><span class="p">,</span> <span class="s2">&quot;8&quot;</span><span class="p">,</span> <span class="s2">&quot;9&quot;</span><span class="p">}</span>  <span class="c1"># Because isdigit(&quot;²&quot;) == True, but int(&quot;²&quot;) is invalid</span>
+</span><span id="TypeParser-175"><a href="#TypeParser-175"><span class="linenos">175</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_digit_separators</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;_&quot;</span><span class="p">}</span>
+</span><span id="TypeParser-176"><a href="#TypeParser-176"><span class="linenos">176</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_scientific_char</span> <span class="o">=</span> <span class="s2">&quot;e&quot;</span>
+</span><span id="TypeParser-177"><a href="#TypeParser-177"><span class="linenos">177</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_float_separator</span> <span class="o">=</span> <span class="s2">&quot;.&quot;</span>
+</span><span id="TypeParser-178"><a href="#TypeParser-178"><span class="linenos">178</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_reserved_chars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sign_chars</span> <span class="o">|</span> <span class="bp">self</span><span class="o">.</span><span class="n">_digit_chars</span> <span class="o">|</span> <span class="bp">self</span><span class="o">.</span><span class="n">_digit_separators</span> <span class="o">|</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_scientific_char</span><span class="p">}</span> <span class="o">|</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_float_separator</span><span class="p">}</span>
+</span><span id="TypeParser-179"><a href="#TypeParser-179"><span class="linenos">179</span></a>		<span class="c1"># special_chars = self._reserved_chars | self.list_delimiter</span>
+</span><span id="TypeParser-180"><a href="#TypeParser-180"><span class="linenos">180</span></a>
+</span><span id="TypeParser-181"><a href="#TypeParser-181"><span class="linenos">181</span></a>		<span class="c1"># Check if any special values conflict</span>
+</span><span id="TypeParser-182"><a href="#TypeParser-182"><span class="linenos">182</span></a>		<span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">special_values</span> <span class="ow">in</span> <span class="p">[</span>
+</span><span id="TypeParser-183"><a href="#TypeParser-183"><span class="linenos">183</span></a>			<span class="p">(</span><span class="n">_SpecialValue</span><span class="o">.</span><span class="n">LIST</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">list_delimiter</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_delimiter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[]),</span>
+</span><span id="TypeParser-184"><a href="#TypeParser-184"><span class="linenos">184</span></a>			<span class="p">(</span><span class="n">_SpecialValue</span><span class="o">.</span><span class="n">NONE</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">none_values</span><span class="p">),</span>
+</span><span id="TypeParser-185"><a href="#TypeParser-185"><span class="linenos">185</span></a>			<span class="p">(</span><span class="n">_SpecialValue</span><span class="o">.</span><span class="n">TRUE</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">true_values</span><span class="p">),</span>
+</span><span id="TypeParser-186"><a href="#TypeParser-186"><span class="linenos">186</span></a>			<span class="p">(</span><span class="n">_SpecialValue</span><span class="o">.</span><span class="n">FALSE</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">false_values</span><span class="p">),</span>
+</span><span id="TypeParser-187"><a href="#TypeParser-187"><span class="linenos">187</span></a>			<span class="p">(</span><span class="n">_SpecialValue</span><span class="o">.</span><span class="n">INF</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inf_values</span><span class="p">),</span>
+</span><span id="TypeParser-188"><a href="#TypeParser-188"><span class="linenos">188</span></a>			<span class="p">(</span><span class="n">_SpecialValue</span><span class="o">.</span><span class="n">NAN</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nan_values</span><span class="p">),</span>
+</span><span id="TypeParser-189"><a href="#TypeParser-189"><span class="linenos">189</span></a>		<span class="p">]:</span>
+</span><span id="TypeParser-190"><a href="#TypeParser-190"><span class="linenos">190</span></a>			<span class="k">for</span> <span class="n">special_value</span> <span class="ow">in</span> <span class="n">special_values</span><span class="p">:</span>
+</span><span id="TypeParser-191"><a href="#TypeParser-191"><span class="linenos">191</span></a>				<span class="k">if</span> <span class="n">special_value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reserved_chars</span><span class="p">:</span>
+</span><span id="TypeParser-192"><a href="#TypeParser-192"><span class="linenos">192</span></a>					<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cannot use reserved char as </span><span class="si">{</span><span class="n">name</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">special_value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
+</span><span id="TypeParser-193"><a href="#TypeParser-193"><span class="linenos">193</span></a>
+</span><span id="TypeParser-194"><a href="#TypeParser-194"><span class="linenos">194</span></a>				<span class="k">if</span> <span class="n">name</span> <span class="o">!=</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">NONE</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_none</span><span class="p">(</span><span class="n">special_value</span><span class="p">):</span>
+</span><span id="TypeParser-195"><a href="#TypeParser-195"><span class="linenos">195</span></a>					<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cannot use None value as </span><span class="si">{</span><span class="n">name</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">special_value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
+</span><span id="TypeParser-196"><a href="#TypeParser-196"><span class="linenos">196</span></a>
+</span><span id="TypeParser-197"><a href="#TypeParser-197"><span class="linenos">197</span></a>				<span class="k">if</span> <span class="p">(</span>
+</span><span id="TypeParser-198"><a href="#TypeParser-198"><span class="linenos">198</span></a>					<span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">TRUE</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_bool</span><span class="p">(</span><span class="n">special_value</span><span class="p">)</span> <span class="o">!=</span> <span class="kc">True</span><span class="p">)</span> <span class="ow">or</span>
+</span><span id="TypeParser-199"><a href="#TypeParser-199"><span class="linenos">199</span></a>					<span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">FALSE</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_bool</span><span class="p">(</span><span class="n">special_value</span><span class="p">)</span> <span class="o">!=</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">or</span>
+</span><span id="TypeParser-200"><a href="#TypeParser-200"><span class="linenos">200</span></a>					<span class="p">(</span><span class="n">name</span> <span class="o">!=</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">TRUE</span> <span class="ow">and</span> <span class="n">name</span> <span class="o">!=</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">FALSE</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_bool</span><span class="p">(</span><span class="n">special_value</span><span class="p">))</span>
+</span><span id="TypeParser-201"><a href="#TypeParser-201"><span class="linenos">201</span></a>				<span class="p">):</span>
+</span><span id="TypeParser-202"><a href="#TypeParser-202"><span class="linenos">202</span></a>					<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cannot use bool value as </span><span class="si">{</span><span class="n">name</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">special_value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
+</span><span id="TypeParser-203"><a href="#TypeParser-203"><span class="linenos">203</span></a>
+</span><span id="TypeParser-204"><a href="#TypeParser-204"><span class="linenos">204</span></a>				<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_int</span><span class="p">(</span><span class="n">special_value</span><span class="p">):</span>
+</span><span id="TypeParser-205"><a href="#TypeParser-205"><span class="linenos">205</span></a>					<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cannot use int value as </span><span class="si">{</span><span class="n">name</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">special_value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
+</span><span id="TypeParser-206"><a href="#TypeParser-206"><span class="linenos">206</span></a>
+</span><span id="TypeParser-207"><a href="#TypeParser-207"><span class="linenos">207</span></a>				<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_decimal</span><span class="p">:</span>
+</span><span id="TypeParser-208"><a href="#TypeParser-208"><span class="linenos">208</span></a>					<span class="k">if</span> <span class="p">(</span>
+</span><span id="TypeParser-209"><a href="#TypeParser-209"><span class="linenos">209</span></a>						<span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">INF</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_decimal</span><span class="p">(</span><span class="n">special_value</span><span class="p">)</span> <span class="o">!=</span> <span class="n">Decimal</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">))</span> <span class="ow">or</span>
+</span><span id="TypeParser-210"><a href="#TypeParser-210"><span class="linenos">210</span></a>						<span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">NAN</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_decimal</span><span class="p">(</span><span class="n">special_value</span><span class="p">)</span><span class="o">.</span><span class="n">is_nan</span><span class="p">())</span> <span class="ow">or</span>
+</span><span id="TypeParser-211"><a href="#TypeParser-211"><span class="linenos">211</span></a>						<span class="p">(</span><span class="n">name</span> <span class="o">!=</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">INF</span> <span class="ow">and</span> <span class="n">name</span> <span class="o">!=</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">NAN</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_float</span><span class="p">(</span><span class="n">special_value</span><span class="p">))</span>
+</span><span id="TypeParser-212"><a href="#TypeParser-212"><span class="linenos">212</span></a>					<span class="p">):</span>
+</span><span id="TypeParser-213"><a href="#TypeParser-213"><span class="linenos">213</span></a>						<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cannot use Decimal value as </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">special_value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
+</span><span id="TypeParser-214"><a href="#TypeParser-214"><span class="linenos">214</span></a>				<span class="k">else</span><span class="p">:</span>
+</span><span id="TypeParser-215"><a href="#TypeParser-215"><span class="linenos">215</span></a>					<span class="k">if</span> <span class="p">(</span>
+</span><span id="TypeParser-216"><a href="#TypeParser-216"><span class="linenos">216</span></a>						<span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">INF</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_float</span><span class="p">(</span><span class="n">special_value</span><span class="p">)</span> <span class="o">!=</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span> <span class="ow">or</span>
+</span><span id="TypeParser-217"><a href="#TypeParser-217"><span class="linenos">217</span></a>						<span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">NAN</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_float</span><span class="p">(</span><span class="n">special_value</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">math</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span> <span class="ow">or</span>
+</span><span id="TypeParser-218"><a href="#TypeParser-218"><span class="linenos">218</span></a>						<span class="p">(</span><span class="n">name</span> <span class="o">!=</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">INF</span> <span class="ow">and</span> <span class="n">name</span> <span class="o">!=</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">NAN</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_float</span><span class="p">(</span><span class="n">special_value</span><span class="p">))</span>
+</span><span id="TypeParser-219"><a href="#TypeParser-219"><span class="linenos">219</span></a>					<span class="p">):</span>
+</span><span id="TypeParser-220"><a href="#TypeParser-220"><span class="linenos">220</span></a>						<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cannot use float value as </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">special_value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
+</span><span id="TypeParser-221"><a href="#TypeParser-221"><span class="linenos">221</span></a>
 </span><span id="TypeParser-222"><a href="#TypeParser-222"><span class="linenos">222</span></a>
-</span><span id="TypeParser-223"><a href="#TypeParser-223"><span class="linenos">223</span></a>
-</span><span id="TypeParser-224"><a href="#TypeParser-224"><span class="linenos">224</span></a>	<span class="k">def</span> <span class="nf">is_none</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
-</span><span id="TypeParser-225"><a href="#TypeParser-225"><span class="linenos">225</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
-</span><span id="TypeParser-226"><a href="#TypeParser-226"><span class="linenos">226</span></a><span class="sd">			Check if a string represents the value None</span>
-</span><span id="TypeParser-227"><a href="#TypeParser-227"><span class="linenos">227</span></a>
-</span><span id="TypeParser-228"><a href="#TypeParser-228"><span class="linenos">228</span></a><span class="sd">			Only strings that match the values in `self.none_values` will be interpreted as None. The default accepted values are `[&quot;&quot;]`, i.e. an empty string. The case sensitivity of this matching depends on `self.none_case_sensitive`, which is False by default.</span>
-</span><span id="TypeParser-229"><a href="#TypeParser-229"><span class="linenos">229</span></a>
-</span><span id="TypeParser-230"><a href="#TypeParser-230"><span class="linenos">230</span></a><span class="sd">			Parameters</span>
-</span><span id="TypeParser-231"><a href="#TypeParser-231"><span class="linenos">231</span></a><span class="sd">			----------</span>
-</span><span id="TypeParser-232"><a href="#TypeParser-232"><span class="linenos">232</span></a><span class="sd">			`value`</span>
-</span><span id="TypeParser-233"><a href="#TypeParser-233"><span class="linenos">233</span></a><span class="sd">			: string to be checked</span>
-</span><span id="TypeParser-234"><a href="#TypeParser-234"><span class="linenos">234</span></a>
-</span><span id="TypeParser-235"><a href="#TypeParser-235"><span class="linenos">235</span></a><span class="sd">			Returns</span>
-</span><span id="TypeParser-236"><a href="#TypeParser-236"><span class="linenos">236</span></a><span class="sd">			-------</span>
-</span><span id="TypeParser-237"><a href="#TypeParser-237"><span class="linenos">237</span></a><span class="sd">			whether it is None</span>
-</span><span id="TypeParser-238"><a href="#TypeParser-238"><span class="linenos">238</span></a>
-</span><span id="TypeParser-239"><a href="#TypeParser-239"><span class="linenos">239</span></a><span class="sd">			Examples</span>
-</span><span id="TypeParser-240"><a href="#TypeParser-240"><span class="linenos">240</span></a><span class="sd">			--------</span>
-</span><span id="TypeParser-241"><a href="#TypeParser-241"><span class="linenos">241</span></a><span class="sd">			```python</span>
-</span><span id="TypeParser-242"><a href="#TypeParser-242"><span class="linenos">242</span></a><span class="sd">			parser = TypeParser()</span>
-</span><span id="TypeParser-243"><a href="#TypeParser-243"><span class="linenos">243</span></a><span class="sd">			parser.parse_bool(&quot;&quot;)     # True</span>
-</span><span id="TypeParser-244"><a href="#TypeParser-244"><span class="linenos">244</span></a><span class="sd">			parser.parse_bool(&quot;abc&quot;)  # False</span>
-</span><span id="TypeParser-245"><a href="#TypeParser-245"><span class="linenos">245</span></a><span class="sd">			```</span>
-</span><span id="TypeParser-246"><a href="#TypeParser-246"><span class="linenos">246</span></a><span class="sd">		&quot;&quot;&quot;</span>
-</span><span id="TypeParser-247"><a href="#TypeParser-247"><span class="linenos">247</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trim</span><span class="p">:</span>
-</span><span id="TypeParser-248"><a href="#TypeParser-248"><span class="linenos">248</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
-</span><span id="TypeParser-249"><a href="#TypeParser-249"><span class="linenos">249</span></a>		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">bool_case_sensitive</span><span class="p">:</span>
-</span><span id="TypeParser-250"><a href="#TypeParser-250"><span class="linenos">250</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
-</span><span id="TypeParser-251"><a href="#TypeParser-251"><span class="linenos">251</span></a>
-</span><span id="TypeParser-252"><a href="#TypeParser-252"><span class="linenos">252</span></a>		<span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">none_values</span><span class="p">:</span>
-</span><span id="TypeParser-253"><a href="#TypeParser-253"><span class="linenos">253</span></a>			<span class="k">return</span> <span class="kc">True</span>
-</span><span id="TypeParser-254"><a href="#TypeParser-254"><span class="linenos">254</span></a>		<span class="k">else</span><span class="p">:</span>
-</span><span id="TypeParser-255"><a href="#TypeParser-255"><span class="linenos">255</span></a>			<span class="k">return</span> <span class="kc">False</span>
+</span><span id="TypeParser-223"><a href="#TypeParser-223"><span class="linenos">223</span></a>	<span class="k">def</span> <span class="nf">is_none</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
+</span><span id="TypeParser-224"><a href="#TypeParser-224"><span class="linenos">224</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
+</span><span id="TypeParser-225"><a href="#TypeParser-225"><span class="linenos">225</span></a><span class="sd">			Check if a string represents the value None</span>
+</span><span id="TypeParser-226"><a href="#TypeParser-226"><span class="linenos">226</span></a>
+</span><span id="TypeParser-227"><a href="#TypeParser-227"><span class="linenos">227</span></a><span class="sd">			Only strings that match the values in `self.none_values` will be interpreted as None. The default accepted values are `[&quot;&quot;]`, i.e. an empty string. The case sensitivity of this matching depends on `self.none_case_sensitive`, which is False by default.</span>
+</span><span id="TypeParser-228"><a href="#TypeParser-228"><span class="linenos">228</span></a>
+</span><span id="TypeParser-229"><a href="#TypeParser-229"><span class="linenos">229</span></a><span class="sd">			Parameters</span>
+</span><span id="TypeParser-230"><a href="#TypeParser-230"><span class="linenos">230</span></a><span class="sd">			----------</span>
+</span><span id="TypeParser-231"><a href="#TypeParser-231"><span class="linenos">231</span></a><span class="sd">			`value`</span>
+</span><span id="TypeParser-232"><a href="#TypeParser-232"><span class="linenos">232</span></a><span class="sd">			: string to be checked</span>
+</span><span id="TypeParser-233"><a href="#TypeParser-233"><span class="linenos">233</span></a>
+</span><span id="TypeParser-234"><a href="#TypeParser-234"><span class="linenos">234</span></a><span class="sd">			Returns</span>
+</span><span id="TypeParser-235"><a href="#TypeParser-235"><span class="linenos">235</span></a><span class="sd">			-------</span>
+</span><span id="TypeParser-236"><a href="#TypeParser-236"><span class="linenos">236</span></a><span class="sd">			whether it is None</span>
+</span><span id="TypeParser-237"><a href="#TypeParser-237"><span class="linenos">237</span></a>
+</span><span id="TypeParser-238"><a href="#TypeParser-238"><span class="linenos">238</span></a><span class="sd">			Examples</span>
+</span><span id="TypeParser-239"><a href="#TypeParser-239"><span class="linenos">239</span></a><span class="sd">			--------</span>
+</span><span id="TypeParser-240"><a href="#TypeParser-240"><span class="linenos">240</span></a><span class="sd">			```python</span>
+</span><span id="TypeParser-241"><a href="#TypeParser-241"><span class="linenos">241</span></a><span class="sd">			parser = TypeParser()</span>
+</span><span id="TypeParser-242"><a href="#TypeParser-242"><span class="linenos">242</span></a><span class="sd">			parser.parse_bool(&quot;&quot;)     # True</span>
+</span><span id="TypeParser-243"><a href="#TypeParser-243"><span class="linenos">243</span></a><span class="sd">			parser.parse_bool(&quot;abc&quot;)  # False</span>
+</span><span id="TypeParser-244"><a href="#TypeParser-244"><span class="linenos">244</span></a><span class="sd">			```</span>
+</span><span id="TypeParser-245"><a href="#TypeParser-245"><span class="linenos">245</span></a><span class="sd">		&quot;&quot;&quot;</span>
+</span><span id="TypeParser-246"><a href="#TypeParser-246"><span class="linenos">246</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trim</span><span class="p">:</span>
+</span><span id="TypeParser-247"><a href="#TypeParser-247"><span class="linenos">247</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
+</span><span id="TypeParser-248"><a href="#TypeParser-248"><span class="linenos">248</span></a>		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">bool_case_sensitive</span><span class="p">:</span>
+</span><span id="TypeParser-249"><a href="#TypeParser-249"><span class="linenos">249</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
+</span><span id="TypeParser-250"><a href="#TypeParser-250"><span class="linenos">250</span></a>
+</span><span id="TypeParser-251"><a href="#TypeParser-251"><span class="linenos">251</span></a>		<span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">none_values</span><span class="p">:</span>
+</span><span id="TypeParser-252"><a href="#TypeParser-252"><span class="linenos">252</span></a>			<span class="k">return</span> <span class="kc">True</span>
+</span><span id="TypeParser-253"><a href="#TypeParser-253"><span class="linenos">253</span></a>		<span class="k">else</span><span class="p">:</span>
+</span><span id="TypeParser-254"><a href="#TypeParser-254"><span class="linenos">254</span></a>			<span class="k">return</span> <span class="kc">False</span>
+</span><span id="TypeParser-255"><a href="#TypeParser-255"><span class="linenos">255</span></a>
 </span><span id="TypeParser-256"><a href="#TypeParser-256"><span class="linenos">256</span></a>
-</span><span id="TypeParser-257"><a href="#TypeParser-257"><span class="linenos">257</span></a>
-</span><span id="TypeParser-258"><a href="#TypeParser-258"><span class="linenos">258</span></a>	<span class="k">def</span> <span class="nf">is_bool</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
-</span><span id="TypeParser-259"><a href="#TypeParser-259"><span class="linenos">259</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
-</span><span id="TypeParser-260"><a href="#TypeParser-260"><span class="linenos">260</span></a><span class="sd">			Check if a string represents a bool</span>
-</span><span id="TypeParser-261"><a href="#TypeParser-261"><span class="linenos">261</span></a>
-</span><span id="TypeParser-262"><a href="#TypeParser-262"><span class="linenos">262</span></a><span class="sd">			Only strings that match the values in `self.true_values` and `self.false_values` will be interpreted as booleans. The default accepted values are `[&quot;true&quot;]` and `[&quot;false&quot;]` respectively. The case sensitivity of this matching depends on `self.bool_case_sensitive`, which is False by default.</span>
-</span><span id="TypeParser-263"><a href="#TypeParser-263"><span class="linenos">263</span></a>
-</span><span id="TypeParser-264"><a href="#TypeParser-264"><span class="linenos">264</span></a><span class="sd">			Parameters</span>
-</span><span id="TypeParser-265"><a href="#TypeParser-265"><span class="linenos">265</span></a><span class="sd">			----------</span>
-</span><span id="TypeParser-266"><a href="#TypeParser-266"><span class="linenos">266</span></a><span class="sd">			`value`</span>
-</span><span id="TypeParser-267"><a href="#TypeParser-267"><span class="linenos">267</span></a><span class="sd">			: string to be checked</span>
-</span><span id="TypeParser-268"><a href="#TypeParser-268"><span class="linenos">268</span></a>
-</span><span id="TypeParser-269"><a href="#TypeParser-269"><span class="linenos">269</span></a><span class="sd">			Returns</span>
-</span><span id="TypeParser-270"><a href="#TypeParser-270"><span class="linenos">270</span></a><span class="sd">			-------</span>
-</span><span id="TypeParser-271"><a href="#TypeParser-271"><span class="linenos">271</span></a><span class="sd">			whether it is a bool</span>
-</span><span id="TypeParser-272"><a href="#TypeParser-272"><span class="linenos">272</span></a>
-</span><span id="TypeParser-273"><a href="#TypeParser-273"><span class="linenos">273</span></a><span class="sd">			Examples</span>
-</span><span id="TypeParser-274"><a href="#TypeParser-274"><span class="linenos">274</span></a><span class="sd">			--------</span>
-</span><span id="TypeParser-275"><a href="#TypeParser-275"><span class="linenos">275</span></a><span class="sd">			```python</span>
-</span><span id="TypeParser-276"><a href="#TypeParser-276"><span class="linenos">276</span></a><span class="sd">			parser = TypeParser()</span>
-</span><span id="TypeParser-277"><a href="#TypeParser-277"><span class="linenos">277</span></a><span class="sd">			parser.is_bool(&quot;true&quot;)  # True</span>
-</span><span id="TypeParser-278"><a href="#TypeParser-278"><span class="linenos">278</span></a><span class="sd">			parser.is_bool(&quot;&quot;)      # True</span>
-</span><span id="TypeParser-279"><a href="#TypeParser-279"><span class="linenos">279</span></a><span class="sd">			parser.is_bool(&quot;abc&quot;)   # False</span>
-</span><span id="TypeParser-280"><a href="#TypeParser-280"><span class="linenos">280</span></a><span class="sd">			```</span>
-</span><span id="TypeParser-281"><a href="#TypeParser-281"><span class="linenos">281</span></a><span class="sd">		&quot;&quot;&quot;</span>
-</span><span id="TypeParser-282"><a href="#TypeParser-282"><span class="linenos">282</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trim</span><span class="p">:</span>
-</span><span id="TypeParser-283"><a href="#TypeParser-283"><span class="linenos">283</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
-</span><span id="TypeParser-284"><a href="#TypeParser-284"><span class="linenos">284</span></a>
-</span><span id="TypeParser-285"><a href="#TypeParser-285"><span class="linenos">285</span></a>		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">bool_case_sensitive</span><span class="p">:</span>
-</span><span id="TypeParser-286"><a href="#TypeParser-286"><span class="linenos">286</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
-</span><span id="TypeParser-287"><a href="#TypeParser-287"><span class="linenos">287</span></a>		<span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">true_values</span><span class="p">:</span>
-</span><span id="TypeParser-288"><a href="#TypeParser-288"><span class="linenos">288</span></a>			<span class="k">return</span> <span class="kc">True</span>
-</span><span id="TypeParser-289"><a href="#TypeParser-289"><span class="linenos">289</span></a>		<span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">false_values</span><span class="p">:</span>
-</span><span id="TypeParser-290"><a href="#TypeParser-290"><span class="linenos">290</span></a>			<span class="k">return</span> <span class="kc">True</span>
-</span><span id="TypeParser-291"><a href="#TypeParser-291"><span class="linenos">291</span></a>
-</span><span id="TypeParser-292"><a href="#TypeParser-292"><span class="linenos">292</span></a>		<span class="k">return</span> <span class="kc">False</span>
+</span><span id="TypeParser-257"><a href="#TypeParser-257"><span class="linenos">257</span></a>	<span class="k">def</span> <span class="nf">is_bool</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
+</span><span id="TypeParser-258"><a href="#TypeParser-258"><span class="linenos">258</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
+</span><span id="TypeParser-259"><a href="#TypeParser-259"><span class="linenos">259</span></a><span class="sd">			Check if a string represents a bool</span>
+</span><span id="TypeParser-260"><a href="#TypeParser-260"><span class="linenos">260</span></a>
+</span><span id="TypeParser-261"><a href="#TypeParser-261"><span class="linenos">261</span></a><span class="sd">			Only strings that match the values in `self.true_values` and `self.false_values` will be interpreted as booleans. The default accepted values are `[&quot;true&quot;]` and `[&quot;false&quot;]` respectively. The case sensitivity of this matching depends on `self.bool_case_sensitive`, which is False by default.</span>
+</span><span id="TypeParser-262"><a href="#TypeParser-262"><span class="linenos">262</span></a>
+</span><span id="TypeParser-263"><a href="#TypeParser-263"><span class="linenos">263</span></a><span class="sd">			Parameters</span>
+</span><span id="TypeParser-264"><a href="#TypeParser-264"><span class="linenos">264</span></a><span class="sd">			----------</span>
+</span><span id="TypeParser-265"><a href="#TypeParser-265"><span class="linenos">265</span></a><span class="sd">			`value`</span>
+</span><span id="TypeParser-266"><a href="#TypeParser-266"><span class="linenos">266</span></a><span class="sd">			: string to be checked</span>
+</span><span id="TypeParser-267"><a href="#TypeParser-267"><span class="linenos">267</span></a>
+</span><span id="TypeParser-268"><a href="#TypeParser-268"><span class="linenos">268</span></a><span class="sd">			Returns</span>
+</span><span id="TypeParser-269"><a href="#TypeParser-269"><span class="linenos">269</span></a><span class="sd">			-------</span>
+</span><span id="TypeParser-270"><a href="#TypeParser-270"><span class="linenos">270</span></a><span class="sd">			whether it is a bool</span>
+</span><span id="TypeParser-271"><a href="#TypeParser-271"><span class="linenos">271</span></a>
+</span><span id="TypeParser-272"><a href="#TypeParser-272"><span class="linenos">272</span></a><span class="sd">			Examples</span>
+</span><span id="TypeParser-273"><a href="#TypeParser-273"><span class="linenos">273</span></a><span class="sd">			--------</span>
+</span><span id="TypeParser-274"><a href="#TypeParser-274"><span class="linenos">274</span></a><span class="sd">			```python</span>
+</span><span id="TypeParser-275"><a href="#TypeParser-275"><span class="linenos">275</span></a><span class="sd">			parser = TypeParser()</span>
+</span><span id="TypeParser-276"><a href="#TypeParser-276"><span class="linenos">276</span></a><span class="sd">			parser.is_bool(&quot;true&quot;)  # True</span>
+</span><span id="TypeParser-277"><a href="#TypeParser-277"><span class="linenos">277</span></a><span class="sd">			parser.is_bool(&quot;&quot;)      # True</span>
+</span><span id="TypeParser-278"><a href="#TypeParser-278"><span class="linenos">278</span></a><span class="sd">			parser.is_bool(&quot;abc&quot;)   # False</span>
+</span><span id="TypeParser-279"><a href="#TypeParser-279"><span class="linenos">279</span></a><span class="sd">			```</span>
+</span><span id="TypeParser-280"><a href="#TypeParser-280"><span class="linenos">280</span></a><span class="sd">		&quot;&quot;&quot;</span>
+</span><span id="TypeParser-281"><a href="#TypeParser-281"><span class="linenos">281</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trim</span><span class="p">:</span>
+</span><span id="TypeParser-282"><a href="#TypeParser-282"><span class="linenos">282</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
+</span><span id="TypeParser-283"><a href="#TypeParser-283"><span class="linenos">283</span></a>
+</span><span id="TypeParser-284"><a href="#TypeParser-284"><span class="linenos">284</span></a>		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">bool_case_sensitive</span><span class="p">:</span>
+</span><span id="TypeParser-285"><a href="#TypeParser-285"><span class="linenos">285</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
+</span><span id="TypeParser-286"><a href="#TypeParser-286"><span class="linenos">286</span></a>		<span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">true_values</span><span class="p">:</span>
+</span><span id="TypeParser-287"><a href="#TypeParser-287"><span class="linenos">287</span></a>			<span class="k">return</span> <span class="kc">True</span>
+</span><span id="TypeParser-288"><a href="#TypeParser-288"><span class="linenos">288</span></a>		<span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">false_values</span><span class="p">:</span>
+</span><span id="TypeParser-289"><a href="#TypeParser-289"><span class="linenos">289</span></a>			<span class="k">return</span> <span class="kc">True</span>
+</span><span id="TypeParser-290"><a href="#TypeParser-290"><span class="linenos">290</span></a>
+</span><span id="TypeParser-291"><a href="#TypeParser-291"><span class="linenos">291</span></a>		<span class="k">return</span> <span class="kc">False</span>
+</span><span id="TypeParser-292"><a href="#TypeParser-292"><span class="linenos">292</span></a>
 </span><span id="TypeParser-293"><a href="#TypeParser-293"><span class="linenos">293</span></a>
-</span><span id="TypeParser-294"><a href="#TypeParser-294"><span class="linenos">294</span></a>
-</span><span id="TypeParser-295"><a href="#TypeParser-295"><span class="linenos">295</span></a>	<span class="k">def</span> <span class="nf">is_int</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">allow_sign</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_negative</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
-</span><span id="TypeParser-296"><a href="#TypeParser-296"><span class="linenos">296</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
-</span><span id="TypeParser-297"><a href="#TypeParser-297"><span class="linenos">297</span></a><span class="sd">			Check if a string represents an int</span>
-</span><span id="TypeParser-298"><a href="#TypeParser-298"><span class="linenos">298</span></a>
-</span><span id="TypeParser-299"><a href="#TypeParser-299"><span class="linenos">299</span></a><span class="sd">			Parameters</span>
-</span><span id="TypeParser-300"><a href="#TypeParser-300"><span class="linenos">300</span></a><span class="sd">			----------</span>
-</span><span id="TypeParser-301"><a href="#TypeParser-301"><span class="linenos">301</span></a><span class="sd">			`value`</span>
-</span><span id="TypeParser-302"><a href="#TypeParser-302"><span class="linenos">302</span></a><span class="sd">			: string to be checked</span>
-</span><span id="TypeParser-303"><a href="#TypeParser-303"><span class="linenos">303</span></a>
-</span><span id="TypeParser-304"><a href="#TypeParser-304"><span class="linenos">304</span></a><span class="sd">			`allow_negative`</span>
-</span><span id="TypeParser-305"><a href="#TypeParser-305"><span class="linenos">305</span></a><span class="sd">			: whether to accept negative values</span>
-</span><span id="TypeParser-306"><a href="#TypeParser-306"><span class="linenos">306</span></a>
-</span><span id="TypeParser-307"><a href="#TypeParser-307"><span class="linenos">307</span></a><span class="sd">			`allow_sign`</span>
-</span><span id="TypeParser-308"><a href="#TypeParser-308"><span class="linenos">308</span></a><span class="sd">			: whether to accept signed values. If False, it implies that `allow_negative` is False also.</span>
-</span><span id="TypeParser-309"><a href="#TypeParser-309"><span class="linenos">309</span></a>
-</span><span id="TypeParser-310"><a href="#TypeParser-310"><span class="linenos">310</span></a><span class="sd">			`allow_scientific`</span>
-</span><span id="TypeParser-311"><a href="#TypeParser-311"><span class="linenos">311</span></a><span class="sd">			: whether to accept scientific notation. If True, strings of the form `&quot;&lt;var&gt;M&lt;/var&gt;e&lt;var&gt;X&lt;/var&gt;&quot;` will be interpreted as the expression `&lt;var&gt;M&lt;/var&gt; * (10 ** &lt;var&gt;X&lt;/var&gt;)`, where &lt;var&gt;M&lt;/var&gt; is the mantissa/significand and &lt;var&gt;X&lt;/var&gt; is the exponent. Note &lt;var&gt;M&lt;/var&gt; *must* be an integer and &lt;var&gt;X&lt;/var&gt; *must* be a non-negative integer, even in cases where the above expression evaluates mathematically to an integer.</span>
-</span><span id="TypeParser-312"><a href="#TypeParser-312"><span class="linenos">312</span></a>
-</span><span id="TypeParser-313"><a href="#TypeParser-313"><span class="linenos">313</span></a><span class="sd">			Returns</span>
-</span><span id="TypeParser-314"><a href="#TypeParser-314"><span class="linenos">314</span></a><span class="sd">			-------</span>
-</span><span id="TypeParser-315"><a href="#TypeParser-315"><span class="linenos">315</span></a><span class="sd">			whether it is an int</span>
-</span><span id="TypeParser-316"><a href="#TypeParser-316"><span class="linenos">316</span></a>
-</span><span id="TypeParser-317"><a href="#TypeParser-317"><span class="linenos">317</span></a><span class="sd">			Examples</span>
-</span><span id="TypeParser-318"><a href="#TypeParser-318"><span class="linenos">318</span></a><span class="sd">			--------</span>
-</span><span id="TypeParser-319"><a href="#TypeParser-319"><span class="linenos">319</span></a><span class="sd">			```python</span>
-</span><span id="TypeParser-320"><a href="#TypeParser-320"><span class="linenos">320</span></a><span class="sd">			parser = TypeParser()</span>
-</span><span id="TypeParser-321"><a href="#TypeParser-321"><span class="linenos">321</span></a><span class="sd">			parser.is_int(&quot;0&quot;)    # True</span>
-</span><span id="TypeParser-322"><a href="#TypeParser-322"><span class="linenos">322</span></a><span class="sd">			parser.is_int(&quot;-1&quot;)   # True</span>
-</span><span id="TypeParser-323"><a href="#TypeParser-323"><span class="linenos">323</span></a><span class="sd">			parser.is_int(&quot;abc&quot;)  # False</span>
-</span><span id="TypeParser-324"><a href="#TypeParser-324"><span class="linenos">324</span></a><span class="sd">			parser.is_int(&quot;&quot;)     # False</span>
-</span><span id="TypeParser-325"><a href="#TypeParser-325"><span class="linenos">325</span></a><span class="sd">			```</span>
-</span><span id="TypeParser-326"><a href="#TypeParser-326"><span class="linenos">326</span></a><span class="sd">		&quot;&quot;&quot;</span>
-</span><span id="TypeParser-327"><a href="#TypeParser-327"><span class="linenos">327</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trim</span><span class="p">:</span>
-</span><span id="TypeParser-328"><a href="#TypeParser-328"><span class="linenos">328</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
-</span><span id="TypeParser-329"><a href="#TypeParser-329"><span class="linenos">329</span></a>
-</span><span id="TypeParser-330"><a href="#TypeParser-330"><span class="linenos">330</span></a>		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
-</span><span id="TypeParser-331"><a href="#TypeParser-331"><span class="linenos">331</span></a>			<span class="k">return</span> <span class="kc">False</span>
-</span><span id="TypeParser-332"><a href="#TypeParser-332"><span class="linenos">332</span></a>
-</span><span id="TypeParser-333"><a href="#TypeParser-333"><span class="linenos">333</span></a>		<span class="k">if</span> <span class="n">allow_scientific</span><span class="p">:</span>
-</span><span id="TypeParser-334"><a href="#TypeParser-334"><span class="linenos">334</span></a>			<span class="n">value</span><span class="p">,</span> <span class="n">exp</span> <span class="o">=</span> <span class="n">_decompose_string_pair</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scientific_char</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">int_case_sensitive</span><span class="p">)</span>
-</span><span id="TypeParser-335"><a href="#TypeParser-335"><span class="linenos">335</span></a>			<span class="k">if</span> <span class="n">exp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
-</span><span id="TypeParser-336"><a href="#TypeParser-336"><span class="linenos">336</span></a>				<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_int</span><span class="p">(</span>
-</span><span id="TypeParser-337"><a href="#TypeParser-337"><span class="linenos">337</span></a>					<span class="n">value</span><span class="p">,</span> <span class="n">allow_sign</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_negative</span><span class="o">=</span><span class="n">allow_negative</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="o">=</span><span class="kc">False</span>
-</span><span id="TypeParser-338"><a href="#TypeParser-338"><span class="linenos">338</span></a>				<span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_int</span><span class="p">(</span>
-</span><span id="TypeParser-339"><a href="#TypeParser-339"><span class="linenos">339</span></a>					<span class="n">exp</span><span class="p">,</span> <span class="n">allow_sign</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_negative</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="o">=</span><span class="kc">False</span>
-</span><span id="TypeParser-340"><a href="#TypeParser-340"><span class="linenos">340</span></a>				<span class="p">)</span>
-</span><span id="TypeParser-341"><a href="#TypeParser-341"><span class="linenos">341</span></a>
-</span><span id="TypeParser-342"><a href="#TypeParser-342"><span class="linenos">342</span></a>		<span class="k">if</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sign_chars</span><span class="p">:</span>
-</span><span id="TypeParser-343"><a href="#TypeParser-343"><span class="linenos">343</span></a>			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
-</span><span id="TypeParser-344"><a href="#TypeParser-344"><span class="linenos">344</span></a>				<span class="k">return</span> <span class="kc">False</span>
-</span><span id="TypeParser-345"><a href="#TypeParser-345"><span class="linenos">345</span></a>			<span class="k">if</span> <span class="ow">not</span> <span class="n">allow_sign</span><span class="p">:</span>
-</span><span id="TypeParser-346"><a href="#TypeParser-346"><span class="linenos">346</span></a>				<span class="k">return</span> <span class="kc">False</span>
-</span><span id="TypeParser-347"><a href="#TypeParser-347"><span class="linenos">347</span></a>			<span class="k">if</span> <span class="ow">not</span> <span class="n">allow_negative</span> <span class="ow">and</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_negative_chars</span><span class="p">:</span>
-</span><span id="TypeParser-348"><a href="#TypeParser-348"><span class="linenos">348</span></a>				<span class="k">return</span> <span class="kc">False</span>
-</span><span id="TypeParser-349"><a href="#TypeParser-349"><span class="linenos">349</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
-</span><span id="TypeParser-350"><a href="#TypeParser-350"><span class="linenos">350</span></a>		<span class="k">if</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_digit_separators</span> <span class="ow">or</span> <span class="n">value</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_digit_separators</span><span class="p">:</span>
-</span><span id="TypeParser-351"><a href="#TypeParser-351"><span class="linenos">351</span></a>			<span class="k">return</span> <span class="kc">False</span>
-</span><span id="TypeParser-352"><a href="#TypeParser-352"><span class="linenos">352</span></a>
-</span><span id="TypeParser-353"><a href="#TypeParser-353"><span class="linenos">353</span></a>		<span class="n">prev_separated</span> <span class="o">=</span> <span class="kc">False</span>
-</span><span id="TypeParser-354"><a href="#TypeParser-354"><span class="linenos">354</span></a>		<span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
-</span><span id="TypeParser-355"><a href="#TypeParser-355"><span class="linenos">355</span></a>			<span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_digit_separators</span><span class="p">:</span>
-</span><span id="TypeParser-356"><a href="#TypeParser-356"><span class="linenos">356</span></a>				<span class="k">if</span> <span class="n">prev_separated</span><span class="p">:</span>
-</span><span id="TypeParser-357"><a href="#TypeParser-357"><span class="linenos">357</span></a>					<span class="k">return</span> <span class="kc">False</span>
-</span><span id="TypeParser-358"><a href="#TypeParser-358"><span class="linenos">358</span></a>				<span class="n">prev_separated</span> <span class="o">=</span> <span class="kc">True</span>
-</span><span id="TypeParser-359"><a href="#TypeParser-359"><span class="linenos">359</span></a>			<span class="k">else</span><span class="p">:</span>
-</span><span id="TypeParser-360"><a href="#TypeParser-360"><span class="linenos">360</span></a>				<span class="n">prev_separated</span> <span class="o">=</span> <span class="kc">False</span>
-</span><span id="TypeParser-361"><a href="#TypeParser-361"><span class="linenos">361</span></a>				<span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_digit_chars</span><span class="p">:</span>
-</span><span id="TypeParser-362"><a href="#TypeParser-362"><span class="linenos">362</span></a>					<span class="k">return</span> <span class="kc">False</span>
-</span><span id="TypeParser-363"><a href="#TypeParser-363"><span class="linenos">363</span></a>		<span class="k">return</span> <span class="kc">True</span>
+</span><span id="TypeParser-294"><a href="#TypeParser-294"><span class="linenos">294</span></a>	<span class="k">def</span> <span class="nf">is_int</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">allow_sign</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_negative</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
+</span><span id="TypeParser-295"><a href="#TypeParser-295"><span class="linenos">295</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
+</span><span id="TypeParser-296"><a href="#TypeParser-296"><span class="linenos">296</span></a><span class="sd">			Check if a string represents an int</span>
+</span><span id="TypeParser-297"><a href="#TypeParser-297"><span class="linenos">297</span></a>
+</span><span id="TypeParser-298"><a href="#TypeParser-298"><span class="linenos">298</span></a><span class="sd">			Parameters</span>
+</span><span id="TypeParser-299"><a href="#TypeParser-299"><span class="linenos">299</span></a><span class="sd">			----------</span>
+</span><span id="TypeParser-300"><a href="#TypeParser-300"><span class="linenos">300</span></a><span class="sd">			`value`</span>
+</span><span id="TypeParser-301"><a href="#TypeParser-301"><span class="linenos">301</span></a><span class="sd">			: string to be checked</span>
+</span><span id="TypeParser-302"><a href="#TypeParser-302"><span class="linenos">302</span></a>
+</span><span id="TypeParser-303"><a href="#TypeParser-303"><span class="linenos">303</span></a><span class="sd">			`allow_negative`</span>
+</span><span id="TypeParser-304"><a href="#TypeParser-304"><span class="linenos">304</span></a><span class="sd">			: whether to accept negative values</span>
+</span><span id="TypeParser-305"><a href="#TypeParser-305"><span class="linenos">305</span></a>
+</span><span id="TypeParser-306"><a href="#TypeParser-306"><span class="linenos">306</span></a><span class="sd">			`allow_sign`</span>
+</span><span id="TypeParser-307"><a href="#TypeParser-307"><span class="linenos">307</span></a><span class="sd">			: whether to accept signed values. If False, it implies that `allow_negative` is False also.</span>
+</span><span id="TypeParser-308"><a href="#TypeParser-308"><span class="linenos">308</span></a>
+</span><span id="TypeParser-309"><a href="#TypeParser-309"><span class="linenos">309</span></a><span class="sd">			`allow_scientific`</span>
+</span><span id="TypeParser-310"><a href="#TypeParser-310"><span class="linenos">310</span></a><span class="sd">			: whether to accept scientific notation. If True, strings of the form `&quot;&lt;var&gt;M&lt;/var&gt;e&lt;var&gt;X&lt;/var&gt;&quot;` will be interpreted as the expression `&lt;var&gt;M&lt;/var&gt; * (10 ** &lt;var&gt;X&lt;/var&gt;)`, where &lt;var&gt;M&lt;/var&gt; is the mantissa/significand and &lt;var&gt;X&lt;/var&gt; is the exponent. Note &lt;var&gt;M&lt;/var&gt; *must* be an integer and &lt;var&gt;X&lt;/var&gt; *must* be a non-negative integer, even in cases where the above expression evaluates mathematically to an integer.</span>
+</span><span id="TypeParser-311"><a href="#TypeParser-311"><span class="linenos">311</span></a>
+</span><span id="TypeParser-312"><a href="#TypeParser-312"><span class="linenos">312</span></a><span class="sd">			Returns</span>
+</span><span id="TypeParser-313"><a href="#TypeParser-313"><span class="linenos">313</span></a><span class="sd">			-------</span>
+</span><span id="TypeParser-314"><a href="#TypeParser-314"><span class="linenos">314</span></a><span class="sd">			whether it is an int</span>
+</span><span id="TypeParser-315"><a href="#TypeParser-315"><span class="linenos">315</span></a>
+</span><span id="TypeParser-316"><a href="#TypeParser-316"><span class="linenos">316</span></a><span class="sd">			Examples</span>
+</span><span id="TypeParser-317"><a href="#TypeParser-317"><span class="linenos">317</span></a><span class="sd">			--------</span>
+</span><span id="TypeParser-318"><a href="#TypeParser-318"><span class="linenos">318</span></a><span class="sd">			```python</span>
+</span><span id="TypeParser-319"><a href="#TypeParser-319"><span class="linenos">319</span></a><span class="sd">			parser = TypeParser()</span>
+</span><span id="TypeParser-320"><a href="#TypeParser-320"><span class="linenos">320</span></a><span class="sd">			parser.is_int(&quot;0&quot;)    # True</span>
+</span><span id="TypeParser-321"><a href="#TypeParser-321"><span class="linenos">321</span></a><span class="sd">			parser.is_int(&quot;-1&quot;)   # True</span>
+</span><span id="TypeParser-322"><a href="#TypeParser-322"><span class="linenos">322</span></a><span class="sd">			parser.is_int(&quot;abc&quot;)  # False</span>
+</span><span id="TypeParser-323"><a href="#TypeParser-323"><span class="linenos">323</span></a><span class="sd">			parser.is_int(&quot;&quot;)     # False</span>
+</span><span id="TypeParser-324"><a href="#TypeParser-324"><span class="linenos">324</span></a><span class="sd">			```</span>
+</span><span id="TypeParser-325"><a href="#TypeParser-325"><span class="linenos">325</span></a><span class="sd">		&quot;&quot;&quot;</span>
+</span><span id="TypeParser-326"><a href="#TypeParser-326"><span class="linenos">326</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trim</span><span class="p">:</span>
+</span><span id="TypeParser-327"><a href="#TypeParser-327"><span class="linenos">327</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
+</span><span id="TypeParser-328"><a href="#TypeParser-328"><span class="linenos">328</span></a>
+</span><span id="TypeParser-329"><a href="#TypeParser-329"><span class="linenos">329</span></a>		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
+</span><span id="TypeParser-330"><a href="#TypeParser-330"><span class="linenos">330</span></a>			<span class="k">return</span> <span class="kc">False</span>
+</span><span id="TypeParser-331"><a href="#TypeParser-331"><span class="linenos">331</span></a>
+</span><span id="TypeParser-332"><a href="#TypeParser-332"><span class="linenos">332</span></a>		<span class="k">if</span> <span class="n">allow_scientific</span><span class="p">:</span>
+</span><span id="TypeParser-333"><a href="#TypeParser-333"><span class="linenos">333</span></a>			<span class="n">value</span><span class="p">,</span> <span class="n">exp</span> <span class="o">=</span> <span class="n">_decompose_string_pair</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scientific_char</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">int_case_sensitive</span><span class="p">)</span>
+</span><span id="TypeParser-334"><a href="#TypeParser-334"><span class="linenos">334</span></a>			<span class="k">if</span> <span class="n">exp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
+</span><span id="TypeParser-335"><a href="#TypeParser-335"><span class="linenos">335</span></a>				<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_int</span><span class="p">(</span>
+</span><span id="TypeParser-336"><a href="#TypeParser-336"><span class="linenos">336</span></a>					<span class="n">value</span><span class="p">,</span> <span class="n">allow_sign</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_negative</span><span class="o">=</span><span class="n">allow_negative</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="o">=</span><span class="kc">False</span>
+</span><span id="TypeParser-337"><a href="#TypeParser-337"><span class="linenos">337</span></a>				<span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_int</span><span class="p">(</span>
+</span><span id="TypeParser-338"><a href="#TypeParser-338"><span class="linenos">338</span></a>					<span class="n">exp</span><span class="p">,</span> <span class="n">allow_sign</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_negative</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="o">=</span><span class="kc">False</span>
+</span><span id="TypeParser-339"><a href="#TypeParser-339"><span class="linenos">339</span></a>				<span class="p">)</span>
+</span><span id="TypeParser-340"><a href="#TypeParser-340"><span class="linenos">340</span></a>
+</span><span id="TypeParser-341"><a href="#TypeParser-341"><span class="linenos">341</span></a>		<span class="k">if</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sign_chars</span><span class="p">:</span>
+</span><span id="TypeParser-342"><a href="#TypeParser-342"><span class="linenos">342</span></a>			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
+</span><span id="TypeParser-343"><a href="#TypeParser-343"><span class="linenos">343</span></a>				<span class="k">return</span> <span class="kc">False</span>
+</span><span id="TypeParser-344"><a href="#TypeParser-344"><span class="linenos">344</span></a>			<span class="k">if</span> <span class="ow">not</span> <span class="n">allow_sign</span><span class="p">:</span>
+</span><span id="TypeParser-345"><a href="#TypeParser-345"><span class="linenos">345</span></a>				<span class="k">return</span> <span class="kc">False</span>
+</span><span id="TypeParser-346"><a href="#TypeParser-346"><span class="linenos">346</span></a>			<span class="k">if</span> <span class="ow">not</span> <span class="n">allow_negative</span> <span class="ow">and</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_negative_chars</span><span class="p">:</span>
+</span><span id="TypeParser-347"><a href="#TypeParser-347"><span class="linenos">347</span></a>				<span class="k">return</span> <span class="kc">False</span>
+</span><span id="TypeParser-348"><a href="#TypeParser-348"><span class="linenos">348</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
+</span><span id="TypeParser-349"><a href="#TypeParser-349"><span class="linenos">349</span></a>		<span class="k">if</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_digit_separators</span> <span class="ow">or</span> <span class="n">value</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_digit_separators</span><span class="p">:</span>
+</span><span id="TypeParser-350"><a href="#TypeParser-350"><span class="linenos">350</span></a>			<span class="k">return</span> <span class="kc">False</span>
+</span><span id="TypeParser-351"><a href="#TypeParser-351"><span class="linenos">351</span></a>
+</span><span id="TypeParser-352"><a href="#TypeParser-352"><span class="linenos">352</span></a>		<span class="n">prev_separated</span> <span class="o">=</span> <span class="kc">False</span>
+</span><span id="TypeParser-353"><a href="#TypeParser-353"><span class="linenos">353</span></a>		<span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
+</span><span id="TypeParser-354"><a href="#TypeParser-354"><span class="linenos">354</span></a>			<span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_digit_separators</span><span class="p">:</span>
+</span><span id="TypeParser-355"><a href="#TypeParser-355"><span class="linenos">355</span></a>				<span class="k">if</span> <span class="n">prev_separated</span><span class="p">:</span>
+</span><span id="TypeParser-356"><a href="#TypeParser-356"><span class="linenos">356</span></a>					<span class="k">return</span> <span class="kc">False</span>
+</span><span id="TypeParser-357"><a href="#TypeParser-357"><span class="linenos">357</span></a>				<span class="n">prev_separated</span> <span class="o">=</span> <span class="kc">True</span>
+</span><span id="TypeParser-358"><a href="#TypeParser-358"><span class="linenos">358</span></a>			<span class="k">else</span><span class="p">:</span>
+</span><span id="TypeParser-359"><a href="#TypeParser-359"><span class="linenos">359</span></a>				<span class="n">prev_separated</span> <span class="o">=</span> <span class="kc">False</span>
+</span><span id="TypeParser-360"><a href="#TypeParser-360"><span class="linenos">360</span></a>				<span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_digit_chars</span><span class="p">:</span>
+</span><span id="TypeParser-361"><a href="#TypeParser-361"><span class="linenos">361</span></a>					<span class="k">return</span> <span class="kc">False</span>
+</span><span id="TypeParser-362"><a href="#TypeParser-362"><span class="linenos">362</span></a>		<span class="k">return</span> <span class="kc">True</span>
+</span><span id="TypeParser-363"><a href="#TypeParser-363"><span class="linenos">363</span></a>
 </span><span id="TypeParser-364"><a href="#TypeParser-364"><span class="linenos">364</span></a>
-</span><span id="TypeParser-365"><a href="#TypeParser-365"><span class="linenos">365</span></a>
-</span><span id="TypeParser-366"><a href="#TypeParser-366"><span class="linenos">366</span></a>	<span class="k">def</span> <span class="nf">is_float</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_inf</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_nan</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
-</span><span id="TypeParser-367"><a href="#TypeParser-367"><span class="linenos">367</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
-</span><span id="TypeParser-368"><a href="#TypeParser-368"><span class="linenos">368</span></a><span class="sd">			Check if a string represents a float (or equivalently, a Decimal)</span>
-</span><span id="TypeParser-369"><a href="#TypeParser-369"><span class="linenos">369</span></a>
-</span><span id="TypeParser-370"><a href="#TypeParser-370"><span class="linenos">370</span></a><span class="sd">			This function will also return True if the string represents an int.</span>
-</span><span id="TypeParser-371"><a href="#TypeParser-371"><span class="linenos">371</span></a>
-</span><span id="TypeParser-372"><a href="#TypeParser-372"><span class="linenos">372</span></a><span class="sd">			Alias: `is_decimal()`</span>
-</span><span id="TypeParser-373"><a href="#TypeParser-373"><span class="linenos">373</span></a>
-</span><span id="TypeParser-374"><a href="#TypeParser-374"><span class="linenos">374</span></a><span class="sd">			Parameters</span>
-</span><span id="TypeParser-375"><a href="#TypeParser-375"><span class="linenos">375</span></a><span class="sd">			----------</span>
-</span><span id="TypeParser-376"><a href="#TypeParser-376"><span class="linenos">376</span></a><span class="sd">			`value`</span>
-</span><span id="TypeParser-377"><a href="#TypeParser-377"><span class="linenos">377</span></a><span class="sd">			: string to be checked</span>
-</span><span id="TypeParser-378"><a href="#TypeParser-378"><span class="linenos">378</span></a>
-</span><span id="TypeParser-379"><a href="#TypeParser-379"><span class="linenos">379</span></a><span class="sd">			`allow_scientific`</span>
-</span><span id="TypeParser-380"><a href="#TypeParser-380"><span class="linenos">380</span></a><span class="sd">			: whether to accept scientific notation. If True, strings of the form `&quot;&lt;var&gt;M&lt;/var&gt;e&lt;var&gt;X&lt;/var&gt;&quot;` will be interpreted as the expression `&lt;var&gt;M&lt;/var&gt; * (10 ** &lt;var&gt;X&lt;/var&gt;)`, where &lt;var&gt;M&lt;/var&gt; is the mantissa/significand and &lt;var&gt;X&lt;/var&gt; is the exponent. Note that &lt;var&gt;X&lt;/var&gt; must be an integer, but can be negative.</span>
-</span><span id="TypeParser-381"><a href="#TypeParser-381"><span class="linenos">381</span></a>
-</span><span id="TypeParser-382"><a href="#TypeParser-382"><span class="linenos">382</span></a><span class="sd">			`allow_inf`</span>
-</span><span id="TypeParser-383"><a href="#TypeParser-383"><span class="linenos">383</span></a><span class="sd">			: whether to accept positive and negative infinity values. If True, strings that match the values in `self.inf_values` (empty by default) are interpreted as infinity, or as negative infinity if prepended by a negative sign. The case sensitivity of this matching depends on `self.float_case_sensitive`, which is False by default.</span>
-</span><span id="TypeParser-384"><a href="#TypeParser-384"><span class="linenos">384</span></a>
-</span><span id="TypeParser-385"><a href="#TypeParser-385"><span class="linenos">385</span></a><span class="sd">			`allow_nan`</span>
-</span><span id="TypeParser-386"><a href="#TypeParser-386"><span class="linenos">386</span></a><span class="sd">			: whether to accept NaN (not a number) representations. If True, strings that match the values in `self.nan_values` (empty by default) are interpeted as NaN. The case sensitivity of this matching depends on `self.float_case_sensitive`, which is False by default.</span>
-</span><span id="TypeParser-387"><a href="#TypeParser-387"><span class="linenos">387</span></a>
-</span><span id="TypeParser-388"><a href="#TypeParser-388"><span class="linenos">388</span></a><span class="sd">			Returns</span>
-</span><span id="TypeParser-389"><a href="#TypeParser-389"><span class="linenos">389</span></a><span class="sd">			-------</span>
-</span><span id="TypeParser-390"><a href="#TypeParser-390"><span class="linenos">390</span></a><span class="sd">			whether it is a float or Decimal</span>
-</span><span id="TypeParser-391"><a href="#TypeParser-391"><span class="linenos">391</span></a>
-</span><span id="TypeParser-392"><a href="#TypeParser-392"><span class="linenos">392</span></a><span class="sd">			Examples</span>
-</span><span id="TypeParser-393"><a href="#TypeParser-393"><span class="linenos">393</span></a><span class="sd">			--------</span>
-</span><span id="TypeParser-394"><a href="#TypeParser-394"><span class="linenos">394</span></a><span class="sd">			```python</span>
-</span><span id="TypeParser-395"><a href="#TypeParser-395"><span class="linenos">395</span></a><span class="sd">			parser = TypeParser()</span>
-</span><span id="TypeParser-396"><a href="#TypeParser-396"><span class="linenos">396</span></a><span class="sd">			parser.is_float(&quot;1.&quot;)       # True</span>
-</span><span id="TypeParser-397"><a href="#TypeParser-397"><span class="linenos">397</span></a><span class="sd">			parser.is_float(&quot;12.3e-2&quot;)  # True</span>
-</span><span id="TypeParser-398"><a href="#TypeParser-398"><span class="linenos">398</span></a><span class="sd">			parser.is_float(&quot;abc&quot;)      # False</span>
-</span><span id="TypeParser-399"><a href="#TypeParser-399"><span class="linenos">399</span></a><span class="sd">			parser.is_float(&quot;&quot;)         # False</span>
-</span><span id="TypeParser-400"><a href="#TypeParser-400"><span class="linenos">400</span></a><span class="sd">			```</span>
-</span><span id="TypeParser-401"><a href="#TypeParser-401"><span class="linenos">401</span></a><span class="sd">		&quot;&quot;&quot;</span>
-</span><span id="TypeParser-402"><a href="#TypeParser-402"><span class="linenos">402</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trim</span><span class="p">:</span>
-</span><span id="TypeParser-403"><a href="#TypeParser-403"><span class="linenos">403</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
-</span><span id="TypeParser-404"><a href="#TypeParser-404"><span class="linenos">404</span></a>
-</span><span id="TypeParser-405"><a href="#TypeParser-405"><span class="linenos">405</span></a>		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sign_chars</span><span class="p">:</span>
-</span><span id="TypeParser-406"><a href="#TypeParser-406"><span class="linenos">406</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
-</span><span id="TypeParser-407"><a href="#TypeParser-407"><span class="linenos">407</span></a>
-</span><span id="TypeParser-408"><a href="#TypeParser-408"><span class="linenos">408</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">float_case_sensitive</span><span class="p">:</span>
-</span><span id="TypeParser-409"><a href="#TypeParser-409"><span class="linenos">409</span></a>			<span class="n">special_value</span> <span class="o">=</span> <span class="n">value</span>
-</span><span id="TypeParser-410"><a href="#TypeParser-410"><span class="linenos">410</span></a>		<span class="k">else</span><span class="p">:</span>
-</span><span id="TypeParser-411"><a href="#TypeParser-411"><span class="linenos">411</span></a>			<span class="n">special_value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
-</span><span id="TypeParser-412"><a href="#TypeParser-412"><span class="linenos">412</span></a>		<span class="k">if</span> <span class="n">allow_inf</span> <span class="ow">and</span> <span class="n">special_value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inf_values</span><span class="p">:</span>
-</span><span id="TypeParser-413"><a href="#TypeParser-413"><span class="linenos">413</span></a>			<span class="k">return</span> <span class="kc">True</span>
-</span><span id="TypeParser-414"><a href="#TypeParser-414"><span class="linenos">414</span></a>		<span class="k">if</span> <span class="n">allow_nan</span> <span class="ow">and</span> <span class="n">special_value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nan_values</span><span class="p">:</span>
-</span><span id="TypeParser-415"><a href="#TypeParser-415"><span class="linenos">415</span></a>			<span class="k">return</span> <span class="kc">True</span>
-</span><span id="TypeParser-416"><a href="#TypeParser-416"><span class="linenos">416</span></a>
-</span><span id="TypeParser-417"><a href="#TypeParser-417"><span class="linenos">417</span></a>		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
-</span><span id="TypeParser-418"><a href="#TypeParser-418"><span class="linenos">418</span></a>			<span class="k">return</span> <span class="kc">False</span>
-</span><span id="TypeParser-419"><a href="#TypeParser-419"><span class="linenos">419</span></a>
-</span><span id="TypeParser-420"><a href="#TypeParser-420"><span class="linenos">420</span></a>		<span class="k">if</span> <span class="n">allow_scientific</span><span class="p">:</span>
-</span><span id="TypeParser-421"><a href="#TypeParser-421"><span class="linenos">421</span></a>			<span class="n">value</span><span class="p">,</span> <span class="n">exp</span> <span class="o">=</span> <span class="n">_decompose_string_pair</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scientific_char</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">float_case_sensitive</span><span class="p">)</span>
-</span><span id="TypeParser-422"><a href="#TypeParser-422"><span class="linenos">422</span></a>			<span class="k">if</span> <span class="n">exp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
-</span><span id="TypeParser-423"><a href="#TypeParser-423"><span class="linenos">423</span></a>				<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_float</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">allow_inf</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">allow_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_int</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">allow_sign</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_negative</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
-</span><span id="TypeParser-424"><a href="#TypeParser-424"><span class="linenos">424</span></a>
-</span><span id="TypeParser-425"><a href="#TypeParser-425"><span class="linenos">425</span></a>		<span class="n">value</span><span class="p">,</span> <span class="n">frac</span> <span class="o">=</span> <span class="n">_decompose_string_pair</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_float_separator</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">float_case_sensitive</span><span class="p">)</span>
-</span><span id="TypeParser-426"><a href="#TypeParser-426"><span class="linenos">426</span></a>		<span class="k">if</span> <span class="n">frac</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
-</span><span id="TypeParser-427"><a href="#TypeParser-427"><span class="linenos">427</span></a>			<span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span> <span class="ow">and</span> <span class="n">frac</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
-</span><span id="TypeParser-428"><a href="#TypeParser-428"><span class="linenos">428</span></a>				<span class="k">return</span> <span class="kc">False</span>
-</span><span id="TypeParser-429"><a href="#TypeParser-429"><span class="linenos">429</span></a>			<span class="k">return</span> <span class="p">(</span>
-</span><span id="TypeParser-430"><a href="#TypeParser-430"><span class="linenos">430</span></a>				<span class="bp">self</span><span class="o">.</span><span class="n">is_int</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">allow_sign</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_negative</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="ow">or</span> <span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span>
-</span><span id="TypeParser-431"><a href="#TypeParser-431"><span class="linenos">431</span></a>			<span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
-</span><span id="TypeParser-432"><a href="#TypeParser-432"><span class="linenos">432</span></a>				<span class="bp">self</span><span class="o">.</span><span class="n">is_int</span><span class="p">(</span><span class="n">frac</span><span class="p">,</span> <span class="n">allow_sign</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">allow_negative</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="ow">or</span> <span class="n">frac</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span>
-</span><span id="TypeParser-433"><a href="#TypeParser-433"><span class="linenos">433</span></a>			<span class="p">)</span>
-</span><span id="TypeParser-434"><a href="#TypeParser-434"><span class="linenos">434</span></a>
-</span><span id="TypeParser-435"><a href="#TypeParser-435"><span class="linenos">435</span></a>		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_int</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">allow_sign</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_negative</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
+</span><span id="TypeParser-365"><a href="#TypeParser-365"><span class="linenos">365</span></a>	<span class="k">def</span> <span class="nf">is_float</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_inf</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_nan</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
+</span><span id="TypeParser-366"><a href="#TypeParser-366"><span class="linenos">366</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
+</span><span id="TypeParser-367"><a href="#TypeParser-367"><span class="linenos">367</span></a><span class="sd">			Check if a string represents a float (or equivalently, a Decimal)</span>
+</span><span id="TypeParser-368"><a href="#TypeParser-368"><span class="linenos">368</span></a>
+</span><span id="TypeParser-369"><a href="#TypeParser-369"><span class="linenos">369</span></a><span class="sd">			This function will also return True if the string represents an int.</span>
+</span><span id="TypeParser-370"><a href="#TypeParser-370"><span class="linenos">370</span></a>
+</span><span id="TypeParser-371"><a href="#TypeParser-371"><span class="linenos">371</span></a><span class="sd">			Alias: `is_decimal()`</span>
+</span><span id="TypeParser-372"><a href="#TypeParser-372"><span class="linenos">372</span></a>
+</span><span id="TypeParser-373"><a href="#TypeParser-373"><span class="linenos">373</span></a><span class="sd">			Parameters</span>
+</span><span id="TypeParser-374"><a href="#TypeParser-374"><span class="linenos">374</span></a><span class="sd">			----------</span>
+</span><span id="TypeParser-375"><a href="#TypeParser-375"><span class="linenos">375</span></a><span class="sd">			`value`</span>
+</span><span id="TypeParser-376"><a href="#TypeParser-376"><span class="linenos">376</span></a><span class="sd">			: string to be checked</span>
+</span><span id="TypeParser-377"><a href="#TypeParser-377"><span class="linenos">377</span></a>
+</span><span id="TypeParser-378"><a href="#TypeParser-378"><span class="linenos">378</span></a><span class="sd">			`allow_scientific`</span>
+</span><span id="TypeParser-379"><a href="#TypeParser-379"><span class="linenos">379</span></a><span class="sd">			: whether to accept scientific notation. If True, strings of the form `&quot;&lt;var&gt;M&lt;/var&gt;e&lt;var&gt;X&lt;/var&gt;&quot;` will be interpreted as the expression `&lt;var&gt;M&lt;/var&gt; * (10 ** &lt;var&gt;X&lt;/var&gt;)`, where &lt;var&gt;M&lt;/var&gt; is the mantissa/significand and &lt;var&gt;X&lt;/var&gt; is the exponent. Note that &lt;var&gt;X&lt;/var&gt; must be an integer, but can be negative.</span>
+</span><span id="TypeParser-380"><a href="#TypeParser-380"><span class="linenos">380</span></a>
+</span><span id="TypeParser-381"><a href="#TypeParser-381"><span class="linenos">381</span></a><span class="sd">			`allow_inf`</span>
+</span><span id="TypeParser-382"><a href="#TypeParser-382"><span class="linenos">382</span></a><span class="sd">			: whether to accept positive and negative infinity values. If True, strings that match the values in `self.inf_values` (empty by default) are interpreted as infinity, or as negative infinity if prepended by a negative sign. The case sensitivity of this matching depends on `self.float_case_sensitive`, which is False by default.</span>
+</span><span id="TypeParser-383"><a href="#TypeParser-383"><span class="linenos">383</span></a>
+</span><span id="TypeParser-384"><a href="#TypeParser-384"><span class="linenos">384</span></a><span class="sd">			`allow_nan`</span>
+</span><span id="TypeParser-385"><a href="#TypeParser-385"><span class="linenos">385</span></a><span class="sd">			: whether to accept NaN (not a number) representations. If True, strings that match the values in `self.nan_values` (empty by default) are interpeted as NaN. The case sensitivity of this matching depends on `self.float_case_sensitive`, which is False by default.</span>
+</span><span id="TypeParser-386"><a href="#TypeParser-386"><span class="linenos">386</span></a>
+</span><span id="TypeParser-387"><a href="#TypeParser-387"><span class="linenos">387</span></a><span class="sd">			Returns</span>
+</span><span id="TypeParser-388"><a href="#TypeParser-388"><span class="linenos">388</span></a><span class="sd">			-------</span>
+</span><span id="TypeParser-389"><a href="#TypeParser-389"><span class="linenos">389</span></a><span class="sd">			whether it is a float or Decimal</span>
+</span><span id="TypeParser-390"><a href="#TypeParser-390"><span class="linenos">390</span></a>
+</span><span id="TypeParser-391"><a href="#TypeParser-391"><span class="linenos">391</span></a><span class="sd">			Examples</span>
+</span><span id="TypeParser-392"><a href="#TypeParser-392"><span class="linenos">392</span></a><span class="sd">			--------</span>
+</span><span id="TypeParser-393"><a href="#TypeParser-393"><span class="linenos">393</span></a><span class="sd">			```python</span>
+</span><span id="TypeParser-394"><a href="#TypeParser-394"><span class="linenos">394</span></a><span class="sd">			parser = TypeParser()</span>
+</span><span id="TypeParser-395"><a href="#TypeParser-395"><span class="linenos">395</span></a><span class="sd">			parser.is_float(&quot;1.&quot;)       # True</span>
+</span><span id="TypeParser-396"><a href="#TypeParser-396"><span class="linenos">396</span></a><span class="sd">			parser.is_float(&quot;12.3e-2&quot;)  # True</span>
+</span><span id="TypeParser-397"><a href="#TypeParser-397"><span class="linenos">397</span></a><span class="sd">			parser.is_float(&quot;abc&quot;)      # False</span>
+</span><span id="TypeParser-398"><a href="#TypeParser-398"><span class="linenos">398</span></a><span class="sd">			parser.is_float(&quot;&quot;)         # False</span>
+</span><span id="TypeParser-399"><a href="#TypeParser-399"><span class="linenos">399</span></a><span class="sd">			```</span>
+</span><span id="TypeParser-400"><a href="#TypeParser-400"><span class="linenos">400</span></a><span class="sd">		&quot;&quot;&quot;</span>
+</span><span id="TypeParser-401"><a href="#TypeParser-401"><span class="linenos">401</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trim</span><span class="p">:</span>
+</span><span id="TypeParser-402"><a href="#TypeParser-402"><span class="linenos">402</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
+</span><span id="TypeParser-403"><a href="#TypeParser-403"><span class="linenos">403</span></a>
+</span><span id="TypeParser-404"><a href="#TypeParser-404"><span class="linenos">404</span></a>		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sign_chars</span><span class="p">:</span>
+</span><span id="TypeParser-405"><a href="#TypeParser-405"><span class="linenos">405</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
+</span><span id="TypeParser-406"><a href="#TypeParser-406"><span class="linenos">406</span></a>
+</span><span id="TypeParser-407"><a href="#TypeParser-407"><span class="linenos">407</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">float_case_sensitive</span><span class="p">:</span>
+</span><span id="TypeParser-408"><a href="#TypeParser-408"><span class="linenos">408</span></a>			<span class="n">special_value</span> <span class="o">=</span> <span class="n">value</span>
+</span><span id="TypeParser-409"><a href="#TypeParser-409"><span class="linenos">409</span></a>		<span class="k">else</span><span class="p">:</span>
+</span><span id="TypeParser-410"><a href="#TypeParser-410"><span class="linenos">410</span></a>			<span class="n">special_value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
+</span><span id="TypeParser-411"><a href="#TypeParser-411"><span class="linenos">411</span></a>		<span class="k">if</span> <span class="n">allow_inf</span> <span class="ow">and</span> <span class="n">special_value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inf_values</span><span class="p">:</span>
+</span><span id="TypeParser-412"><a href="#TypeParser-412"><span class="linenos">412</span></a>			<span class="k">return</span> <span class="kc">True</span>
+</span><span id="TypeParser-413"><a href="#TypeParser-413"><span class="linenos">413</span></a>		<span class="k">if</span> <span class="n">allow_nan</span> <span class="ow">and</span> <span class="n">special_value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nan_values</span><span class="p">:</span>
+</span><span id="TypeParser-414"><a href="#TypeParser-414"><span class="linenos">414</span></a>			<span class="k">return</span> <span class="kc">True</span>
+</span><span id="TypeParser-415"><a href="#TypeParser-415"><span class="linenos">415</span></a>
+</span><span id="TypeParser-416"><a href="#TypeParser-416"><span class="linenos">416</span></a>		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
+</span><span id="TypeParser-417"><a href="#TypeParser-417"><span class="linenos">417</span></a>			<span class="k">return</span> <span class="kc">False</span>
+</span><span id="TypeParser-418"><a href="#TypeParser-418"><span class="linenos">418</span></a>
+</span><span id="TypeParser-419"><a href="#TypeParser-419"><span class="linenos">419</span></a>		<span class="k">if</span> <span class="n">allow_scientific</span><span class="p">:</span>
+</span><span id="TypeParser-420"><a href="#TypeParser-420"><span class="linenos">420</span></a>			<span class="n">value</span><span class="p">,</span> <span class="n">exp</span> <span class="o">=</span> <span class="n">_decompose_string_pair</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scientific_char</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">float_case_sensitive</span><span class="p">)</span>
+</span><span id="TypeParser-421"><a href="#TypeParser-421"><span class="linenos">421</span></a>			<span class="k">if</span> <span class="n">exp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
+</span><span id="TypeParser-422"><a href="#TypeParser-422"><span class="linenos">422</span></a>				<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_float</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">allow_inf</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">allow_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_int</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">allow_sign</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_negative</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
+</span><span id="TypeParser-423"><a href="#TypeParser-423"><span class="linenos">423</span></a>
+</span><span id="TypeParser-424"><a href="#TypeParser-424"><span class="linenos">424</span></a>		<span class="n">value</span><span class="p">,</span> <span class="n">frac</span> <span class="o">=</span> <span class="n">_decompose_string_pair</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_float_separator</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">float_case_sensitive</span><span class="p">)</span>
+</span><span id="TypeParser-425"><a href="#TypeParser-425"><span class="linenos">425</span></a>		<span class="k">if</span> <span class="n">frac</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
+</span><span id="TypeParser-426"><a href="#TypeParser-426"><span class="linenos">426</span></a>			<span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span> <span class="ow">and</span> <span class="n">frac</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
+</span><span id="TypeParser-427"><a href="#TypeParser-427"><span class="linenos">427</span></a>				<span class="k">return</span> <span class="kc">False</span>
+</span><span id="TypeParser-428"><a href="#TypeParser-428"><span class="linenos">428</span></a>			<span class="k">return</span> <span class="p">(</span>
+</span><span id="TypeParser-429"><a href="#TypeParser-429"><span class="linenos">429</span></a>				<span class="bp">self</span><span class="o">.</span><span class="n">is_int</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">allow_sign</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_negative</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="ow">or</span> <span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span>
+</span><span id="TypeParser-430"><a href="#TypeParser-430"><span class="linenos">430</span></a>			<span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
+</span><span id="TypeParser-431"><a href="#TypeParser-431"><span class="linenos">431</span></a>				<span class="bp">self</span><span class="o">.</span><span class="n">is_int</span><span class="p">(</span><span class="n">frac</span><span class="p">,</span> <span class="n">allow_sign</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">allow_negative</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="ow">or</span> <span class="n">frac</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span>
+</span><span id="TypeParser-432"><a href="#TypeParser-432"><span class="linenos">432</span></a>			<span class="p">)</span>
+</span><span id="TypeParser-433"><a href="#TypeParser-433"><span class="linenos">433</span></a>
+</span><span id="TypeParser-434"><a href="#TypeParser-434"><span class="linenos">434</span></a>		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_int</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">allow_sign</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_negative</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
+</span><span id="TypeParser-435"><a href="#TypeParser-435"><span class="linenos">435</span></a>
 </span><span id="TypeParser-436"><a href="#TypeParser-436"><span class="linenos">436</span></a>
-</span><span id="TypeParser-437"><a href="#TypeParser-437"><span class="linenos">437</span></a>
-</span><span id="TypeParser-438"><a href="#TypeParser-438"><span class="linenos">438</span></a>	<span class="k">def</span> <span class="nf">is_decimal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_inf</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_nan</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
-</span><span id="TypeParser-439"><a href="#TypeParser-439"><span class="linenos">439</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
-</span><span id="TypeParser-440"><a href="#TypeParser-440"><span class="linenos">440</span></a><span class="sd">			Alias of `is_float()`</span>
-</span><span id="TypeParser-441"><a href="#TypeParser-441"><span class="linenos">441</span></a><span class="sd">		&quot;&quot;&quot;</span>
-</span><span id="TypeParser-442"><a href="#TypeParser-442"><span class="linenos">442</span></a>		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_float</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="o">=</span><span class="n">allow_scientific</span><span class="p">,</span> <span class="n">allow_inf</span><span class="o">=</span><span class="n">allow_inf</span><span class="p">,</span> <span class="n">allow_nan</span><span class="o">=</span><span class="n">allow_nan</span><span class="p">)</span>
+</span><span id="TypeParser-437"><a href="#TypeParser-437"><span class="linenos">437</span></a>	<span class="k">def</span> <span class="nf">is_decimal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_inf</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_nan</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
+</span><span id="TypeParser-438"><a href="#TypeParser-438"><span class="linenos">438</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
+</span><span id="TypeParser-439"><a href="#TypeParser-439"><span class="linenos">439</span></a><span class="sd">			Alias of `is_float()`</span>
+</span><span id="TypeParser-440"><a href="#TypeParser-440"><span class="linenos">440</span></a><span class="sd">		&quot;&quot;&quot;</span>
+</span><span id="TypeParser-441"><a href="#TypeParser-441"><span class="linenos">441</span></a>		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_float</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="o">=</span><span class="n">allow_scientific</span><span class="p">,</span> <span class="n">allow_inf</span><span class="o">=</span><span class="n">allow_inf</span><span class="p">,</span> <span class="n">allow_nan</span><span class="o">=</span><span class="n">allow_nan</span><span class="p">)</span>
+</span><span id="TypeParser-442"><a href="#TypeParser-442"><span class="linenos">442</span></a>
 </span><span id="TypeParser-443"><a href="#TypeParser-443"><span class="linenos">443</span></a>
-</span><span id="TypeParser-444"><a href="#TypeParser-444"><span class="linenos">444</span></a>
-</span><span id="TypeParser-445"><a href="#TypeParser-445"><span class="linenos">445</span></a>	<span class="k">def</span> <span class="nf">parse_none</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
-</span><span id="TypeParser-446"><a href="#TypeParser-446"><span class="linenos">446</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
-</span><span id="TypeParser-447"><a href="#TypeParser-447"><span class="linenos">447</span></a><span class="sd">			Parse a string and return it as the value None if possible</span>
-</span><span id="TypeParser-448"><a href="#TypeParser-448"><span class="linenos">448</span></a>
-</span><span id="TypeParser-449"><a href="#TypeParser-449"><span class="linenos">449</span></a><span class="sd">			Only strings that match the values in `self.none_values` will be interpreted as None. The default accepted values are `[&quot;&quot;]`, i.e. an empty string. The case sensitivity of this matching depends on `self.none_case_sensitive`, which is False by default.</span>
-</span><span id="TypeParser-450"><a href="#TypeParser-450"><span class="linenos">450</span></a>
-</span><span id="TypeParser-451"><a href="#TypeParser-451"><span class="linenos">451</span></a><span class="sd">			Parameters</span>
-</span><span id="TypeParser-452"><a href="#TypeParser-452"><span class="linenos">452</span></a><span class="sd">			----------</span>
-</span><span id="TypeParser-453"><a href="#TypeParser-453"><span class="linenos">453</span></a><span class="sd">			`value`</span>
-</span><span id="TypeParser-454"><a href="#TypeParser-454"><span class="linenos">454</span></a><span class="sd">			: string to be parsed</span>
-</span><span id="TypeParser-455"><a href="#TypeParser-455"><span class="linenos">455</span></a>
-</span><span id="TypeParser-456"><a href="#TypeParser-456"><span class="linenos">456</span></a><span class="sd">			Returns</span>
-</span><span id="TypeParser-457"><a href="#TypeParser-457"><span class="linenos">457</span></a><span class="sd">			-------</span>
-</span><span id="TypeParser-458"><a href="#TypeParser-458"><span class="linenos">458</span></a><span class="sd">			parsed None value</span>
-</span><span id="TypeParser-459"><a href="#TypeParser-459"><span class="linenos">459</span></a>
-</span><span id="TypeParser-460"><a href="#TypeParser-460"><span class="linenos">460</span></a><span class="sd">			Raises</span>
-</span><span id="TypeParser-461"><a href="#TypeParser-461"><span class="linenos">461</span></a><span class="sd">			------</span>
-</span><span id="TypeParser-462"><a href="#TypeParser-462"><span class="linenos">462</span></a><span class="sd">			`ValueError` if `value` cannot be parsed</span>
-</span><span id="TypeParser-463"><a href="#TypeParser-463"><span class="linenos">463</span></a>
-</span><span id="TypeParser-464"><a href="#TypeParser-464"><span class="linenos">464</span></a><span class="sd">			Examples</span>
-</span><span id="TypeParser-465"><a href="#TypeParser-465"><span class="linenos">465</span></a><span class="sd">			--------</span>
-</span><span id="TypeParser-466"><a href="#TypeParser-466"><span class="linenos">466</span></a><span class="sd">			```python</span>
-</span><span id="TypeParser-467"><a href="#TypeParser-467"><span class="linenos">467</span></a><span class="sd">			parser = TypeParser()</span>
-</span><span id="TypeParser-468"><a href="#TypeParser-468"><span class="linenos">468</span></a><span class="sd">			parser.parse_bool(&quot;&quot;)     # None</span>
-</span><span id="TypeParser-469"><a href="#TypeParser-469"><span class="linenos">469</span></a><span class="sd">			parser.parse_bool(&quot;abc&quot;)  # raises ValueError</span>
-</span><span id="TypeParser-470"><a href="#TypeParser-470"><span class="linenos">470</span></a><span class="sd">			```</span>
-</span><span id="TypeParser-471"><a href="#TypeParser-471"><span class="linenos">471</span></a><span class="sd">		&quot;&quot;&quot;</span>
-</span><span id="TypeParser-472"><a href="#TypeParser-472"><span class="linenos">472</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_none</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
-</span><span id="TypeParser-473"><a href="#TypeParser-473"><span class="linenos">473</span></a>			<span class="k">return</span> <span class="kc">None</span>
-</span><span id="TypeParser-474"><a href="#TypeParser-474"><span class="linenos">474</span></a>		<span class="k">else</span><span class="p">:</span>
-</span><span id="TypeParser-475"><a href="#TypeParser-475"><span class="linenos">475</span></a>			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;not a none value: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
+</span><span id="TypeParser-444"><a href="#TypeParser-444"><span class="linenos">444</span></a>	<span class="k">def</span> <span class="nf">parse_none</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
+</span><span id="TypeParser-445"><a href="#TypeParser-445"><span class="linenos">445</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
+</span><span id="TypeParser-446"><a href="#TypeParser-446"><span class="linenos">446</span></a><span class="sd">			Parse a string and return it as the value None if possible</span>
+</span><span id="TypeParser-447"><a href="#TypeParser-447"><span class="linenos">447</span></a>
+</span><span id="TypeParser-448"><a href="#TypeParser-448"><span class="linenos">448</span></a><span class="sd">			Only strings that match the values in `self.none_values` will be interpreted as None. The default accepted values are `[&quot;&quot;]`, i.e. an empty string. The case sensitivity of this matching depends on `self.none_case_sensitive`, which is False by default.</span>
+</span><span id="TypeParser-449"><a href="#TypeParser-449"><span class="linenos">449</span></a>
+</span><span id="TypeParser-450"><a href="#TypeParser-450"><span class="linenos">450</span></a><span class="sd">			Parameters</span>
+</span><span id="TypeParser-451"><a href="#TypeParser-451"><span class="linenos">451</span></a><span class="sd">			----------</span>
+</span><span id="TypeParser-452"><a href="#TypeParser-452"><span class="linenos">452</span></a><span class="sd">			`value`</span>
+</span><span id="TypeParser-453"><a href="#TypeParser-453"><span class="linenos">453</span></a><span class="sd">			: string to be parsed</span>
+</span><span id="TypeParser-454"><a href="#TypeParser-454"><span class="linenos">454</span></a>
+</span><span id="TypeParser-455"><a href="#TypeParser-455"><span class="linenos">455</span></a><span class="sd">			Returns</span>
+</span><span id="TypeParser-456"><a href="#TypeParser-456"><span class="linenos">456</span></a><span class="sd">			-------</span>
+</span><span id="TypeParser-457"><a href="#TypeParser-457"><span class="linenos">457</span></a><span class="sd">			parsed None value</span>
+</span><span id="TypeParser-458"><a href="#TypeParser-458"><span class="linenos">458</span></a>
+</span><span id="TypeParser-459"><a href="#TypeParser-459"><span class="linenos">459</span></a><span class="sd">			Raises</span>
+</span><span id="TypeParser-460"><a href="#TypeParser-460"><span class="linenos">460</span></a><span class="sd">			------</span>
+</span><span id="TypeParser-461"><a href="#TypeParser-461"><span class="linenos">461</span></a><span class="sd">			`ValueError` if `value` cannot be parsed</span>
+</span><span id="TypeParser-462"><a href="#TypeParser-462"><span class="linenos">462</span></a>
+</span><span id="TypeParser-463"><a href="#TypeParser-463"><span class="linenos">463</span></a><span class="sd">			Examples</span>
+</span><span id="TypeParser-464"><a href="#TypeParser-464"><span class="linenos">464</span></a><span class="sd">			--------</span>
+</span><span id="TypeParser-465"><a href="#TypeParser-465"><span class="linenos">465</span></a><span class="sd">			```python</span>
+</span><span id="TypeParser-466"><a href="#TypeParser-466"><span class="linenos">466</span></a><span class="sd">			parser = TypeParser()</span>
+</span><span id="TypeParser-467"><a href="#TypeParser-467"><span class="linenos">467</span></a><span class="sd">			parser.parse_bool(&quot;&quot;)     # None</span>
+</span><span id="TypeParser-468"><a href="#TypeParser-468"><span class="linenos">468</span></a><span class="sd">			parser.parse_bool(&quot;abc&quot;)  # raises ValueError</span>
+</span><span id="TypeParser-469"><a href="#TypeParser-469"><span class="linenos">469</span></a><span class="sd">			```</span>
+</span><span id="TypeParser-470"><a href="#TypeParser-470"><span class="linenos">470</span></a><span class="sd">		&quot;&quot;&quot;</span>
+</span><span id="TypeParser-471"><a href="#TypeParser-471"><span class="linenos">471</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_none</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
+</span><span id="TypeParser-472"><a href="#TypeParser-472"><span class="linenos">472</span></a>			<span class="k">return</span> <span class="kc">None</span>
+</span><span id="TypeParser-473"><a href="#TypeParser-473"><span class="linenos">473</span></a>		<span class="k">else</span><span class="p">:</span>
+</span><span id="TypeParser-474"><a href="#TypeParser-474"><span class="linenos">474</span></a>			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;not a none value: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
+</span><span id="TypeParser-475"><a href="#TypeParser-475"><span class="linenos">475</span></a>
 </span><span id="TypeParser-476"><a href="#TypeParser-476"><span class="linenos">476</span></a>
-</span><span id="TypeParser-477"><a href="#TypeParser-477"><span class="linenos">477</span></a>
-</span><span id="TypeParser-478"><a href="#TypeParser-478"><span class="linenos">478</span></a>	<span class="k">def</span> <span class="nf">parse_bool</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
-</span><span id="TypeParser-479"><a href="#TypeParser-479"><span class="linenos">479</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
-</span><span id="TypeParser-480"><a href="#TypeParser-480"><span class="linenos">480</span></a><span class="sd">			Parse a string and return it as a bool if possible</span>
-</span><span id="TypeParser-481"><a href="#TypeParser-481"><span class="linenos">481</span></a>
-</span><span id="TypeParser-482"><a href="#TypeParser-482"><span class="linenos">482</span></a><span class="sd">			Only strings that match the values in `self.true_values` and `self.false_values` will be interpreted as booleans. The default accepted values are `[&quot;true&quot;]` and `[&quot;false&quot;]` respectively. The case sensitivity of this matching depends on `self.bool_case_sensitive`, which is False by default.</span>
-</span><span id="TypeParser-483"><a href="#TypeParser-483"><span class="linenos">483</span></a>
-</span><span id="TypeParser-484"><a href="#TypeParser-484"><span class="linenos">484</span></a><span class="sd">			Parameters</span>
-</span><span id="TypeParser-485"><a href="#TypeParser-485"><span class="linenos">485</span></a><span class="sd">			----------</span>
-</span><span id="TypeParser-486"><a href="#TypeParser-486"><span class="linenos">486</span></a><span class="sd">			`value`</span>
-</span><span id="TypeParser-487"><a href="#TypeParser-487"><span class="linenos">487</span></a><span class="sd">			: string to be parsed</span>
-</span><span id="TypeParser-488"><a href="#TypeParser-488"><span class="linenos">488</span></a>
-</span><span id="TypeParser-489"><a href="#TypeParser-489"><span class="linenos">489</span></a><span class="sd">			Returns</span>
-</span><span id="TypeParser-490"><a href="#TypeParser-490"><span class="linenos">490</span></a><span class="sd">			-------</span>
-</span><span id="TypeParser-491"><a href="#TypeParser-491"><span class="linenos">491</span></a><span class="sd">			parsed bool value</span>
-</span><span id="TypeParser-492"><a href="#TypeParser-492"><span class="linenos">492</span></a>
-</span><span id="TypeParser-493"><a href="#TypeParser-493"><span class="linenos">493</span></a><span class="sd">			Raises</span>
-</span><span id="TypeParser-494"><a href="#TypeParser-494"><span class="linenos">494</span></a><span class="sd">			------</span>
-</span><span id="TypeParser-495"><a href="#TypeParser-495"><span class="linenos">495</span></a><span class="sd">			`ValueError` if `value` cannot be parsed</span>
-</span><span id="TypeParser-496"><a href="#TypeParser-496"><span class="linenos">496</span></a>
-</span><span id="TypeParser-497"><a href="#TypeParser-497"><span class="linenos">497</span></a><span class="sd">			Examples</span>
-</span><span id="TypeParser-498"><a href="#TypeParser-498"><span class="linenos">498</span></a><span class="sd">			--------</span>
-</span><span id="TypeParser-499"><a href="#TypeParser-499"><span class="linenos">499</span></a><span class="sd">			```python</span>
-</span><span id="TypeParser-500"><a href="#TypeParser-500"><span class="linenos">500</span></a><span class="sd">			parser = TypeParser()</span>
-</span><span id="TypeParser-501"><a href="#TypeParser-501"><span class="linenos">501</span></a><span class="sd">			parser.parse_bool(&quot;true&quot;)   # True</span>
-</span><span id="TypeParser-502"><a href="#TypeParser-502"><span class="linenos">502</span></a><span class="sd">			parser.parse_bool(&quot;FALSE&quot;)  # False</span>
-</span><span id="TypeParser-503"><a href="#TypeParser-503"><span class="linenos">503</span></a><span class="sd">			```</span>
-</span><span id="TypeParser-504"><a href="#TypeParser-504"><span class="linenos">504</span></a><span class="sd">		&quot;&quot;&quot;</span>
-</span><span id="TypeParser-505"><a href="#TypeParser-505"><span class="linenos">505</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trim</span><span class="p">:</span>
-</span><span id="TypeParser-506"><a href="#TypeParser-506"><span class="linenos">506</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
-</span><span id="TypeParser-507"><a href="#TypeParser-507"><span class="linenos">507</span></a>
-</span><span id="TypeParser-508"><a href="#TypeParser-508"><span class="linenos">508</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bool_case_sensitive</span><span class="p">:</span>
-</span><span id="TypeParser-509"><a href="#TypeParser-509"><span class="linenos">509</span></a>			<span class="n">special_value</span> <span class="o">=</span> <span class="n">value</span>
-</span><span id="TypeParser-510"><a href="#TypeParser-510"><span class="linenos">510</span></a>		<span class="k">else</span><span class="p">:</span>
-</span><span id="TypeParser-511"><a href="#TypeParser-511"><span class="linenos">511</span></a>			<span class="n">special_value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
-</span><span id="TypeParser-512"><a href="#TypeParser-512"><span class="linenos">512</span></a>		<span class="k">if</span> <span class="n">special_value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">true_values</span><span class="p">:</span>
-</span><span id="TypeParser-513"><a href="#TypeParser-513"><span class="linenos">513</span></a>			<span class="k">return</span> <span class="kc">True</span>
-</span><span id="TypeParser-514"><a href="#TypeParser-514"><span class="linenos">514</span></a>		<span class="k">if</span> <span class="n">special_value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">false_values</span><span class="p">:</span>
-</span><span id="TypeParser-515"><a href="#TypeParser-515"><span class="linenos">515</span></a>			<span class="k">return</span> <span class="kc">False</span>
-</span><span id="TypeParser-516"><a href="#TypeParser-516"><span class="linenos">516</span></a>
-</span><span id="TypeParser-517"><a href="#TypeParser-517"><span class="linenos">517</span></a>		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;not a boolean: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
+</span><span id="TypeParser-477"><a href="#TypeParser-477"><span class="linenos">477</span></a>	<span class="k">def</span> <span class="nf">parse_bool</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
+</span><span id="TypeParser-478"><a href="#TypeParser-478"><span class="linenos">478</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
+</span><span id="TypeParser-479"><a href="#TypeParser-479"><span class="linenos">479</span></a><span class="sd">			Parse a string and return it as a bool if possible</span>
+</span><span id="TypeParser-480"><a href="#TypeParser-480"><span class="linenos">480</span></a>
+</span><span id="TypeParser-481"><a href="#TypeParser-481"><span class="linenos">481</span></a><span class="sd">			Only strings that match the values in `self.true_values` and `self.false_values` will be interpreted as booleans. The default accepted values are `[&quot;true&quot;]` and `[&quot;false&quot;]` respectively. The case sensitivity of this matching depends on `self.bool_case_sensitive`, which is False by default.</span>
+</span><span id="TypeParser-482"><a href="#TypeParser-482"><span class="linenos">482</span></a>
+</span><span id="TypeParser-483"><a href="#TypeParser-483"><span class="linenos">483</span></a><span class="sd">			Parameters</span>
+</span><span id="TypeParser-484"><a href="#TypeParser-484"><span class="linenos">484</span></a><span class="sd">			----------</span>
+</span><span id="TypeParser-485"><a href="#TypeParser-485"><span class="linenos">485</span></a><span class="sd">			`value`</span>
+</span><span id="TypeParser-486"><a href="#TypeParser-486"><span class="linenos">486</span></a><span class="sd">			: string to be parsed</span>
+</span><span id="TypeParser-487"><a href="#TypeParser-487"><span class="linenos">487</span></a>
+</span><span id="TypeParser-488"><a href="#TypeParser-488"><span class="linenos">488</span></a><span class="sd">			Returns</span>
+</span><span id="TypeParser-489"><a href="#TypeParser-489"><span class="linenos">489</span></a><span class="sd">			-------</span>
+</span><span id="TypeParser-490"><a href="#TypeParser-490"><span class="linenos">490</span></a><span class="sd">			parsed bool value</span>
+</span><span id="TypeParser-491"><a href="#TypeParser-491"><span class="linenos">491</span></a>
+</span><span id="TypeParser-492"><a href="#TypeParser-492"><span class="linenos">492</span></a><span class="sd">			Raises</span>
+</span><span id="TypeParser-493"><a href="#TypeParser-493"><span class="linenos">493</span></a><span class="sd">			------</span>
+</span><span id="TypeParser-494"><a href="#TypeParser-494"><span class="linenos">494</span></a><span class="sd">			`ValueError` if `value` cannot be parsed</span>
+</span><span id="TypeParser-495"><a href="#TypeParser-495"><span class="linenos">495</span></a>
+</span><span id="TypeParser-496"><a href="#TypeParser-496"><span class="linenos">496</span></a><span class="sd">			Examples</span>
+</span><span id="TypeParser-497"><a href="#TypeParser-497"><span class="linenos">497</span></a><span class="sd">			--------</span>
+</span><span id="TypeParser-498"><a href="#TypeParser-498"><span class="linenos">498</span></a><span class="sd">			```python</span>
+</span><span id="TypeParser-499"><a href="#TypeParser-499"><span class="linenos">499</span></a><span class="sd">			parser = TypeParser()</span>
+</span><span id="TypeParser-500"><a href="#TypeParser-500"><span class="linenos">500</span></a><span class="sd">			parser.parse_bool(&quot;true&quot;)   # True</span>
+</span><span id="TypeParser-501"><a href="#TypeParser-501"><span class="linenos">501</span></a><span class="sd">			parser.parse_bool(&quot;FALSE&quot;)  # False</span>
+</span><span id="TypeParser-502"><a href="#TypeParser-502"><span class="linenos">502</span></a><span class="sd">			```</span>
+</span><span id="TypeParser-503"><a href="#TypeParser-503"><span class="linenos">503</span></a><span class="sd">		&quot;&quot;&quot;</span>
+</span><span id="TypeParser-504"><a href="#TypeParser-504"><span class="linenos">504</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trim</span><span class="p">:</span>
+</span><span id="TypeParser-505"><a href="#TypeParser-505"><span class="linenos">505</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
+</span><span id="TypeParser-506"><a href="#TypeParser-506"><span class="linenos">506</span></a>
+</span><span id="TypeParser-507"><a href="#TypeParser-507"><span class="linenos">507</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bool_case_sensitive</span><span class="p">:</span>
+</span><span id="TypeParser-508"><a href="#TypeParser-508"><span class="linenos">508</span></a>			<span class="n">special_value</span> <span class="o">=</span> <span class="n">value</span>
+</span><span id="TypeParser-509"><a href="#TypeParser-509"><span class="linenos">509</span></a>		<span class="k">else</span><span class="p">:</span>
+</span><span id="TypeParser-510"><a href="#TypeParser-510"><span class="linenos">510</span></a>			<span class="n">special_value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
+</span><span id="TypeParser-511"><a href="#TypeParser-511"><span class="linenos">511</span></a>		<span class="k">if</span> <span class="n">special_value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">true_values</span><span class="p">:</span>
+</span><span id="TypeParser-512"><a href="#TypeParser-512"><span class="linenos">512</span></a>			<span class="k">return</span> <span class="kc">True</span>
+</span><span id="TypeParser-513"><a href="#TypeParser-513"><span class="linenos">513</span></a>		<span class="k">if</span> <span class="n">special_value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">false_values</span><span class="p">:</span>
+</span><span id="TypeParser-514"><a href="#TypeParser-514"><span class="linenos">514</span></a>			<span class="k">return</span> <span class="kc">False</span>
+</span><span id="TypeParser-515"><a href="#TypeParser-515"><span class="linenos">515</span></a>
+</span><span id="TypeParser-516"><a href="#TypeParser-516"><span class="linenos">516</span></a>		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;not a boolean: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
+</span><span id="TypeParser-517"><a href="#TypeParser-517"><span class="linenos">517</span></a>
 </span><span id="TypeParser-518"><a href="#TypeParser-518"><span class="linenos">518</span></a>
-</span><span id="TypeParser-519"><a href="#TypeParser-519"><span class="linenos">519</span></a>
-</span><span id="TypeParser-520"><a href="#TypeParser-520"><span class="linenos">520</span></a>	<span class="k">def</span> <span class="nf">parse_int</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
-</span><span id="TypeParser-521"><a href="#TypeParser-521"><span class="linenos">521</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
-</span><span id="TypeParser-522"><a href="#TypeParser-522"><span class="linenos">522</span></a><span class="sd">			Parse a string and return it as an int if possible</span>
-</span><span id="TypeParser-523"><a href="#TypeParser-523"><span class="linenos">523</span></a>
-</span><span id="TypeParser-524"><a href="#TypeParser-524"><span class="linenos">524</span></a><span class="sd">			If the string represents a bool, it will be converted to `1` for True and `0` for False.</span>
-</span><span id="TypeParser-525"><a href="#TypeParser-525"><span class="linenos">525</span></a>
-</span><span id="TypeParser-526"><a href="#TypeParser-526"><span class="linenos">526</span></a><span class="sd">			Parameters</span>
-</span><span id="TypeParser-527"><a href="#TypeParser-527"><span class="linenos">527</span></a><span class="sd">			----------</span>
-</span><span id="TypeParser-528"><a href="#TypeParser-528"><span class="linenos">528</span></a><span class="sd">			`value`</span>
-</span><span id="TypeParser-529"><a href="#TypeParser-529"><span class="linenos">529</span></a><span class="sd">			: string to be parsed</span>
-</span><span id="TypeParser-530"><a href="#TypeParser-530"><span class="linenos">530</span></a>
-</span><span id="TypeParser-531"><a href="#TypeParser-531"><span class="linenos">531</span></a><span class="sd">			`allow_scientific`</span>
-</span><span id="TypeParser-532"><a href="#TypeParser-532"><span class="linenos">532</span></a><span class="sd">			: whether to accept scientific notation. If True, strings of the form `&quot;&lt;var&gt;M&lt;/var&gt;e&lt;var&gt;X&lt;/var&gt;&quot;` will be interpreted as the expression `&lt;var&gt;M&lt;/var&gt; * (10 ** &lt;var&gt;X&lt;/var&gt;)`, where &lt;var&gt;M&lt;/var&gt; is the mantissa/significand and &lt;var&gt;X&lt;/var&gt; is the exponent. Note &lt;var&gt;M&lt;/var&gt; *must* be an integer and &lt;var&gt;X&lt;/var&gt; *must* be a non-negative integer, even in cases where the above expression evaluates mathematically to an integer.</span>
-</span><span id="TypeParser-533"><a href="#TypeParser-533"><span class="linenos">533</span></a>
-</span><span id="TypeParser-534"><a href="#TypeParser-534"><span class="linenos">534</span></a><span class="sd">			Returns</span>
-</span><span id="TypeParser-535"><a href="#TypeParser-535"><span class="linenos">535</span></a><span class="sd">			-------</span>
-</span><span id="TypeParser-536"><a href="#TypeParser-536"><span class="linenos">536</span></a><span class="sd">			parsed int value</span>
-</span><span id="TypeParser-537"><a href="#TypeParser-537"><span class="linenos">537</span></a>
-</span><span id="TypeParser-538"><a href="#TypeParser-538"><span class="linenos">538</span></a><span class="sd">			Raises</span>
-</span><span id="TypeParser-539"><a href="#TypeParser-539"><span class="linenos">539</span></a><span class="sd">			------</span>
-</span><span id="TypeParser-540"><a href="#TypeParser-540"><span class="linenos">540</span></a><span class="sd">			`ValueError` if `value` cannot be parsed</span>
-</span><span id="TypeParser-541"><a href="#TypeParser-541"><span class="linenos">541</span></a>
-</span><span id="TypeParser-542"><a href="#TypeParser-542"><span class="linenos">542</span></a><span class="sd">			Examples</span>
-</span><span id="TypeParser-543"><a href="#TypeParser-543"><span class="linenos">543</span></a><span class="sd">			--------</span>
-</span><span id="TypeParser-544"><a href="#TypeParser-544"><span class="linenos">544</span></a><span class="sd">			```python</span>
-</span><span id="TypeParser-545"><a href="#TypeParser-545"><span class="linenos">545</span></a><span class="sd">			parser = TypeParser()</span>
-</span><span id="TypeParser-546"><a href="#TypeParser-546"><span class="linenos">546</span></a><span class="sd">			parser.parse_int(&quot;0&quot;)    # 0</span>
-</span><span id="TypeParser-547"><a href="#TypeParser-547"><span class="linenos">547</span></a><span class="sd">			parser.parse_int(&quot;-1&quot;)   # -1</span>
-</span><span id="TypeParser-548"><a href="#TypeParser-548"><span class="linenos">548</span></a><span class="sd">			parser.parse_int(&quot;2e3&quot;)  # 2000</span>
-</span><span id="TypeParser-549"><a href="#TypeParser-549"><span class="linenos">549</span></a><span class="sd">			```</span>
-</span><span id="TypeParser-550"><a href="#TypeParser-550"><span class="linenos">550</span></a><span class="sd">		&quot;&quot;&quot;</span>
-</span><span id="TypeParser-551"><a href="#TypeParser-551"><span class="linenos">551</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trim</span><span class="p">:</span>
-</span><span id="TypeParser-552"><a href="#TypeParser-552"><span class="linenos">552</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
-</span><span id="TypeParser-553"><a href="#TypeParser-553"><span class="linenos">553</span></a>
-</span><span id="TypeParser-554"><a href="#TypeParser-554"><span class="linenos">554</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_int</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">allow_sign</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_negative</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="o">=</span><span class="n">allow_scientific</span><span class="p">):</span>
-</span><span id="TypeParser-555"><a href="#TypeParser-555"><span class="linenos">555</span></a>			<span class="k">if</span> <span class="n">allow_scientific</span><span class="p">:</span>
-</span><span id="TypeParser-556"><a href="#TypeParser-556"><span class="linenos">556</span></a>				<span class="n">value</span><span class="p">,</span> <span class="n">exp</span> <span class="o">=</span> <span class="n">_decompose_string_pair</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scientific_char</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">int_case_sensitive</span><span class="p">)</span>
-</span><span id="TypeParser-557"><a href="#TypeParser-557"><span class="linenos">557</span></a>				<span class="k">if</span> <span class="n">exp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
-</span><span id="TypeParser-558"><a href="#TypeParser-558"><span class="linenos">558</span></a>					<span class="k">if</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_negative_chars</span> <span class="o">-</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_negative_char</span><span class="p">}):</span>
-</span><span id="TypeParser-559"><a href="#TypeParser-559"><span class="linenos">559</span></a>						<span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_negative_char</span> <span class="o">+</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
-</span><span id="TypeParser-560"><a href="#TypeParser-560"><span class="linenos">560</span></a>					<span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">10</span> <span class="o">**</span> <span class="nb">int</span><span class="p">(</span><span class="n">exp</span><span class="p">))</span>
-</span><span id="TypeParser-561"><a href="#TypeParser-561"><span class="linenos">561</span></a>
-</span><span id="TypeParser-562"><a href="#TypeParser-562"><span class="linenos">562</span></a>			<span class="k">if</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_negative_chars</span> <span class="o">-</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_negative_char</span><span class="p">}):</span>
-</span><span id="TypeParser-563"><a href="#TypeParser-563"><span class="linenos">563</span></a>				<span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_negative_char</span> <span class="o">+</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
-</span><span id="TypeParser-564"><a href="#TypeParser-564"><span class="linenos">564</span></a>			<span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
-</span><span id="TypeParser-565"><a href="#TypeParser-565"><span class="linenos">565</span></a>
-</span><span id="TypeParser-566"><a href="#TypeParser-566"><span class="linenos">566</span></a>		<span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_bool</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
-</span><span id="TypeParser-567"><a href="#TypeParser-567"><span class="linenos">567</span></a>			<span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parse_bool</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
-</span><span id="TypeParser-568"><a href="#TypeParser-568"><span class="linenos">568</span></a>		<span class="k">else</span><span class="p">:</span>
-</span><span id="TypeParser-569"><a href="#TypeParser-569"><span class="linenos">569</span></a>			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;not an integer: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
+</span><span id="TypeParser-519"><a href="#TypeParser-519"><span class="linenos">519</span></a>	<span class="k">def</span> <span class="nf">parse_int</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
+</span><span id="TypeParser-520"><a href="#TypeParser-520"><span class="linenos">520</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
+</span><span id="TypeParser-521"><a href="#TypeParser-521"><span class="linenos">521</span></a><span class="sd">			Parse a string and return it as an int if possible</span>
+</span><span id="TypeParser-522"><a href="#TypeParser-522"><span class="linenos">522</span></a>
+</span><span id="TypeParser-523"><a href="#TypeParser-523"><span class="linenos">523</span></a><span class="sd">			If the string represents a bool, it will be converted to `1` for True and `0` for False.</span>
+</span><span id="TypeParser-524"><a href="#TypeParser-524"><span class="linenos">524</span></a>
+</span><span id="TypeParser-525"><a href="#TypeParser-525"><span class="linenos">525</span></a><span class="sd">			Parameters</span>
+</span><span id="TypeParser-526"><a href="#TypeParser-526"><span class="linenos">526</span></a><span class="sd">			----------</span>
+</span><span id="TypeParser-527"><a href="#TypeParser-527"><span class="linenos">527</span></a><span class="sd">			`value`</span>
+</span><span id="TypeParser-528"><a href="#TypeParser-528"><span class="linenos">528</span></a><span class="sd">			: string to be parsed</span>
+</span><span id="TypeParser-529"><a href="#TypeParser-529"><span class="linenos">529</span></a>
+</span><span id="TypeParser-530"><a href="#TypeParser-530"><span class="linenos">530</span></a><span class="sd">			`allow_scientific`</span>
+</span><span id="TypeParser-531"><a href="#TypeParser-531"><span class="linenos">531</span></a><span class="sd">			: whether to accept scientific notation. If True, strings of the form `&quot;&lt;var&gt;M&lt;/var&gt;e&lt;var&gt;X&lt;/var&gt;&quot;` will be interpreted as the expression `&lt;var&gt;M&lt;/var&gt; * (10 ** &lt;var&gt;X&lt;/var&gt;)`, where &lt;var&gt;M&lt;/var&gt; is the mantissa/significand and &lt;var&gt;X&lt;/var&gt; is the exponent. Note &lt;var&gt;M&lt;/var&gt; *must* be an integer and &lt;var&gt;X&lt;/var&gt; *must* be a non-negative integer, even in cases where the above expression evaluates mathematically to an integer.</span>
+</span><span id="TypeParser-532"><a href="#TypeParser-532"><span class="linenos">532</span></a>
+</span><span id="TypeParser-533"><a href="#TypeParser-533"><span class="linenos">533</span></a><span class="sd">			Returns</span>
+</span><span id="TypeParser-534"><a href="#TypeParser-534"><span class="linenos">534</span></a><span class="sd">			-------</span>
+</span><span id="TypeParser-535"><a href="#TypeParser-535"><span class="linenos">535</span></a><span class="sd">			parsed int value</span>
+</span><span id="TypeParser-536"><a href="#TypeParser-536"><span class="linenos">536</span></a>
+</span><span id="TypeParser-537"><a href="#TypeParser-537"><span class="linenos">537</span></a><span class="sd">			Raises</span>
+</span><span id="TypeParser-538"><a href="#TypeParser-538"><span class="linenos">538</span></a><span class="sd">			------</span>
+</span><span id="TypeParser-539"><a href="#TypeParser-539"><span class="linenos">539</span></a><span class="sd">			`ValueError` if `value` cannot be parsed</span>
+</span><span id="TypeParser-540"><a href="#TypeParser-540"><span class="linenos">540</span></a>
+</span><span id="TypeParser-541"><a href="#TypeParser-541"><span class="linenos">541</span></a><span class="sd">			Examples</span>
+</span><span id="TypeParser-542"><a href="#TypeParser-542"><span class="linenos">542</span></a><span class="sd">			--------</span>
+</span><span id="TypeParser-543"><a href="#TypeParser-543"><span class="linenos">543</span></a><span class="sd">			```python</span>
+</span><span id="TypeParser-544"><a href="#TypeParser-544"><span class="linenos">544</span></a><span class="sd">			parser = TypeParser()</span>
+</span><span id="TypeParser-545"><a href="#TypeParser-545"><span class="linenos">545</span></a><span class="sd">			parser.parse_int(&quot;0&quot;)    # 0</span>
+</span><span id="TypeParser-546"><a href="#TypeParser-546"><span class="linenos">546</span></a><span class="sd">			parser.parse_int(&quot;-1&quot;)   # -1</span>
+</span><span id="TypeParser-547"><a href="#TypeParser-547"><span class="linenos">547</span></a><span class="sd">			parser.parse_int(&quot;2e3&quot;)  # 2000</span>
+</span><span id="TypeParser-548"><a href="#TypeParser-548"><span class="linenos">548</span></a><span class="sd">			```</span>
+</span><span id="TypeParser-549"><a href="#TypeParser-549"><span class="linenos">549</span></a><span class="sd">		&quot;&quot;&quot;</span>
+</span><span id="TypeParser-550"><a href="#TypeParser-550"><span class="linenos">550</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trim</span><span class="p">:</span>
+</span><span id="TypeParser-551"><a href="#TypeParser-551"><span class="linenos">551</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
+</span><span id="TypeParser-552"><a href="#TypeParser-552"><span class="linenos">552</span></a>
+</span><span id="TypeParser-553"><a href="#TypeParser-553"><span class="linenos">553</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_int</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">allow_sign</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_negative</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="o">=</span><span class="n">allow_scientific</span><span class="p">):</span>
+</span><span id="TypeParser-554"><a href="#TypeParser-554"><span class="linenos">554</span></a>			<span class="k">if</span> <span class="n">allow_scientific</span><span class="p">:</span>
+</span><span id="TypeParser-555"><a href="#TypeParser-555"><span class="linenos">555</span></a>				<span class="n">value</span><span class="p">,</span> <span class="n">exp</span> <span class="o">=</span> <span class="n">_decompose_string_pair</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scientific_char</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">int_case_sensitive</span><span class="p">)</span>
+</span><span id="TypeParser-556"><a href="#TypeParser-556"><span class="linenos">556</span></a>				<span class="k">if</span> <span class="n">exp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
+</span><span id="TypeParser-557"><a href="#TypeParser-557"><span class="linenos">557</span></a>					<span class="k">if</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_negative_chars</span> <span class="o">-</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_negative_char</span><span class="p">}):</span>
+</span><span id="TypeParser-558"><a href="#TypeParser-558"><span class="linenos">558</span></a>						<span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_negative_char</span> <span class="o">+</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
+</span><span id="TypeParser-559"><a href="#TypeParser-559"><span class="linenos">559</span></a>					<span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">10</span> <span class="o">**</span> <span class="nb">int</span><span class="p">(</span><span class="n">exp</span><span class="p">))</span>
+</span><span id="TypeParser-560"><a href="#TypeParser-560"><span class="linenos">560</span></a>
+</span><span id="TypeParser-561"><a href="#TypeParser-561"><span class="linenos">561</span></a>			<span class="k">if</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_negative_chars</span> <span class="o">-</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_negative_char</span><span class="p">}):</span>
+</span><span id="TypeParser-562"><a href="#TypeParser-562"><span class="linenos">562</span></a>				<span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_negative_char</span> <span class="o">+</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
+</span><span id="TypeParser-563"><a href="#TypeParser-563"><span class="linenos">563</span></a>			<span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
+</span><span id="TypeParser-564"><a href="#TypeParser-564"><span class="linenos">564</span></a>
+</span><span id="TypeParser-565"><a href="#TypeParser-565"><span class="linenos">565</span></a>		<span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_bool</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
+</span><span id="TypeParser-566"><a href="#TypeParser-566"><span class="linenos">566</span></a>			<span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parse_bool</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
+</span><span id="TypeParser-567"><a href="#TypeParser-567"><span class="linenos">567</span></a>		<span class="k">else</span><span class="p">:</span>
+</span><span id="TypeParser-568"><a href="#TypeParser-568"><span class="linenos">568</span></a>			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;not an integer: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
+</span><span id="TypeParser-569"><a href="#TypeParser-569"><span class="linenos">569</span></a>
 </span><span id="TypeParser-570"><a href="#TypeParser-570"><span class="linenos">570</span></a>
-</span><span id="TypeParser-571"><a href="#TypeParser-571"><span class="linenos">571</span></a>
-</span><span id="TypeParser-572"><a href="#TypeParser-572"><span class="linenos">572</span></a>	<span class="k">def</span> <span class="nf">_parse_floatlike</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
-</span><span id="TypeParser-573"><a href="#TypeParser-573"><span class="linenos">573</span></a>		<span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
-</span><span id="TypeParser-574"><a href="#TypeParser-574"><span class="linenos">574</span></a>		<span class="n">converter</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]],</span> <span class="n">_FloatLike</span><span class="p">],</span>
-</span><span id="TypeParser-575"><a href="#TypeParser-575"><span class="linenos">575</span></a>		<span class="n">inf_value</span><span class="p">:</span> <span class="n">_FloatLike</span><span class="p">,</span>
-</span><span id="TypeParser-576"><a href="#TypeParser-576"><span class="linenos">576</span></a>		<span class="n">nan_value</span><span class="p">:</span> <span class="n">_FloatLike</span><span class="p">,</span>
-</span><span id="TypeParser-577"><a href="#TypeParser-577"><span class="linenos">577</span></a>		<span class="o">*</span><span class="p">,</span>
-</span><span id="TypeParser-578"><a href="#TypeParser-578"><span class="linenos">578</span></a>		<span class="n">allow_scientific</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
-</span><span id="TypeParser-579"><a href="#TypeParser-579"><span class="linenos">579</span></a>		<span class="n">allow_inf</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
-</span><span id="TypeParser-580"><a href="#TypeParser-580"><span class="linenos">580</span></a>		<span class="n">allow_nan</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span>
-</span><span id="TypeParser-581"><a href="#TypeParser-581"><span class="linenos">581</span></a>	<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_FloatLike</span><span class="p">:</span>
-</span><span id="TypeParser-582"><a href="#TypeParser-582"><span class="linenos">582</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trim</span><span class="p">:</span>
-</span><span id="TypeParser-583"><a href="#TypeParser-583"><span class="linenos">583</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
-</span><span id="TypeParser-584"><a href="#TypeParser-584"><span class="linenos">584</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_float</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="o">=</span><span class="n">allow_scientific</span><span class="p">,</span> <span class="n">allow_inf</span><span class="o">=</span><span class="n">allow_inf</span><span class="p">,</span> <span class="n">allow_nan</span><span class="o">=</span><span class="n">allow_nan</span><span class="p">):</span>
-</span><span id="TypeParser-585"><a href="#TypeParser-585"><span class="linenos">585</span></a>			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">float_case_sensitive</span><span class="p">:</span>
-</span><span id="TypeParser-586"><a href="#TypeParser-586"><span class="linenos">586</span></a>				<span class="n">special_value</span> <span class="o">=</span> <span class="n">value</span>
-</span><span id="TypeParser-587"><a href="#TypeParser-587"><span class="linenos">587</span></a>			<span class="k">else</span><span class="p">:</span>
-</span><span id="TypeParser-588"><a href="#TypeParser-588"><span class="linenos">588</span></a>				<span class="n">special_value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
-</span><span id="TypeParser-589"><a href="#TypeParser-589"><span class="linenos">589</span></a>			<span class="k">if</span> <span class="n">allow_inf</span> <span class="ow">and</span> <span class="n">special_value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inf_values</span><span class="p">:</span>
-</span><span id="TypeParser-590"><a href="#TypeParser-590"><span class="linenos">590</span></a>				<span class="k">return</span> <span class="n">inf_value</span>
-</span><span id="TypeParser-591"><a href="#TypeParser-591"><span class="linenos">591</span></a>			<span class="k">if</span> <span class="n">allow_nan</span> <span class="ow">and</span> <span class="n">special_value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nan_values</span><span class="p">:</span>
-</span><span id="TypeParser-592"><a href="#TypeParser-592"><span class="linenos">592</span></a>				<span class="k">return</span> <span class="n">nan_value</span>
-</span><span id="TypeParser-593"><a href="#TypeParser-593"><span class="linenos">593</span></a>
-</span><span id="TypeParser-594"><a href="#TypeParser-594"><span class="linenos">594</span></a>			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sign_chars</span><span class="p">:</span>
-</span><span id="TypeParser-595"><a href="#TypeParser-595"><span class="linenos">595</span></a>				<span class="n">positive_part</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
-</span><span id="TypeParser-596"><a href="#TypeParser-596"><span class="linenos">596</span></a>				<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">float_case_sensitive</span><span class="p">:</span>
-</span><span id="TypeParser-597"><a href="#TypeParser-597"><span class="linenos">597</span></a>					<span class="n">special_value</span> <span class="o">=</span> <span class="n">positive_part</span>
-</span><span id="TypeParser-598"><a href="#TypeParser-598"><span class="linenos">598</span></a>				<span class="k">else</span><span class="p">:</span>
-</span><span id="TypeParser-599"><a href="#TypeParser-599"><span class="linenos">599</span></a>					<span class="n">special_value</span> <span class="o">=</span> <span class="n">positive_part</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
-</span><span id="TypeParser-600"><a href="#TypeParser-600"><span class="linenos">600</span></a>				<span class="k">if</span> <span class="n">allow_inf</span> <span class="ow">and</span> <span class="n">special_value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inf_values</span><span class="p">:</span>
-</span><span id="TypeParser-601"><a href="#TypeParser-601"><span class="linenos">601</span></a>					<span class="k">if</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_negative_chars</span><span class="p">:</span>
-</span><span id="TypeParser-602"><a href="#TypeParser-602"><span class="linenos">602</span></a>						<span class="k">return</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">inf_value</span>
-</span><span id="TypeParser-603"><a href="#TypeParser-603"><span class="linenos">603</span></a>					<span class="k">else</span><span class="p">:</span>
-</span><span id="TypeParser-604"><a href="#TypeParser-604"><span class="linenos">604</span></a>						<span class="k">return</span> <span class="n">inf_value</span>
-</span><span id="TypeParser-605"><a href="#TypeParser-605"><span class="linenos">605</span></a>				<span class="k">if</span> <span class="n">allow_nan</span> <span class="ow">and</span> <span class="n">special_value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nan_values</span><span class="p">:</span>
-</span><span id="TypeParser-606"><a href="#TypeParser-606"><span class="linenos">606</span></a>					<span class="k">return</span> <span class="n">nan_value</span>
-</span><span id="TypeParser-607"><a href="#TypeParser-607"><span class="linenos">607</span></a>
-</span><span id="TypeParser-608"><a href="#TypeParser-608"><span class="linenos">608</span></a>				<span class="k">if</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_negative_chars</span><span class="p">:</span>
-</span><span id="TypeParser-609"><a href="#TypeParser-609"><span class="linenos">609</span></a>					<span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_negative_char</span> <span class="o">+</span> <span class="n">positive_part</span>
-</span><span id="TypeParser-610"><a href="#TypeParser-610"><span class="linenos">610</span></a>			<span class="k">return</span> <span class="n">converter</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
-</span><span id="TypeParser-611"><a href="#TypeParser-611"><span class="linenos">611</span></a>		<span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_bool</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
-</span><span id="TypeParser-612"><a href="#TypeParser-612"><span class="linenos">612</span></a>			<span class="k">return</span> <span class="n">converter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parse_bool</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
-</span><span id="TypeParser-613"><a href="#TypeParser-613"><span class="linenos">613</span></a>		<span class="k">else</span><span class="p">:</span>
-</span><span id="TypeParser-614"><a href="#TypeParser-614"><span class="linenos">614</span></a>			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;not a </span><span class="si">{</span><span class="n">_FloatLike</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
+</span><span id="TypeParser-571"><a href="#TypeParser-571"><span class="linenos">571</span></a>	<span class="k">def</span> <span class="nf">_parse_floatlike</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
+</span><span id="TypeParser-572"><a href="#TypeParser-572"><span class="linenos">572</span></a>		<span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
+</span><span id="TypeParser-573"><a href="#TypeParser-573"><span class="linenos">573</span></a>		<span class="n">converter</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]],</span> <span class="n">_FloatLike</span><span class="p">],</span>
+</span><span id="TypeParser-574"><a href="#TypeParser-574"><span class="linenos">574</span></a>		<span class="n">inf_value</span><span class="p">:</span> <span class="n">_FloatLike</span><span class="p">,</span>
+</span><span id="TypeParser-575"><a href="#TypeParser-575"><span class="linenos">575</span></a>		<span class="n">nan_value</span><span class="p">:</span> <span class="n">_FloatLike</span><span class="p">,</span>
+</span><span id="TypeParser-576"><a href="#TypeParser-576"><span class="linenos">576</span></a>		<span class="o">*</span><span class="p">,</span>
+</span><span id="TypeParser-577"><a href="#TypeParser-577"><span class="linenos">577</span></a>		<span class="n">allow_scientific</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
+</span><span id="TypeParser-578"><a href="#TypeParser-578"><span class="linenos">578</span></a>		<span class="n">allow_inf</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
+</span><span id="TypeParser-579"><a href="#TypeParser-579"><span class="linenos">579</span></a>		<span class="n">allow_nan</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span>
+</span><span id="TypeParser-580"><a href="#TypeParser-580"><span class="linenos">580</span></a>	<span class="p">)</span> <span class="o">-&gt;</span> <span class="n">_FloatLike</span><span class="p">:</span>
+</span><span id="TypeParser-581"><a href="#TypeParser-581"><span class="linenos">581</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trim</span><span class="p">:</span>
+</span><span id="TypeParser-582"><a href="#TypeParser-582"><span class="linenos">582</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
+</span><span id="TypeParser-583"><a href="#TypeParser-583"><span class="linenos">583</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_float</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="o">=</span><span class="n">allow_scientific</span><span class="p">,</span> <span class="n">allow_inf</span><span class="o">=</span><span class="n">allow_inf</span><span class="p">,</span> <span class="n">allow_nan</span><span class="o">=</span><span class="n">allow_nan</span><span class="p">):</span>
+</span><span id="TypeParser-584"><a href="#TypeParser-584"><span class="linenos">584</span></a>			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">float_case_sensitive</span><span class="p">:</span>
+</span><span id="TypeParser-585"><a href="#TypeParser-585"><span class="linenos">585</span></a>				<span class="n">special_value</span> <span class="o">=</span> <span class="n">value</span>
+</span><span id="TypeParser-586"><a href="#TypeParser-586"><span class="linenos">586</span></a>			<span class="k">else</span><span class="p">:</span>
+</span><span id="TypeParser-587"><a href="#TypeParser-587"><span class="linenos">587</span></a>				<span class="n">special_value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
+</span><span id="TypeParser-588"><a href="#TypeParser-588"><span class="linenos">588</span></a>			<span class="k">if</span> <span class="n">allow_inf</span> <span class="ow">and</span> <span class="n">special_value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inf_values</span><span class="p">:</span>
+</span><span id="TypeParser-589"><a href="#TypeParser-589"><span class="linenos">589</span></a>				<span class="k">return</span> <span class="n">inf_value</span>
+</span><span id="TypeParser-590"><a href="#TypeParser-590"><span class="linenos">590</span></a>			<span class="k">if</span> <span class="n">allow_nan</span> <span class="ow">and</span> <span class="n">special_value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nan_values</span><span class="p">:</span>
+</span><span id="TypeParser-591"><a href="#TypeParser-591"><span class="linenos">591</span></a>				<span class="k">return</span> <span class="n">nan_value</span>
+</span><span id="TypeParser-592"><a href="#TypeParser-592"><span class="linenos">592</span></a>
+</span><span id="TypeParser-593"><a href="#TypeParser-593"><span class="linenos">593</span></a>			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sign_chars</span><span class="p">:</span>
+</span><span id="TypeParser-594"><a href="#TypeParser-594"><span class="linenos">594</span></a>				<span class="n">positive_part</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
+</span><span id="TypeParser-595"><a href="#TypeParser-595"><span class="linenos">595</span></a>				<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">float_case_sensitive</span><span class="p">:</span>
+</span><span id="TypeParser-596"><a href="#TypeParser-596"><span class="linenos">596</span></a>					<span class="n">special_value</span> <span class="o">=</span> <span class="n">positive_part</span>
+</span><span id="TypeParser-597"><a href="#TypeParser-597"><span class="linenos">597</span></a>				<span class="k">else</span><span class="p">:</span>
+</span><span id="TypeParser-598"><a href="#TypeParser-598"><span class="linenos">598</span></a>					<span class="n">special_value</span> <span class="o">=</span> <span class="n">positive_part</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
+</span><span id="TypeParser-599"><a href="#TypeParser-599"><span class="linenos">599</span></a>				<span class="k">if</span> <span class="n">allow_inf</span> <span class="ow">and</span> <span class="n">special_value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inf_values</span><span class="p">:</span>
+</span><span id="TypeParser-600"><a href="#TypeParser-600"><span class="linenos">600</span></a>					<span class="k">if</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_negative_chars</span><span class="p">:</span>
+</span><span id="TypeParser-601"><a href="#TypeParser-601"><span class="linenos">601</span></a>						<span class="k">return</span> <span class="o">-</span><span class="mi">1</span> <span class="o">*</span> <span class="n">inf_value</span>
+</span><span id="TypeParser-602"><a href="#TypeParser-602"><span class="linenos">602</span></a>					<span class="k">else</span><span class="p">:</span>
+</span><span id="TypeParser-603"><a href="#TypeParser-603"><span class="linenos">603</span></a>						<span class="k">return</span> <span class="n">inf_value</span>
+</span><span id="TypeParser-604"><a href="#TypeParser-604"><span class="linenos">604</span></a>				<span class="k">if</span> <span class="n">allow_nan</span> <span class="ow">and</span> <span class="n">special_value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nan_values</span><span class="p">:</span>
+</span><span id="TypeParser-605"><a href="#TypeParser-605"><span class="linenos">605</span></a>					<span class="k">return</span> <span class="n">nan_value</span>
+</span><span id="TypeParser-606"><a href="#TypeParser-606"><span class="linenos">606</span></a>
+</span><span id="TypeParser-607"><a href="#TypeParser-607"><span class="linenos">607</span></a>				<span class="k">if</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_negative_chars</span><span class="p">:</span>
+</span><span id="TypeParser-608"><a href="#TypeParser-608"><span class="linenos">608</span></a>					<span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_negative_char</span> <span class="o">+</span> <span class="n">positive_part</span>
+</span><span id="TypeParser-609"><a href="#TypeParser-609"><span class="linenos">609</span></a>			<span class="k">return</span> <span class="n">converter</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
+</span><span id="TypeParser-610"><a href="#TypeParser-610"><span class="linenos">610</span></a>		<span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_bool</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
+</span><span id="TypeParser-611"><a href="#TypeParser-611"><span class="linenos">611</span></a>			<span class="k">return</span> <span class="n">converter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parse_bool</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
+</span><span id="TypeParser-612"><a href="#TypeParser-612"><span class="linenos">612</span></a>		<span class="k">else</span><span class="p">:</span>
+</span><span id="TypeParser-613"><a href="#TypeParser-613"><span class="linenos">613</span></a>			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;not a </span><span class="si">{</span><span class="n">_FloatLike</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
+</span><span id="TypeParser-614"><a href="#TypeParser-614"><span class="linenos">614</span></a>
 </span><span id="TypeParser-615"><a href="#TypeParser-615"><span class="linenos">615</span></a>
-</span><span id="TypeParser-616"><a href="#TypeParser-616"><span class="linenos">616</span></a>
-</span><span id="TypeParser-617"><a href="#TypeParser-617"><span class="linenos">617</span></a>	<span class="k">def</span> <span class="nf">parse_float</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_inf</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_nan</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
-</span><span id="TypeParser-618"><a href="#TypeParser-618"><span class="linenos">618</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
-</span><span id="TypeParser-619"><a href="#TypeParser-619"><span class="linenos">619</span></a><span class="sd">			Parse a string and return it as a (non-exact) float if possible</span>
-</span><span id="TypeParser-620"><a href="#TypeParser-620"><span class="linenos">620</span></a>
-</span><span id="TypeParser-621"><a href="#TypeParser-621"><span class="linenos">621</span></a><span class="sd">			If the string represents a bool, it will be converted to `1.` for True and `0.` for False. If the string represents an int, it will be converted to a float also.</span>
-</span><span id="TypeParser-622"><a href="#TypeParser-622"><span class="linenos">622</span></a>
-</span><span id="TypeParser-623"><a href="#TypeParser-623"><span class="linenos">623</span></a><span class="sd">			Behaves analogously to `parse_decimal()`, except that that returns an exact Decimal instead.</span>
-</span><span id="TypeParser-624"><a href="#TypeParser-624"><span class="linenos">624</span></a>
-</span><span id="TypeParser-625"><a href="#TypeParser-625"><span class="linenos">625</span></a><span class="sd">			Parameters</span>
-</span><span id="TypeParser-626"><a href="#TypeParser-626"><span class="linenos">626</span></a><span class="sd">			----------</span>
-</span><span id="TypeParser-627"><a href="#TypeParser-627"><span class="linenos">627</span></a><span class="sd">			`value`</span>
-</span><span id="TypeParser-628"><a href="#TypeParser-628"><span class="linenos">628</span></a><span class="sd">			: string to be parsed</span>
-</span><span id="TypeParser-629"><a href="#TypeParser-629"><span class="linenos">629</span></a>
-</span><span id="TypeParser-630"><a href="#TypeParser-630"><span class="linenos">630</span></a><span class="sd">			`allow_scientific`</span>
-</span><span id="TypeParser-631"><a href="#TypeParser-631"><span class="linenos">631</span></a><span class="sd">			: whether to accept scientific notation. If True, strings of the form `&quot;&lt;var&gt;M&lt;/var&gt;e&lt;var&gt;X&lt;/var&gt;&quot;` will be interpreted as the expression `&lt;var&gt;M&lt;/var&gt; * (10 ** &lt;var&gt;X&lt;/var&gt;)`, where &lt;var&gt;M&lt;/var&gt; is the mantissa/significand and &lt;var&gt;X&lt;/var&gt; is the exponent. Note that &lt;var&gt;X&lt;/var&gt; must be an integer, but can be negative.</span>
-</span><span id="TypeParser-632"><a href="#TypeParser-632"><span class="linenos">632</span></a>
-</span><span id="TypeParser-633"><a href="#TypeParser-633"><span class="linenos">633</span></a><span class="sd">			`allow_inf`</span>
-</span><span id="TypeParser-634"><a href="#TypeParser-634"><span class="linenos">634</span></a><span class="sd">			: whether to accept positive and negative infinity values. If True, strings that match the values in `self.inf_values` (empty by default) are interpreted as infinity, or as negative infinity if prepended by a negative sign. The case sensitivity of this matching depends on `self.float_case_sensitive`, which is False by default.</span>
-</span><span id="TypeParser-635"><a href="#TypeParser-635"><span class="linenos">635</span></a>
-</span><span id="TypeParser-636"><a href="#TypeParser-636"><span class="linenos">636</span></a><span class="sd">			`allow_nan`</span>
-</span><span id="TypeParser-637"><a href="#TypeParser-637"><span class="linenos">637</span></a><span class="sd">			: whether to accept NaN (not a number) representations. If True, strings that match the values in `self.nan_values` (empty by default) are interpeted as NaN. The case sensitivity of this matching depends on `self.float_case_sensitive`, which is False by default.</span>
-</span><span id="TypeParser-638"><a href="#TypeParser-638"><span class="linenos">638</span></a>
-</span><span id="TypeParser-639"><a href="#TypeParser-639"><span class="linenos">639</span></a><span class="sd">			Returns</span>
-</span><span id="TypeParser-640"><a href="#TypeParser-640"><span class="linenos">640</span></a><span class="sd">			-------</span>
-</span><span id="TypeParser-641"><a href="#TypeParser-641"><span class="linenos">641</span></a><span class="sd">			parsed float value</span>
-</span><span id="TypeParser-642"><a href="#TypeParser-642"><span class="linenos">642</span></a>
-</span><span id="TypeParser-643"><a href="#TypeParser-643"><span class="linenos">643</span></a><span class="sd">			Raises</span>
-</span><span id="TypeParser-644"><a href="#TypeParser-644"><span class="linenos">644</span></a><span class="sd">			------</span>
-</span><span id="TypeParser-645"><a href="#TypeParser-645"><span class="linenos">645</span></a><span class="sd">			`ValueError` if `value` cannot be parsed</span>
-</span><span id="TypeParser-646"><a href="#TypeParser-646"><span class="linenos">646</span></a>
-</span><span id="TypeParser-647"><a href="#TypeParser-647"><span class="linenos">647</span></a><span class="sd">			Examples</span>
-</span><span id="TypeParser-648"><a href="#TypeParser-648"><span class="linenos">648</span></a><span class="sd">			--------</span>
-</span><span id="TypeParser-649"><a href="#TypeParser-649"><span class="linenos">649</span></a><span class="sd">			```python</span>
-</span><span id="TypeParser-650"><a href="#TypeParser-650"><span class="linenos">650</span></a><span class="sd">			parser = TypeParser(inf_values=[&quot;inf&quot;], nan_values=[&quot;nan&quot;])</span>
-</span><span id="TypeParser-651"><a href="#TypeParser-651"><span class="linenos">651</span></a><span class="sd">			parser.parse_float(&quot;1.&quot;)       # 1.</span>
-</span><span id="TypeParser-652"><a href="#TypeParser-652"><span class="linenos">652</span></a><span class="sd">			parser.parse_float(&quot;1.23e2&quot;)   # 123.</span>
-</span><span id="TypeParser-653"><a href="#TypeParser-653"><span class="linenos">653</span></a><span class="sd">			parser.parse_float(&quot;1.23e-2&quot;)  # 0.0123</span>
-</span><span id="TypeParser-654"><a href="#TypeParser-654"><span class="linenos">654</span></a><span class="sd">			parser.parse_float(&quot;inf&quot;)      # math.inf</span>
-</span><span id="TypeParser-655"><a href="#TypeParser-655"><span class="linenos">655</span></a><span class="sd">			```</span>
-</span><span id="TypeParser-656"><a href="#TypeParser-656"><span class="linenos">656</span></a><span class="sd">		&quot;&quot;&quot;</span>
-</span><span id="TypeParser-657"><a href="#TypeParser-657"><span class="linenos">657</span></a>		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_floatlike</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
-</span><span id="TypeParser-658"><a href="#TypeParser-658"><span class="linenos">658</span></a>			<span class="n">allow_scientific</span><span class="o">=</span><span class="n">allow_scientific</span><span class="p">,</span>
-</span><span id="TypeParser-659"><a href="#TypeParser-659"><span class="linenos">659</span></a>			<span class="n">allow_inf</span><span class="o">=</span><span class="n">allow_inf</span><span class="p">,</span>
-</span><span id="TypeParser-660"><a href="#TypeParser-660"><span class="linenos">660</span></a>			<span class="n">allow_nan</span><span class="o">=</span><span class="n">allow_nan</span><span class="p">,</span>
-</span><span id="TypeParser-661"><a href="#TypeParser-661"><span class="linenos">661</span></a>		<span class="p">)</span>
+</span><span id="TypeParser-616"><a href="#TypeParser-616"><span class="linenos">616</span></a>	<span class="k">def</span> <span class="nf">parse_float</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_inf</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_nan</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
+</span><span id="TypeParser-617"><a href="#TypeParser-617"><span class="linenos">617</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
+</span><span id="TypeParser-618"><a href="#TypeParser-618"><span class="linenos">618</span></a><span class="sd">			Parse a string and return it as a (non-exact) float if possible</span>
+</span><span id="TypeParser-619"><a href="#TypeParser-619"><span class="linenos">619</span></a>
+</span><span id="TypeParser-620"><a href="#TypeParser-620"><span class="linenos">620</span></a><span class="sd">			If the string represents a bool, it will be converted to `1.` for True and `0.` for False. If the string represents an int, it will be converted to a float also.</span>
+</span><span id="TypeParser-621"><a href="#TypeParser-621"><span class="linenos">621</span></a>
+</span><span id="TypeParser-622"><a href="#TypeParser-622"><span class="linenos">622</span></a><span class="sd">			Behaves analogously to `parse_decimal()`, except that that returns an exact Decimal instead.</span>
+</span><span id="TypeParser-623"><a href="#TypeParser-623"><span class="linenos">623</span></a>
+</span><span id="TypeParser-624"><a href="#TypeParser-624"><span class="linenos">624</span></a><span class="sd">			Parameters</span>
+</span><span id="TypeParser-625"><a href="#TypeParser-625"><span class="linenos">625</span></a><span class="sd">			----------</span>
+</span><span id="TypeParser-626"><a href="#TypeParser-626"><span class="linenos">626</span></a><span class="sd">			`value`</span>
+</span><span id="TypeParser-627"><a href="#TypeParser-627"><span class="linenos">627</span></a><span class="sd">			: string to be parsed</span>
+</span><span id="TypeParser-628"><a href="#TypeParser-628"><span class="linenos">628</span></a>
+</span><span id="TypeParser-629"><a href="#TypeParser-629"><span class="linenos">629</span></a><span class="sd">			`allow_scientific`</span>
+</span><span id="TypeParser-630"><a href="#TypeParser-630"><span class="linenos">630</span></a><span class="sd">			: whether to accept scientific notation. If True, strings of the form `&quot;&lt;var&gt;M&lt;/var&gt;e&lt;var&gt;X&lt;/var&gt;&quot;` will be interpreted as the expression `&lt;var&gt;M&lt;/var&gt; * (10 ** &lt;var&gt;X&lt;/var&gt;)`, where &lt;var&gt;M&lt;/var&gt; is the mantissa/significand and &lt;var&gt;X&lt;/var&gt; is the exponent. Note that &lt;var&gt;X&lt;/var&gt; must be an integer, but can be negative.</span>
+</span><span id="TypeParser-631"><a href="#TypeParser-631"><span class="linenos">631</span></a>
+</span><span id="TypeParser-632"><a href="#TypeParser-632"><span class="linenos">632</span></a><span class="sd">			`allow_inf`</span>
+</span><span id="TypeParser-633"><a href="#TypeParser-633"><span class="linenos">633</span></a><span class="sd">			: whether to accept positive and negative infinity values. If True, strings that match the values in `self.inf_values` (empty by default) are interpreted as infinity, or as negative infinity if prepended by a negative sign. The case sensitivity of this matching depends on `self.float_case_sensitive`, which is False by default.</span>
+</span><span id="TypeParser-634"><a href="#TypeParser-634"><span class="linenos">634</span></a>
+</span><span id="TypeParser-635"><a href="#TypeParser-635"><span class="linenos">635</span></a><span class="sd">			`allow_nan`</span>
+</span><span id="TypeParser-636"><a href="#TypeParser-636"><span class="linenos">636</span></a><span class="sd">			: whether to accept NaN (not a number) representations. If True, strings that match the values in `self.nan_values` (empty by default) are interpeted as NaN. The case sensitivity of this matching depends on `self.float_case_sensitive`, which is False by default.</span>
+</span><span id="TypeParser-637"><a href="#TypeParser-637"><span class="linenos">637</span></a>
+</span><span id="TypeParser-638"><a href="#TypeParser-638"><span class="linenos">638</span></a><span class="sd">			Returns</span>
+</span><span id="TypeParser-639"><a href="#TypeParser-639"><span class="linenos">639</span></a><span class="sd">			-------</span>
+</span><span id="TypeParser-640"><a href="#TypeParser-640"><span class="linenos">640</span></a><span class="sd">			parsed float value</span>
+</span><span id="TypeParser-641"><a href="#TypeParser-641"><span class="linenos">641</span></a>
+</span><span id="TypeParser-642"><a href="#TypeParser-642"><span class="linenos">642</span></a><span class="sd">			Raises</span>
+</span><span id="TypeParser-643"><a href="#TypeParser-643"><span class="linenos">643</span></a><span class="sd">			------</span>
+</span><span id="TypeParser-644"><a href="#TypeParser-644"><span class="linenos">644</span></a><span class="sd">			`ValueError` if `value` cannot be parsed</span>
+</span><span id="TypeParser-645"><a href="#TypeParser-645"><span class="linenos">645</span></a>
+</span><span id="TypeParser-646"><a href="#TypeParser-646"><span class="linenos">646</span></a><span class="sd">			Examples</span>
+</span><span id="TypeParser-647"><a href="#TypeParser-647"><span class="linenos">647</span></a><span class="sd">			--------</span>
+</span><span id="TypeParser-648"><a href="#TypeParser-648"><span class="linenos">648</span></a><span class="sd">			```python</span>
+</span><span id="TypeParser-649"><a href="#TypeParser-649"><span class="linenos">649</span></a><span class="sd">			parser = TypeParser(inf_values=[&quot;inf&quot;], nan_values=[&quot;nan&quot;])</span>
+</span><span id="TypeParser-650"><a href="#TypeParser-650"><span class="linenos">650</span></a><span class="sd">			parser.parse_float(&quot;1.&quot;)       # 1.</span>
+</span><span id="TypeParser-651"><a href="#TypeParser-651"><span class="linenos">651</span></a><span class="sd">			parser.parse_float(&quot;1.23e2&quot;)   # 123.</span>
+</span><span id="TypeParser-652"><a href="#TypeParser-652"><span class="linenos">652</span></a><span class="sd">			parser.parse_float(&quot;1.23e-2&quot;)  # 0.0123</span>
+</span><span id="TypeParser-653"><a href="#TypeParser-653"><span class="linenos">653</span></a><span class="sd">			parser.parse_float(&quot;inf&quot;)      # math.inf</span>
+</span><span id="TypeParser-654"><a href="#TypeParser-654"><span class="linenos">654</span></a><span class="sd">			```</span>
+</span><span id="TypeParser-655"><a href="#TypeParser-655"><span class="linenos">655</span></a><span class="sd">		&quot;&quot;&quot;</span>
+</span><span id="TypeParser-656"><a href="#TypeParser-656"><span class="linenos">656</span></a>		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_floatlike</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
+</span><span id="TypeParser-657"><a href="#TypeParser-657"><span class="linenos">657</span></a>			<span class="n">allow_scientific</span><span class="o">=</span><span class="n">allow_scientific</span><span class="p">,</span>
+</span><span id="TypeParser-658"><a href="#TypeParser-658"><span class="linenos">658</span></a>			<span class="n">allow_inf</span><span class="o">=</span><span class="n">allow_inf</span><span class="p">,</span>
+</span><span id="TypeParser-659"><a href="#TypeParser-659"><span class="linenos">659</span></a>			<span class="n">allow_nan</span><span class="o">=</span><span class="n">allow_nan</span><span class="p">,</span>
+</span><span id="TypeParser-660"><a href="#TypeParser-660"><span class="linenos">660</span></a>		<span class="p">)</span>
+</span><span id="TypeParser-661"><a href="#TypeParser-661"><span class="linenos">661</span></a>
 </span><span id="TypeParser-662"><a href="#TypeParser-662"><span class="linenos">662</span></a>
-</span><span id="TypeParser-663"><a href="#TypeParser-663"><span class="linenos">663</span></a>
-</span><span id="TypeParser-664"><a href="#TypeParser-664"><span class="linenos">664</span></a>	<span class="k">def</span> <span class="nf">parse_decimal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_inf</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_nan</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Decimal</span><span class="p">:</span>
-</span><span id="TypeParser-665"><a href="#TypeParser-665"><span class="linenos">665</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
-</span><span id="TypeParser-666"><a href="#TypeParser-666"><span class="linenos">666</span></a><span class="sd">			Parse a string and return it as an exact Decimal if possible</span>
-</span><span id="TypeParser-667"><a href="#TypeParser-667"><span class="linenos">667</span></a>
-</span><span id="TypeParser-668"><a href="#TypeParser-668"><span class="linenos">668</span></a><span class="sd">			If the string represents a bool, it will be converted to `Decimal(1)` for True and `Decimal(0)` for False. If the string represents an int, it will be converted to a Decimal also.</span>
-</span><span id="TypeParser-669"><a href="#TypeParser-669"><span class="linenos">669</span></a>
-</span><span id="TypeParser-670"><a href="#TypeParser-670"><span class="linenos">670</span></a><span class="sd">			Behaves analogously to `parse_float()`, except that that returns a non-exact float instead.</span>
-</span><span id="TypeParser-671"><a href="#TypeParser-671"><span class="linenos">671</span></a>
-</span><span id="TypeParser-672"><a href="#TypeParser-672"><span class="linenos">672</span></a><span class="sd">			Parameters</span>
-</span><span id="TypeParser-673"><a href="#TypeParser-673"><span class="linenos">673</span></a><span class="sd">			----------</span>
-</span><span id="TypeParser-674"><a href="#TypeParser-674"><span class="linenos">674</span></a><span class="sd">			`value`</span>
-</span><span id="TypeParser-675"><a href="#TypeParser-675"><span class="linenos">675</span></a><span class="sd">			: string to be parsed</span>
-</span><span id="TypeParser-676"><a href="#TypeParser-676"><span class="linenos">676</span></a>
-</span><span id="TypeParser-677"><a href="#TypeParser-677"><span class="linenos">677</span></a><span class="sd">			`allow_scientific`</span>
-</span><span id="TypeParser-678"><a href="#TypeParser-678"><span class="linenos">678</span></a><span class="sd">			: whether to accept scientific notation. If True, strings of the form `&quot;&lt;var&gt;M&lt;/var&gt;e&lt;var&gt;X&lt;/var&gt;&quot;` will be interpreted as the expression `&lt;var&gt;M&lt;/var&gt; * (10 ** &lt;var&gt;X&lt;/var&gt;)`, where &lt;var&gt;M&lt;/var&gt; is the mantissa/significand and &lt;var&gt;X&lt;/var&gt; is the exponent. Note that &lt;var&gt;X&lt;/var&gt; must be an integer, but can be negative.</span>
-</span><span id="TypeParser-679"><a href="#TypeParser-679"><span class="linenos">679</span></a>
-</span><span id="TypeParser-680"><a href="#TypeParser-680"><span class="linenos">680</span></a><span class="sd">			`allow_inf`</span>
-</span><span id="TypeParser-681"><a href="#TypeParser-681"><span class="linenos">681</span></a><span class="sd">			: whether to accept positive and negative infinity values. If True, strings that match the values in `self.inf_values` (empty by default) are interpreted as infinity, or as negative infinity if prepended by a negative sign. The case sensitivity of this matching depends on `self.float_case_sensitive`, which is False by default.</span>
-</span><span id="TypeParser-682"><a href="#TypeParser-682"><span class="linenos">682</span></a>
-</span><span id="TypeParser-683"><a href="#TypeParser-683"><span class="linenos">683</span></a><span class="sd">			`allow_nan`</span>
-</span><span id="TypeParser-684"><a href="#TypeParser-684"><span class="linenos">684</span></a><span class="sd">			: whether to accept NaN (not a number) representations. If True, strings that match the values in `self.nan_values` (empty by default) are interpeted as NaN. The case sensitivity of this matching depends on `self.float_case_sensitive`, which is False by default.</span>
-</span><span id="TypeParser-685"><a href="#TypeParser-685"><span class="linenos">685</span></a>
-</span><span id="TypeParser-686"><a href="#TypeParser-686"><span class="linenos">686</span></a><span class="sd">			Returns</span>
-</span><span id="TypeParser-687"><a href="#TypeParser-687"><span class="linenos">687</span></a><span class="sd">			-------</span>
-</span><span id="TypeParser-688"><a href="#TypeParser-688"><span class="linenos">688</span></a><span class="sd">			parsed Decimal value</span>
-</span><span id="TypeParser-689"><a href="#TypeParser-689"><span class="linenos">689</span></a>
-</span><span id="TypeParser-690"><a href="#TypeParser-690"><span class="linenos">690</span></a><span class="sd">			Raises</span>
-</span><span id="TypeParser-691"><a href="#TypeParser-691"><span class="linenos">691</span></a><span class="sd">			------</span>
-</span><span id="TypeParser-692"><a href="#TypeParser-692"><span class="linenos">692</span></a><span class="sd">			`ValueError` if `value` cannot be parsed</span>
-</span><span id="TypeParser-693"><a href="#TypeParser-693"><span class="linenos">693</span></a>
-</span><span id="TypeParser-694"><a href="#TypeParser-694"><span class="linenos">694</span></a><span class="sd">			Examples</span>
-</span><span id="TypeParser-695"><a href="#TypeParser-695"><span class="linenos">695</span></a><span class="sd">			--------</span>
-</span><span id="TypeParser-696"><a href="#TypeParser-696"><span class="linenos">696</span></a><span class="sd">			```python</span>
-</span><span id="TypeParser-697"><a href="#TypeParser-697"><span class="linenos">697</span></a><span class="sd">			parser = TypeParser(inf_values=[&quot;inf&quot;], nan_values=[&quot;nan&quot;])</span>
-</span><span id="TypeParser-698"><a href="#TypeParser-698"><span class="linenos">698</span></a><span class="sd">			parser.parse_decimal(&quot;1.&quot;)       # Decimal(1)</span>
-</span><span id="TypeParser-699"><a href="#TypeParser-699"><span class="linenos">699</span></a><span class="sd">			parser.parse_decimal(&quot;1.23e2&quot;)   # Decimal(123)</span>
-</span><span id="TypeParser-700"><a href="#TypeParser-700"><span class="linenos">700</span></a><span class="sd">			parser.parse_decimal(&quot;1.23e-2&quot;)  # Decimal(123) / Decimal(10000)</span>
-</span><span id="TypeParser-701"><a href="#TypeParser-701"><span class="linenos">701</span></a><span class="sd">			parser.parse_decimal(&quot;inf&quot;)      # Decimal(math.inf)</span>
-</span><span id="TypeParser-702"><a href="#TypeParser-702"><span class="linenos">702</span></a><span class="sd">			```</span>
-</span><span id="TypeParser-703"><a href="#TypeParser-703"><span class="linenos">703</span></a><span class="sd">		&quot;&quot;&quot;</span>
-</span><span id="TypeParser-704"><a href="#TypeParser-704"><span class="linenos">704</span></a>		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_floatlike</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Decimal</span><span class="p">,</span> <span class="n">Decimal</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">nan</span><span class="p">),</span>
-</span><span id="TypeParser-705"><a href="#TypeParser-705"><span class="linenos">705</span></a>			<span class="n">allow_scientific</span><span class="o">=</span><span class="n">allow_scientific</span><span class="p">,</span>
-</span><span id="TypeParser-706"><a href="#TypeParser-706"><span class="linenos">706</span></a>			<span class="n">allow_inf</span><span class="o">=</span><span class="n">allow_inf</span><span class="p">,</span>
-</span><span id="TypeParser-707"><a href="#TypeParser-707"><span class="linenos">707</span></a>			<span class="n">allow_nan</span><span class="o">=</span><span class="n">allow_nan</span><span class="p">,</span>
-</span><span id="TypeParser-708"><a href="#TypeParser-708"><span class="linenos">708</span></a>		<span class="p">)</span>
+</span><span id="TypeParser-663"><a href="#TypeParser-663"><span class="linenos">663</span></a>	<span class="k">def</span> <span class="nf">parse_decimal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_inf</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_nan</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Decimal</span><span class="p">:</span>
+</span><span id="TypeParser-664"><a href="#TypeParser-664"><span class="linenos">664</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
+</span><span id="TypeParser-665"><a href="#TypeParser-665"><span class="linenos">665</span></a><span class="sd">			Parse a string and return it as an exact Decimal if possible</span>
+</span><span id="TypeParser-666"><a href="#TypeParser-666"><span class="linenos">666</span></a>
+</span><span id="TypeParser-667"><a href="#TypeParser-667"><span class="linenos">667</span></a><span class="sd">			If the string represents a bool, it will be converted to `Decimal(1)` for True and `Decimal(0)` for False. If the string represents an int, it will be converted to a Decimal also.</span>
+</span><span id="TypeParser-668"><a href="#TypeParser-668"><span class="linenos">668</span></a>
+</span><span id="TypeParser-669"><a href="#TypeParser-669"><span class="linenos">669</span></a><span class="sd">			Behaves analogously to `parse_float()`, except that that returns a non-exact float instead.</span>
+</span><span id="TypeParser-670"><a href="#TypeParser-670"><span class="linenos">670</span></a>
+</span><span id="TypeParser-671"><a href="#TypeParser-671"><span class="linenos">671</span></a><span class="sd">			Parameters</span>
+</span><span id="TypeParser-672"><a href="#TypeParser-672"><span class="linenos">672</span></a><span class="sd">			----------</span>
+</span><span id="TypeParser-673"><a href="#TypeParser-673"><span class="linenos">673</span></a><span class="sd">			`value`</span>
+</span><span id="TypeParser-674"><a href="#TypeParser-674"><span class="linenos">674</span></a><span class="sd">			: string to be parsed</span>
+</span><span id="TypeParser-675"><a href="#TypeParser-675"><span class="linenos">675</span></a>
+</span><span id="TypeParser-676"><a href="#TypeParser-676"><span class="linenos">676</span></a><span class="sd">			`allow_scientific`</span>
+</span><span id="TypeParser-677"><a href="#TypeParser-677"><span class="linenos">677</span></a><span class="sd">			: whether to accept scientific notation. If True, strings of the form `&quot;&lt;var&gt;M&lt;/var&gt;e&lt;var&gt;X&lt;/var&gt;&quot;` will be interpreted as the expression `&lt;var&gt;M&lt;/var&gt; * (10 ** &lt;var&gt;X&lt;/var&gt;)`, where &lt;var&gt;M&lt;/var&gt; is the mantissa/significand and &lt;var&gt;X&lt;/var&gt; is the exponent. Note that &lt;var&gt;X&lt;/var&gt; must be an integer, but can be negative.</span>
+</span><span id="TypeParser-678"><a href="#TypeParser-678"><span class="linenos">678</span></a>
+</span><span id="TypeParser-679"><a href="#TypeParser-679"><span class="linenos">679</span></a><span class="sd">			`allow_inf`</span>
+</span><span id="TypeParser-680"><a href="#TypeParser-680"><span class="linenos">680</span></a><span class="sd">			: whether to accept positive and negative infinity values. If True, strings that match the values in `self.inf_values` (empty by default) are interpreted as infinity, or as negative infinity if prepended by a negative sign. The case sensitivity of this matching depends on `self.float_case_sensitive`, which is False by default.</span>
+</span><span id="TypeParser-681"><a href="#TypeParser-681"><span class="linenos">681</span></a>
+</span><span id="TypeParser-682"><a href="#TypeParser-682"><span class="linenos">682</span></a><span class="sd">			`allow_nan`</span>
+</span><span id="TypeParser-683"><a href="#TypeParser-683"><span class="linenos">683</span></a><span class="sd">			: whether to accept NaN (not a number) representations. If True, strings that match the values in `self.nan_values` (empty by default) are interpeted as NaN. The case sensitivity of this matching depends on `self.float_case_sensitive`, which is False by default.</span>
+</span><span id="TypeParser-684"><a href="#TypeParser-684"><span class="linenos">684</span></a>
+</span><span id="TypeParser-685"><a href="#TypeParser-685"><span class="linenos">685</span></a><span class="sd">			Returns</span>
+</span><span id="TypeParser-686"><a href="#TypeParser-686"><span class="linenos">686</span></a><span class="sd">			-------</span>
+</span><span id="TypeParser-687"><a href="#TypeParser-687"><span class="linenos">687</span></a><span class="sd">			parsed Decimal value</span>
+</span><span id="TypeParser-688"><a href="#TypeParser-688"><span class="linenos">688</span></a>
+</span><span id="TypeParser-689"><a href="#TypeParser-689"><span class="linenos">689</span></a><span class="sd">			Raises</span>
+</span><span id="TypeParser-690"><a href="#TypeParser-690"><span class="linenos">690</span></a><span class="sd">			------</span>
+</span><span id="TypeParser-691"><a href="#TypeParser-691"><span class="linenos">691</span></a><span class="sd">			`ValueError` if `value` cannot be parsed</span>
+</span><span id="TypeParser-692"><a href="#TypeParser-692"><span class="linenos">692</span></a>
+</span><span id="TypeParser-693"><a href="#TypeParser-693"><span class="linenos">693</span></a><span class="sd">			Examples</span>
+</span><span id="TypeParser-694"><a href="#TypeParser-694"><span class="linenos">694</span></a><span class="sd">			--------</span>
+</span><span id="TypeParser-695"><a href="#TypeParser-695"><span class="linenos">695</span></a><span class="sd">			```python</span>
+</span><span id="TypeParser-696"><a href="#TypeParser-696"><span class="linenos">696</span></a><span class="sd">			parser = TypeParser(inf_values=[&quot;inf&quot;], nan_values=[&quot;nan&quot;])</span>
+</span><span id="TypeParser-697"><a href="#TypeParser-697"><span class="linenos">697</span></a><span class="sd">			parser.parse_decimal(&quot;1.&quot;)       # Decimal(1)</span>
+</span><span id="TypeParser-698"><a href="#TypeParser-698"><span class="linenos">698</span></a><span class="sd">			parser.parse_decimal(&quot;1.23e2&quot;)   # Decimal(123)</span>
+</span><span id="TypeParser-699"><a href="#TypeParser-699"><span class="linenos">699</span></a><span class="sd">			parser.parse_decimal(&quot;1.23e-2&quot;)  # Decimal(123) / Decimal(10000)</span>
+</span><span id="TypeParser-700"><a href="#TypeParser-700"><span class="linenos">700</span></a><span class="sd">			parser.parse_decimal(&quot;inf&quot;)      # Decimal(math.inf)</span>
+</span><span id="TypeParser-701"><a href="#TypeParser-701"><span class="linenos">701</span></a><span class="sd">			```</span>
+</span><span id="TypeParser-702"><a href="#TypeParser-702"><span class="linenos">702</span></a><span class="sd">		&quot;&quot;&quot;</span>
+</span><span id="TypeParser-703"><a href="#TypeParser-703"><span class="linenos">703</span></a>		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_floatlike</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Decimal</span><span class="p">,</span> <span class="n">Decimal</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">nan</span><span class="p">),</span>
+</span><span id="TypeParser-704"><a href="#TypeParser-704"><span class="linenos">704</span></a>			<span class="n">allow_scientific</span><span class="o">=</span><span class="n">allow_scientific</span><span class="p">,</span>
+</span><span id="TypeParser-705"><a href="#TypeParser-705"><span class="linenos">705</span></a>			<span class="n">allow_inf</span><span class="o">=</span><span class="n">allow_inf</span><span class="p">,</span>
+</span><span id="TypeParser-706"><a href="#TypeParser-706"><span class="linenos">706</span></a>			<span class="n">allow_nan</span><span class="o">=</span><span class="n">allow_nan</span><span class="p">,</span>
+</span><span id="TypeParser-707"><a href="#TypeParser-707"><span class="linenos">707</span></a>		<span class="p">)</span>
+</span><span id="TypeParser-708"><a href="#TypeParser-708"><span class="linenos">708</span></a>
 </span><span id="TypeParser-709"><a href="#TypeParser-709"><span class="linenos">709</span></a>
-</span><span id="TypeParser-710"><a href="#TypeParser-710"><span class="linenos">710</span></a>
-</span><span id="TypeParser-711"><a href="#TypeParser-711"><span class="linenos">711</span></a>	<span class="k">def</span> <span class="nf">infer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AnyValueType</span><span class="p">:</span>
-</span><span id="TypeParser-712"><a href="#TypeParser-712"><span class="linenos">712</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
-</span><span id="TypeParser-713"><a href="#TypeParser-713"><span class="linenos">713</span></a><span class="sd">			Infer the underlying type of a string</span>
-</span><span id="TypeParser-714"><a href="#TypeParser-714"><span class="linenos">714</span></a>
-</span><span id="TypeParser-715"><a href="#TypeParser-715"><span class="linenos">715</span></a><span class="sd">			Also check for inline lists if `self.list_delimiter` is not None.</span>
-</span><span id="TypeParser-716"><a href="#TypeParser-716"><span class="linenos">716</span></a>
-</span><span id="TypeParser-717"><a href="#TypeParser-717"><span class="linenos">717</span></a><span class="sd">			Parameters</span>
-</span><span id="TypeParser-718"><a href="#TypeParser-718"><span class="linenos">718</span></a><span class="sd">			----------</span>
-</span><span id="TypeParser-719"><a href="#TypeParser-719"><span class="linenos">719</span></a><span class="sd">			`value`</span>
-</span><span id="TypeParser-720"><a href="#TypeParser-720"><span class="linenos">720</span></a><span class="sd">			: the string for which the type should be inferred</span>
-</span><span id="TypeParser-721"><a href="#TypeParser-721"><span class="linenos">721</span></a>
-</span><span id="TypeParser-722"><a href="#TypeParser-722"><span class="linenos">722</span></a><span class="sd">			Returns</span>
-</span><span id="TypeParser-723"><a href="#TypeParser-723"><span class="linenos">723</span></a><span class="sd">			-------</span>
-</span><span id="TypeParser-724"><a href="#TypeParser-724"><span class="linenos">724</span></a><span class="sd">			inferred type</span>
-</span><span id="TypeParser-725"><a href="#TypeParser-725"><span class="linenos">725</span></a>
-</span><span id="TypeParser-726"><a href="#TypeParser-726"><span class="linenos">726</span></a><span class="sd">			Examples</span>
-</span><span id="TypeParser-727"><a href="#TypeParser-727"><span class="linenos">727</span></a><span class="sd">			--------</span>
-</span><span id="TypeParser-728"><a href="#TypeParser-728"><span class="linenos">728</span></a><span class="sd">			```python</span>
-</span><span id="TypeParser-729"><a href="#TypeParser-729"><span class="linenos">729</span></a><span class="sd">			parser = TypeParser()</span>
-</span><span id="TypeParser-730"><a href="#TypeParser-730"><span class="linenos">730</span></a><span class="sd">			parser.infer(&quot;true&quot;)  # bool</span>
-</span><span id="TypeParser-731"><a href="#TypeParser-731"><span class="linenos">731</span></a><span class="sd">			parser.infer(&quot;2.0&quot;)   # float</span>
-</span><span id="TypeParser-732"><a href="#TypeParser-732"><span class="linenos">732</span></a><span class="sd">			parser.infer(&quot;abc&quot;)   # str</span>
-</span><span id="TypeParser-733"><a href="#TypeParser-733"><span class="linenos">733</span></a><span class="sd">			```</span>
-</span><span id="TypeParser-734"><a href="#TypeParser-734"><span class="linenos">734</span></a><span class="sd">		&quot;&quot;&quot;</span>
-</span><span id="TypeParser-735"><a href="#TypeParser-735"><span class="linenos">735</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_none</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
-</span><span id="TypeParser-736"><a href="#TypeParser-736"><span class="linenos">736</span></a>			<span class="k">return</span> <span class="n">NoneType</span>
-</span><span id="TypeParser-737"><a href="#TypeParser-737"><span class="linenos">737</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_bool</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
-</span><span id="TypeParser-738"><a href="#TypeParser-738"><span class="linenos">738</span></a>			<span class="k">return</span> <span class="nb">bool</span>
-</span><span id="TypeParser-739"><a href="#TypeParser-739"><span class="linenos">739</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_int</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
-</span><span id="TypeParser-740"><a href="#TypeParser-740"><span class="linenos">740</span></a>			<span class="k">return</span> <span class="nb">int</span>
-</span><span id="TypeParser-741"><a href="#TypeParser-741"><span class="linenos">741</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_float</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
-</span><span id="TypeParser-742"><a href="#TypeParser-742"><span class="linenos">742</span></a>			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_decimal</span><span class="p">:</span>
-</span><span id="TypeParser-743"><a href="#TypeParser-743"><span class="linenos">743</span></a>				<span class="k">return</span> <span class="n">Decimal</span>
-</span><span id="TypeParser-744"><a href="#TypeParser-744"><span class="linenos">744</span></a>			<span class="k">else</span><span class="p">:</span>
-</span><span id="TypeParser-745"><a href="#TypeParser-745"><span class="linenos">745</span></a>				<span class="k">return</span> <span class="nb">float</span>
-</span><span id="TypeParser-746"><a href="#TypeParser-746"><span class="linenos">746</span></a>
-</span><span id="TypeParser-747"><a href="#TypeParser-747"><span class="linenos">747</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trim</span><span class="p">:</span>
-</span><span id="TypeParser-748"><a href="#TypeParser-748"><span class="linenos">748</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
-</span><span id="TypeParser-749"><a href="#TypeParser-749"><span class="linenos">749</span></a>
-</span><span id="TypeParser-750"><a href="#TypeParser-750"><span class="linenos">750</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_delimiter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_delimiter</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
-</span><span id="TypeParser-751"><a href="#TypeParser-751"><span class="linenos">751</span></a>			<span class="n">subvalues</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">list_delimiter</span><span class="p">)</span>
-</span><span id="TypeParser-752"><a href="#TypeParser-752"><span class="linenos">752</span></a>			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trim</span><span class="p">:</span>
-</span><span id="TypeParser-753"><a href="#TypeParser-753"><span class="linenos">753</span></a>				<span class="n">subvalues</span> <span class="o">=</span> <span class="p">[</span><span class="n">subvalue</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">subvalue</span> <span class="ow">in</span> <span class="n">subvalues</span><span class="p">]</span>
-</span><span id="TypeParser-754"><a href="#TypeParser-754"><span class="linenos">754</span></a>			<span class="n">reduced_type</span> <span class="o">=</span> <span class="n">reduce_types</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">infer</span><span class="p">(</span><span class="n">subvalue</span><span class="p">)</span> <span class="k">for</span> <span class="n">subvalue</span> <span class="ow">in</span> <span class="n">subvalues</span><span class="p">)</span>
-</span><span id="TypeParser-755"><a href="#TypeParser-755"><span class="linenos">755</span></a>			<span class="n">reduced_type</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">AnyContainedType</span><span class="p">,</span> <span class="n">reduced_type</span><span class="p">)</span>
-</span><span id="TypeParser-756"><a href="#TypeParser-756"><span class="linenos">756</span></a>			<span class="n">r</span> <span class="o">=</span> <span class="nb">list</span><span class="p">[</span><span class="n">reduced_type</span><span class="p">]</span>
-</span><span id="TypeParser-757"><a href="#TypeParser-757"><span class="linenos">757</span></a>			<span class="k">return</span> <span class="n">r</span>  <span class="c1"># type: ignore</span>
-</span><span id="TypeParser-758"><a href="#TypeParser-758"><span class="linenos">758</span></a>
-</span><span id="TypeParser-759"><a href="#TypeParser-759"><span class="linenos">759</span></a>		<span class="k">return</span> <span class="n">GenericValue</span>
+</span><span id="TypeParser-710"><a href="#TypeParser-710"><span class="linenos">710</span></a>	<span class="k">def</span> <span class="nf">infer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AnyValueType</span><span class="p">:</span>
+</span><span id="TypeParser-711"><a href="#TypeParser-711"><span class="linenos">711</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
+</span><span id="TypeParser-712"><a href="#TypeParser-712"><span class="linenos">712</span></a><span class="sd">			Infer the underlying type of a string</span>
+</span><span id="TypeParser-713"><a href="#TypeParser-713"><span class="linenos">713</span></a>
+</span><span id="TypeParser-714"><a href="#TypeParser-714"><span class="linenos">714</span></a><span class="sd">			Also check for inline lists if `self.list_delimiter` is not None.</span>
+</span><span id="TypeParser-715"><a href="#TypeParser-715"><span class="linenos">715</span></a>
+</span><span id="TypeParser-716"><a href="#TypeParser-716"><span class="linenos">716</span></a><span class="sd">			Parameters</span>
+</span><span id="TypeParser-717"><a href="#TypeParser-717"><span class="linenos">717</span></a><span class="sd">			----------</span>
+</span><span id="TypeParser-718"><a href="#TypeParser-718"><span class="linenos">718</span></a><span class="sd">			`value`</span>
+</span><span id="TypeParser-719"><a href="#TypeParser-719"><span class="linenos">719</span></a><span class="sd">			: the string for which the type should be inferred</span>
+</span><span id="TypeParser-720"><a href="#TypeParser-720"><span class="linenos">720</span></a>
+</span><span id="TypeParser-721"><a href="#TypeParser-721"><span class="linenos">721</span></a><span class="sd">			Returns</span>
+</span><span id="TypeParser-722"><a href="#TypeParser-722"><span class="linenos">722</span></a><span class="sd">			-------</span>
+</span><span id="TypeParser-723"><a href="#TypeParser-723"><span class="linenos">723</span></a><span class="sd">			inferred type</span>
+</span><span id="TypeParser-724"><a href="#TypeParser-724"><span class="linenos">724</span></a>
+</span><span id="TypeParser-725"><a href="#TypeParser-725"><span class="linenos">725</span></a><span class="sd">			Examples</span>
+</span><span id="TypeParser-726"><a href="#TypeParser-726"><span class="linenos">726</span></a><span class="sd">			--------</span>
+</span><span id="TypeParser-727"><a href="#TypeParser-727"><span class="linenos">727</span></a><span class="sd">			```python</span>
+</span><span id="TypeParser-728"><a href="#TypeParser-728"><span class="linenos">728</span></a><span class="sd">			parser = TypeParser()</span>
+</span><span id="TypeParser-729"><a href="#TypeParser-729"><span class="linenos">729</span></a><span class="sd">			parser.infer(&quot;true&quot;)  # bool</span>
+</span><span id="TypeParser-730"><a href="#TypeParser-730"><span class="linenos">730</span></a><span class="sd">			parser.infer(&quot;2.0&quot;)   # float</span>
+</span><span id="TypeParser-731"><a href="#TypeParser-731"><span class="linenos">731</span></a><span class="sd">			parser.infer(&quot;abc&quot;)   # str</span>
+</span><span id="TypeParser-732"><a href="#TypeParser-732"><span class="linenos">732</span></a><span class="sd">			```</span>
+</span><span id="TypeParser-733"><a href="#TypeParser-733"><span class="linenos">733</span></a><span class="sd">		&quot;&quot;&quot;</span>
+</span><span id="TypeParser-734"><a href="#TypeParser-734"><span class="linenos">734</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_none</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
+</span><span id="TypeParser-735"><a href="#TypeParser-735"><span class="linenos">735</span></a>			<span class="k">return</span> <span class="n">NoneType</span>
+</span><span id="TypeParser-736"><a href="#TypeParser-736"><span class="linenos">736</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_bool</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
+</span><span id="TypeParser-737"><a href="#TypeParser-737"><span class="linenos">737</span></a>			<span class="k">return</span> <span class="nb">bool</span>
+</span><span id="TypeParser-738"><a href="#TypeParser-738"><span class="linenos">738</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_int</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
+</span><span id="TypeParser-739"><a href="#TypeParser-739"><span class="linenos">739</span></a>			<span class="k">return</span> <span class="nb">int</span>
+</span><span id="TypeParser-740"><a href="#TypeParser-740"><span class="linenos">740</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_float</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
+</span><span id="TypeParser-741"><a href="#TypeParser-741"><span class="linenos">741</span></a>			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_decimal</span><span class="p">:</span>
+</span><span id="TypeParser-742"><a href="#TypeParser-742"><span class="linenos">742</span></a>				<span class="k">return</span> <span class="n">Decimal</span>
+</span><span id="TypeParser-743"><a href="#TypeParser-743"><span class="linenos">743</span></a>			<span class="k">else</span><span class="p">:</span>
+</span><span id="TypeParser-744"><a href="#TypeParser-744"><span class="linenos">744</span></a>				<span class="k">return</span> <span class="nb">float</span>
+</span><span id="TypeParser-745"><a href="#TypeParser-745"><span class="linenos">745</span></a>
+</span><span id="TypeParser-746"><a href="#TypeParser-746"><span class="linenos">746</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trim</span><span class="p">:</span>
+</span><span id="TypeParser-747"><a href="#TypeParser-747"><span class="linenos">747</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
+</span><span id="TypeParser-748"><a href="#TypeParser-748"><span class="linenos">748</span></a>
+</span><span id="TypeParser-749"><a href="#TypeParser-749"><span class="linenos">749</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_delimiter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_delimiter</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
+</span><span id="TypeParser-750"><a href="#TypeParser-750"><span class="linenos">750</span></a>			<span class="n">subvalues</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">list_delimiter</span><span class="p">)</span>
+</span><span id="TypeParser-751"><a href="#TypeParser-751"><span class="linenos">751</span></a>			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trim</span><span class="p">:</span>
+</span><span id="TypeParser-752"><a href="#TypeParser-752"><span class="linenos">752</span></a>				<span class="n">subvalues</span> <span class="o">=</span> <span class="p">[</span><span class="n">subvalue</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">subvalue</span> <span class="ow">in</span> <span class="n">subvalues</span><span class="p">]</span>
+</span><span id="TypeParser-753"><a href="#TypeParser-753"><span class="linenos">753</span></a>			<span class="n">reduced_type</span> <span class="o">=</span> <span class="n">reduce_types</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">infer</span><span class="p">(</span><span class="n">subvalue</span><span class="p">)</span> <span class="k">for</span> <span class="n">subvalue</span> <span class="ow">in</span> <span class="n">subvalues</span><span class="p">)</span>
+</span><span id="TypeParser-754"><a href="#TypeParser-754"><span class="linenos">754</span></a>			<span class="n">reduced_type</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">AnyContainedType</span><span class="p">,</span> <span class="n">reduced_type</span><span class="p">)</span>
+</span><span id="TypeParser-755"><a href="#TypeParser-755"><span class="linenos">755</span></a>			<span class="n">r</span> <span class="o">=</span> <span class="nb">list</span><span class="p">[</span><span class="n">reduced_type</span><span class="p">]</span>
+</span><span id="TypeParser-756"><a href="#TypeParser-756"><span class="linenos">756</span></a>			<span class="k">return</span> <span class="n">r</span>  <span class="c1"># type: ignore</span>
+</span><span id="TypeParser-757"><a href="#TypeParser-757"><span class="linenos">757</span></a>
+</span><span id="TypeParser-758"><a href="#TypeParser-758"><span class="linenos">758</span></a>		<span class="k">return</span> <span class="n">GenericValue</span>
+</span><span id="TypeParser-759"><a href="#TypeParser-759"><span class="linenos">759</span></a>
 </span><span id="TypeParser-760"><a href="#TypeParser-760"><span class="linenos">760</span></a>
-</span><span id="TypeParser-761"><a href="#TypeParser-761"><span class="linenos">761</span></a>
-</span><span id="TypeParser-762"><a href="#TypeParser-762"><span class="linenos">762</span></a>	<span class="k">def</span> <span class="nf">infer_series</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">AnyValueType</span><span class="p">:</span>
-</span><span id="TypeParser-763"><a href="#TypeParser-763"><span class="linenos">763</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
-</span><span id="TypeParser-764"><a href="#TypeParser-764"><span class="linenos">764</span></a><span class="sd">			Infer the underlying common type of a series of strings</span>
-</span><span id="TypeParser-765"><a href="#TypeParser-765"><span class="linenos">765</span></a>
-</span><span id="TypeParser-766"><a href="#TypeParser-766"><span class="linenos">766</span></a><span class="sd">			If the values in the series do not have the same apparent type, the resulting type will be narrowest possible type that will encompass all values in the series. See `parsetypes.reduce_types()` for more information.</span>
-</span><span id="TypeParser-767"><a href="#TypeParser-767"><span class="linenos">767</span></a>
-</span><span id="TypeParser-768"><a href="#TypeParser-768"><span class="linenos">768</span></a><span class="sd">			Parameters</span>
-</span><span id="TypeParser-769"><a href="#TypeParser-769"><span class="linenos">769</span></a><span class="sd">			----------</span>
-</span><span id="TypeParser-770"><a href="#TypeParser-770"><span class="linenos">770</span></a><span class="sd">			`values`</span>
-</span><span id="TypeParser-771"><a href="#TypeParser-771"><span class="linenos">771</span></a><span class="sd">			: series of strings for which the type should be inferred</span>
-</span><span id="TypeParser-772"><a href="#TypeParser-772"><span class="linenos">772</span></a>
-</span><span id="TypeParser-773"><a href="#TypeParser-773"><span class="linenos">773</span></a><span class="sd">			Returns</span>
-</span><span id="TypeParser-774"><a href="#TypeParser-774"><span class="linenos">774</span></a><span class="sd">			-------</span>
-</span><span id="TypeParser-775"><a href="#TypeParser-775"><span class="linenos">775</span></a><span class="sd">			inferred type</span>
-</span><span id="TypeParser-776"><a href="#TypeParser-776"><span class="linenos">776</span></a>
-</span><span id="TypeParser-777"><a href="#TypeParser-777"><span class="linenos">777</span></a><span class="sd">			Examples</span>
-</span><span id="TypeParser-778"><a href="#TypeParser-778"><span class="linenos">778</span></a><span class="sd">			--------</span>
-</span><span id="TypeParser-779"><a href="#TypeParser-779"><span class="linenos">779</span></a><span class="sd">			```python</span>
-</span><span id="TypeParser-780"><a href="#TypeParser-780"><span class="linenos">780</span></a><span class="sd">			parser = TypeParser()</span>
-</span><span id="TypeParser-781"><a href="#TypeParser-781"><span class="linenos">781</span></a><span class="sd">			parser.infer_series([&quot;1&quot;, &quot;2&quot;, &quot;3.4&quot;])       # float</span>
-</span><span id="TypeParser-782"><a href="#TypeParser-782"><span class="linenos">782</span></a><span class="sd">			parser.infer_series([&quot;true&quot;, &quot;false&quot;, &quot;2&quot;])  # int</span>
-</span><span id="TypeParser-783"><a href="#TypeParser-783"><span class="linenos">783</span></a><span class="sd">			parser.infer_series([&quot;1&quot;, &quot;2.3&quot;, &quot;abc&quot;])     # str</span>
-</span><span id="TypeParser-784"><a href="#TypeParser-784"><span class="linenos">784</span></a><span class="sd">			```</span>
-</span><span id="TypeParser-785"><a href="#TypeParser-785"><span class="linenos">785</span></a><span class="sd">		&quot;&quot;&quot;</span>
-</span><span id="TypeParser-786"><a href="#TypeParser-786"><span class="linenos">786</span></a>		<span class="k">return</span> <span class="n">reduce_types</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">infer</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">)</span>
+</span><span id="TypeParser-761"><a href="#TypeParser-761"><span class="linenos">761</span></a>	<span class="k">def</span> <span class="nf">infer_series</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">AnyValueType</span><span class="p">:</span>
+</span><span id="TypeParser-762"><a href="#TypeParser-762"><span class="linenos">762</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
+</span><span id="TypeParser-763"><a href="#TypeParser-763"><span class="linenos">763</span></a><span class="sd">			Infer the underlying common type of a series of strings</span>
+</span><span id="TypeParser-764"><a href="#TypeParser-764"><span class="linenos">764</span></a>
+</span><span id="TypeParser-765"><a href="#TypeParser-765"><span class="linenos">765</span></a><span class="sd">			If the values in the series do not have the same apparent type, the resulting type will be narrowest possible type that will encompass all values in the series. See `parsetypes.reduce_types()` for more information.</span>
+</span><span id="TypeParser-766"><a href="#TypeParser-766"><span class="linenos">766</span></a>
+</span><span id="TypeParser-767"><a href="#TypeParser-767"><span class="linenos">767</span></a><span class="sd">			Parameters</span>
+</span><span id="TypeParser-768"><a href="#TypeParser-768"><span class="linenos">768</span></a><span class="sd">			----------</span>
+</span><span id="TypeParser-769"><a href="#TypeParser-769"><span class="linenos">769</span></a><span class="sd">			`values`</span>
+</span><span id="TypeParser-770"><a href="#TypeParser-770"><span class="linenos">770</span></a><span class="sd">			: series of strings for which the type should be inferred</span>
+</span><span id="TypeParser-771"><a href="#TypeParser-771"><span class="linenos">771</span></a>
+</span><span id="TypeParser-772"><a href="#TypeParser-772"><span class="linenos">772</span></a><span class="sd">			Returns</span>
+</span><span id="TypeParser-773"><a href="#TypeParser-773"><span class="linenos">773</span></a><span class="sd">			-------</span>
+</span><span id="TypeParser-774"><a href="#TypeParser-774"><span class="linenos">774</span></a><span class="sd">			inferred type</span>
+</span><span id="TypeParser-775"><a href="#TypeParser-775"><span class="linenos">775</span></a>
+</span><span id="TypeParser-776"><a href="#TypeParser-776"><span class="linenos">776</span></a><span class="sd">			Examples</span>
+</span><span id="TypeParser-777"><a href="#TypeParser-777"><span class="linenos">777</span></a><span class="sd">			--------</span>
+</span><span id="TypeParser-778"><a href="#TypeParser-778"><span class="linenos">778</span></a><span class="sd">			```python</span>
+</span><span id="TypeParser-779"><a href="#TypeParser-779"><span class="linenos">779</span></a><span class="sd">			parser = TypeParser()</span>
+</span><span id="TypeParser-780"><a href="#TypeParser-780"><span class="linenos">780</span></a><span class="sd">			parser.infer_series([&quot;1&quot;, &quot;2&quot;, &quot;3.4&quot;])       # float</span>
+</span><span id="TypeParser-781"><a href="#TypeParser-781"><span class="linenos">781</span></a><span class="sd">			parser.infer_series([&quot;true&quot;, &quot;false&quot;, &quot;2&quot;])  # int</span>
+</span><span id="TypeParser-782"><a href="#TypeParser-782"><span class="linenos">782</span></a><span class="sd">			parser.infer_series([&quot;1&quot;, &quot;2.3&quot;, &quot;abc&quot;])     # str</span>
+</span><span id="TypeParser-783"><a href="#TypeParser-783"><span class="linenos">783</span></a><span class="sd">			```</span>
+</span><span id="TypeParser-784"><a href="#TypeParser-784"><span class="linenos">784</span></a><span class="sd">		&quot;&quot;&quot;</span>
+</span><span id="TypeParser-785"><a href="#TypeParser-785"><span class="linenos">785</span></a>		<span class="k">return</span> <span class="n">reduce_types</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">infer</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">)</span>
+</span><span id="TypeParser-786"><a href="#TypeParser-786"><span class="linenos">786</span></a>
 </span><span id="TypeParser-787"><a href="#TypeParser-787"><span class="linenos">787</span></a>
-</span><span id="TypeParser-788"><a href="#TypeParser-788"><span class="linenos">788</span></a>
-</span><span id="TypeParser-789"><a href="#TypeParser-789"><span class="linenos">789</span></a>	<span class="k">def</span> <span class="nf">infer_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rows</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">AnyValueType</span><span class="p">]:</span>
-</span><span id="TypeParser-790"><a href="#TypeParser-790"><span class="linenos">790</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
-</span><span id="TypeParser-791"><a href="#TypeParser-791"><span class="linenos">791</span></a><span class="sd">			Infer the underlying common type for each column of a table of strings</span>
-</span><span id="TypeParser-792"><a href="#TypeParser-792"><span class="linenos">792</span></a>
-</span><span id="TypeParser-793"><a href="#TypeParser-793"><span class="linenos">793</span></a><span class="sd">			For each column, if the values do not have the same apparent type, the resulting type will be narrowest possible type that will encompass all values in the column. See `parsetypes.reduce_types()` for more information.</span>
-</span><span id="TypeParser-794"><a href="#TypeParser-794"><span class="linenos">794</span></a>
-</span><span id="TypeParser-795"><a href="#TypeParser-795"><span class="linenos">795</span></a><span class="sd">			Note that the inferred types of every individual value must all be able to fit into memory at once.</span>
-</span><span id="TypeParser-796"><a href="#TypeParser-796"><span class="linenos">796</span></a>
-</span><span id="TypeParser-797"><a href="#TypeParser-797"><span class="linenos">797</span></a><span class="sd">			Parameters</span>
-</span><span id="TypeParser-798"><a href="#TypeParser-798"><span class="linenos">798</span></a><span class="sd">			----------</span>
-</span><span id="TypeParser-799"><a href="#TypeParser-799"><span class="linenos">799</span></a><span class="sd">			`rows`</span>
-</span><span id="TypeParser-800"><a href="#TypeParser-800"><span class="linenos">800</span></a><span class="sd">			: table of strings for which the types should be inferred, in row-major order</span>
-</span><span id="TypeParser-801"><a href="#TypeParser-801"><span class="linenos">801</span></a>
-</span><span id="TypeParser-802"><a href="#TypeParser-802"><span class="linenos">802</span></a><span class="sd">			Returns</span>
-</span><span id="TypeParser-803"><a href="#TypeParser-803"><span class="linenos">803</span></a><span class="sd">			-------</span>
-</span><span id="TypeParser-804"><a href="#TypeParser-804"><span class="linenos">804</span></a><span class="sd">			inferred types</span>
-</span><span id="TypeParser-805"><a href="#TypeParser-805"><span class="linenos">805</span></a>
-</span><span id="TypeParser-806"><a href="#TypeParser-806"><span class="linenos">806</span></a><span class="sd">			Examples</span>
-</span><span id="TypeParser-807"><a href="#TypeParser-807"><span class="linenos">807</span></a><span class="sd">			--------</span>
-</span><span id="TypeParser-808"><a href="#TypeParser-808"><span class="linenos">808</span></a><span class="sd">			```python</span>
-</span><span id="TypeParser-809"><a href="#TypeParser-809"><span class="linenos">809</span></a><span class="sd">			parser = TypeParser()</span>
-</span><span id="TypeParser-810"><a href="#TypeParser-810"><span class="linenos">810</span></a><span class="sd">			parser.infer_table([</span>
-</span><span id="TypeParser-811"><a href="#TypeParser-811"><span class="linenos">811</span></a><span class="sd">				[&quot;1&quot;,   &quot;true&quot;,  &quot;1&quot;],</span>
-</span><span id="TypeParser-812"><a href="#TypeParser-812"><span class="linenos">812</span></a><span class="sd">				[&quot;2&quot;,   &quot;false&quot;, &quot;2.3&quot;],</span>
-</span><span id="TypeParser-813"><a href="#TypeParser-813"><span class="linenos">813</span></a><span class="sd">				[&quot;3.4&quot;, &quot;2&quot;,     &quot;abc&quot;],</span>
-</span><span id="TypeParser-814"><a href="#TypeParser-814"><span class="linenos">814</span></a><span class="sd">			])</span>
-</span><span id="TypeParser-815"><a href="#TypeParser-815"><span class="linenos">815</span></a><span class="sd">			# [float, int, str]</span>
-</span><span id="TypeParser-816"><a href="#TypeParser-816"><span class="linenos">816</span></a><span class="sd">			```</span>
-</span><span id="TypeParser-817"><a href="#TypeParser-817"><span class="linenos">817</span></a><span class="sd">		&quot;&quot;&quot;</span>
-</span><span id="TypeParser-818"><a href="#TypeParser-818"><span class="linenos">818</span></a>		<span class="n">rows_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>
-</span><span id="TypeParser-819"><a href="#TypeParser-819"><span class="linenos">819</span></a>		<span class="n">first_row</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">rows_iter</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
-</span><span id="TypeParser-820"><a href="#TypeParser-820"><span class="linenos">820</span></a>		<span class="k">if</span> <span class="n">first_row</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
-</span><span id="TypeParser-821"><a href="#TypeParser-821"><span class="linenos">821</span></a>			<span class="k">return</span> <span class="p">[]</span>
-</span><span id="TypeParser-822"><a href="#TypeParser-822"><span class="linenos">822</span></a>
-</span><span id="TypeParser-823"><a href="#TypeParser-823"><span class="linenos">823</span></a>		<span class="n">num_cols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">first_row</span><span class="p">)</span>
-</span><span id="TypeParser-824"><a href="#TypeParser-824"><span class="linenos">824</span></a>		<span class="k">if</span> <span class="n">num_cols</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
-</span><span id="TypeParser-825"><a href="#TypeParser-825"><span class="linenos">825</span></a>			<span class="k">return</span> <span class="p">[]</span>
-</span><span id="TypeParser-826"><a href="#TypeParser-826"><span class="linenos">826</span></a>
-</span><span id="TypeParser-827"><a href="#TypeParser-827"><span class="linenos">827</span></a>		<span class="n">table</span> <span class="o">=</span> <span class="n">_TypeTable</span><span class="p">([[</span><span class="bp">self</span><span class="o">.</span><span class="n">infer</span><span class="p">(</span><span class="n">value</span><span class="p">)]</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">first_row</span><span class="p">])</span>
-</span><span id="TypeParser-828"><a href="#TypeParser-828"><span class="linenos">828</span></a>		<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">rows_iter</span><span class="p">:</span>
-</span><span id="TypeParser-829"><a href="#TypeParser-829"><span class="linenos">829</span></a>			<span class="n">table</span><span class="o">.</span><span class="n">add_row</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">infer</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">row</span><span class="p">])</span>
-</span><span id="TypeParser-830"><a href="#TypeParser-830"><span class="linenos">830</span></a>
-</span><span id="TypeParser-831"><a href="#TypeParser-831"><span class="linenos">831</span></a>		<span class="k">return</span> <span class="p">[</span><span class="n">reduce_types</span><span class="p">(</span><span class="n">col</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">table</span><span class="o">.</span><span class="n">cols</span><span class="p">]</span>
+</span><span id="TypeParser-788"><a href="#TypeParser-788"><span class="linenos">788</span></a>	<span class="k">def</span> <span class="nf">infer_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rows</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">AnyValueType</span><span class="p">]:</span>
+</span><span id="TypeParser-789"><a href="#TypeParser-789"><span class="linenos">789</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
+</span><span id="TypeParser-790"><a href="#TypeParser-790"><span class="linenos">790</span></a><span class="sd">			Infer the underlying common type for each column of a table of strings</span>
+</span><span id="TypeParser-791"><a href="#TypeParser-791"><span class="linenos">791</span></a>
+</span><span id="TypeParser-792"><a href="#TypeParser-792"><span class="linenos">792</span></a><span class="sd">			For each column, if the values do not have the same apparent type, the resulting type will be narrowest possible type that will encompass all values in the column. See `parsetypes.reduce_types()` for more information.</span>
+</span><span id="TypeParser-793"><a href="#TypeParser-793"><span class="linenos">793</span></a>
+</span><span id="TypeParser-794"><a href="#TypeParser-794"><span class="linenos">794</span></a><span class="sd">			Note that the inferred types of every individual value must all be able to fit into memory at once.</span>
+</span><span id="TypeParser-795"><a href="#TypeParser-795"><span class="linenos">795</span></a>
+</span><span id="TypeParser-796"><a href="#TypeParser-796"><span class="linenos">796</span></a><span class="sd">			Parameters</span>
+</span><span id="TypeParser-797"><a href="#TypeParser-797"><span class="linenos">797</span></a><span class="sd">			----------</span>
+</span><span id="TypeParser-798"><a href="#TypeParser-798"><span class="linenos">798</span></a><span class="sd">			`rows`</span>
+</span><span id="TypeParser-799"><a href="#TypeParser-799"><span class="linenos">799</span></a><span class="sd">			: table of strings for which the types should be inferred, in row-major order</span>
+</span><span id="TypeParser-800"><a href="#TypeParser-800"><span class="linenos">800</span></a>
+</span><span id="TypeParser-801"><a href="#TypeParser-801"><span class="linenos">801</span></a><span class="sd">			Returns</span>
+</span><span id="TypeParser-802"><a href="#TypeParser-802"><span class="linenos">802</span></a><span class="sd">			-------</span>
+</span><span id="TypeParser-803"><a href="#TypeParser-803"><span class="linenos">803</span></a><span class="sd">			inferred types</span>
+</span><span id="TypeParser-804"><a href="#TypeParser-804"><span class="linenos">804</span></a>
+</span><span id="TypeParser-805"><a href="#TypeParser-805"><span class="linenos">805</span></a><span class="sd">			Examples</span>
+</span><span id="TypeParser-806"><a href="#TypeParser-806"><span class="linenos">806</span></a><span class="sd">			--------</span>
+</span><span id="TypeParser-807"><a href="#TypeParser-807"><span class="linenos">807</span></a><span class="sd">			```python</span>
+</span><span id="TypeParser-808"><a href="#TypeParser-808"><span class="linenos">808</span></a><span class="sd">			parser = TypeParser()</span>
+</span><span id="TypeParser-809"><a href="#TypeParser-809"><span class="linenos">809</span></a><span class="sd">			parser.infer_table([</span>
+</span><span id="TypeParser-810"><a href="#TypeParser-810"><span class="linenos">810</span></a><span class="sd">				[&quot;1&quot;,   &quot;true&quot;,  &quot;1&quot;],</span>
+</span><span id="TypeParser-811"><a href="#TypeParser-811"><span class="linenos">811</span></a><span class="sd">				[&quot;2&quot;,   &quot;false&quot;, &quot;2.3&quot;],</span>
+</span><span id="TypeParser-812"><a href="#TypeParser-812"><span class="linenos">812</span></a><span class="sd">				[&quot;3.4&quot;, &quot;2&quot;,     &quot;abc&quot;],</span>
+</span><span id="TypeParser-813"><a href="#TypeParser-813"><span class="linenos">813</span></a><span class="sd">			])</span>
+</span><span id="TypeParser-814"><a href="#TypeParser-814"><span class="linenos">814</span></a><span class="sd">			# [float, int, str]</span>
+</span><span id="TypeParser-815"><a href="#TypeParser-815"><span class="linenos">815</span></a><span class="sd">			```</span>
+</span><span id="TypeParser-816"><a href="#TypeParser-816"><span class="linenos">816</span></a><span class="sd">		&quot;&quot;&quot;</span>
+</span><span id="TypeParser-817"><a href="#TypeParser-817"><span class="linenos">817</span></a>		<span class="n">rows_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>
+</span><span id="TypeParser-818"><a href="#TypeParser-818"><span class="linenos">818</span></a>		<span class="n">first_row</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">rows_iter</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
+</span><span id="TypeParser-819"><a href="#TypeParser-819"><span class="linenos">819</span></a>		<span class="k">if</span> <span class="n">first_row</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
+</span><span id="TypeParser-820"><a href="#TypeParser-820"><span class="linenos">820</span></a>			<span class="k">return</span> <span class="p">[]</span>
+</span><span id="TypeParser-821"><a href="#TypeParser-821"><span class="linenos">821</span></a>
+</span><span id="TypeParser-822"><a href="#TypeParser-822"><span class="linenos">822</span></a>		<span class="n">num_cols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">first_row</span><span class="p">)</span>
+</span><span id="TypeParser-823"><a href="#TypeParser-823"><span class="linenos">823</span></a>		<span class="k">if</span> <span class="n">num_cols</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
+</span><span id="TypeParser-824"><a href="#TypeParser-824"><span class="linenos">824</span></a>			<span class="k">return</span> <span class="p">[]</span>
+</span><span id="TypeParser-825"><a href="#TypeParser-825"><span class="linenos">825</span></a>
+</span><span id="TypeParser-826"><a href="#TypeParser-826"><span class="linenos">826</span></a>		<span class="n">table</span> <span class="o">=</span> <span class="n">_TypeTable</span><span class="p">([[</span><span class="bp">self</span><span class="o">.</span><span class="n">infer</span><span class="p">(</span><span class="n">value</span><span class="p">)]</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">first_row</span><span class="p">])</span>
+</span><span id="TypeParser-827"><a href="#TypeParser-827"><span class="linenos">827</span></a>		<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">rows_iter</span><span class="p">:</span>
+</span><span id="TypeParser-828"><a href="#TypeParser-828"><span class="linenos">828</span></a>			<span class="n">table</span><span class="o">.</span><span class="n">add_row</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">infer</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">row</span><span class="p">])</span>
+</span><span id="TypeParser-829"><a href="#TypeParser-829"><span class="linenos">829</span></a>
+</span><span id="TypeParser-830"><a href="#TypeParser-830"><span class="linenos">830</span></a>		<span class="k">return</span> <span class="p">[</span><span class="n">reduce_types</span><span class="p">(</span><span class="n">col</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">table</span><span class="o">.</span><span class="n">cols</span><span class="p">]</span>
+</span><span id="TypeParser-831"><a href="#TypeParser-831"><span class="linenos">831</span></a>
 </span><span id="TypeParser-832"><a href="#TypeParser-832"><span class="linenos">832</span></a>
-</span><span id="TypeParser-833"><a href="#TypeParser-833"><span class="linenos">833</span></a>
-</span><span id="TypeParser-834"><a href="#TypeParser-834"><span class="linenos">834</span></a>	<span class="k">def</span> <span class="nf">_convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">AnyValueType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AnyValue</span><span class="p">:</span>
-</span><span id="TypeParser-835"><a href="#TypeParser-835"><span class="linenos">835</span></a>		<span class="n">base</span><span class="p">,</span> <span class="n">type_args</span> <span class="o">=</span> <span class="n">_decompose_type</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
-</span><span id="TypeParser-836"><a href="#TypeParser-836"><span class="linenos">836</span></a>		<span class="k">if</span> <span class="n">base</span> <span class="o">==</span> <span class="n">NoneType</span><span class="p">:</span>
-</span><span id="TypeParser-837"><a href="#TypeParser-837"><span class="linenos">837</span></a>			<span class="k">return</span> <span class="kc">None</span>
-</span><span id="TypeParser-838"><a href="#TypeParser-838"><span class="linenos">838</span></a>		<span class="k">elif</span> <span class="n">base</span> <span class="o">==</span> <span class="nb">bool</span><span class="p">:</span>
-</span><span id="TypeParser-839"><a href="#TypeParser-839"><span class="linenos">839</span></a>			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_bool</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
-</span><span id="TypeParser-840"><a href="#TypeParser-840"><span class="linenos">840</span></a>		<span class="k">elif</span> <span class="n">base</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
-</span><span id="TypeParser-841"><a href="#TypeParser-841"><span class="linenos">841</span></a>			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
-</span><span id="TypeParser-842"><a href="#TypeParser-842"><span class="linenos">842</span></a>		<span class="k">elif</span> <span class="n">base</span> <span class="o">==</span> <span class="n">Decimal</span><span class="p">:</span>
-</span><span id="TypeParser-843"><a href="#TypeParser-843"><span class="linenos">843</span></a>			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_decimal</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
-</span><span id="TypeParser-844"><a href="#TypeParser-844"><span class="linenos">844</span></a>		<span class="k">elif</span> <span class="n">base</span> <span class="o">==</span> <span class="nb">float</span><span class="p">:</span>
-</span><span id="TypeParser-845"><a href="#TypeParser-845"><span class="linenos">845</span></a>			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
-</span><span id="TypeParser-846"><a href="#TypeParser-846"><span class="linenos">846</span></a>		<span class="k">elif</span> <span class="n">base</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
-</span><span id="TypeParser-847"><a href="#TypeParser-847"><span class="linenos">847</span></a>			<span class="k">return</span> <span class="n">value</span>
-</span><span id="TypeParser-848"><a href="#TypeParser-848"><span class="linenos">848</span></a>		<span class="k">elif</span> <span class="n">base</span> <span class="o">==</span> <span class="n">Nullable</span><span class="p">:</span>
-</span><span id="TypeParser-849"><a href="#TypeParser-849"><span class="linenos">849</span></a>			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_none</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
-</span><span id="TypeParser-850"><a href="#TypeParser-850"><span class="linenos">850</span></a>				<span class="k">return</span> <span class="kc">None</span>
-</span><span id="TypeParser-851"><a href="#TypeParser-851"><span class="linenos">851</span></a>			<span class="k">else</span><span class="p">:</span>
-</span><span id="TypeParser-852"><a href="#TypeParser-852"><span class="linenos">852</span></a>				<span class="k">if</span> <span class="n">type_args</span> <span class="ow">is</span> <span class="ow">not</span>  <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">type_args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">type_args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">str</span><span class="p">:</span>
-</span><span id="TypeParser-853"><a href="#TypeParser-853"><span class="linenos">853</span></a>					<span class="n">inner_type</span> <span class="o">=</span> <span class="n">type_args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
-</span><span id="TypeParser-854"><a href="#TypeParser-854"><span class="linenos">854</span></a>					<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">inner_type</span><span class="p">)</span>
-</span><span id="TypeParser-855"><a href="#TypeParser-855"><span class="linenos">855</span></a>				<span class="k">else</span><span class="p">:</span>
-</span><span id="TypeParser-856"><a href="#TypeParser-856"><span class="linenos">856</span></a>					<span class="k">return</span> <span class="n">value</span>
-</span><span id="TypeParser-857"><a href="#TypeParser-857"><span class="linenos">857</span></a>		<span class="k">elif</span> <span class="n">base</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
-</span><span id="TypeParser-858"><a href="#TypeParser-858"><span class="linenos">858</span></a>			<span class="n">subvalues</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">list_delimiter</span><span class="p">)</span>
-</span><span id="TypeParser-859"><a href="#TypeParser-859"><span class="linenos">859</span></a>			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trim</span><span class="p">:</span>
-</span><span id="TypeParser-860"><a href="#TypeParser-860"><span class="linenos">860</span></a>				<span class="n">subvalues</span> <span class="o">=</span> <span class="p">[</span><span class="n">subvalue</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">subvalue</span> <span class="ow">in</span> <span class="n">subvalues</span><span class="p">]</span>
-</span><span id="TypeParser-861"><a href="#TypeParser-861"><span class="linenos">861</span></a>			<span class="k">if</span> <span class="n">type_args</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">type_args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">type_args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">str</span><span class="p">:</span>
-</span><span id="TypeParser-862"><a href="#TypeParser-862"><span class="linenos">862</span></a>				<span class="n">subtype</span> <span class="o">=</span> <span class="n">type_args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
-</span><span id="TypeParser-863"><a href="#TypeParser-863"><span class="linenos">863</span></a>				<span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="n">AnyContained</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_convert</span><span class="p">(</span><span class="n">subvalue</span><span class="p">,</span> <span class="n">subtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">subvalue</span> <span class="ow">in</span> <span class="n">subvalues</span><span class="p">])</span>
-</span><span id="TypeParser-864"><a href="#TypeParser-864"><span class="linenos">864</span></a>			<span class="k">else</span><span class="p">:</span>
-</span><span id="TypeParser-865"><a href="#TypeParser-865"><span class="linenos">865</span></a>				<span class="k">return</span> <span class="n">subvalues</span>
-</span><span id="TypeParser-866"><a href="#TypeParser-866"><span class="linenos">866</span></a>		<span class="k">else</span><span class="p">:</span>
-</span><span id="TypeParser-867"><a href="#TypeParser-867"><span class="linenos">867</span></a>			<span class="k">return</span> <span class="n">value</span>
+</span><span id="TypeParser-833"><a href="#TypeParser-833"><span class="linenos">833</span></a>	<span class="k">def</span> <span class="nf">_convert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="n">AnyValueType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AnyValue</span><span class="p">:</span>
+</span><span id="TypeParser-834"><a href="#TypeParser-834"><span class="linenos">834</span></a>		<span class="n">base</span><span class="p">,</span> <span class="n">type_args</span> <span class="o">=</span> <span class="n">_decompose_type</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>
+</span><span id="TypeParser-835"><a href="#TypeParser-835"><span class="linenos">835</span></a>		<span class="k">if</span> <span class="n">base</span> <span class="o">==</span> <span class="n">NoneType</span><span class="p">:</span>
+</span><span id="TypeParser-836"><a href="#TypeParser-836"><span class="linenos">836</span></a>			<span class="k">return</span> <span class="kc">None</span>
+</span><span id="TypeParser-837"><a href="#TypeParser-837"><span class="linenos">837</span></a>		<span class="k">elif</span> <span class="n">base</span> <span class="o">==</span> <span class="nb">bool</span><span class="p">:</span>
+</span><span id="TypeParser-838"><a href="#TypeParser-838"><span class="linenos">838</span></a>			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_bool</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
+</span><span id="TypeParser-839"><a href="#TypeParser-839"><span class="linenos">839</span></a>		<span class="k">elif</span> <span class="n">base</span> <span class="o">==</span> <span class="nb">int</span><span class="p">:</span>
+</span><span id="TypeParser-840"><a href="#TypeParser-840"><span class="linenos">840</span></a>			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
+</span><span id="TypeParser-841"><a href="#TypeParser-841"><span class="linenos">841</span></a>		<span class="k">elif</span> <span class="n">base</span> <span class="o">==</span> <span class="n">Decimal</span><span class="p">:</span>
+</span><span id="TypeParser-842"><a href="#TypeParser-842"><span class="linenos">842</span></a>			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_decimal</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
+</span><span id="TypeParser-843"><a href="#TypeParser-843"><span class="linenos">843</span></a>		<span class="k">elif</span> <span class="n">base</span> <span class="o">==</span> <span class="nb">float</span><span class="p">:</span>
+</span><span id="TypeParser-844"><a href="#TypeParser-844"><span class="linenos">844</span></a>			<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_float</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
+</span><span id="TypeParser-845"><a href="#TypeParser-845"><span class="linenos">845</span></a>		<span class="k">elif</span> <span class="n">base</span> <span class="o">==</span> <span class="nb">str</span><span class="p">:</span>
+</span><span id="TypeParser-846"><a href="#TypeParser-846"><span class="linenos">846</span></a>			<span class="k">return</span> <span class="n">value</span>
+</span><span id="TypeParser-847"><a href="#TypeParser-847"><span class="linenos">847</span></a>		<span class="k">elif</span> <span class="n">base</span> <span class="o">==</span> <span class="n">Nullable</span><span class="p">:</span>
+</span><span id="TypeParser-848"><a href="#TypeParser-848"><span class="linenos">848</span></a>			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_none</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
+</span><span id="TypeParser-849"><a href="#TypeParser-849"><span class="linenos">849</span></a>				<span class="k">return</span> <span class="kc">None</span>
+</span><span id="TypeParser-850"><a href="#TypeParser-850"><span class="linenos">850</span></a>			<span class="k">else</span><span class="p">:</span>
+</span><span id="TypeParser-851"><a href="#TypeParser-851"><span class="linenos">851</span></a>				<span class="k">if</span> <span class="n">type_args</span> <span class="ow">is</span> <span class="ow">not</span>  <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">type_args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">type_args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">str</span><span class="p">:</span>
+</span><span id="TypeParser-852"><a href="#TypeParser-852"><span class="linenos">852</span></a>					<span class="n">inner_type</span> <span class="o">=</span> <span class="n">type_args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
+</span><span id="TypeParser-853"><a href="#TypeParser-853"><span class="linenos">853</span></a>					<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">inner_type</span><span class="p">)</span>
+</span><span id="TypeParser-854"><a href="#TypeParser-854"><span class="linenos">854</span></a>				<span class="k">else</span><span class="p">:</span>
+</span><span id="TypeParser-855"><a href="#TypeParser-855"><span class="linenos">855</span></a>					<span class="k">return</span> <span class="n">value</span>
+</span><span id="TypeParser-856"><a href="#TypeParser-856"><span class="linenos">856</span></a>		<span class="k">elif</span> <span class="n">base</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
+</span><span id="TypeParser-857"><a href="#TypeParser-857"><span class="linenos">857</span></a>			<span class="n">subvalues</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">list_delimiter</span><span class="p">)</span>
+</span><span id="TypeParser-858"><a href="#TypeParser-858"><span class="linenos">858</span></a>			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trim</span><span class="p">:</span>
+</span><span id="TypeParser-859"><a href="#TypeParser-859"><span class="linenos">859</span></a>				<span class="n">subvalues</span> <span class="o">=</span> <span class="p">[</span><span class="n">subvalue</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">subvalue</span> <span class="ow">in</span> <span class="n">subvalues</span><span class="p">]</span>
+</span><span id="TypeParser-860"><a href="#TypeParser-860"><span class="linenos">860</span></a>			<span class="k">if</span> <span class="n">type_args</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">type_args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">type_args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">str</span><span class="p">:</span>
+</span><span id="TypeParser-861"><a href="#TypeParser-861"><span class="linenos">861</span></a>				<span class="n">subtype</span> <span class="o">=</span> <span class="n">type_args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
+</span><span id="TypeParser-862"><a href="#TypeParser-862"><span class="linenos">862</span></a>				<span class="k">return</span> <span class="n">cast</span><span class="p">(</span><span class="n">AnyContained</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_convert</span><span class="p">(</span><span class="n">subvalue</span><span class="p">,</span> <span class="n">subtype</span><span class="p">)</span> <span class="k">for</span> <span class="n">subvalue</span> <span class="ow">in</span> <span class="n">subvalues</span><span class="p">])</span>
+</span><span id="TypeParser-863"><a href="#TypeParser-863"><span class="linenos">863</span></a>			<span class="k">else</span><span class="p">:</span>
+</span><span id="TypeParser-864"><a href="#TypeParser-864"><span class="linenos">864</span></a>				<span class="k">return</span> <span class="n">subvalues</span>
+</span><span id="TypeParser-865"><a href="#TypeParser-865"><span class="linenos">865</span></a>		<span class="k">else</span><span class="p">:</span>
+</span><span id="TypeParser-866"><a href="#TypeParser-866"><span class="linenos">866</span></a>			<span class="k">return</span> <span class="n">value</span>
+</span><span id="TypeParser-867"><a href="#TypeParser-867"><span class="linenos">867</span></a>
 </span><span id="TypeParser-868"><a href="#TypeParser-868"><span class="linenos">868</span></a>
-</span><span id="TypeParser-869"><a href="#TypeParser-869"><span class="linenos">869</span></a>
-</span><span id="TypeParser-870"><a href="#TypeParser-870"><span class="linenos">870</span></a>	<span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AnyValue</span><span class="p">:</span>
-</span><span id="TypeParser-871"><a href="#TypeParser-871"><span class="linenos">871</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
-</span><span id="TypeParser-872"><a href="#TypeParser-872"><span class="linenos">872</span></a><span class="sd">			Parse a string and convert it to its underlying type</span>
-</span><span id="TypeParser-873"><a href="#TypeParser-873"><span class="linenos">873</span></a>
-</span><span id="TypeParser-874"><a href="#TypeParser-874"><span class="linenos">874</span></a><span class="sd">			Parameters</span>
-</span><span id="TypeParser-875"><a href="#TypeParser-875"><span class="linenos">875</span></a><span class="sd">			----------</span>
-</span><span id="TypeParser-876"><a href="#TypeParser-876"><span class="linenos">876</span></a><span class="sd">			`value`</span>
-</span><span id="TypeParser-877"><a href="#TypeParser-877"><span class="linenos">877</span></a><span class="sd">			: the string to be parsed</span>
-</span><span id="TypeParser-878"><a href="#TypeParser-878"><span class="linenos">878</span></a>
-</span><span id="TypeParser-879"><a href="#TypeParser-879"><span class="linenos">879</span></a><span class="sd">			Returns</span>
-</span><span id="TypeParser-880"><a href="#TypeParser-880"><span class="linenos">880</span></a><span class="sd">			-------</span>
-</span><span id="TypeParser-881"><a href="#TypeParser-881"><span class="linenos">881</span></a><span class="sd">			converted value</span>
-</span><span id="TypeParser-882"><a href="#TypeParser-882"><span class="linenos">882</span></a>
-</span><span id="TypeParser-883"><a href="#TypeParser-883"><span class="linenos">883</span></a><span class="sd">			Examples</span>
-</span><span id="TypeParser-884"><a href="#TypeParser-884"><span class="linenos">884</span></a><span class="sd">			--------</span>
-</span><span id="TypeParser-885"><a href="#TypeParser-885"><span class="linenos">885</span></a><span class="sd">			```python</span>
-</span><span id="TypeParser-886"><a href="#TypeParser-886"><span class="linenos">886</span></a><span class="sd">			parser = TypeParser()</span>
-</span><span id="TypeParser-887"><a href="#TypeParser-887"><span class="linenos">887</span></a><span class="sd">			parser.parse(&quot;true&quot;)  # True</span>
-</span><span id="TypeParser-888"><a href="#TypeParser-888"><span class="linenos">888</span></a><span class="sd">			parser.parse(&quot;2.0&quot;)   # 2.</span>
-</span><span id="TypeParser-889"><a href="#TypeParser-889"><span class="linenos">889</span></a><span class="sd">			parser.parse(&quot;abc&quot;)   # &quot;abc&quot;</span>
-</span><span id="TypeParser-890"><a href="#TypeParser-890"><span class="linenos">890</span></a><span class="sd">			```</span>
-</span><span id="TypeParser-891"><a href="#TypeParser-891"><span class="linenos">891</span></a><span class="sd">		&quot;&quot;&quot;</span>
-</span><span id="TypeParser-892"><a href="#TypeParser-892"><span class="linenos">892</span></a>		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">infer</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
+</span><span id="TypeParser-869"><a href="#TypeParser-869"><span class="linenos">869</span></a>	<span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AnyValue</span><span class="p">:</span>
+</span><span id="TypeParser-870"><a href="#TypeParser-870"><span class="linenos">870</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
+</span><span id="TypeParser-871"><a href="#TypeParser-871"><span class="linenos">871</span></a><span class="sd">			Parse a string and convert it to its underlying type</span>
+</span><span id="TypeParser-872"><a href="#TypeParser-872"><span class="linenos">872</span></a>
+</span><span id="TypeParser-873"><a href="#TypeParser-873"><span class="linenos">873</span></a><span class="sd">			Parameters</span>
+</span><span id="TypeParser-874"><a href="#TypeParser-874"><span class="linenos">874</span></a><span class="sd">			----------</span>
+</span><span id="TypeParser-875"><a href="#TypeParser-875"><span class="linenos">875</span></a><span class="sd">			`value`</span>
+</span><span id="TypeParser-876"><a href="#TypeParser-876"><span class="linenos">876</span></a><span class="sd">			: the string to be parsed</span>
+</span><span id="TypeParser-877"><a href="#TypeParser-877"><span class="linenos">877</span></a>
+</span><span id="TypeParser-878"><a href="#TypeParser-878"><span class="linenos">878</span></a><span class="sd">			Returns</span>
+</span><span id="TypeParser-879"><a href="#TypeParser-879"><span class="linenos">879</span></a><span class="sd">			-------</span>
+</span><span id="TypeParser-880"><a href="#TypeParser-880"><span class="linenos">880</span></a><span class="sd">			converted value</span>
+</span><span id="TypeParser-881"><a href="#TypeParser-881"><span class="linenos">881</span></a>
+</span><span id="TypeParser-882"><a href="#TypeParser-882"><span class="linenos">882</span></a><span class="sd">			Examples</span>
+</span><span id="TypeParser-883"><a href="#TypeParser-883"><span class="linenos">883</span></a><span class="sd">			--------</span>
+</span><span id="TypeParser-884"><a href="#TypeParser-884"><span class="linenos">884</span></a><span class="sd">			```python</span>
+</span><span id="TypeParser-885"><a href="#TypeParser-885"><span class="linenos">885</span></a><span class="sd">			parser = TypeParser()</span>
+</span><span id="TypeParser-886"><a href="#TypeParser-886"><span class="linenos">886</span></a><span class="sd">			parser.parse(&quot;true&quot;)  # True</span>
+</span><span id="TypeParser-887"><a href="#TypeParser-887"><span class="linenos">887</span></a><span class="sd">			parser.parse(&quot;2.0&quot;)   # 2.</span>
+</span><span id="TypeParser-888"><a href="#TypeParser-888"><span class="linenos">888</span></a><span class="sd">			parser.parse(&quot;abc&quot;)   # &quot;abc&quot;</span>
+</span><span id="TypeParser-889"><a href="#TypeParser-889"><span class="linenos">889</span></a><span class="sd">			```</span>
+</span><span id="TypeParser-890"><a href="#TypeParser-890"><span class="linenos">890</span></a><span class="sd">		&quot;&quot;&quot;</span>
+</span><span id="TypeParser-891"><a href="#TypeParser-891"><span class="linenos">891</span></a>		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">infer</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
+</span><span id="TypeParser-892"><a href="#TypeParser-892"><span class="linenos">892</span></a>
 </span><span id="TypeParser-893"><a href="#TypeParser-893"><span class="linenos">893</span></a>
-</span><span id="TypeParser-894"><a href="#TypeParser-894"><span class="linenos">894</span></a>
-</span><span id="TypeParser-895"><a href="#TypeParser-895"><span class="linenos">895</span></a>	<span class="k">def</span> <span class="nf">parse_series</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">AnyValue</span><span class="p">]:</span>
-</span><span id="TypeParser-896"><a href="#TypeParser-896"><span class="linenos">896</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
-</span><span id="TypeParser-897"><a href="#TypeParser-897"><span class="linenos">897</span></a><span class="sd">			Parse a series of strings and convert them to their underlying common type</span>
-</span><span id="TypeParser-898"><a href="#TypeParser-898"><span class="linenos">898</span></a>
-</span><span id="TypeParser-899"><a href="#TypeParser-899"><span class="linenos">899</span></a><span class="sd">			If the values in the series do not have the same apparent type, the common type is taken as the narrowest possible type that will encompass all values in the series. See `parsetypes.reduce_types()` for more information.</span>
-</span><span id="TypeParser-900"><a href="#TypeParser-900"><span class="linenos">900</span></a>
-</span><span id="TypeParser-901"><a href="#TypeParser-901"><span class="linenos">901</span></a><span class="sd">			Parameters</span>
-</span><span id="TypeParser-902"><a href="#TypeParser-902"><span class="linenos">902</span></a><span class="sd">			----------</span>
-</span><span id="TypeParser-903"><a href="#TypeParser-903"><span class="linenos">903</span></a><span class="sd">			`values`</span>
-</span><span id="TypeParser-904"><a href="#TypeParser-904"><span class="linenos">904</span></a><span class="sd">			: series of strings to be parsed</span>
-</span><span id="TypeParser-905"><a href="#TypeParser-905"><span class="linenos">905</span></a>
-</span><span id="TypeParser-906"><a href="#TypeParser-906"><span class="linenos">906</span></a><span class="sd">			Returns</span>
-</span><span id="TypeParser-907"><a href="#TypeParser-907"><span class="linenos">907</span></a><span class="sd">			-------</span>
-</span><span id="TypeParser-908"><a href="#TypeParser-908"><span class="linenos">908</span></a><span class="sd">			converted values</span>
-</span><span id="TypeParser-909"><a href="#TypeParser-909"><span class="linenos">909</span></a>
-</span><span id="TypeParser-910"><a href="#TypeParser-910"><span class="linenos">910</span></a><span class="sd">			Examples</span>
-</span><span id="TypeParser-911"><a href="#TypeParser-911"><span class="linenos">911</span></a><span class="sd">			--------</span>
-</span><span id="TypeParser-912"><a href="#TypeParser-912"><span class="linenos">912</span></a><span class="sd">			```python</span>
-</span><span id="TypeParser-913"><a href="#TypeParser-913"><span class="linenos">913</span></a><span class="sd">			parser = TypeParser()</span>
-</span><span id="TypeParser-914"><a href="#TypeParser-914"><span class="linenos">914</span></a><span class="sd">			parser.parse_series([&quot;1&quot;, &quot;2&quot;, &quot;3&quot;])        # [1, 2, 3]</span>
-</span><span id="TypeParser-915"><a href="#TypeParser-915"><span class="linenos">915</span></a><span class="sd">			parser.parse_series([&quot;5&quot;, &quot;6.7&quot;, &quot;8.&quot;])     # [5., 6.7, 8.]</span>
-</span><span id="TypeParser-916"><a href="#TypeParser-916"><span class="linenos">916</span></a><span class="sd">			parser.parse_series([&quot;true&quot;, &quot;false&quot;, &quot;&quot;])  # [True, False, None]</span>
-</span><span id="TypeParser-917"><a href="#TypeParser-917"><span class="linenos">917</span></a><span class="sd">			parser.parse_series([&quot;1&quot;, &quot;2.3&quot;, &quot;abc&quot;])    # [&quot;1&quot;, &quot;2.3&quot;, &quot;abc&quot;]</span>
-</span><span id="TypeParser-918"><a href="#TypeParser-918"><span class="linenos">918</span></a><span class="sd">			```</span>
-</span><span id="TypeParser-919"><a href="#TypeParser-919"><span class="linenos">919</span></a><span class="sd">		&quot;&quot;&quot;</span>
-</span><span id="TypeParser-920"><a href="#TypeParser-920"><span class="linenos">920</span></a>		<span class="n">inferred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">infer_series</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
-</span><span id="TypeParser-921"><a href="#TypeParser-921"><span class="linenos">921</span></a>		<span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_convert</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">inferred</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span>
+</span><span id="TypeParser-894"><a href="#TypeParser-894"><span class="linenos">894</span></a>	<span class="k">def</span> <span class="nf">parse_series</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">AnyValue</span><span class="p">]:</span>
+</span><span id="TypeParser-895"><a href="#TypeParser-895"><span class="linenos">895</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
+</span><span id="TypeParser-896"><a href="#TypeParser-896"><span class="linenos">896</span></a><span class="sd">			Parse a series of strings and convert them to their underlying common type</span>
+</span><span id="TypeParser-897"><a href="#TypeParser-897"><span class="linenos">897</span></a>
+</span><span id="TypeParser-898"><a href="#TypeParser-898"><span class="linenos">898</span></a><span class="sd">			If the values in the series do not have the same apparent type, the common type is taken as the narrowest possible type that will encompass all values in the series. See `parsetypes.reduce_types()` for more information.</span>
+</span><span id="TypeParser-899"><a href="#TypeParser-899"><span class="linenos">899</span></a>
+</span><span id="TypeParser-900"><a href="#TypeParser-900"><span class="linenos">900</span></a><span class="sd">			Parameters</span>
+</span><span id="TypeParser-901"><a href="#TypeParser-901"><span class="linenos">901</span></a><span class="sd">			----------</span>
+</span><span id="TypeParser-902"><a href="#TypeParser-902"><span class="linenos">902</span></a><span class="sd">			`values`</span>
+</span><span id="TypeParser-903"><a href="#TypeParser-903"><span class="linenos">903</span></a><span class="sd">			: series of strings to be parsed</span>
+</span><span id="TypeParser-904"><a href="#TypeParser-904"><span class="linenos">904</span></a>
+</span><span id="TypeParser-905"><a href="#TypeParser-905"><span class="linenos">905</span></a><span class="sd">			Returns</span>
+</span><span id="TypeParser-906"><a href="#TypeParser-906"><span class="linenos">906</span></a><span class="sd">			-------</span>
+</span><span id="TypeParser-907"><a href="#TypeParser-907"><span class="linenos">907</span></a><span class="sd">			converted values</span>
+</span><span id="TypeParser-908"><a href="#TypeParser-908"><span class="linenos">908</span></a>
+</span><span id="TypeParser-909"><a href="#TypeParser-909"><span class="linenos">909</span></a><span class="sd">			Examples</span>
+</span><span id="TypeParser-910"><a href="#TypeParser-910"><span class="linenos">910</span></a><span class="sd">			--------</span>
+</span><span id="TypeParser-911"><a href="#TypeParser-911"><span class="linenos">911</span></a><span class="sd">			```python</span>
+</span><span id="TypeParser-912"><a href="#TypeParser-912"><span class="linenos">912</span></a><span class="sd">			parser = TypeParser()</span>
+</span><span id="TypeParser-913"><a href="#TypeParser-913"><span class="linenos">913</span></a><span class="sd">			parser.parse_series([&quot;1&quot;, &quot;2&quot;, &quot;3&quot;])        # [1, 2, 3]</span>
+</span><span id="TypeParser-914"><a href="#TypeParser-914"><span class="linenos">914</span></a><span class="sd">			parser.parse_series([&quot;5&quot;, &quot;6.7&quot;, &quot;8.&quot;])     # [5., 6.7, 8.]</span>
+</span><span id="TypeParser-915"><a href="#TypeParser-915"><span class="linenos">915</span></a><span class="sd">			parser.parse_series([&quot;true&quot;, &quot;false&quot;, &quot;&quot;])  # [True, False, None]</span>
+</span><span id="TypeParser-916"><a href="#TypeParser-916"><span class="linenos">916</span></a><span class="sd">			parser.parse_series([&quot;1&quot;, &quot;2.3&quot;, &quot;abc&quot;])    # [&quot;1&quot;, &quot;2.3&quot;, &quot;abc&quot;]</span>
+</span><span id="TypeParser-917"><a href="#TypeParser-917"><span class="linenos">917</span></a><span class="sd">			```</span>
+</span><span id="TypeParser-918"><a href="#TypeParser-918"><span class="linenos">918</span></a><span class="sd">		&quot;&quot;&quot;</span>
+</span><span id="TypeParser-919"><a href="#TypeParser-919"><span class="linenos">919</span></a>		<span class="n">inferred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">infer_series</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
+</span><span id="TypeParser-920"><a href="#TypeParser-920"><span class="linenos">920</span></a>		<span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_convert</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">inferred</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span>
+</span><span id="TypeParser-921"><a href="#TypeParser-921"><span class="linenos">921</span></a>
 </span><span id="TypeParser-922"><a href="#TypeParser-922"><span class="linenos">922</span></a>
-</span><span id="TypeParser-923"><a href="#TypeParser-923"><span class="linenos">923</span></a>
-</span><span id="TypeParser-924"><a href="#TypeParser-924"><span class="linenos">924</span></a>	<span class="k">def</span> <span class="nf">parse_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rows</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">AnyValue</span><span class="p">]]:</span>
-</span><span id="TypeParser-925"><a href="#TypeParser-925"><span class="linenos">925</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
-</span><span id="TypeParser-926"><a href="#TypeParser-926"><span class="linenos">926</span></a><span class="sd">			Parse a table of strings and convert them to the underlying common type of each column</span>
-</span><span id="TypeParser-927"><a href="#TypeParser-927"><span class="linenos">927</span></a>
-</span><span id="TypeParser-928"><a href="#TypeParser-928"><span class="linenos">928</span></a><span class="sd">			For each column, if the values do not have the same apparent type, the common type is taken as the narrowest possible type that will encompass all values in the column. See `parsetypes.reduce_types()` for more information.</span>
-</span><span id="TypeParser-929"><a href="#TypeParser-929"><span class="linenos">929</span></a>
-</span><span id="TypeParser-930"><a href="#TypeParser-930"><span class="linenos">930</span></a><span class="sd">			Note that the type inference requires that the inferred types of every individual value must all be able to fit into memory at once.</span>
-</span><span id="TypeParser-931"><a href="#TypeParser-931"><span class="linenos">931</span></a>
-</span><span id="TypeParser-932"><a href="#TypeParser-932"><span class="linenos">932</span></a><span class="sd">			This is a function that computes the entire table and returns it all at once. The generator `iterate_table()` behaves analogously, except that it computes and yields each row one at a time.</span>
-</span><span id="TypeParser-933"><a href="#TypeParser-933"><span class="linenos">933</span></a>
-</span><span id="TypeParser-934"><a href="#TypeParser-934"><span class="linenos">934</span></a><span class="sd">			Parameters</span>
-</span><span id="TypeParser-935"><a href="#TypeParser-935"><span class="linenos">935</span></a><span class="sd">			----------</span>
-</span><span id="TypeParser-936"><a href="#TypeParser-936"><span class="linenos">936</span></a><span class="sd">			`rows`</span>
-</span><span id="TypeParser-937"><a href="#TypeParser-937"><span class="linenos">937</span></a><span class="sd">			: table of strings to be parsed, in row-major order</span>
-</span><span id="TypeParser-938"><a href="#TypeParser-938"><span class="linenos">938</span></a>
-</span><span id="TypeParser-939"><a href="#TypeParser-939"><span class="linenos">939</span></a><span class="sd">			`iterator`</span>
-</span><span id="TypeParser-940"><a href="#TypeParser-940"><span class="linenos">940</span></a><span class="sd">			: whether the parsed values should be yielded as an iterator. If False, which is the default, the entire table is computed and returned as a list of lists. If True, this function behaves as a generator, and the rows of the table are computed and yielded one at a time. However, note that even when set to True, the type inference requires that inferred type of each individual value must all be able to fit into memory at once.</span>
-</span><span id="TypeParser-941"><a href="#TypeParser-941"><span class="linenos">941</span></a>
-</span><span id="TypeParser-942"><a href="#TypeParser-942"><span class="linenos">942</span></a><span class="sd">			Returns</span>
-</span><span id="TypeParser-943"><a href="#TypeParser-943"><span class="linenos">943</span></a><span class="sd">			-------</span>
-</span><span id="TypeParser-944"><a href="#TypeParser-944"><span class="linenos">944</span></a><span class="sd">			converted table of values, in row-major order</span>
-</span><span id="TypeParser-945"><a href="#TypeParser-945"><span class="linenos">945</span></a>
-</span><span id="TypeParser-946"><a href="#TypeParser-946"><span class="linenos">946</span></a><span class="sd">			Examples</span>
-</span><span id="TypeParser-947"><a href="#TypeParser-947"><span class="linenos">947</span></a><span class="sd">			--------</span>
-</span><span id="TypeParser-948"><a href="#TypeParser-948"><span class="linenos">948</span></a><span class="sd">			```python</span>
-</span><span id="TypeParser-949"><a href="#TypeParser-949"><span class="linenos">949</span></a><span class="sd">			parser = TypeParser()</span>
-</span><span id="TypeParser-950"><a href="#TypeParser-950"><span class="linenos">950</span></a><span class="sd">			table = parser.parse_table([</span>
-</span><span id="TypeParser-951"><a href="#TypeParser-951"><span class="linenos">951</span></a><span class="sd">				[&quot;1&quot;, &quot;5&quot;,   &quot;true&quot;,  &quot;1&quot;],</span>
-</span><span id="TypeParser-952"><a href="#TypeParser-952"><span class="linenos">952</span></a><span class="sd">				[&quot;2&quot;, &quot;6.7&quot;, &quot;false&quot;, &quot;2.3&quot;],</span>
-</span><span id="TypeParser-953"><a href="#TypeParser-953"><span class="linenos">953</span></a><span class="sd">				[&quot;3&quot;, &quot;8.0&quot;, &quot;&quot;,     &quot;abc&quot;],</span>
-</span><span id="TypeParser-954"><a href="#TypeParser-954"><span class="linenos">954</span></a><span class="sd">			]):</span>
-</span><span id="TypeParser-955"><a href="#TypeParser-955"><span class="linenos">955</span></a><span class="sd">			assert table == [</span>
-</span><span id="TypeParser-956"><a href="#TypeParser-956"><span class="linenos">956</span></a><span class="sd">				[1, 5.,  True,  &quot;1&quot;],</span>
-</span><span id="TypeParser-957"><a href="#TypeParser-957"><span class="linenos">957</span></a><span class="sd">				[2, 6.7, False, &quot;2.3&quot;],</span>
-</span><span id="TypeParser-958"><a href="#TypeParser-958"><span class="linenos">958</span></a><span class="sd">				[3, 8.,  None,  &quot;abc&quot;],</span>
-</span><span id="TypeParser-959"><a href="#TypeParser-959"><span class="linenos">959</span></a><span class="sd">			]</span>
-</span><span id="TypeParser-960"><a href="#TypeParser-960"><span class="linenos">960</span></a><span class="sd">			```</span>
-</span><span id="TypeParser-961"><a href="#TypeParser-961"><span class="linenos">961</span></a><span class="sd">		&quot;&quot;&quot;</span>
-</span><span id="TypeParser-962"><a href="#TypeParser-962"><span class="linenos">962</span></a>		<span class="k">return</span> <span class="p">[</span><span class="n">converted_row</span> <span class="k">for</span> <span class="n">converted_row</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterate_table</span><span class="p">(</span><span class="n">rows</span><span class="p">)]</span>
+</span><span id="TypeParser-923"><a href="#TypeParser-923"><span class="linenos">923</span></a>	<span class="k">def</span> <span class="nf">parse_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rows</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">AnyValue</span><span class="p">]]:</span>
+</span><span id="TypeParser-924"><a href="#TypeParser-924"><span class="linenos">924</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
+</span><span id="TypeParser-925"><a href="#TypeParser-925"><span class="linenos">925</span></a><span class="sd">			Parse a table of strings and convert them to the underlying common type of each column</span>
+</span><span id="TypeParser-926"><a href="#TypeParser-926"><span class="linenos">926</span></a>
+</span><span id="TypeParser-927"><a href="#TypeParser-927"><span class="linenos">927</span></a><span class="sd">			For each column, if the values do not have the same apparent type, the common type is taken as the narrowest possible type that will encompass all values in the column. See `parsetypes.reduce_types()` for more information.</span>
+</span><span id="TypeParser-928"><a href="#TypeParser-928"><span class="linenos">928</span></a>
+</span><span id="TypeParser-929"><a href="#TypeParser-929"><span class="linenos">929</span></a><span class="sd">			Note that the type inference requires that the inferred types of every individual value must all be able to fit into memory at once.</span>
+</span><span id="TypeParser-930"><a href="#TypeParser-930"><span class="linenos">930</span></a>
+</span><span id="TypeParser-931"><a href="#TypeParser-931"><span class="linenos">931</span></a><span class="sd">			This is a function that computes the entire table and returns it all at once. The generator `iterate_table()` behaves analogously, except that it computes and yields each row one at a time.</span>
+</span><span id="TypeParser-932"><a href="#TypeParser-932"><span class="linenos">932</span></a>
+</span><span id="TypeParser-933"><a href="#TypeParser-933"><span class="linenos">933</span></a><span class="sd">			Parameters</span>
+</span><span id="TypeParser-934"><a href="#TypeParser-934"><span class="linenos">934</span></a><span class="sd">			----------</span>
+</span><span id="TypeParser-935"><a href="#TypeParser-935"><span class="linenos">935</span></a><span class="sd">			`rows`</span>
+</span><span id="TypeParser-936"><a href="#TypeParser-936"><span class="linenos">936</span></a><span class="sd">			: table of strings to be parsed, in row-major order</span>
+</span><span id="TypeParser-937"><a href="#TypeParser-937"><span class="linenos">937</span></a>
+</span><span id="TypeParser-938"><a href="#TypeParser-938"><span class="linenos">938</span></a><span class="sd">			`iterator`</span>
+</span><span id="TypeParser-939"><a href="#TypeParser-939"><span class="linenos">939</span></a><span class="sd">			: whether the parsed values should be yielded as an iterator. If False, which is the default, the entire table is computed and returned as a list of lists. If True, this function behaves as a generator, and the rows of the table are computed and yielded one at a time. However, note that even when set to True, the type inference requires that inferred type of each individual value must all be able to fit into memory at once.</span>
+</span><span id="TypeParser-940"><a href="#TypeParser-940"><span class="linenos">940</span></a>
+</span><span id="TypeParser-941"><a href="#TypeParser-941"><span class="linenos">941</span></a><span class="sd">			Returns</span>
+</span><span id="TypeParser-942"><a href="#TypeParser-942"><span class="linenos">942</span></a><span class="sd">			-------</span>
+</span><span id="TypeParser-943"><a href="#TypeParser-943"><span class="linenos">943</span></a><span class="sd">			converted table of values, in row-major order</span>
+</span><span id="TypeParser-944"><a href="#TypeParser-944"><span class="linenos">944</span></a>
+</span><span id="TypeParser-945"><a href="#TypeParser-945"><span class="linenos">945</span></a><span class="sd">			Examples</span>
+</span><span id="TypeParser-946"><a href="#TypeParser-946"><span class="linenos">946</span></a><span class="sd">			--------</span>
+</span><span id="TypeParser-947"><a href="#TypeParser-947"><span class="linenos">947</span></a><span class="sd">			```python</span>
+</span><span id="TypeParser-948"><a href="#TypeParser-948"><span class="linenos">948</span></a><span class="sd">			parser = TypeParser()</span>
+</span><span id="TypeParser-949"><a href="#TypeParser-949"><span class="linenos">949</span></a><span class="sd">			table = parser.parse_table([</span>
+</span><span id="TypeParser-950"><a href="#TypeParser-950"><span class="linenos">950</span></a><span class="sd">				[&quot;1&quot;, &quot;5&quot;,   &quot;true&quot;,  &quot;1&quot;],</span>
+</span><span id="TypeParser-951"><a href="#TypeParser-951"><span class="linenos">951</span></a><span class="sd">				[&quot;2&quot;, &quot;6.7&quot;, &quot;false&quot;, &quot;2.3&quot;],</span>
+</span><span id="TypeParser-952"><a href="#TypeParser-952"><span class="linenos">952</span></a><span class="sd">				[&quot;3&quot;, &quot;8.0&quot;, &quot;&quot;,     &quot;abc&quot;],</span>
+</span><span id="TypeParser-953"><a href="#TypeParser-953"><span class="linenos">953</span></a><span class="sd">			]):</span>
+</span><span id="TypeParser-954"><a href="#TypeParser-954"><span class="linenos">954</span></a><span class="sd">			assert table == [</span>
+</span><span id="TypeParser-955"><a href="#TypeParser-955"><span class="linenos">955</span></a><span class="sd">				[1, 5.,  True,  &quot;1&quot;],</span>
+</span><span id="TypeParser-956"><a href="#TypeParser-956"><span class="linenos">956</span></a><span class="sd">				[2, 6.7, False, &quot;2.3&quot;],</span>
+</span><span id="TypeParser-957"><a href="#TypeParser-957"><span class="linenos">957</span></a><span class="sd">				[3, 8.,  None,  &quot;abc&quot;],</span>
+</span><span id="TypeParser-958"><a href="#TypeParser-958"><span class="linenos">958</span></a><span class="sd">			]</span>
+</span><span id="TypeParser-959"><a href="#TypeParser-959"><span class="linenos">959</span></a><span class="sd">			```</span>
+</span><span id="TypeParser-960"><a href="#TypeParser-960"><span class="linenos">960</span></a><span class="sd">		&quot;&quot;&quot;</span>
+</span><span id="TypeParser-961"><a href="#TypeParser-961"><span class="linenos">961</span></a>		<span class="k">return</span> <span class="p">[</span><span class="n">converted_row</span> <span class="k">for</span> <span class="n">converted_row</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterate_table</span><span class="p">(</span><span class="n">rows</span><span class="p">)]</span>
+</span><span id="TypeParser-962"><a href="#TypeParser-962"><span class="linenos">962</span></a>
 </span><span id="TypeParser-963"><a href="#TypeParser-963"><span class="linenos">963</span></a>
-</span><span id="TypeParser-964"><a href="#TypeParser-964"><span class="linenos">964</span></a>
-</span><span id="TypeParser-965"><a href="#TypeParser-965"><span class="linenos">965</span></a>	<span class="k">def</span> <span class="nf">iterate_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rows</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">AnyValue</span><span class="p">]]:</span>
-</span><span id="TypeParser-966"><a href="#TypeParser-966"><span class="linenos">966</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
-</span><span id="TypeParser-967"><a href="#TypeParser-967"><span class="linenos">967</span></a><span class="sd">			Parse a table of strings for the underlying common type of each column, then convert and yield each row</span>
-</span><span id="TypeParser-968"><a href="#TypeParser-968"><span class="linenos">968</span></a>
-</span><span id="TypeParser-969"><a href="#TypeParser-969"><span class="linenos">969</span></a><span class="sd">			For each column, if the values do not have the same apparent type, the common type is taken as the narrowest possible type that will encompass all values in the column. See `parsetypes.reduce_types()` for more information.</span>
-</span><span id="TypeParser-970"><a href="#TypeParser-970"><span class="linenos">970</span></a>
-</span><span id="TypeParser-971"><a href="#TypeParser-971"><span class="linenos">971</span></a><span class="sd">			This is a generator that computes and yields each row one at a time. The function `parse_table()` behaves analogously, except that it computes the entire table and returns it as a list of lists. However, note that although this is a generator, the type inference still requires that the inferred types of every individual value must all be able to fit into memory at once.</span>
-</span><span id="TypeParser-972"><a href="#TypeParser-972"><span class="linenos">972</span></a>
-</span><span id="TypeParser-973"><a href="#TypeParser-973"><span class="linenos">973</span></a><span class="sd">			Parameters</span>
-</span><span id="TypeParser-974"><a href="#TypeParser-974"><span class="linenos">974</span></a><span class="sd">			----------</span>
-</span><span id="TypeParser-975"><a href="#TypeParser-975"><span class="linenos">975</span></a><span class="sd">			`rows`</span>
-</span><span id="TypeParser-976"><a href="#TypeParser-976"><span class="linenos">976</span></a><span class="sd">			: table of strings to be parsed, in row-major order</span>
-</span><span id="TypeParser-977"><a href="#TypeParser-977"><span class="linenos">977</span></a>
-</span><span id="TypeParser-978"><a href="#TypeParser-978"><span class="linenos">978</span></a><span class="sd">			Yields</span>
-</span><span id="TypeParser-979"><a href="#TypeParser-979"><span class="linenos">979</span></a><span class="sd">			-------</span>
-</span><span id="TypeParser-980"><a href="#TypeParser-980"><span class="linenos">980</span></a><span class="sd">			each row of converted table values</span>
-</span><span id="TypeParser-981"><a href="#TypeParser-981"><span class="linenos">981</span></a>
-</span><span id="TypeParser-982"><a href="#TypeParser-982"><span class="linenos">982</span></a><span class="sd">			Examples</span>
-</span><span id="TypeParser-983"><a href="#TypeParser-983"><span class="linenos">983</span></a><span class="sd">			--------</span>
-</span><span id="TypeParser-984"><a href="#TypeParser-984"><span class="linenos">984</span></a><span class="sd">			```python</span>
-</span><span id="TypeParser-985"><a href="#TypeParser-985"><span class="linenos">985</span></a><span class="sd">			parser = TypeParser()</span>
-</span><span id="TypeParser-986"><a href="#TypeParser-986"><span class="linenos">986</span></a><span class="sd">			table = parser.iterate_table([</span>
-</span><span id="TypeParser-987"><a href="#TypeParser-987"><span class="linenos">987</span></a><span class="sd">				[&quot;1&quot;,   &quot;true&quot;,  &quot;1&quot;],</span>
-</span><span id="TypeParser-988"><a href="#TypeParser-988"><span class="linenos">988</span></a><span class="sd">				[&quot;2&quot;,   &quot;false&quot;, &quot;2.3&quot;],</span>
-</span><span id="TypeParser-989"><a href="#TypeParser-989"><span class="linenos">989</span></a><span class="sd">				[&quot;3.4&quot;, &quot;2&quot;,     &quot;abc&quot;],</span>
-</span><span id="TypeParser-990"><a href="#TypeParser-990"><span class="linenos">990</span></a><span class="sd">			]):</span>
-</span><span id="TypeParser-991"><a href="#TypeParser-991"><span class="linenos">991</span></a><span class="sd">			assert next(table) == [1.,  1, &quot;1&quot;]</span>
-</span><span id="TypeParser-992"><a href="#TypeParser-992"><span class="linenos">992</span></a><span class="sd">			assert next(table) == [2.,  0, &quot;2.3&quot;]</span>
-</span><span id="TypeParser-993"><a href="#TypeParser-993"><span class="linenos">993</span></a><span class="sd">			assert next(table) == [3.4, 2, &quot;abc&quot;]</span>
-</span><span id="TypeParser-994"><a href="#TypeParser-994"><span class="linenos">994</span></a><span class="sd">			```</span>
-</span><span id="TypeParser-995"><a href="#TypeParser-995"><span class="linenos">995</span></a><span class="sd">		&quot;&quot;&quot;</span>
-</span><span id="TypeParser-996"><a href="#TypeParser-996"><span class="linenos">996</span></a>		<span class="n">inferred_types</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">infer_table</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>
-</span><span id="TypeParser-997"><a href="#TypeParser-997"><span class="linenos">997</span></a>
-</span><span id="TypeParser-998"><a href="#TypeParser-998"><span class="linenos">998</span></a>		<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">rows</span><span class="p">:</span>
-</span><span id="TypeParser-999"><a href="#TypeParser-999"><span class="linenos">999</span></a>			<span class="k">yield</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_convert</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">inferred</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span><span class="p">,</span> <span class="n">inferred</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">inferred_types</span><span class="p">)]</span>
+</span><span id="TypeParser-964"><a href="#TypeParser-964"><span class="linenos">964</span></a>	<span class="k">def</span> <span class="nf">iterate_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rows</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">AnyValue</span><span class="p">]]:</span>
+</span><span id="TypeParser-965"><a href="#TypeParser-965"><span class="linenos">965</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
+</span><span id="TypeParser-966"><a href="#TypeParser-966"><span class="linenos">966</span></a><span class="sd">			Parse a table of strings for the underlying common type of each column, then convert and yield each row</span>
+</span><span id="TypeParser-967"><a href="#TypeParser-967"><span class="linenos">967</span></a>
+</span><span id="TypeParser-968"><a href="#TypeParser-968"><span class="linenos">968</span></a><span class="sd">			For each column, if the values do not have the same apparent type, the common type is taken as the narrowest possible type that will encompass all values in the column. See `parsetypes.reduce_types()` for more information.</span>
+</span><span id="TypeParser-969"><a href="#TypeParser-969"><span class="linenos">969</span></a>
+</span><span id="TypeParser-970"><a href="#TypeParser-970"><span class="linenos">970</span></a><span class="sd">			This is a generator that computes and yields each row one at a time. The function `parse_table()` behaves analogously, except that it computes the entire table and returns it as a list of lists. However, note that although this is a generator, the type inference still requires that the inferred types of every individual value must all be able to fit into memory at once.</span>
+</span><span id="TypeParser-971"><a href="#TypeParser-971"><span class="linenos">971</span></a>
+</span><span id="TypeParser-972"><a href="#TypeParser-972"><span class="linenos">972</span></a><span class="sd">			Parameters</span>
+</span><span id="TypeParser-973"><a href="#TypeParser-973"><span class="linenos">973</span></a><span class="sd">			----------</span>
+</span><span id="TypeParser-974"><a href="#TypeParser-974"><span class="linenos">974</span></a><span class="sd">			`rows`</span>
+</span><span id="TypeParser-975"><a href="#TypeParser-975"><span class="linenos">975</span></a><span class="sd">			: table of strings to be parsed, in row-major order</span>
+</span><span id="TypeParser-976"><a href="#TypeParser-976"><span class="linenos">976</span></a>
+</span><span id="TypeParser-977"><a href="#TypeParser-977"><span class="linenos">977</span></a><span class="sd">			Yields</span>
+</span><span id="TypeParser-978"><a href="#TypeParser-978"><span class="linenos">978</span></a><span class="sd">			-------</span>
+</span><span id="TypeParser-979"><a href="#TypeParser-979"><span class="linenos">979</span></a><span class="sd">			each row of converted table values</span>
+</span><span id="TypeParser-980"><a href="#TypeParser-980"><span class="linenos">980</span></a>
+</span><span id="TypeParser-981"><a href="#TypeParser-981"><span class="linenos">981</span></a><span class="sd">			Examples</span>
+</span><span id="TypeParser-982"><a href="#TypeParser-982"><span class="linenos">982</span></a><span class="sd">			--------</span>
+</span><span id="TypeParser-983"><a href="#TypeParser-983"><span class="linenos">983</span></a><span class="sd">			```python</span>
+</span><span id="TypeParser-984"><a href="#TypeParser-984"><span class="linenos">984</span></a><span class="sd">			parser = TypeParser()</span>
+</span><span id="TypeParser-985"><a href="#TypeParser-985"><span class="linenos">985</span></a><span class="sd">			table = parser.iterate_table([</span>
+</span><span id="TypeParser-986"><a href="#TypeParser-986"><span class="linenos">986</span></a><span class="sd">				[&quot;1&quot;,   &quot;true&quot;,  &quot;1&quot;],</span>
+</span><span id="TypeParser-987"><a href="#TypeParser-987"><span class="linenos">987</span></a><span class="sd">				[&quot;2&quot;,   &quot;false&quot;, &quot;2.3&quot;],</span>
+</span><span id="TypeParser-988"><a href="#TypeParser-988"><span class="linenos">988</span></a><span class="sd">				[&quot;3.4&quot;, &quot;2&quot;,     &quot;abc&quot;],</span>
+</span><span id="TypeParser-989"><a href="#TypeParser-989"><span class="linenos">989</span></a><span class="sd">			]):</span>
+</span><span id="TypeParser-990"><a href="#TypeParser-990"><span class="linenos">990</span></a><span class="sd">			assert next(table) == [1.,  1, &quot;1&quot;]</span>
+</span><span id="TypeParser-991"><a href="#TypeParser-991"><span class="linenos">991</span></a><span class="sd">			assert next(table) == [2.,  0, &quot;2.3&quot;]</span>
+</span><span id="TypeParser-992"><a href="#TypeParser-992"><span class="linenos">992</span></a><span class="sd">			assert next(table) == [3.4, 2, &quot;abc&quot;]</span>
+</span><span id="TypeParser-993"><a href="#TypeParser-993"><span class="linenos">993</span></a><span class="sd">			```</span>
+</span><span id="TypeParser-994"><a href="#TypeParser-994"><span class="linenos">994</span></a><span class="sd">		&quot;&quot;&quot;</span>
+</span><span id="TypeParser-995"><a href="#TypeParser-995"><span class="linenos">995</span></a>		<span class="n">inferred_types</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">infer_table</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>
+</span><span id="TypeParser-996"><a href="#TypeParser-996"><span class="linenos">996</span></a>
+</span><span id="TypeParser-997"><a href="#TypeParser-997"><span class="linenos">997</span></a>		<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">rows</span><span class="p">:</span>
+</span><span id="TypeParser-998"><a href="#TypeParser-998"><span class="linenos">998</span></a>			<span class="k">yield</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_convert</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">inferred</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span><span class="p">,</span> <span class="n">inferred</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">inferred_types</span><span class="p">)]</span>
 </span></pre></div>
 
 
     <div class="docstring">
 <p>A parser that can be used to infer the underlying types of data serialised as strings, and to convert them into their original underlying types.</p>
 
 <p>Instances of this class can be configured with different settings for the parser and inferrer. See the constructor for more details about the available options.</p></div>
 
 
 
                             <div id="TypeParser.__init__" class="classattr">
                                         <input id="TypeParser.__init__-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
 <div class="attr function">
             
-        <span class="name">TypeParser</span><span class="signature pdoc-code multiline">(<span class="param">	<span class="o">*</span>,</span><span class="param">	<span class="n">trim</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>,</span><span class="param">	<span class="n">use_decimal</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>,</span><span class="param">	<span class="n">list_delimiter</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>,</span><span class="param">	<span class="n">none_values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">]</span>,</span><span class="param">	<span class="n">none_case_sensitive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>,</span><span class="param">	<span class="n">true_values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;true&#39;</span><span class="p">]</span>,</span><span class="param">	<span class="n">false_values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;false&#39;</span><span class="p">]</span>,</span><span class="param">	<span class="n">bool_case_sensitive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>,</span><span class="param">	<span class="n">int_case_sensitive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>,</span><span class="param">	<span class="n">inf_values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>,</span><span class="param">	<span class="n">nan_values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>,</span><span class="param">	<span class="n">float_case_sensitive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>,</span><span class="param">	<span class="n">case_sensitive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span></span>)</span>
+        <span class="name">TypeParser</span><span class="signature pdoc-code multiline">(<span class="param">	<span class="o">*</span>,</span><span class="param">	<span class="n">trim</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>,</span><span class="param">	<span class="n">use_decimal</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>,</span><span class="param">	<span class="n">list_delimiter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>,</span><span class="param">	<span class="n">none_values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">]</span>,</span><span class="param">	<span class="n">none_case_sensitive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>,</span><span class="param">	<span class="n">true_values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;true&#39;</span><span class="p">]</span>,</span><span class="param">	<span class="n">false_values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;false&#39;</span><span class="p">]</span>,</span><span class="param">	<span class="n">bool_case_sensitive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>,</span><span class="param">	<span class="n">int_case_sensitive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>,</span><span class="param">	<span class="n">inf_values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>,</span><span class="param">	<span class="n">nan_values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>,</span><span class="param">	<span class="n">float_case_sensitive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>,</span><span class="param">	<span class="n">case_sensitive</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span></span>)</span>
 
 
                 <label class="view-source-button" for="TypeParser.__init__-view-source"><span>View Source</span></label>
 
     </div>
     <a class="headerlink" href="#TypeParser.__init__"></a>
-            <div class="pdoc-code codehilite"><pre><span></span><span id="TypeParser.__init__-68"><a href="#TypeParser.__init__-68"><span class="linenos"> 68</span></a>	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
-</span><span id="TypeParser.__init__-69"><a href="#TypeParser.__init__-69"><span class="linenos"> 69</span></a>	    <span class="o">*</span><span class="p">,</span>
-</span><span id="TypeParser.__init__-70"><a href="#TypeParser.__init__-70"><span class="linenos"> 70</span></a>		<span class="n">trim</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
-</span><span id="TypeParser.__init__-71"><a href="#TypeParser.__init__-71"><span class="linenos"> 71</span></a>		<span class="n">use_decimal</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
-</span><span id="TypeParser.__init__-72"><a href="#TypeParser.__init__-72"><span class="linenos"> 72</span></a>		<span class="n">list_delimiter</span><span class="p">:</span> <span class="nb">str</span> <span class="o">|</span> <span class="kc">None</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
-</span><span id="TypeParser.__init__-73"><a href="#TypeParser.__init__-73"><span class="linenos"> 73</span></a>		<span class="n">none_values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">],</span>
-</span><span id="TypeParser.__init__-74"><a href="#TypeParser.__init__-74"><span class="linenos"> 74</span></a>		<span class="n">none_case_sensitive</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
-</span><span id="TypeParser.__init__-75"><a href="#TypeParser.__init__-75"><span class="linenos"> 75</span></a>		<span class="n">true_values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;true&quot;</span><span class="p">],</span>
-</span><span id="TypeParser.__init__-76"><a href="#TypeParser.__init__-76"><span class="linenos"> 76</span></a>		<span class="n">false_values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;false&quot;</span><span class="p">],</span>
-</span><span id="TypeParser.__init__-77"><a href="#TypeParser.__init__-77"><span class="linenos"> 77</span></a>		<span class="n">bool_case_sensitive</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
-</span><span id="TypeParser.__init__-78"><a href="#TypeParser.__init__-78"><span class="linenos"> 78</span></a>		<span class="n">int_case_sensitive</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
-</span><span id="TypeParser.__init__-79"><a href="#TypeParser.__init__-79"><span class="linenos"> 79</span></a>		<span class="n">inf_values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="p">[],</span>
-</span><span id="TypeParser.__init__-80"><a href="#TypeParser.__init__-80"><span class="linenos"> 80</span></a>		<span class="n">nan_values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="p">[],</span>
-</span><span id="TypeParser.__init__-81"><a href="#TypeParser.__init__-81"><span class="linenos"> 81</span></a>		<span class="n">float_case_sensitive</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
-</span><span id="TypeParser.__init__-82"><a href="#TypeParser.__init__-82"><span class="linenos"> 82</span></a>		<span class="n">case_sensitive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">|</span> <span class="kc">None</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
-</span><span id="TypeParser.__init__-83"><a href="#TypeParser.__init__-83"><span class="linenos"> 83</span></a>	<span class="p">):</span>
-</span><span id="TypeParser.__init__-84"><a href="#TypeParser.__init__-84"><span class="linenos"> 84</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
-</span><span id="TypeParser.__init__-85"><a href="#TypeParser.__init__-85"><span class="linenos"> 85</span></a><span class="sd">			Initialise a new parser</span>
-</span><span id="TypeParser.__init__-86"><a href="#TypeParser.__init__-86"><span class="linenos"> 86</span></a>
-</span><span id="TypeParser.__init__-87"><a href="#TypeParser.__init__-87"><span class="linenos"> 87</span></a><span class="sd">			Parameters</span>
-</span><span id="TypeParser.__init__-88"><a href="#TypeParser.__init__-88"><span class="linenos"> 88</span></a><span class="sd">			----------</span>
-</span><span id="TypeParser.__init__-89"><a href="#TypeParser.__init__-89"><span class="linenos"> 89</span></a><span class="sd">			`trim`</span>
-</span><span id="TypeParser.__init__-90"><a href="#TypeParser.__init__-90"><span class="linenos"> 90</span></a><span class="sd">			: whether leading and trailing whitespace should be stripped from strings</span>
-</span><span id="TypeParser.__init__-91"><a href="#TypeParser.__init__-91"><span class="linenos"> 91</span></a>
-</span><span id="TypeParser.__init__-92"><a href="#TypeParser.__init__-92"><span class="linenos"> 92</span></a><span class="sd">			`use_decimal`</span>
-</span><span id="TypeParser.__init__-93"><a href="#TypeParser.__init__-93"><span class="linenos"> 93</span></a><span class="sd">			: whether non-integer numeric values should be inferred as Decimal (exact values) instead of float (non-exact values). Note that this only applies to methods that attempt to infer type (`infer()` and `infer_*()`), and does not affect methods where the type is explicitly specified (`is_float()`, `is_decimal()`, `parse_float()`, `parse_decimal()`).</span>
-</span><span id="TypeParser.__init__-94"><a href="#TypeParser.__init__-94"><span class="linenos"> 94</span></a>
-</span><span id="TypeParser.__init__-95"><a href="#TypeParser.__init__-95"><span class="linenos"> 95</span></a><span class="sd">			`list_delimiter`</span>
-</span><span id="TypeParser.__init__-96"><a href="#TypeParser.__init__-96"><span class="linenos"> 96</span></a><span class="sd">			: the delimiter used for identifying lists and for separating list items. If set to None, the parser will not attempt to identify lists when inferring types, which usually causes the value to be treated as a str instead.</span>
-</span><span id="TypeParser.__init__-97"><a href="#TypeParser.__init__-97"><span class="linenos"> 97</span></a>
-</span><span id="TypeParser.__init__-98"><a href="#TypeParser.__init__-98"><span class="linenos"> 98</span></a><span class="sd">			`none_values`</span>
-</span><span id="TypeParser.__init__-99"><a href="#TypeParser.__init__-99"><span class="linenos"> 99</span></a><span class="sd">			: list of strings that represent the value None</span>
-</span><span id="TypeParser.__init__-100"><a href="#TypeParser.__init__-100"><span class="linenos">100</span></a>
-</span><span id="TypeParser.__init__-101"><a href="#TypeParser.__init__-101"><span class="linenos">101</span></a><span class="sd">			`none_case_sensitive`</span>
-</span><span id="TypeParser.__init__-102"><a href="#TypeParser.__init__-102"><span class="linenos">102</span></a><span class="sd">			: whether matches against `none_values` should be made in a case-sensitive manner</span>
-</span><span id="TypeParser.__init__-103"><a href="#TypeParser.__init__-103"><span class="linenos">103</span></a>
-</span><span id="TypeParser.__init__-104"><a href="#TypeParser.__init__-104"><span class="linenos">104</span></a><span class="sd">			`true_values`</span>
-</span><span id="TypeParser.__init__-105"><a href="#TypeParser.__init__-105"><span class="linenos">105</span></a><span class="sd">			: list of strings that represent the bool value True</span>
-</span><span id="TypeParser.__init__-106"><a href="#TypeParser.__init__-106"><span class="linenos">106</span></a>
-</span><span id="TypeParser.__init__-107"><a href="#TypeParser.__init__-107"><span class="linenos">107</span></a><span class="sd">			`false_values`</span>
-</span><span id="TypeParser.__init__-108"><a href="#TypeParser.__init__-108"><span class="linenos">108</span></a><span class="sd">			: list of strings that represent the bool value False</span>
-</span><span id="TypeParser.__init__-109"><a href="#TypeParser.__init__-109"><span class="linenos">109</span></a>
-</span><span id="TypeParser.__init__-110"><a href="#TypeParser.__init__-110"><span class="linenos">110</span></a><span class="sd">			`bool_case_sensitive`</span>
-</span><span id="TypeParser.__init__-111"><a href="#TypeParser.__init__-111"><span class="linenos">111</span></a><span class="sd">			: whether matches against `true_values` and `false_values` should be made in a case-sensitive manner</span>
-</span><span id="TypeParser.__init__-112"><a href="#TypeParser.__init__-112"><span class="linenos">112</span></a>
-</span><span id="TypeParser.__init__-113"><a href="#TypeParser.__init__-113"><span class="linenos">113</span></a><span class="sd">			`int_case_sensitive`</span>
-</span><span id="TypeParser.__init__-114"><a href="#TypeParser.__init__-114"><span class="linenos">114</span></a><span class="sd">			: whether checks for int should be done in a case-sensitive manner. This usually only applies to values given in scientific notation, where the mantissa and exponent usually are separated by `e`.</span>
-</span><span id="TypeParser.__init__-115"><a href="#TypeParser.__init__-115"><span class="linenos">115</span></a>
-</span><span id="TypeParser.__init__-116"><a href="#TypeParser.__init__-116"><span class="linenos">116</span></a><span class="sd">			`inf_values`</span>
-</span><span id="TypeParser.__init__-117"><a href="#TypeParser.__init__-117"><span class="linenos">117</span></a><span class="sd">			: list of strings that represent the float or Decimal value of infinity. Each of the strings can be prepended with a negative sign to represent negative infinity also.</span>
-</span><span id="TypeParser.__init__-118"><a href="#TypeParser.__init__-118"><span class="linenos">118</span></a>
-</span><span id="TypeParser.__init__-119"><a href="#TypeParser.__init__-119"><span class="linenos">119</span></a><span class="sd">			`nan_values`</span>
-</span><span id="TypeParser.__init__-120"><a href="#TypeParser.__init__-120"><span class="linenos">120</span></a><span class="sd">			: list of strings that represent a float or Decimal that is NaN (not a number)</span>
-</span><span id="TypeParser.__init__-121"><a href="#TypeParser.__init__-121"><span class="linenos">121</span></a>
-</span><span id="TypeParser.__init__-122"><a href="#TypeParser.__init__-122"><span class="linenos">122</span></a><span class="sd">			`float_case_sensitive`</span>
-</span><span id="TypeParser.__init__-123"><a href="#TypeParser.__init__-123"><span class="linenos">123</span></a><span class="sd">			: whether checks for float should be done in a case-sensitive manner. This applies to matches against `inf_values` and `nan_values`, as well as to values given in scientific notation, where the mantissa and exponent are usually separated by `e`.</span>
-</span><span id="TypeParser.__init__-124"><a href="#TypeParser.__init__-124"><span class="linenos">124</span></a>
-</span><span id="TypeParser.__init__-125"><a href="#TypeParser.__init__-125"><span class="linenos">125</span></a><span class="sd">			`case_sensitive`</span>
-</span><span id="TypeParser.__init__-126"><a href="#TypeParser.__init__-126"><span class="linenos">126</span></a><span class="sd">			: whether all matches should be made in a case-sensitive manner. Sets all of `none_case_sensitive`, `bool_case_sensitive`, `int_case_sensitive`, `float_case_sensitive` to the same value, ignoring any individual settings.</span>
-</span><span id="TypeParser.__init__-127"><a href="#TypeParser.__init__-127"><span class="linenos">127</span></a>
-</span><span id="TypeParser.__init__-128"><a href="#TypeParser.__init__-128"><span class="linenos">128</span></a><span class="sd">			Raises</span>
-</span><span id="TypeParser.__init__-129"><a href="#TypeParser.__init__-129"><span class="linenos">129</span></a><span class="sd">			------</span>
-</span><span id="TypeParser.__init__-130"><a href="#TypeParser.__init__-130"><span class="linenos">130</span></a><span class="sd">			`ValueError` if any of the options would lead to ambiguities during parsing</span>
-</span><span id="TypeParser.__init__-131"><a href="#TypeParser.__init__-131"><span class="linenos">131</span></a><span class="sd">		&quot;&quot;&quot;</span>
-</span><span id="TypeParser.__init__-132"><a href="#TypeParser.__init__-132"><span class="linenos">132</span></a>
-</span><span id="TypeParser.__init__-133"><a href="#TypeParser.__init__-133"><span class="linenos">133</span></a>		<span class="k">if</span> <span class="n">case_sensitive</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
-</span><span id="TypeParser.__init__-134"><a href="#TypeParser.__init__-134"><span class="linenos">134</span></a>			<span class="n">none_case_sensitive</span> <span class="o">=</span> <span class="n">case_sensitive</span>
-</span><span id="TypeParser.__init__-135"><a href="#TypeParser.__init__-135"><span class="linenos">135</span></a>			<span class="n">int_case_sensitive</span> <span class="o">=</span> <span class="n">case_sensitive</span>
-</span><span id="TypeParser.__init__-136"><a href="#TypeParser.__init__-136"><span class="linenos">136</span></a>			<span class="n">bool_case_sensitive</span> <span class="o">=</span> <span class="n">case_sensitive</span>
-</span><span id="TypeParser.__init__-137"><a href="#TypeParser.__init__-137"><span class="linenos">137</span></a>			<span class="n">float_case_sensitive</span> <span class="o">=</span> <span class="n">case_sensitive</span>
-</span><span id="TypeParser.__init__-138"><a href="#TypeParser.__init__-138"><span class="linenos">138</span></a>
-</span><span id="TypeParser.__init__-139"><a href="#TypeParser.__init__-139"><span class="linenos">139</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">trim</span> <span class="o">=</span> <span class="n">trim</span>
-</span><span id="TypeParser.__init__-140"><a href="#TypeParser.__init__-140"><span class="linenos">140</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trim</span><span class="p">:</span>
-</span><span id="TypeParser.__init__-141"><a href="#TypeParser.__init__-141"><span class="linenos">141</span></a>			<span class="n">none_values</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">none_values</span><span class="p">)</span>
-</span><span id="TypeParser.__init__-142"><a href="#TypeParser.__init__-142"><span class="linenos">142</span></a>			<span class="n">true_values</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">true_values</span><span class="p">)</span>
-</span><span id="TypeParser.__init__-143"><a href="#TypeParser.__init__-143"><span class="linenos">143</span></a>			<span class="n">false_values</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">false_values</span><span class="p">)</span>
-</span><span id="TypeParser.__init__-144"><a href="#TypeParser.__init__-144"><span class="linenos">144</span></a>			<span class="n">inf_values</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">inf_values</span><span class="p">)</span>
-</span><span id="TypeParser.__init__-145"><a href="#TypeParser.__init__-145"><span class="linenos">145</span></a>			<span class="n">nan_values</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">nan_values</span><span class="p">)</span>
-</span><span id="TypeParser.__init__-146"><a href="#TypeParser.__init__-146"><span class="linenos">146</span></a>
-</span><span id="TypeParser.__init__-147"><a href="#TypeParser.__init__-147"><span class="linenos">147</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">use_decimal</span> <span class="o">=</span> <span class="n">use_decimal</span>
-</span><span id="TypeParser.__init__-148"><a href="#TypeParser.__init__-148"><span class="linenos">148</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">list_delimiter</span> <span class="o">=</span> <span class="n">list_delimiter</span>
-</span><span id="TypeParser.__init__-149"><a href="#TypeParser.__init__-149"><span class="linenos">149</span></a>
-</span><span id="TypeParser.__init__-150"><a href="#TypeParser.__init__-150"><span class="linenos">150</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">none_case_sensitive</span> <span class="o">=</span> <span class="n">none_case_sensitive</span>
-</span><span id="TypeParser.__init__-151"><a href="#TypeParser.__init__-151"><span class="linenos">151</span></a>		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">none_case_sensitive</span><span class="p">:</span>
-</span><span id="TypeParser.__init__-152"><a href="#TypeParser.__init__-152"><span class="linenos">152</span></a>			<span class="n">none_values</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">none_values</span><span class="p">)</span>
-</span><span id="TypeParser.__init__-153"><a href="#TypeParser.__init__-153"><span class="linenos">153</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">none_values</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">none_values</span><span class="p">)</span>
-</span><span id="TypeParser.__init__-154"><a href="#TypeParser.__init__-154"><span class="linenos">154</span></a>
-</span><span id="TypeParser.__init__-155"><a href="#TypeParser.__init__-155"><span class="linenos">155</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">bool_case_sensitive</span> <span class="o">=</span> <span class="n">bool_case_sensitive</span>
-</span><span id="TypeParser.__init__-156"><a href="#TypeParser.__init__-156"><span class="linenos">156</span></a>		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">bool_case_sensitive</span><span class="p">:</span>
-</span><span id="TypeParser.__init__-157"><a href="#TypeParser.__init__-157"><span class="linenos">157</span></a>			<span class="n">true_values</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">true_values</span><span class="p">)</span>
-</span><span id="TypeParser.__init__-158"><a href="#TypeParser.__init__-158"><span class="linenos">158</span></a>			<span class="n">false_values</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">false_values</span><span class="p">)</span>
-</span><span id="TypeParser.__init__-159"><a href="#TypeParser.__init__-159"><span class="linenos">159</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">true_values</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">true_values</span><span class="p">)</span>
-</span><span id="TypeParser.__init__-160"><a href="#TypeParser.__init__-160"><span class="linenos">160</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">false_values</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">false_values</span><span class="p">)</span>
-</span><span id="TypeParser.__init__-161"><a href="#TypeParser.__init__-161"><span class="linenos">161</span></a>
-</span><span id="TypeParser.__init__-162"><a href="#TypeParser.__init__-162"><span class="linenos">162</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">int_case_sensitive</span> <span class="o">=</span> <span class="n">int_case_sensitive</span>
-</span><span id="TypeParser.__init__-163"><a href="#TypeParser.__init__-163"><span class="linenos">163</span></a>
-</span><span id="TypeParser.__init__-164"><a href="#TypeParser.__init__-164"><span class="linenos">164</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">float_case_sensitive</span> <span class="o">=</span> <span class="n">float_case_sensitive</span>
-</span><span id="TypeParser.__init__-165"><a href="#TypeParser.__init__-165"><span class="linenos">165</span></a>		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">float_case_sensitive</span><span class="p">:</span>
-</span><span id="TypeParser.__init__-166"><a href="#TypeParser.__init__-166"><span class="linenos">166</span></a>			<span class="n">inf_values</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">inf_values</span><span class="p">)</span>
-</span><span id="TypeParser.__init__-167"><a href="#TypeParser.__init__-167"><span class="linenos">167</span></a>			<span class="n">nan_values</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">nan_values</span><span class="p">)</span>
-</span><span id="TypeParser.__init__-168"><a href="#TypeParser.__init__-168"><span class="linenos">168</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">inf_values</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">inf_values</span><span class="p">)</span>
-</span><span id="TypeParser.__init__-169"><a href="#TypeParser.__init__-169"><span class="linenos">169</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">nan_values</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">nan_values</span><span class="p">)</span>
-</span><span id="TypeParser.__init__-170"><a href="#TypeParser.__init__-170"><span class="linenos">170</span></a>
-</span><span id="TypeParser.__init__-171"><a href="#TypeParser.__init__-171"><span class="linenos">171</span></a>		<span class="c1"># Unconfigurable default values</span>
-</span><span id="TypeParser.__init__-172"><a href="#TypeParser.__init__-172"><span class="linenos">172</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_negative_char</span> <span class="o">=</span> <span class="s2">&quot;-&quot;</span>
-</span><span id="TypeParser.__init__-173"><a href="#TypeParser.__init__-173"><span class="linenos">173</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_negative_chars</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_negative_char</span><span class="p">,</span> <span class="s2">&quot;−&quot;</span><span class="p">}</span>
-</span><span id="TypeParser.__init__-174"><a href="#TypeParser.__init__-174"><span class="linenos">174</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_sign_chars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_negative_chars</span> <span class="o">|</span> <span class="p">{</span><span class="s2">&quot;+&quot;</span><span class="p">}</span>
-</span><span id="TypeParser.__init__-175"><a href="#TypeParser.__init__-175"><span class="linenos">175</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_digit_chars</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">,</span> <span class="s2">&quot;3&quot;</span><span class="p">,</span> <span class="s2">&quot;4&quot;</span><span class="p">,</span> <span class="s2">&quot;5&quot;</span><span class="p">,</span> <span class="s2">&quot;6&quot;</span><span class="p">,</span> <span class="s2">&quot;7&quot;</span><span class="p">,</span> <span class="s2">&quot;8&quot;</span><span class="p">,</span> <span class="s2">&quot;9&quot;</span><span class="p">}</span>  <span class="c1"># Because isdigit(&quot;²&quot;) == True, but int(&quot;²&quot;) is invalid</span>
-</span><span id="TypeParser.__init__-176"><a href="#TypeParser.__init__-176"><span class="linenos">176</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_digit_separators</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;_&quot;</span><span class="p">}</span>
-</span><span id="TypeParser.__init__-177"><a href="#TypeParser.__init__-177"><span class="linenos">177</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_scientific_char</span> <span class="o">=</span> <span class="s2">&quot;e&quot;</span>
-</span><span id="TypeParser.__init__-178"><a href="#TypeParser.__init__-178"><span class="linenos">178</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_float_separator</span> <span class="o">=</span> <span class="s2">&quot;.&quot;</span>
-</span><span id="TypeParser.__init__-179"><a href="#TypeParser.__init__-179"><span class="linenos">179</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_reserved_chars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sign_chars</span> <span class="o">|</span> <span class="bp">self</span><span class="o">.</span><span class="n">_digit_chars</span> <span class="o">|</span> <span class="bp">self</span><span class="o">.</span><span class="n">_digit_separators</span> <span class="o">|</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_scientific_char</span><span class="p">}</span> <span class="o">|</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_float_separator</span><span class="p">}</span>
-</span><span id="TypeParser.__init__-180"><a href="#TypeParser.__init__-180"><span class="linenos">180</span></a>		<span class="c1"># special_chars = self._reserved_chars | self.list_delimiter</span>
-</span><span id="TypeParser.__init__-181"><a href="#TypeParser.__init__-181"><span class="linenos">181</span></a>
-</span><span id="TypeParser.__init__-182"><a href="#TypeParser.__init__-182"><span class="linenos">182</span></a>		<span class="c1"># Check if any special values conflict</span>
-</span><span id="TypeParser.__init__-183"><a href="#TypeParser.__init__-183"><span class="linenos">183</span></a>		<span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">special_values</span> <span class="ow">in</span> <span class="p">[</span>
-</span><span id="TypeParser.__init__-184"><a href="#TypeParser.__init__-184"><span class="linenos">184</span></a>			<span class="p">(</span><span class="n">_SpecialValue</span><span class="o">.</span><span class="n">LIST</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">list_delimiter</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_delimiter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[]),</span>
-</span><span id="TypeParser.__init__-185"><a href="#TypeParser.__init__-185"><span class="linenos">185</span></a>			<span class="p">(</span><span class="n">_SpecialValue</span><span class="o">.</span><span class="n">NONE</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">none_values</span><span class="p">),</span>
-</span><span id="TypeParser.__init__-186"><a href="#TypeParser.__init__-186"><span class="linenos">186</span></a>			<span class="p">(</span><span class="n">_SpecialValue</span><span class="o">.</span><span class="n">TRUE</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">true_values</span><span class="p">),</span>
-</span><span id="TypeParser.__init__-187"><a href="#TypeParser.__init__-187"><span class="linenos">187</span></a>			<span class="p">(</span><span class="n">_SpecialValue</span><span class="o">.</span><span class="n">FALSE</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">false_values</span><span class="p">),</span>
-</span><span id="TypeParser.__init__-188"><a href="#TypeParser.__init__-188"><span class="linenos">188</span></a>			<span class="p">(</span><span class="n">_SpecialValue</span><span class="o">.</span><span class="n">INF</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inf_values</span><span class="p">),</span>
-</span><span id="TypeParser.__init__-189"><a href="#TypeParser.__init__-189"><span class="linenos">189</span></a>			<span class="p">(</span><span class="n">_SpecialValue</span><span class="o">.</span><span class="n">NAN</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nan_values</span><span class="p">),</span>
-</span><span id="TypeParser.__init__-190"><a href="#TypeParser.__init__-190"><span class="linenos">190</span></a>		<span class="p">]:</span>
-</span><span id="TypeParser.__init__-191"><a href="#TypeParser.__init__-191"><span class="linenos">191</span></a>			<span class="k">for</span> <span class="n">special_value</span> <span class="ow">in</span> <span class="n">special_values</span><span class="p">:</span>
-</span><span id="TypeParser.__init__-192"><a href="#TypeParser.__init__-192"><span class="linenos">192</span></a>				<span class="k">if</span> <span class="n">special_value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reserved_chars</span><span class="p">:</span>
-</span><span id="TypeParser.__init__-193"><a href="#TypeParser.__init__-193"><span class="linenos">193</span></a>					<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cannot use reserved char as </span><span class="si">{</span><span class="n">name</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">special_value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
-</span><span id="TypeParser.__init__-194"><a href="#TypeParser.__init__-194"><span class="linenos">194</span></a>
-</span><span id="TypeParser.__init__-195"><a href="#TypeParser.__init__-195"><span class="linenos">195</span></a>				<span class="k">if</span> <span class="n">name</span> <span class="o">!=</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">NONE</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_none</span><span class="p">(</span><span class="n">special_value</span><span class="p">):</span>
-</span><span id="TypeParser.__init__-196"><a href="#TypeParser.__init__-196"><span class="linenos">196</span></a>					<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cannot use None value as </span><span class="si">{</span><span class="n">name</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">special_value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
-</span><span id="TypeParser.__init__-197"><a href="#TypeParser.__init__-197"><span class="linenos">197</span></a>
-</span><span id="TypeParser.__init__-198"><a href="#TypeParser.__init__-198"><span class="linenos">198</span></a>				<span class="k">if</span> <span class="p">(</span>
-</span><span id="TypeParser.__init__-199"><a href="#TypeParser.__init__-199"><span class="linenos">199</span></a>					<span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">TRUE</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_bool</span><span class="p">(</span><span class="n">special_value</span><span class="p">)</span> <span class="o">!=</span> <span class="kc">True</span><span class="p">)</span> <span class="ow">or</span>
-</span><span id="TypeParser.__init__-200"><a href="#TypeParser.__init__-200"><span class="linenos">200</span></a>					<span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">FALSE</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_bool</span><span class="p">(</span><span class="n">special_value</span><span class="p">)</span> <span class="o">!=</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">or</span>
-</span><span id="TypeParser.__init__-201"><a href="#TypeParser.__init__-201"><span class="linenos">201</span></a>					<span class="p">(</span><span class="n">name</span> <span class="o">!=</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">TRUE</span> <span class="ow">and</span> <span class="n">name</span> <span class="o">!=</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">FALSE</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_bool</span><span class="p">(</span><span class="n">special_value</span><span class="p">))</span>
-</span><span id="TypeParser.__init__-202"><a href="#TypeParser.__init__-202"><span class="linenos">202</span></a>				<span class="p">):</span>
-</span><span id="TypeParser.__init__-203"><a href="#TypeParser.__init__-203"><span class="linenos">203</span></a>					<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cannot use bool value as </span><span class="si">{</span><span class="n">name</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">special_value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
-</span><span id="TypeParser.__init__-204"><a href="#TypeParser.__init__-204"><span class="linenos">204</span></a>
-</span><span id="TypeParser.__init__-205"><a href="#TypeParser.__init__-205"><span class="linenos">205</span></a>				<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_int</span><span class="p">(</span><span class="n">special_value</span><span class="p">):</span>
-</span><span id="TypeParser.__init__-206"><a href="#TypeParser.__init__-206"><span class="linenos">206</span></a>					<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cannot use int value as </span><span class="si">{</span><span class="n">name</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">special_value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
-</span><span id="TypeParser.__init__-207"><a href="#TypeParser.__init__-207"><span class="linenos">207</span></a>
-</span><span id="TypeParser.__init__-208"><a href="#TypeParser.__init__-208"><span class="linenos">208</span></a>				<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_decimal</span><span class="p">:</span>
-</span><span id="TypeParser.__init__-209"><a href="#TypeParser.__init__-209"><span class="linenos">209</span></a>					<span class="k">if</span> <span class="p">(</span>
-</span><span id="TypeParser.__init__-210"><a href="#TypeParser.__init__-210"><span class="linenos">210</span></a>						<span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">INF</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_decimal</span><span class="p">(</span><span class="n">special_value</span><span class="p">)</span> <span class="o">!=</span> <span class="n">Decimal</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">))</span> <span class="ow">or</span>
-</span><span id="TypeParser.__init__-211"><a href="#TypeParser.__init__-211"><span class="linenos">211</span></a>						<span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">NAN</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_decimal</span><span class="p">(</span><span class="n">special_value</span><span class="p">)</span><span class="o">.</span><span class="n">is_nan</span><span class="p">())</span> <span class="ow">or</span>
-</span><span id="TypeParser.__init__-212"><a href="#TypeParser.__init__-212"><span class="linenos">212</span></a>						<span class="p">(</span><span class="n">name</span> <span class="o">!=</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">INF</span> <span class="ow">and</span> <span class="n">name</span> <span class="o">!=</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">NAN</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_float</span><span class="p">(</span><span class="n">special_value</span><span class="p">))</span>
-</span><span id="TypeParser.__init__-213"><a href="#TypeParser.__init__-213"><span class="linenos">213</span></a>					<span class="p">):</span>
-</span><span id="TypeParser.__init__-214"><a href="#TypeParser.__init__-214"><span class="linenos">214</span></a>						<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cannot use Decimal value as </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">special_value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
-</span><span id="TypeParser.__init__-215"><a href="#TypeParser.__init__-215"><span class="linenos">215</span></a>				<span class="k">else</span><span class="p">:</span>
-</span><span id="TypeParser.__init__-216"><a href="#TypeParser.__init__-216"><span class="linenos">216</span></a>					<span class="k">if</span> <span class="p">(</span>
-</span><span id="TypeParser.__init__-217"><a href="#TypeParser.__init__-217"><span class="linenos">217</span></a>						<span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">INF</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_float</span><span class="p">(</span><span class="n">special_value</span><span class="p">)</span> <span class="o">!=</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span> <span class="ow">or</span>
-</span><span id="TypeParser.__init__-218"><a href="#TypeParser.__init__-218"><span class="linenos">218</span></a>						<span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">NAN</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_float</span><span class="p">(</span><span class="n">special_value</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">math</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span> <span class="ow">or</span>
-</span><span id="TypeParser.__init__-219"><a href="#TypeParser.__init__-219"><span class="linenos">219</span></a>						<span class="p">(</span><span class="n">name</span> <span class="o">!=</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">INF</span> <span class="ow">and</span> <span class="n">name</span> <span class="o">!=</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">NAN</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_float</span><span class="p">(</span><span class="n">special_value</span><span class="p">))</span>
-</span><span id="TypeParser.__init__-220"><a href="#TypeParser.__init__-220"><span class="linenos">220</span></a>					<span class="p">):</span>
-</span><span id="TypeParser.__init__-221"><a href="#TypeParser.__init__-221"><span class="linenos">221</span></a>						<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cannot use float value as </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">special_value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
+            <div class="pdoc-code codehilite"><pre><span></span><span id="TypeParser.__init__-67"><a href="#TypeParser.__init__-67"><span class="linenos"> 67</span></a>	<span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
+</span><span id="TypeParser.__init__-68"><a href="#TypeParser.__init__-68"><span class="linenos"> 68</span></a>	    <span class="o">*</span><span class="p">,</span>
+</span><span id="TypeParser.__init__-69"><a href="#TypeParser.__init__-69"><span class="linenos"> 69</span></a>		<span class="n">trim</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
+</span><span id="TypeParser.__init__-70"><a href="#TypeParser.__init__-70"><span class="linenos"> 70</span></a>		<span class="n">use_decimal</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
+</span><span id="TypeParser.__init__-71"><a href="#TypeParser.__init__-71"><span class="linenos"> 71</span></a>		<span class="n">list_delimiter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
+</span><span id="TypeParser.__init__-72"><a href="#TypeParser.__init__-72"><span class="linenos"> 72</span></a>		<span class="n">none_values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">],</span>
+</span><span id="TypeParser.__init__-73"><a href="#TypeParser.__init__-73"><span class="linenos"> 73</span></a>		<span class="n">none_case_sensitive</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
+</span><span id="TypeParser.__init__-74"><a href="#TypeParser.__init__-74"><span class="linenos"> 74</span></a>		<span class="n">true_values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;true&quot;</span><span class="p">],</span>
+</span><span id="TypeParser.__init__-75"><a href="#TypeParser.__init__-75"><span class="linenos"> 75</span></a>		<span class="n">false_values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;false&quot;</span><span class="p">],</span>
+</span><span id="TypeParser.__init__-76"><a href="#TypeParser.__init__-76"><span class="linenos"> 76</span></a>		<span class="n">bool_case_sensitive</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
+</span><span id="TypeParser.__init__-77"><a href="#TypeParser.__init__-77"><span class="linenos"> 77</span></a>		<span class="n">int_case_sensitive</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
+</span><span id="TypeParser.__init__-78"><a href="#TypeParser.__init__-78"><span class="linenos"> 78</span></a>		<span class="n">inf_values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="p">[],</span>
+</span><span id="TypeParser.__init__-79"><a href="#TypeParser.__init__-79"><span class="linenos"> 79</span></a>		<span class="n">nan_values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span><span class="o">=</span><span class="p">[],</span>
+</span><span id="TypeParser.__init__-80"><a href="#TypeParser.__init__-80"><span class="linenos"> 80</span></a>		<span class="n">float_case_sensitive</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
+</span><span id="TypeParser.__init__-81"><a href="#TypeParser.__init__-81"><span class="linenos"> 81</span></a>		<span class="n">case_sensitive</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
+</span><span id="TypeParser.__init__-82"><a href="#TypeParser.__init__-82"><span class="linenos"> 82</span></a>	<span class="p">):</span>
+</span><span id="TypeParser.__init__-83"><a href="#TypeParser.__init__-83"><span class="linenos"> 83</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
+</span><span id="TypeParser.__init__-84"><a href="#TypeParser.__init__-84"><span class="linenos"> 84</span></a><span class="sd">			Initialise a new parser</span>
+</span><span id="TypeParser.__init__-85"><a href="#TypeParser.__init__-85"><span class="linenos"> 85</span></a>
+</span><span id="TypeParser.__init__-86"><a href="#TypeParser.__init__-86"><span class="linenos"> 86</span></a><span class="sd">			Parameters</span>
+</span><span id="TypeParser.__init__-87"><a href="#TypeParser.__init__-87"><span class="linenos"> 87</span></a><span class="sd">			----------</span>
+</span><span id="TypeParser.__init__-88"><a href="#TypeParser.__init__-88"><span class="linenos"> 88</span></a><span class="sd">			`trim`</span>
+</span><span id="TypeParser.__init__-89"><a href="#TypeParser.__init__-89"><span class="linenos"> 89</span></a><span class="sd">			: whether leading and trailing whitespace should be stripped from strings</span>
+</span><span id="TypeParser.__init__-90"><a href="#TypeParser.__init__-90"><span class="linenos"> 90</span></a>
+</span><span id="TypeParser.__init__-91"><a href="#TypeParser.__init__-91"><span class="linenos"> 91</span></a><span class="sd">			`use_decimal`</span>
+</span><span id="TypeParser.__init__-92"><a href="#TypeParser.__init__-92"><span class="linenos"> 92</span></a><span class="sd">			: whether non-integer numeric values should be inferred as Decimal (exact values) instead of float (non-exact values). Note that this only applies to methods that attempt to infer type (`infer()` and `infer_*()`), and does not affect methods where the type is explicitly specified (`is_float()`, `is_decimal()`, `parse_float()`, `parse_decimal()`).</span>
+</span><span id="TypeParser.__init__-93"><a href="#TypeParser.__init__-93"><span class="linenos"> 93</span></a>
+</span><span id="TypeParser.__init__-94"><a href="#TypeParser.__init__-94"><span class="linenos"> 94</span></a><span class="sd">			`list_delimiter`</span>
+</span><span id="TypeParser.__init__-95"><a href="#TypeParser.__init__-95"><span class="linenos"> 95</span></a><span class="sd">			: the delimiter used for identifying lists and for separating list items. If set to None, the parser will not attempt to identify lists when inferring types, which usually causes the value to be treated as a str instead.</span>
+</span><span id="TypeParser.__init__-96"><a href="#TypeParser.__init__-96"><span class="linenos"> 96</span></a>
+</span><span id="TypeParser.__init__-97"><a href="#TypeParser.__init__-97"><span class="linenos"> 97</span></a><span class="sd">			`none_values`</span>
+</span><span id="TypeParser.__init__-98"><a href="#TypeParser.__init__-98"><span class="linenos"> 98</span></a><span class="sd">			: list of strings that represent the value None</span>
+</span><span id="TypeParser.__init__-99"><a href="#TypeParser.__init__-99"><span class="linenos"> 99</span></a>
+</span><span id="TypeParser.__init__-100"><a href="#TypeParser.__init__-100"><span class="linenos">100</span></a><span class="sd">			`none_case_sensitive`</span>
+</span><span id="TypeParser.__init__-101"><a href="#TypeParser.__init__-101"><span class="linenos">101</span></a><span class="sd">			: whether matches against `none_values` should be made in a case-sensitive manner</span>
+</span><span id="TypeParser.__init__-102"><a href="#TypeParser.__init__-102"><span class="linenos">102</span></a>
+</span><span id="TypeParser.__init__-103"><a href="#TypeParser.__init__-103"><span class="linenos">103</span></a><span class="sd">			`true_values`</span>
+</span><span id="TypeParser.__init__-104"><a href="#TypeParser.__init__-104"><span class="linenos">104</span></a><span class="sd">			: list of strings that represent the bool value True</span>
+</span><span id="TypeParser.__init__-105"><a href="#TypeParser.__init__-105"><span class="linenos">105</span></a>
+</span><span id="TypeParser.__init__-106"><a href="#TypeParser.__init__-106"><span class="linenos">106</span></a><span class="sd">			`false_values`</span>
+</span><span id="TypeParser.__init__-107"><a href="#TypeParser.__init__-107"><span class="linenos">107</span></a><span class="sd">			: list of strings that represent the bool value False</span>
+</span><span id="TypeParser.__init__-108"><a href="#TypeParser.__init__-108"><span class="linenos">108</span></a>
+</span><span id="TypeParser.__init__-109"><a href="#TypeParser.__init__-109"><span class="linenos">109</span></a><span class="sd">			`bool_case_sensitive`</span>
+</span><span id="TypeParser.__init__-110"><a href="#TypeParser.__init__-110"><span class="linenos">110</span></a><span class="sd">			: whether matches against `true_values` and `false_values` should be made in a case-sensitive manner</span>
+</span><span id="TypeParser.__init__-111"><a href="#TypeParser.__init__-111"><span class="linenos">111</span></a>
+</span><span id="TypeParser.__init__-112"><a href="#TypeParser.__init__-112"><span class="linenos">112</span></a><span class="sd">			`int_case_sensitive`</span>
+</span><span id="TypeParser.__init__-113"><a href="#TypeParser.__init__-113"><span class="linenos">113</span></a><span class="sd">			: whether checks for int should be done in a case-sensitive manner. This usually only applies to values given in scientific notation, where the mantissa and exponent usually are separated by `e`.</span>
+</span><span id="TypeParser.__init__-114"><a href="#TypeParser.__init__-114"><span class="linenos">114</span></a>
+</span><span id="TypeParser.__init__-115"><a href="#TypeParser.__init__-115"><span class="linenos">115</span></a><span class="sd">			`inf_values`</span>
+</span><span id="TypeParser.__init__-116"><a href="#TypeParser.__init__-116"><span class="linenos">116</span></a><span class="sd">			: list of strings that represent the float or Decimal value of infinity. Each of the strings can be prepended with a negative sign to represent negative infinity also.</span>
+</span><span id="TypeParser.__init__-117"><a href="#TypeParser.__init__-117"><span class="linenos">117</span></a>
+</span><span id="TypeParser.__init__-118"><a href="#TypeParser.__init__-118"><span class="linenos">118</span></a><span class="sd">			`nan_values`</span>
+</span><span id="TypeParser.__init__-119"><a href="#TypeParser.__init__-119"><span class="linenos">119</span></a><span class="sd">			: list of strings that represent a float or Decimal that is NaN (not a number)</span>
+</span><span id="TypeParser.__init__-120"><a href="#TypeParser.__init__-120"><span class="linenos">120</span></a>
+</span><span id="TypeParser.__init__-121"><a href="#TypeParser.__init__-121"><span class="linenos">121</span></a><span class="sd">			`float_case_sensitive`</span>
+</span><span id="TypeParser.__init__-122"><a href="#TypeParser.__init__-122"><span class="linenos">122</span></a><span class="sd">			: whether checks for float should be done in a case-sensitive manner. This applies to matches against `inf_values` and `nan_values`, as well as to values given in scientific notation, where the mantissa and exponent are usually separated by `e`.</span>
+</span><span id="TypeParser.__init__-123"><a href="#TypeParser.__init__-123"><span class="linenos">123</span></a>
+</span><span id="TypeParser.__init__-124"><a href="#TypeParser.__init__-124"><span class="linenos">124</span></a><span class="sd">			`case_sensitive`</span>
+</span><span id="TypeParser.__init__-125"><a href="#TypeParser.__init__-125"><span class="linenos">125</span></a><span class="sd">			: whether all matches should be made in a case-sensitive manner. Sets all of `none_case_sensitive`, `bool_case_sensitive`, `int_case_sensitive`, `float_case_sensitive` to the same value, ignoring any individual settings.</span>
+</span><span id="TypeParser.__init__-126"><a href="#TypeParser.__init__-126"><span class="linenos">126</span></a>
+</span><span id="TypeParser.__init__-127"><a href="#TypeParser.__init__-127"><span class="linenos">127</span></a><span class="sd">			Raises</span>
+</span><span id="TypeParser.__init__-128"><a href="#TypeParser.__init__-128"><span class="linenos">128</span></a><span class="sd">			------</span>
+</span><span id="TypeParser.__init__-129"><a href="#TypeParser.__init__-129"><span class="linenos">129</span></a><span class="sd">			`ValueError` if any of the options would lead to ambiguities during parsing</span>
+</span><span id="TypeParser.__init__-130"><a href="#TypeParser.__init__-130"><span class="linenos">130</span></a><span class="sd">		&quot;&quot;&quot;</span>
+</span><span id="TypeParser.__init__-131"><a href="#TypeParser.__init__-131"><span class="linenos">131</span></a>
+</span><span id="TypeParser.__init__-132"><a href="#TypeParser.__init__-132"><span class="linenos">132</span></a>		<span class="k">if</span> <span class="n">case_sensitive</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
+</span><span id="TypeParser.__init__-133"><a href="#TypeParser.__init__-133"><span class="linenos">133</span></a>			<span class="n">none_case_sensitive</span> <span class="o">=</span> <span class="n">case_sensitive</span>
+</span><span id="TypeParser.__init__-134"><a href="#TypeParser.__init__-134"><span class="linenos">134</span></a>			<span class="n">int_case_sensitive</span> <span class="o">=</span> <span class="n">case_sensitive</span>
+</span><span id="TypeParser.__init__-135"><a href="#TypeParser.__init__-135"><span class="linenos">135</span></a>			<span class="n">bool_case_sensitive</span> <span class="o">=</span> <span class="n">case_sensitive</span>
+</span><span id="TypeParser.__init__-136"><a href="#TypeParser.__init__-136"><span class="linenos">136</span></a>			<span class="n">float_case_sensitive</span> <span class="o">=</span> <span class="n">case_sensitive</span>
+</span><span id="TypeParser.__init__-137"><a href="#TypeParser.__init__-137"><span class="linenos">137</span></a>
+</span><span id="TypeParser.__init__-138"><a href="#TypeParser.__init__-138"><span class="linenos">138</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">trim</span> <span class="o">=</span> <span class="n">trim</span>
+</span><span id="TypeParser.__init__-139"><a href="#TypeParser.__init__-139"><span class="linenos">139</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trim</span><span class="p">:</span>
+</span><span id="TypeParser.__init__-140"><a href="#TypeParser.__init__-140"><span class="linenos">140</span></a>			<span class="n">none_values</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">none_values</span><span class="p">)</span>
+</span><span id="TypeParser.__init__-141"><a href="#TypeParser.__init__-141"><span class="linenos">141</span></a>			<span class="n">true_values</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">true_values</span><span class="p">)</span>
+</span><span id="TypeParser.__init__-142"><a href="#TypeParser.__init__-142"><span class="linenos">142</span></a>			<span class="n">false_values</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">false_values</span><span class="p">)</span>
+</span><span id="TypeParser.__init__-143"><a href="#TypeParser.__init__-143"><span class="linenos">143</span></a>			<span class="n">inf_values</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">inf_values</span><span class="p">)</span>
+</span><span id="TypeParser.__init__-144"><a href="#TypeParser.__init__-144"><span class="linenos">144</span></a>			<span class="n">nan_values</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">nan_values</span><span class="p">)</span>
+</span><span id="TypeParser.__init__-145"><a href="#TypeParser.__init__-145"><span class="linenos">145</span></a>
+</span><span id="TypeParser.__init__-146"><a href="#TypeParser.__init__-146"><span class="linenos">146</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">use_decimal</span> <span class="o">=</span> <span class="n">use_decimal</span>
+</span><span id="TypeParser.__init__-147"><a href="#TypeParser.__init__-147"><span class="linenos">147</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">list_delimiter</span> <span class="o">=</span> <span class="n">list_delimiter</span>
+</span><span id="TypeParser.__init__-148"><a href="#TypeParser.__init__-148"><span class="linenos">148</span></a>
+</span><span id="TypeParser.__init__-149"><a href="#TypeParser.__init__-149"><span class="linenos">149</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">none_case_sensitive</span> <span class="o">=</span> <span class="n">none_case_sensitive</span>
+</span><span id="TypeParser.__init__-150"><a href="#TypeParser.__init__-150"><span class="linenos">150</span></a>		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">none_case_sensitive</span><span class="p">:</span>
+</span><span id="TypeParser.__init__-151"><a href="#TypeParser.__init__-151"><span class="linenos">151</span></a>			<span class="n">none_values</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">none_values</span><span class="p">)</span>
+</span><span id="TypeParser.__init__-152"><a href="#TypeParser.__init__-152"><span class="linenos">152</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">none_values</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">none_values</span><span class="p">)</span>
+</span><span id="TypeParser.__init__-153"><a href="#TypeParser.__init__-153"><span class="linenos">153</span></a>
+</span><span id="TypeParser.__init__-154"><a href="#TypeParser.__init__-154"><span class="linenos">154</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">bool_case_sensitive</span> <span class="o">=</span> <span class="n">bool_case_sensitive</span>
+</span><span id="TypeParser.__init__-155"><a href="#TypeParser.__init__-155"><span class="linenos">155</span></a>		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">bool_case_sensitive</span><span class="p">:</span>
+</span><span id="TypeParser.__init__-156"><a href="#TypeParser.__init__-156"><span class="linenos">156</span></a>			<span class="n">true_values</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">true_values</span><span class="p">)</span>
+</span><span id="TypeParser.__init__-157"><a href="#TypeParser.__init__-157"><span class="linenos">157</span></a>			<span class="n">false_values</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">false_values</span><span class="p">)</span>
+</span><span id="TypeParser.__init__-158"><a href="#TypeParser.__init__-158"><span class="linenos">158</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">true_values</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">true_values</span><span class="p">)</span>
+</span><span id="TypeParser.__init__-159"><a href="#TypeParser.__init__-159"><span class="linenos">159</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">false_values</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">false_values</span><span class="p">)</span>
+</span><span id="TypeParser.__init__-160"><a href="#TypeParser.__init__-160"><span class="linenos">160</span></a>
+</span><span id="TypeParser.__init__-161"><a href="#TypeParser.__init__-161"><span class="linenos">161</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">int_case_sensitive</span> <span class="o">=</span> <span class="n">int_case_sensitive</span>
+</span><span id="TypeParser.__init__-162"><a href="#TypeParser.__init__-162"><span class="linenos">162</span></a>
+</span><span id="TypeParser.__init__-163"><a href="#TypeParser.__init__-163"><span class="linenos">163</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">float_case_sensitive</span> <span class="o">=</span> <span class="n">float_case_sensitive</span>
+</span><span id="TypeParser.__init__-164"><a href="#TypeParser.__init__-164"><span class="linenos">164</span></a>		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">float_case_sensitive</span><span class="p">:</span>
+</span><span id="TypeParser.__init__-165"><a href="#TypeParser.__init__-165"><span class="linenos">165</span></a>			<span class="n">inf_values</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">inf_values</span><span class="p">)</span>
+</span><span id="TypeParser.__init__-166"><a href="#TypeParser.__init__-166"><span class="linenos">166</span></a>			<span class="n">nan_values</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">nan_values</span><span class="p">)</span>
+</span><span id="TypeParser.__init__-167"><a href="#TypeParser.__init__-167"><span class="linenos">167</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">inf_values</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">inf_values</span><span class="p">)</span>
+</span><span id="TypeParser.__init__-168"><a href="#TypeParser.__init__-168"><span class="linenos">168</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">nan_values</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">nan_values</span><span class="p">)</span>
+</span><span id="TypeParser.__init__-169"><a href="#TypeParser.__init__-169"><span class="linenos">169</span></a>
+</span><span id="TypeParser.__init__-170"><a href="#TypeParser.__init__-170"><span class="linenos">170</span></a>		<span class="c1"># Unconfigurable default values</span>
+</span><span id="TypeParser.__init__-171"><a href="#TypeParser.__init__-171"><span class="linenos">171</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_negative_char</span> <span class="o">=</span> <span class="s2">&quot;-&quot;</span>
+</span><span id="TypeParser.__init__-172"><a href="#TypeParser.__init__-172"><span class="linenos">172</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_negative_chars</span> <span class="o">=</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_negative_char</span><span class="p">,</span> <span class="s2">&quot;−&quot;</span><span class="p">}</span>
+</span><span id="TypeParser.__init__-173"><a href="#TypeParser.__init__-173"><span class="linenos">173</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_sign_chars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_negative_chars</span> <span class="o">|</span> <span class="p">{</span><span class="s2">&quot;+&quot;</span><span class="p">}</span>
+</span><span id="TypeParser.__init__-174"><a href="#TypeParser.__init__-174"><span class="linenos">174</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_digit_chars</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;0&quot;</span><span class="p">,</span> <span class="s2">&quot;1&quot;</span><span class="p">,</span> <span class="s2">&quot;2&quot;</span><span class="p">,</span> <span class="s2">&quot;3&quot;</span><span class="p">,</span> <span class="s2">&quot;4&quot;</span><span class="p">,</span> <span class="s2">&quot;5&quot;</span><span class="p">,</span> <span class="s2">&quot;6&quot;</span><span class="p">,</span> <span class="s2">&quot;7&quot;</span><span class="p">,</span> <span class="s2">&quot;8&quot;</span><span class="p">,</span> <span class="s2">&quot;9&quot;</span><span class="p">}</span>  <span class="c1"># Because isdigit(&quot;²&quot;) == True, but int(&quot;²&quot;) is invalid</span>
+</span><span id="TypeParser.__init__-175"><a href="#TypeParser.__init__-175"><span class="linenos">175</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_digit_separators</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;_&quot;</span><span class="p">}</span>
+</span><span id="TypeParser.__init__-176"><a href="#TypeParser.__init__-176"><span class="linenos">176</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_scientific_char</span> <span class="o">=</span> <span class="s2">&quot;e&quot;</span>
+</span><span id="TypeParser.__init__-177"><a href="#TypeParser.__init__-177"><span class="linenos">177</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_float_separator</span> <span class="o">=</span> <span class="s2">&quot;.&quot;</span>
+</span><span id="TypeParser.__init__-178"><a href="#TypeParser.__init__-178"><span class="linenos">178</span></a>		<span class="bp">self</span><span class="o">.</span><span class="n">_reserved_chars</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sign_chars</span> <span class="o">|</span> <span class="bp">self</span><span class="o">.</span><span class="n">_digit_chars</span> <span class="o">|</span> <span class="bp">self</span><span class="o">.</span><span class="n">_digit_separators</span> <span class="o">|</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_scientific_char</span><span class="p">}</span> <span class="o">|</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_float_separator</span><span class="p">}</span>
+</span><span id="TypeParser.__init__-179"><a href="#TypeParser.__init__-179"><span class="linenos">179</span></a>		<span class="c1"># special_chars = self._reserved_chars | self.list_delimiter</span>
+</span><span id="TypeParser.__init__-180"><a href="#TypeParser.__init__-180"><span class="linenos">180</span></a>
+</span><span id="TypeParser.__init__-181"><a href="#TypeParser.__init__-181"><span class="linenos">181</span></a>		<span class="c1"># Check if any special values conflict</span>
+</span><span id="TypeParser.__init__-182"><a href="#TypeParser.__init__-182"><span class="linenos">182</span></a>		<span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">special_values</span> <span class="ow">in</span> <span class="p">[</span>
+</span><span id="TypeParser.__init__-183"><a href="#TypeParser.__init__-183"><span class="linenos">183</span></a>			<span class="p">(</span><span class="n">_SpecialValue</span><span class="o">.</span><span class="n">LIST</span><span class="p">,</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">list_delimiter</span><span class="p">]</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_delimiter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">[]),</span>
+</span><span id="TypeParser.__init__-184"><a href="#TypeParser.__init__-184"><span class="linenos">184</span></a>			<span class="p">(</span><span class="n">_SpecialValue</span><span class="o">.</span><span class="n">NONE</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">none_values</span><span class="p">),</span>
+</span><span id="TypeParser.__init__-185"><a href="#TypeParser.__init__-185"><span class="linenos">185</span></a>			<span class="p">(</span><span class="n">_SpecialValue</span><span class="o">.</span><span class="n">TRUE</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">true_values</span><span class="p">),</span>
+</span><span id="TypeParser.__init__-186"><a href="#TypeParser.__init__-186"><span class="linenos">186</span></a>			<span class="p">(</span><span class="n">_SpecialValue</span><span class="o">.</span><span class="n">FALSE</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">false_values</span><span class="p">),</span>
+</span><span id="TypeParser.__init__-187"><a href="#TypeParser.__init__-187"><span class="linenos">187</span></a>			<span class="p">(</span><span class="n">_SpecialValue</span><span class="o">.</span><span class="n">INF</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">inf_values</span><span class="p">),</span>
+</span><span id="TypeParser.__init__-188"><a href="#TypeParser.__init__-188"><span class="linenos">188</span></a>			<span class="p">(</span><span class="n">_SpecialValue</span><span class="o">.</span><span class="n">NAN</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nan_values</span><span class="p">),</span>
+</span><span id="TypeParser.__init__-189"><a href="#TypeParser.__init__-189"><span class="linenos">189</span></a>		<span class="p">]:</span>
+</span><span id="TypeParser.__init__-190"><a href="#TypeParser.__init__-190"><span class="linenos">190</span></a>			<span class="k">for</span> <span class="n">special_value</span> <span class="ow">in</span> <span class="n">special_values</span><span class="p">:</span>
+</span><span id="TypeParser.__init__-191"><a href="#TypeParser.__init__-191"><span class="linenos">191</span></a>				<span class="k">if</span> <span class="n">special_value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_reserved_chars</span><span class="p">:</span>
+</span><span id="TypeParser.__init__-192"><a href="#TypeParser.__init__-192"><span class="linenos">192</span></a>					<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cannot use reserved char as </span><span class="si">{</span><span class="n">name</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">special_value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
+</span><span id="TypeParser.__init__-193"><a href="#TypeParser.__init__-193"><span class="linenos">193</span></a>
+</span><span id="TypeParser.__init__-194"><a href="#TypeParser.__init__-194"><span class="linenos">194</span></a>				<span class="k">if</span> <span class="n">name</span> <span class="o">!=</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">NONE</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_none</span><span class="p">(</span><span class="n">special_value</span><span class="p">):</span>
+</span><span id="TypeParser.__init__-195"><a href="#TypeParser.__init__-195"><span class="linenos">195</span></a>					<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cannot use None value as </span><span class="si">{</span><span class="n">name</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">special_value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
+</span><span id="TypeParser.__init__-196"><a href="#TypeParser.__init__-196"><span class="linenos">196</span></a>
+</span><span id="TypeParser.__init__-197"><a href="#TypeParser.__init__-197"><span class="linenos">197</span></a>				<span class="k">if</span> <span class="p">(</span>
+</span><span id="TypeParser.__init__-198"><a href="#TypeParser.__init__-198"><span class="linenos">198</span></a>					<span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">TRUE</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_bool</span><span class="p">(</span><span class="n">special_value</span><span class="p">)</span> <span class="o">!=</span> <span class="kc">True</span><span class="p">)</span> <span class="ow">or</span>
+</span><span id="TypeParser.__init__-199"><a href="#TypeParser.__init__-199"><span class="linenos">199</span></a>					<span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">FALSE</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_bool</span><span class="p">(</span><span class="n">special_value</span><span class="p">)</span> <span class="o">!=</span> <span class="kc">False</span><span class="p">)</span> <span class="ow">or</span>
+</span><span id="TypeParser.__init__-200"><a href="#TypeParser.__init__-200"><span class="linenos">200</span></a>					<span class="p">(</span><span class="n">name</span> <span class="o">!=</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">TRUE</span> <span class="ow">and</span> <span class="n">name</span> <span class="o">!=</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">FALSE</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_bool</span><span class="p">(</span><span class="n">special_value</span><span class="p">))</span>
+</span><span id="TypeParser.__init__-201"><a href="#TypeParser.__init__-201"><span class="linenos">201</span></a>				<span class="p">):</span>
+</span><span id="TypeParser.__init__-202"><a href="#TypeParser.__init__-202"><span class="linenos">202</span></a>					<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cannot use bool value as </span><span class="si">{</span><span class="n">name</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">special_value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
+</span><span id="TypeParser.__init__-203"><a href="#TypeParser.__init__-203"><span class="linenos">203</span></a>
+</span><span id="TypeParser.__init__-204"><a href="#TypeParser.__init__-204"><span class="linenos">204</span></a>				<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_int</span><span class="p">(</span><span class="n">special_value</span><span class="p">):</span>
+</span><span id="TypeParser.__init__-205"><a href="#TypeParser.__init__-205"><span class="linenos">205</span></a>					<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cannot use int value as </span><span class="si">{</span><span class="n">name</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">special_value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
+</span><span id="TypeParser.__init__-206"><a href="#TypeParser.__init__-206"><span class="linenos">206</span></a>
+</span><span id="TypeParser.__init__-207"><a href="#TypeParser.__init__-207"><span class="linenos">207</span></a>				<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_decimal</span><span class="p">:</span>
+</span><span id="TypeParser.__init__-208"><a href="#TypeParser.__init__-208"><span class="linenos">208</span></a>					<span class="k">if</span> <span class="p">(</span>
+</span><span id="TypeParser.__init__-209"><a href="#TypeParser.__init__-209"><span class="linenos">209</span></a>						<span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">INF</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_decimal</span><span class="p">(</span><span class="n">special_value</span><span class="p">)</span> <span class="o">!=</span> <span class="n">Decimal</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">))</span> <span class="ow">or</span>
+</span><span id="TypeParser.__init__-210"><a href="#TypeParser.__init__-210"><span class="linenos">210</span></a>						<span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">NAN</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_decimal</span><span class="p">(</span><span class="n">special_value</span><span class="p">)</span><span class="o">.</span><span class="n">is_nan</span><span class="p">())</span> <span class="ow">or</span>
+</span><span id="TypeParser.__init__-211"><a href="#TypeParser.__init__-211"><span class="linenos">211</span></a>						<span class="p">(</span><span class="n">name</span> <span class="o">!=</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">INF</span> <span class="ow">and</span> <span class="n">name</span> <span class="o">!=</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">NAN</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_float</span><span class="p">(</span><span class="n">special_value</span><span class="p">))</span>
+</span><span id="TypeParser.__init__-212"><a href="#TypeParser.__init__-212"><span class="linenos">212</span></a>					<span class="p">):</span>
+</span><span id="TypeParser.__init__-213"><a href="#TypeParser.__init__-213"><span class="linenos">213</span></a>						<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cannot use Decimal value as </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">special_value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
+</span><span id="TypeParser.__init__-214"><a href="#TypeParser.__init__-214"><span class="linenos">214</span></a>				<span class="k">else</span><span class="p">:</span>
+</span><span id="TypeParser.__init__-215"><a href="#TypeParser.__init__-215"><span class="linenos">215</span></a>					<span class="k">if</span> <span class="p">(</span>
+</span><span id="TypeParser.__init__-216"><a href="#TypeParser.__init__-216"><span class="linenos">216</span></a>						<span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">INF</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_float</span><span class="p">(</span><span class="n">special_value</span><span class="p">)</span> <span class="o">!=</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span> <span class="ow">or</span>
+</span><span id="TypeParser.__init__-217"><a href="#TypeParser.__init__-217"><span class="linenos">217</span></a>						<span class="p">(</span><span class="n">name</span> <span class="o">==</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">NAN</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">parse_float</span><span class="p">(</span><span class="n">special_value</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">math</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span> <span class="ow">or</span>
+</span><span id="TypeParser.__init__-218"><a href="#TypeParser.__init__-218"><span class="linenos">218</span></a>						<span class="p">(</span><span class="n">name</span> <span class="o">!=</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">INF</span> <span class="ow">and</span> <span class="n">name</span> <span class="o">!=</span> <span class="n">_SpecialValue</span><span class="o">.</span><span class="n">NAN</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_float</span><span class="p">(</span><span class="n">special_value</span><span class="p">))</span>
+</span><span id="TypeParser.__init__-219"><a href="#TypeParser.__init__-219"><span class="linenos">219</span></a>					<span class="p">):</span>
+</span><span id="TypeParser.__init__-220"><a href="#TypeParser.__init__-220"><span class="linenos">220</span></a>						<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;cannot use float value as </span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="n">special_value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
 </span></pre></div>
 
 
     <div class="docstring">
 <p>Initialise a new parser</p>
 
 <h2 id="parameters">Parameters</h2>
@@ -1404,46 +1404,46 @@
         <span class="name">is_none</span><span class="signature pdoc-code condensed">(<span class="param"><span class="bp">self</span>, </span><span class="param"><span class="n">value</span><span class="p">:</span> <span class="nb">str</span></span><span class="return-annotation">) -> <span class="nb">bool</span>:</span></span>
 
 
                 <label class="view-source-button" for="TypeParser.is_none-view-source"><span>View Source</span></label>
 
     </div>
     <a class="headerlink" href="#TypeParser.is_none"></a>
-            <div class="pdoc-code codehilite"><pre><span></span><span id="TypeParser.is_none-224"><a href="#TypeParser.is_none-224"><span class="linenos">224</span></a>	<span class="k">def</span> <span class="nf">is_none</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
-</span><span id="TypeParser.is_none-225"><a href="#TypeParser.is_none-225"><span class="linenos">225</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
-</span><span id="TypeParser.is_none-226"><a href="#TypeParser.is_none-226"><span class="linenos">226</span></a><span class="sd">			Check if a string represents the value None</span>
-</span><span id="TypeParser.is_none-227"><a href="#TypeParser.is_none-227"><span class="linenos">227</span></a>
-</span><span id="TypeParser.is_none-228"><a href="#TypeParser.is_none-228"><span class="linenos">228</span></a><span class="sd">			Only strings that match the values in `self.none_values` will be interpreted as None. The default accepted values are `[&quot;&quot;]`, i.e. an empty string. The case sensitivity of this matching depends on `self.none_case_sensitive`, which is False by default.</span>
-</span><span id="TypeParser.is_none-229"><a href="#TypeParser.is_none-229"><span class="linenos">229</span></a>
-</span><span id="TypeParser.is_none-230"><a href="#TypeParser.is_none-230"><span class="linenos">230</span></a><span class="sd">			Parameters</span>
-</span><span id="TypeParser.is_none-231"><a href="#TypeParser.is_none-231"><span class="linenos">231</span></a><span class="sd">			----------</span>
-</span><span id="TypeParser.is_none-232"><a href="#TypeParser.is_none-232"><span class="linenos">232</span></a><span class="sd">			`value`</span>
-</span><span id="TypeParser.is_none-233"><a href="#TypeParser.is_none-233"><span class="linenos">233</span></a><span class="sd">			: string to be checked</span>
-</span><span id="TypeParser.is_none-234"><a href="#TypeParser.is_none-234"><span class="linenos">234</span></a>
-</span><span id="TypeParser.is_none-235"><a href="#TypeParser.is_none-235"><span class="linenos">235</span></a><span class="sd">			Returns</span>
-</span><span id="TypeParser.is_none-236"><a href="#TypeParser.is_none-236"><span class="linenos">236</span></a><span class="sd">			-------</span>
-</span><span id="TypeParser.is_none-237"><a href="#TypeParser.is_none-237"><span class="linenos">237</span></a><span class="sd">			whether it is None</span>
-</span><span id="TypeParser.is_none-238"><a href="#TypeParser.is_none-238"><span class="linenos">238</span></a>
-</span><span id="TypeParser.is_none-239"><a href="#TypeParser.is_none-239"><span class="linenos">239</span></a><span class="sd">			Examples</span>
-</span><span id="TypeParser.is_none-240"><a href="#TypeParser.is_none-240"><span class="linenos">240</span></a><span class="sd">			--------</span>
-</span><span id="TypeParser.is_none-241"><a href="#TypeParser.is_none-241"><span class="linenos">241</span></a><span class="sd">			```python</span>
-</span><span id="TypeParser.is_none-242"><a href="#TypeParser.is_none-242"><span class="linenos">242</span></a><span class="sd">			parser = TypeParser()</span>
-</span><span id="TypeParser.is_none-243"><a href="#TypeParser.is_none-243"><span class="linenos">243</span></a><span class="sd">			parser.parse_bool(&quot;&quot;)     # True</span>
-</span><span id="TypeParser.is_none-244"><a href="#TypeParser.is_none-244"><span class="linenos">244</span></a><span class="sd">			parser.parse_bool(&quot;abc&quot;)  # False</span>
-</span><span id="TypeParser.is_none-245"><a href="#TypeParser.is_none-245"><span class="linenos">245</span></a><span class="sd">			```</span>
-</span><span id="TypeParser.is_none-246"><a href="#TypeParser.is_none-246"><span class="linenos">246</span></a><span class="sd">		&quot;&quot;&quot;</span>
-</span><span id="TypeParser.is_none-247"><a href="#TypeParser.is_none-247"><span class="linenos">247</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trim</span><span class="p">:</span>
-</span><span id="TypeParser.is_none-248"><a href="#TypeParser.is_none-248"><span class="linenos">248</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
-</span><span id="TypeParser.is_none-249"><a href="#TypeParser.is_none-249"><span class="linenos">249</span></a>		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">bool_case_sensitive</span><span class="p">:</span>
-</span><span id="TypeParser.is_none-250"><a href="#TypeParser.is_none-250"><span class="linenos">250</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
-</span><span id="TypeParser.is_none-251"><a href="#TypeParser.is_none-251"><span class="linenos">251</span></a>
-</span><span id="TypeParser.is_none-252"><a href="#TypeParser.is_none-252"><span class="linenos">252</span></a>		<span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">none_values</span><span class="p">:</span>
-</span><span id="TypeParser.is_none-253"><a href="#TypeParser.is_none-253"><span class="linenos">253</span></a>			<span class="k">return</span> <span class="kc">True</span>
-</span><span id="TypeParser.is_none-254"><a href="#TypeParser.is_none-254"><span class="linenos">254</span></a>		<span class="k">else</span><span class="p">:</span>
-</span><span id="TypeParser.is_none-255"><a href="#TypeParser.is_none-255"><span class="linenos">255</span></a>			<span class="k">return</span> <span class="kc">False</span>
+            <div class="pdoc-code codehilite"><pre><span></span><span id="TypeParser.is_none-223"><a href="#TypeParser.is_none-223"><span class="linenos">223</span></a>	<span class="k">def</span> <span class="nf">is_none</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
+</span><span id="TypeParser.is_none-224"><a href="#TypeParser.is_none-224"><span class="linenos">224</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
+</span><span id="TypeParser.is_none-225"><a href="#TypeParser.is_none-225"><span class="linenos">225</span></a><span class="sd">			Check if a string represents the value None</span>
+</span><span id="TypeParser.is_none-226"><a href="#TypeParser.is_none-226"><span class="linenos">226</span></a>
+</span><span id="TypeParser.is_none-227"><a href="#TypeParser.is_none-227"><span class="linenos">227</span></a><span class="sd">			Only strings that match the values in `self.none_values` will be interpreted as None. The default accepted values are `[&quot;&quot;]`, i.e. an empty string. The case sensitivity of this matching depends on `self.none_case_sensitive`, which is False by default.</span>
+</span><span id="TypeParser.is_none-228"><a href="#TypeParser.is_none-228"><span class="linenos">228</span></a>
+</span><span id="TypeParser.is_none-229"><a href="#TypeParser.is_none-229"><span class="linenos">229</span></a><span class="sd">			Parameters</span>
+</span><span id="TypeParser.is_none-230"><a href="#TypeParser.is_none-230"><span class="linenos">230</span></a><span class="sd">			----------</span>
+</span><span id="TypeParser.is_none-231"><a href="#TypeParser.is_none-231"><span class="linenos">231</span></a><span class="sd">			`value`</span>
+</span><span id="TypeParser.is_none-232"><a href="#TypeParser.is_none-232"><span class="linenos">232</span></a><span class="sd">			: string to be checked</span>
+</span><span id="TypeParser.is_none-233"><a href="#TypeParser.is_none-233"><span class="linenos">233</span></a>
+</span><span id="TypeParser.is_none-234"><a href="#TypeParser.is_none-234"><span class="linenos">234</span></a><span class="sd">			Returns</span>
+</span><span id="TypeParser.is_none-235"><a href="#TypeParser.is_none-235"><span class="linenos">235</span></a><span class="sd">			-------</span>
+</span><span id="TypeParser.is_none-236"><a href="#TypeParser.is_none-236"><span class="linenos">236</span></a><span class="sd">			whether it is None</span>
+</span><span id="TypeParser.is_none-237"><a href="#TypeParser.is_none-237"><span class="linenos">237</span></a>
+</span><span id="TypeParser.is_none-238"><a href="#TypeParser.is_none-238"><span class="linenos">238</span></a><span class="sd">			Examples</span>
+</span><span id="TypeParser.is_none-239"><a href="#TypeParser.is_none-239"><span class="linenos">239</span></a><span class="sd">			--------</span>
+</span><span id="TypeParser.is_none-240"><a href="#TypeParser.is_none-240"><span class="linenos">240</span></a><span class="sd">			```python</span>
+</span><span id="TypeParser.is_none-241"><a href="#TypeParser.is_none-241"><span class="linenos">241</span></a><span class="sd">			parser = TypeParser()</span>
+</span><span id="TypeParser.is_none-242"><a href="#TypeParser.is_none-242"><span class="linenos">242</span></a><span class="sd">			parser.parse_bool(&quot;&quot;)     # True</span>
+</span><span id="TypeParser.is_none-243"><a href="#TypeParser.is_none-243"><span class="linenos">243</span></a><span class="sd">			parser.parse_bool(&quot;abc&quot;)  # False</span>
+</span><span id="TypeParser.is_none-244"><a href="#TypeParser.is_none-244"><span class="linenos">244</span></a><span class="sd">			```</span>
+</span><span id="TypeParser.is_none-245"><a href="#TypeParser.is_none-245"><span class="linenos">245</span></a><span class="sd">		&quot;&quot;&quot;</span>
+</span><span id="TypeParser.is_none-246"><a href="#TypeParser.is_none-246"><span class="linenos">246</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trim</span><span class="p">:</span>
+</span><span id="TypeParser.is_none-247"><a href="#TypeParser.is_none-247"><span class="linenos">247</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
+</span><span id="TypeParser.is_none-248"><a href="#TypeParser.is_none-248"><span class="linenos">248</span></a>		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">bool_case_sensitive</span><span class="p">:</span>
+</span><span id="TypeParser.is_none-249"><a href="#TypeParser.is_none-249"><span class="linenos">249</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
+</span><span id="TypeParser.is_none-250"><a href="#TypeParser.is_none-250"><span class="linenos">250</span></a>
+</span><span id="TypeParser.is_none-251"><a href="#TypeParser.is_none-251"><span class="linenos">251</span></a>		<span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">none_values</span><span class="p">:</span>
+</span><span id="TypeParser.is_none-252"><a href="#TypeParser.is_none-252"><span class="linenos">252</span></a>			<span class="k">return</span> <span class="kc">True</span>
+</span><span id="TypeParser.is_none-253"><a href="#TypeParser.is_none-253"><span class="linenos">253</span></a>		<span class="k">else</span><span class="p">:</span>
+</span><span id="TypeParser.is_none-254"><a href="#TypeParser.is_none-254"><span class="linenos">254</span></a>			<span class="k">return</span> <span class="kc">False</span>
 </span></pre></div>
 
 
     <div class="docstring">
 <p>Check if a string represents the value None</p>
 
 <p>Only strings that match the values in <code>self.none_values</code> will be interpreted as None. The default accepted values are <code>[""]</code>, i.e. an empty string. The case sensitivity of this matching depends on <code>self.none_case_sensitive</code>, which is False by default.</p>
@@ -1477,49 +1477,49 @@
         <span class="name">is_bool</span><span class="signature pdoc-code condensed">(<span class="param"><span class="bp">self</span>, </span><span class="param"><span class="n">value</span><span class="p">:</span> <span class="nb">str</span></span><span class="return-annotation">) -> <span class="nb">bool</span>:</span></span>
 
 
                 <label class="view-source-button" for="TypeParser.is_bool-view-source"><span>View Source</span></label>
 
     </div>
     <a class="headerlink" href="#TypeParser.is_bool"></a>
-            <div class="pdoc-code codehilite"><pre><span></span><span id="TypeParser.is_bool-258"><a href="#TypeParser.is_bool-258"><span class="linenos">258</span></a>	<span class="k">def</span> <span class="nf">is_bool</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
-</span><span id="TypeParser.is_bool-259"><a href="#TypeParser.is_bool-259"><span class="linenos">259</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
-</span><span id="TypeParser.is_bool-260"><a href="#TypeParser.is_bool-260"><span class="linenos">260</span></a><span class="sd">			Check if a string represents a bool</span>
-</span><span id="TypeParser.is_bool-261"><a href="#TypeParser.is_bool-261"><span class="linenos">261</span></a>
-</span><span id="TypeParser.is_bool-262"><a href="#TypeParser.is_bool-262"><span class="linenos">262</span></a><span class="sd">			Only strings that match the values in `self.true_values` and `self.false_values` will be interpreted as booleans. The default accepted values are `[&quot;true&quot;]` and `[&quot;false&quot;]` respectively. The case sensitivity of this matching depends on `self.bool_case_sensitive`, which is False by default.</span>
-</span><span id="TypeParser.is_bool-263"><a href="#TypeParser.is_bool-263"><span class="linenos">263</span></a>
-</span><span id="TypeParser.is_bool-264"><a href="#TypeParser.is_bool-264"><span class="linenos">264</span></a><span class="sd">			Parameters</span>
-</span><span id="TypeParser.is_bool-265"><a href="#TypeParser.is_bool-265"><span class="linenos">265</span></a><span class="sd">			----------</span>
-</span><span id="TypeParser.is_bool-266"><a href="#TypeParser.is_bool-266"><span class="linenos">266</span></a><span class="sd">			`value`</span>
-</span><span id="TypeParser.is_bool-267"><a href="#TypeParser.is_bool-267"><span class="linenos">267</span></a><span class="sd">			: string to be checked</span>
-</span><span id="TypeParser.is_bool-268"><a href="#TypeParser.is_bool-268"><span class="linenos">268</span></a>
-</span><span id="TypeParser.is_bool-269"><a href="#TypeParser.is_bool-269"><span class="linenos">269</span></a><span class="sd">			Returns</span>
-</span><span id="TypeParser.is_bool-270"><a href="#TypeParser.is_bool-270"><span class="linenos">270</span></a><span class="sd">			-------</span>
-</span><span id="TypeParser.is_bool-271"><a href="#TypeParser.is_bool-271"><span class="linenos">271</span></a><span class="sd">			whether it is a bool</span>
-</span><span id="TypeParser.is_bool-272"><a href="#TypeParser.is_bool-272"><span class="linenos">272</span></a>
-</span><span id="TypeParser.is_bool-273"><a href="#TypeParser.is_bool-273"><span class="linenos">273</span></a><span class="sd">			Examples</span>
-</span><span id="TypeParser.is_bool-274"><a href="#TypeParser.is_bool-274"><span class="linenos">274</span></a><span class="sd">			--------</span>
-</span><span id="TypeParser.is_bool-275"><a href="#TypeParser.is_bool-275"><span class="linenos">275</span></a><span class="sd">			```python</span>
-</span><span id="TypeParser.is_bool-276"><a href="#TypeParser.is_bool-276"><span class="linenos">276</span></a><span class="sd">			parser = TypeParser()</span>
-</span><span id="TypeParser.is_bool-277"><a href="#TypeParser.is_bool-277"><span class="linenos">277</span></a><span class="sd">			parser.is_bool(&quot;true&quot;)  # True</span>
-</span><span id="TypeParser.is_bool-278"><a href="#TypeParser.is_bool-278"><span class="linenos">278</span></a><span class="sd">			parser.is_bool(&quot;&quot;)      # True</span>
-</span><span id="TypeParser.is_bool-279"><a href="#TypeParser.is_bool-279"><span class="linenos">279</span></a><span class="sd">			parser.is_bool(&quot;abc&quot;)   # False</span>
-</span><span id="TypeParser.is_bool-280"><a href="#TypeParser.is_bool-280"><span class="linenos">280</span></a><span class="sd">			```</span>
-</span><span id="TypeParser.is_bool-281"><a href="#TypeParser.is_bool-281"><span class="linenos">281</span></a><span class="sd">		&quot;&quot;&quot;</span>
-</span><span id="TypeParser.is_bool-282"><a href="#TypeParser.is_bool-282"><span class="linenos">282</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trim</span><span class="p">:</span>
-</span><span id="TypeParser.is_bool-283"><a href="#TypeParser.is_bool-283"><span class="linenos">283</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
-</span><span id="TypeParser.is_bool-284"><a href="#TypeParser.is_bool-284"><span class="linenos">284</span></a>
-</span><span id="TypeParser.is_bool-285"><a href="#TypeParser.is_bool-285"><span class="linenos">285</span></a>		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">bool_case_sensitive</span><span class="p">:</span>
-</span><span id="TypeParser.is_bool-286"><a href="#TypeParser.is_bool-286"><span class="linenos">286</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
-</span><span id="TypeParser.is_bool-287"><a href="#TypeParser.is_bool-287"><span class="linenos">287</span></a>		<span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">true_values</span><span class="p">:</span>
-</span><span id="TypeParser.is_bool-288"><a href="#TypeParser.is_bool-288"><span class="linenos">288</span></a>			<span class="k">return</span> <span class="kc">True</span>
-</span><span id="TypeParser.is_bool-289"><a href="#TypeParser.is_bool-289"><span class="linenos">289</span></a>		<span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">false_values</span><span class="p">:</span>
-</span><span id="TypeParser.is_bool-290"><a href="#TypeParser.is_bool-290"><span class="linenos">290</span></a>			<span class="k">return</span> <span class="kc">True</span>
-</span><span id="TypeParser.is_bool-291"><a href="#TypeParser.is_bool-291"><span class="linenos">291</span></a>
-</span><span id="TypeParser.is_bool-292"><a href="#TypeParser.is_bool-292"><span class="linenos">292</span></a>		<span class="k">return</span> <span class="kc">False</span>
+            <div class="pdoc-code codehilite"><pre><span></span><span id="TypeParser.is_bool-257"><a href="#TypeParser.is_bool-257"><span class="linenos">257</span></a>	<span class="k">def</span> <span class="nf">is_bool</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
+</span><span id="TypeParser.is_bool-258"><a href="#TypeParser.is_bool-258"><span class="linenos">258</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
+</span><span id="TypeParser.is_bool-259"><a href="#TypeParser.is_bool-259"><span class="linenos">259</span></a><span class="sd">			Check if a string represents a bool</span>
+</span><span id="TypeParser.is_bool-260"><a href="#TypeParser.is_bool-260"><span class="linenos">260</span></a>
+</span><span id="TypeParser.is_bool-261"><a href="#TypeParser.is_bool-261"><span class="linenos">261</span></a><span class="sd">			Only strings that match the values in `self.true_values` and `self.false_values` will be interpreted as booleans. The default accepted values are `[&quot;true&quot;]` and `[&quot;false&quot;]` respectively. The case sensitivity of this matching depends on `self.bool_case_sensitive`, which is False by default.</span>
+</span><span id="TypeParser.is_bool-262"><a href="#TypeParser.is_bool-262"><span class="linenos">262</span></a>
+</span><span id="TypeParser.is_bool-263"><a href="#TypeParser.is_bool-263"><span class="linenos">263</span></a><span class="sd">			Parameters</span>
+</span><span id="TypeParser.is_bool-264"><a href="#TypeParser.is_bool-264"><span class="linenos">264</span></a><span class="sd">			----------</span>
+</span><span id="TypeParser.is_bool-265"><a href="#TypeParser.is_bool-265"><span class="linenos">265</span></a><span class="sd">			`value`</span>
+</span><span id="TypeParser.is_bool-266"><a href="#TypeParser.is_bool-266"><span class="linenos">266</span></a><span class="sd">			: string to be checked</span>
+</span><span id="TypeParser.is_bool-267"><a href="#TypeParser.is_bool-267"><span class="linenos">267</span></a>
+</span><span id="TypeParser.is_bool-268"><a href="#TypeParser.is_bool-268"><span class="linenos">268</span></a><span class="sd">			Returns</span>
+</span><span id="TypeParser.is_bool-269"><a href="#TypeParser.is_bool-269"><span class="linenos">269</span></a><span class="sd">			-------</span>
+</span><span id="TypeParser.is_bool-270"><a href="#TypeParser.is_bool-270"><span class="linenos">270</span></a><span class="sd">			whether it is a bool</span>
+</span><span id="TypeParser.is_bool-271"><a href="#TypeParser.is_bool-271"><span class="linenos">271</span></a>
+</span><span id="TypeParser.is_bool-272"><a href="#TypeParser.is_bool-272"><span class="linenos">272</span></a><span class="sd">			Examples</span>
+</span><span id="TypeParser.is_bool-273"><a href="#TypeParser.is_bool-273"><span class="linenos">273</span></a><span class="sd">			--------</span>
+</span><span id="TypeParser.is_bool-274"><a href="#TypeParser.is_bool-274"><span class="linenos">274</span></a><span class="sd">			```python</span>
+</span><span id="TypeParser.is_bool-275"><a href="#TypeParser.is_bool-275"><span class="linenos">275</span></a><span class="sd">			parser = TypeParser()</span>
+</span><span id="TypeParser.is_bool-276"><a href="#TypeParser.is_bool-276"><span class="linenos">276</span></a><span class="sd">			parser.is_bool(&quot;true&quot;)  # True</span>
+</span><span id="TypeParser.is_bool-277"><a href="#TypeParser.is_bool-277"><span class="linenos">277</span></a><span class="sd">			parser.is_bool(&quot;&quot;)      # True</span>
+</span><span id="TypeParser.is_bool-278"><a href="#TypeParser.is_bool-278"><span class="linenos">278</span></a><span class="sd">			parser.is_bool(&quot;abc&quot;)   # False</span>
+</span><span id="TypeParser.is_bool-279"><a href="#TypeParser.is_bool-279"><span class="linenos">279</span></a><span class="sd">			```</span>
+</span><span id="TypeParser.is_bool-280"><a href="#TypeParser.is_bool-280"><span class="linenos">280</span></a><span class="sd">		&quot;&quot;&quot;</span>
+</span><span id="TypeParser.is_bool-281"><a href="#TypeParser.is_bool-281"><span class="linenos">281</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trim</span><span class="p">:</span>
+</span><span id="TypeParser.is_bool-282"><a href="#TypeParser.is_bool-282"><span class="linenos">282</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
+</span><span id="TypeParser.is_bool-283"><a href="#TypeParser.is_bool-283"><span class="linenos">283</span></a>
+</span><span id="TypeParser.is_bool-284"><a href="#TypeParser.is_bool-284"><span class="linenos">284</span></a>		<span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">bool_case_sensitive</span><span class="p">:</span>
+</span><span id="TypeParser.is_bool-285"><a href="#TypeParser.is_bool-285"><span class="linenos">285</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
+</span><span id="TypeParser.is_bool-286"><a href="#TypeParser.is_bool-286"><span class="linenos">286</span></a>		<span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">true_values</span><span class="p">:</span>
+</span><span id="TypeParser.is_bool-287"><a href="#TypeParser.is_bool-287"><span class="linenos">287</span></a>			<span class="k">return</span> <span class="kc">True</span>
+</span><span id="TypeParser.is_bool-288"><a href="#TypeParser.is_bool-288"><span class="linenos">288</span></a>		<span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">false_values</span><span class="p">:</span>
+</span><span id="TypeParser.is_bool-289"><a href="#TypeParser.is_bool-289"><span class="linenos">289</span></a>			<span class="k">return</span> <span class="kc">True</span>
+</span><span id="TypeParser.is_bool-290"><a href="#TypeParser.is_bool-290"><span class="linenos">290</span></a>
+</span><span id="TypeParser.is_bool-291"><a href="#TypeParser.is_bool-291"><span class="linenos">291</span></a>		<span class="k">return</span> <span class="kc">False</span>
 </span></pre></div>
 
 
     <div class="docstring">
 <p>Check if a string represents a bool</p>
 
 <p>Only strings that match the values in <code>self.true_values</code> and <code>self.false_values</code> will be interpreted as booleans. The default accepted values are <code>["true"]</code> and <code>["false"]</code> respectively. The case sensitivity of this matching depends on <code>self.bool_case_sensitive</code>, which is False by default.</p>
@@ -1554,83 +1554,83 @@
         <span class="name">is_int</span><span class="signature pdoc-code multiline">(<span class="param">	<span class="bp">self</span>,</span><span class="param">	<span class="n">value</span><span class="p">:</span> <span class="nb">str</span>,</span><span class="param">	<span class="o">*</span>,</span><span class="param">	<span class="n">allow_sign</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>,</span><span class="param">	<span class="n">allow_negative</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>,</span><span class="param">	<span class="n">allow_scientific</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span></span><span class="return-annotation">) -> <span class="nb">bool</span>:</span></span>
 
 
                 <label class="view-source-button" for="TypeParser.is_int-view-source"><span>View Source</span></label>
 
     </div>
     <a class="headerlink" href="#TypeParser.is_int"></a>
-            <div class="pdoc-code codehilite"><pre><span></span><span id="TypeParser.is_int-295"><a href="#TypeParser.is_int-295"><span class="linenos">295</span></a>	<span class="k">def</span> <span class="nf">is_int</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">allow_sign</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_negative</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
-</span><span id="TypeParser.is_int-296"><a href="#TypeParser.is_int-296"><span class="linenos">296</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
-</span><span id="TypeParser.is_int-297"><a href="#TypeParser.is_int-297"><span class="linenos">297</span></a><span class="sd">			Check if a string represents an int</span>
-</span><span id="TypeParser.is_int-298"><a href="#TypeParser.is_int-298"><span class="linenos">298</span></a>
-</span><span id="TypeParser.is_int-299"><a href="#TypeParser.is_int-299"><span class="linenos">299</span></a><span class="sd">			Parameters</span>
-</span><span id="TypeParser.is_int-300"><a href="#TypeParser.is_int-300"><span class="linenos">300</span></a><span class="sd">			----------</span>
-</span><span id="TypeParser.is_int-301"><a href="#TypeParser.is_int-301"><span class="linenos">301</span></a><span class="sd">			`value`</span>
-</span><span id="TypeParser.is_int-302"><a href="#TypeParser.is_int-302"><span class="linenos">302</span></a><span class="sd">			: string to be checked</span>
-</span><span id="TypeParser.is_int-303"><a href="#TypeParser.is_int-303"><span class="linenos">303</span></a>
-</span><span id="TypeParser.is_int-304"><a href="#TypeParser.is_int-304"><span class="linenos">304</span></a><span class="sd">			`allow_negative`</span>
-</span><span id="TypeParser.is_int-305"><a href="#TypeParser.is_int-305"><span class="linenos">305</span></a><span class="sd">			: whether to accept negative values</span>
-</span><span id="TypeParser.is_int-306"><a href="#TypeParser.is_int-306"><span class="linenos">306</span></a>
-</span><span id="TypeParser.is_int-307"><a href="#TypeParser.is_int-307"><span class="linenos">307</span></a><span class="sd">			`allow_sign`</span>
-</span><span id="TypeParser.is_int-308"><a href="#TypeParser.is_int-308"><span class="linenos">308</span></a><span class="sd">			: whether to accept signed values. If False, it implies that `allow_negative` is False also.</span>
-</span><span id="TypeParser.is_int-309"><a href="#TypeParser.is_int-309"><span class="linenos">309</span></a>
-</span><span id="TypeParser.is_int-310"><a href="#TypeParser.is_int-310"><span class="linenos">310</span></a><span class="sd">			`allow_scientific`</span>
-</span><span id="TypeParser.is_int-311"><a href="#TypeParser.is_int-311"><span class="linenos">311</span></a><span class="sd">			: whether to accept scientific notation. If True, strings of the form `&quot;&lt;var&gt;M&lt;/var&gt;e&lt;var&gt;X&lt;/var&gt;&quot;` will be interpreted as the expression `&lt;var&gt;M&lt;/var&gt; * (10 ** &lt;var&gt;X&lt;/var&gt;)`, where &lt;var&gt;M&lt;/var&gt; is the mantissa/significand and &lt;var&gt;X&lt;/var&gt; is the exponent. Note &lt;var&gt;M&lt;/var&gt; *must* be an integer and &lt;var&gt;X&lt;/var&gt; *must* be a non-negative integer, even in cases where the above expression evaluates mathematically to an integer.</span>
-</span><span id="TypeParser.is_int-312"><a href="#TypeParser.is_int-312"><span class="linenos">312</span></a>
-</span><span id="TypeParser.is_int-313"><a href="#TypeParser.is_int-313"><span class="linenos">313</span></a><span class="sd">			Returns</span>
-</span><span id="TypeParser.is_int-314"><a href="#TypeParser.is_int-314"><span class="linenos">314</span></a><span class="sd">			-------</span>
-</span><span id="TypeParser.is_int-315"><a href="#TypeParser.is_int-315"><span class="linenos">315</span></a><span class="sd">			whether it is an int</span>
-</span><span id="TypeParser.is_int-316"><a href="#TypeParser.is_int-316"><span class="linenos">316</span></a>
-</span><span id="TypeParser.is_int-317"><a href="#TypeParser.is_int-317"><span class="linenos">317</span></a><span class="sd">			Examples</span>
-</span><span id="TypeParser.is_int-318"><a href="#TypeParser.is_int-318"><span class="linenos">318</span></a><span class="sd">			--------</span>
-</span><span id="TypeParser.is_int-319"><a href="#TypeParser.is_int-319"><span class="linenos">319</span></a><span class="sd">			```python</span>
-</span><span id="TypeParser.is_int-320"><a href="#TypeParser.is_int-320"><span class="linenos">320</span></a><span class="sd">			parser = TypeParser()</span>
-</span><span id="TypeParser.is_int-321"><a href="#TypeParser.is_int-321"><span class="linenos">321</span></a><span class="sd">			parser.is_int(&quot;0&quot;)    # True</span>
-</span><span id="TypeParser.is_int-322"><a href="#TypeParser.is_int-322"><span class="linenos">322</span></a><span class="sd">			parser.is_int(&quot;-1&quot;)   # True</span>
-</span><span id="TypeParser.is_int-323"><a href="#TypeParser.is_int-323"><span class="linenos">323</span></a><span class="sd">			parser.is_int(&quot;abc&quot;)  # False</span>
-</span><span id="TypeParser.is_int-324"><a href="#TypeParser.is_int-324"><span class="linenos">324</span></a><span class="sd">			parser.is_int(&quot;&quot;)     # False</span>
-</span><span id="TypeParser.is_int-325"><a href="#TypeParser.is_int-325"><span class="linenos">325</span></a><span class="sd">			```</span>
-</span><span id="TypeParser.is_int-326"><a href="#TypeParser.is_int-326"><span class="linenos">326</span></a><span class="sd">		&quot;&quot;&quot;</span>
-</span><span id="TypeParser.is_int-327"><a href="#TypeParser.is_int-327"><span class="linenos">327</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trim</span><span class="p">:</span>
-</span><span id="TypeParser.is_int-328"><a href="#TypeParser.is_int-328"><span class="linenos">328</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
-</span><span id="TypeParser.is_int-329"><a href="#TypeParser.is_int-329"><span class="linenos">329</span></a>
-</span><span id="TypeParser.is_int-330"><a href="#TypeParser.is_int-330"><span class="linenos">330</span></a>		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
-</span><span id="TypeParser.is_int-331"><a href="#TypeParser.is_int-331"><span class="linenos">331</span></a>			<span class="k">return</span> <span class="kc">False</span>
-</span><span id="TypeParser.is_int-332"><a href="#TypeParser.is_int-332"><span class="linenos">332</span></a>
-</span><span id="TypeParser.is_int-333"><a href="#TypeParser.is_int-333"><span class="linenos">333</span></a>		<span class="k">if</span> <span class="n">allow_scientific</span><span class="p">:</span>
-</span><span id="TypeParser.is_int-334"><a href="#TypeParser.is_int-334"><span class="linenos">334</span></a>			<span class="n">value</span><span class="p">,</span> <span class="n">exp</span> <span class="o">=</span> <span class="n">_decompose_string_pair</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scientific_char</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">int_case_sensitive</span><span class="p">)</span>
-</span><span id="TypeParser.is_int-335"><a href="#TypeParser.is_int-335"><span class="linenos">335</span></a>			<span class="k">if</span> <span class="n">exp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
-</span><span id="TypeParser.is_int-336"><a href="#TypeParser.is_int-336"><span class="linenos">336</span></a>				<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_int</span><span class="p">(</span>
-</span><span id="TypeParser.is_int-337"><a href="#TypeParser.is_int-337"><span class="linenos">337</span></a>					<span class="n">value</span><span class="p">,</span> <span class="n">allow_sign</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_negative</span><span class="o">=</span><span class="n">allow_negative</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="o">=</span><span class="kc">False</span>
-</span><span id="TypeParser.is_int-338"><a href="#TypeParser.is_int-338"><span class="linenos">338</span></a>				<span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_int</span><span class="p">(</span>
-</span><span id="TypeParser.is_int-339"><a href="#TypeParser.is_int-339"><span class="linenos">339</span></a>					<span class="n">exp</span><span class="p">,</span> <span class="n">allow_sign</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_negative</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="o">=</span><span class="kc">False</span>
-</span><span id="TypeParser.is_int-340"><a href="#TypeParser.is_int-340"><span class="linenos">340</span></a>				<span class="p">)</span>
-</span><span id="TypeParser.is_int-341"><a href="#TypeParser.is_int-341"><span class="linenos">341</span></a>
-</span><span id="TypeParser.is_int-342"><a href="#TypeParser.is_int-342"><span class="linenos">342</span></a>		<span class="k">if</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sign_chars</span><span class="p">:</span>
-</span><span id="TypeParser.is_int-343"><a href="#TypeParser.is_int-343"><span class="linenos">343</span></a>			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
-</span><span id="TypeParser.is_int-344"><a href="#TypeParser.is_int-344"><span class="linenos">344</span></a>				<span class="k">return</span> <span class="kc">False</span>
-</span><span id="TypeParser.is_int-345"><a href="#TypeParser.is_int-345"><span class="linenos">345</span></a>			<span class="k">if</span> <span class="ow">not</span> <span class="n">allow_sign</span><span class="p">:</span>
-</span><span id="TypeParser.is_int-346"><a href="#TypeParser.is_int-346"><span class="linenos">346</span></a>				<span class="k">return</span> <span class="kc">False</span>
-</span><span id="TypeParser.is_int-347"><a href="#TypeParser.is_int-347"><span class="linenos">347</span></a>			<span class="k">if</span> <span class="ow">not</span> <span class="n">allow_negative</span> <span class="ow">and</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_negative_chars</span><span class="p">:</span>
-</span><span id="TypeParser.is_int-348"><a href="#TypeParser.is_int-348"><span class="linenos">348</span></a>				<span class="k">return</span> <span class="kc">False</span>
-</span><span id="TypeParser.is_int-349"><a href="#TypeParser.is_int-349"><span class="linenos">349</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
-</span><span id="TypeParser.is_int-350"><a href="#TypeParser.is_int-350"><span class="linenos">350</span></a>		<span class="k">if</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_digit_separators</span> <span class="ow">or</span> <span class="n">value</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_digit_separators</span><span class="p">:</span>
-</span><span id="TypeParser.is_int-351"><a href="#TypeParser.is_int-351"><span class="linenos">351</span></a>			<span class="k">return</span> <span class="kc">False</span>
-</span><span id="TypeParser.is_int-352"><a href="#TypeParser.is_int-352"><span class="linenos">352</span></a>
-</span><span id="TypeParser.is_int-353"><a href="#TypeParser.is_int-353"><span class="linenos">353</span></a>		<span class="n">prev_separated</span> <span class="o">=</span> <span class="kc">False</span>
-</span><span id="TypeParser.is_int-354"><a href="#TypeParser.is_int-354"><span class="linenos">354</span></a>		<span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
-</span><span id="TypeParser.is_int-355"><a href="#TypeParser.is_int-355"><span class="linenos">355</span></a>			<span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_digit_separators</span><span class="p">:</span>
-</span><span id="TypeParser.is_int-356"><a href="#TypeParser.is_int-356"><span class="linenos">356</span></a>				<span class="k">if</span> <span class="n">prev_separated</span><span class="p">:</span>
-</span><span id="TypeParser.is_int-357"><a href="#TypeParser.is_int-357"><span class="linenos">357</span></a>					<span class="k">return</span> <span class="kc">False</span>
-</span><span id="TypeParser.is_int-358"><a href="#TypeParser.is_int-358"><span class="linenos">358</span></a>				<span class="n">prev_separated</span> <span class="o">=</span> <span class="kc">True</span>
-</span><span id="TypeParser.is_int-359"><a href="#TypeParser.is_int-359"><span class="linenos">359</span></a>			<span class="k">else</span><span class="p">:</span>
-</span><span id="TypeParser.is_int-360"><a href="#TypeParser.is_int-360"><span class="linenos">360</span></a>				<span class="n">prev_separated</span> <span class="o">=</span> <span class="kc">False</span>
-</span><span id="TypeParser.is_int-361"><a href="#TypeParser.is_int-361"><span class="linenos">361</span></a>				<span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_digit_chars</span><span class="p">:</span>
-</span><span id="TypeParser.is_int-362"><a href="#TypeParser.is_int-362"><span class="linenos">362</span></a>					<span class="k">return</span> <span class="kc">False</span>
-</span><span id="TypeParser.is_int-363"><a href="#TypeParser.is_int-363"><span class="linenos">363</span></a>		<span class="k">return</span> <span class="kc">True</span>
+            <div class="pdoc-code codehilite"><pre><span></span><span id="TypeParser.is_int-294"><a href="#TypeParser.is_int-294"><span class="linenos">294</span></a>	<span class="k">def</span> <span class="nf">is_int</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">allow_sign</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_negative</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
+</span><span id="TypeParser.is_int-295"><a href="#TypeParser.is_int-295"><span class="linenos">295</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
+</span><span id="TypeParser.is_int-296"><a href="#TypeParser.is_int-296"><span class="linenos">296</span></a><span class="sd">			Check if a string represents an int</span>
+</span><span id="TypeParser.is_int-297"><a href="#TypeParser.is_int-297"><span class="linenos">297</span></a>
+</span><span id="TypeParser.is_int-298"><a href="#TypeParser.is_int-298"><span class="linenos">298</span></a><span class="sd">			Parameters</span>
+</span><span id="TypeParser.is_int-299"><a href="#TypeParser.is_int-299"><span class="linenos">299</span></a><span class="sd">			----------</span>
+</span><span id="TypeParser.is_int-300"><a href="#TypeParser.is_int-300"><span class="linenos">300</span></a><span class="sd">			`value`</span>
+</span><span id="TypeParser.is_int-301"><a href="#TypeParser.is_int-301"><span class="linenos">301</span></a><span class="sd">			: string to be checked</span>
+</span><span id="TypeParser.is_int-302"><a href="#TypeParser.is_int-302"><span class="linenos">302</span></a>
+</span><span id="TypeParser.is_int-303"><a href="#TypeParser.is_int-303"><span class="linenos">303</span></a><span class="sd">			`allow_negative`</span>
+</span><span id="TypeParser.is_int-304"><a href="#TypeParser.is_int-304"><span class="linenos">304</span></a><span class="sd">			: whether to accept negative values</span>
+</span><span id="TypeParser.is_int-305"><a href="#TypeParser.is_int-305"><span class="linenos">305</span></a>
+</span><span id="TypeParser.is_int-306"><a href="#TypeParser.is_int-306"><span class="linenos">306</span></a><span class="sd">			`allow_sign`</span>
+</span><span id="TypeParser.is_int-307"><a href="#TypeParser.is_int-307"><span class="linenos">307</span></a><span class="sd">			: whether to accept signed values. If False, it implies that `allow_negative` is False also.</span>
+</span><span id="TypeParser.is_int-308"><a href="#TypeParser.is_int-308"><span class="linenos">308</span></a>
+</span><span id="TypeParser.is_int-309"><a href="#TypeParser.is_int-309"><span class="linenos">309</span></a><span class="sd">			`allow_scientific`</span>
+</span><span id="TypeParser.is_int-310"><a href="#TypeParser.is_int-310"><span class="linenos">310</span></a><span class="sd">			: whether to accept scientific notation. If True, strings of the form `&quot;&lt;var&gt;M&lt;/var&gt;e&lt;var&gt;X&lt;/var&gt;&quot;` will be interpreted as the expression `&lt;var&gt;M&lt;/var&gt; * (10 ** &lt;var&gt;X&lt;/var&gt;)`, where &lt;var&gt;M&lt;/var&gt; is the mantissa/significand and &lt;var&gt;X&lt;/var&gt; is the exponent. Note &lt;var&gt;M&lt;/var&gt; *must* be an integer and &lt;var&gt;X&lt;/var&gt; *must* be a non-negative integer, even in cases where the above expression evaluates mathematically to an integer.</span>
+</span><span id="TypeParser.is_int-311"><a href="#TypeParser.is_int-311"><span class="linenos">311</span></a>
+</span><span id="TypeParser.is_int-312"><a href="#TypeParser.is_int-312"><span class="linenos">312</span></a><span class="sd">			Returns</span>
+</span><span id="TypeParser.is_int-313"><a href="#TypeParser.is_int-313"><span class="linenos">313</span></a><span class="sd">			-------</span>
+</span><span id="TypeParser.is_int-314"><a href="#TypeParser.is_int-314"><span class="linenos">314</span></a><span class="sd">			whether it is an int</span>
+</span><span id="TypeParser.is_int-315"><a href="#TypeParser.is_int-315"><span class="linenos">315</span></a>
+</span><span id="TypeParser.is_int-316"><a href="#TypeParser.is_int-316"><span class="linenos">316</span></a><span class="sd">			Examples</span>
+</span><span id="TypeParser.is_int-317"><a href="#TypeParser.is_int-317"><span class="linenos">317</span></a><span class="sd">			--------</span>
+</span><span id="TypeParser.is_int-318"><a href="#TypeParser.is_int-318"><span class="linenos">318</span></a><span class="sd">			```python</span>
+</span><span id="TypeParser.is_int-319"><a href="#TypeParser.is_int-319"><span class="linenos">319</span></a><span class="sd">			parser = TypeParser()</span>
+</span><span id="TypeParser.is_int-320"><a href="#TypeParser.is_int-320"><span class="linenos">320</span></a><span class="sd">			parser.is_int(&quot;0&quot;)    # True</span>
+</span><span id="TypeParser.is_int-321"><a href="#TypeParser.is_int-321"><span class="linenos">321</span></a><span class="sd">			parser.is_int(&quot;-1&quot;)   # True</span>
+</span><span id="TypeParser.is_int-322"><a href="#TypeParser.is_int-322"><span class="linenos">322</span></a><span class="sd">			parser.is_int(&quot;abc&quot;)  # False</span>
+</span><span id="TypeParser.is_int-323"><a href="#TypeParser.is_int-323"><span class="linenos">323</span></a><span class="sd">			parser.is_int(&quot;&quot;)     # False</span>
+</span><span id="TypeParser.is_int-324"><a href="#TypeParser.is_int-324"><span class="linenos">324</span></a><span class="sd">			```</span>
+</span><span id="TypeParser.is_int-325"><a href="#TypeParser.is_int-325"><span class="linenos">325</span></a><span class="sd">		&quot;&quot;&quot;</span>
+</span><span id="TypeParser.is_int-326"><a href="#TypeParser.is_int-326"><span class="linenos">326</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trim</span><span class="p">:</span>
+</span><span id="TypeParser.is_int-327"><a href="#TypeParser.is_int-327"><span class="linenos">327</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
+</span><span id="TypeParser.is_int-328"><a href="#TypeParser.is_int-328"><span class="linenos">328</span></a>
+</span><span id="TypeParser.is_int-329"><a href="#TypeParser.is_int-329"><span class="linenos">329</span></a>		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
+</span><span id="TypeParser.is_int-330"><a href="#TypeParser.is_int-330"><span class="linenos">330</span></a>			<span class="k">return</span> <span class="kc">False</span>
+</span><span id="TypeParser.is_int-331"><a href="#TypeParser.is_int-331"><span class="linenos">331</span></a>
+</span><span id="TypeParser.is_int-332"><a href="#TypeParser.is_int-332"><span class="linenos">332</span></a>		<span class="k">if</span> <span class="n">allow_scientific</span><span class="p">:</span>
+</span><span id="TypeParser.is_int-333"><a href="#TypeParser.is_int-333"><span class="linenos">333</span></a>			<span class="n">value</span><span class="p">,</span> <span class="n">exp</span> <span class="o">=</span> <span class="n">_decompose_string_pair</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scientific_char</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">int_case_sensitive</span><span class="p">)</span>
+</span><span id="TypeParser.is_int-334"><a href="#TypeParser.is_int-334"><span class="linenos">334</span></a>			<span class="k">if</span> <span class="n">exp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
+</span><span id="TypeParser.is_int-335"><a href="#TypeParser.is_int-335"><span class="linenos">335</span></a>				<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_int</span><span class="p">(</span>
+</span><span id="TypeParser.is_int-336"><a href="#TypeParser.is_int-336"><span class="linenos">336</span></a>					<span class="n">value</span><span class="p">,</span> <span class="n">allow_sign</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_negative</span><span class="o">=</span><span class="n">allow_negative</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="o">=</span><span class="kc">False</span>
+</span><span id="TypeParser.is_int-337"><a href="#TypeParser.is_int-337"><span class="linenos">337</span></a>				<span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_int</span><span class="p">(</span>
+</span><span id="TypeParser.is_int-338"><a href="#TypeParser.is_int-338"><span class="linenos">338</span></a>					<span class="n">exp</span><span class="p">,</span> <span class="n">allow_sign</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_negative</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="o">=</span><span class="kc">False</span>
+</span><span id="TypeParser.is_int-339"><a href="#TypeParser.is_int-339"><span class="linenos">339</span></a>				<span class="p">)</span>
+</span><span id="TypeParser.is_int-340"><a href="#TypeParser.is_int-340"><span class="linenos">340</span></a>
+</span><span id="TypeParser.is_int-341"><a href="#TypeParser.is_int-341"><span class="linenos">341</span></a>		<span class="k">if</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sign_chars</span><span class="p">:</span>
+</span><span id="TypeParser.is_int-342"><a href="#TypeParser.is_int-342"><span class="linenos">342</span></a>			<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
+</span><span id="TypeParser.is_int-343"><a href="#TypeParser.is_int-343"><span class="linenos">343</span></a>				<span class="k">return</span> <span class="kc">False</span>
+</span><span id="TypeParser.is_int-344"><a href="#TypeParser.is_int-344"><span class="linenos">344</span></a>			<span class="k">if</span> <span class="ow">not</span> <span class="n">allow_sign</span><span class="p">:</span>
+</span><span id="TypeParser.is_int-345"><a href="#TypeParser.is_int-345"><span class="linenos">345</span></a>				<span class="k">return</span> <span class="kc">False</span>
+</span><span id="TypeParser.is_int-346"><a href="#TypeParser.is_int-346"><span class="linenos">346</span></a>			<span class="k">if</span> <span class="ow">not</span> <span class="n">allow_negative</span> <span class="ow">and</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_negative_chars</span><span class="p">:</span>
+</span><span id="TypeParser.is_int-347"><a href="#TypeParser.is_int-347"><span class="linenos">347</span></a>				<span class="k">return</span> <span class="kc">False</span>
+</span><span id="TypeParser.is_int-348"><a href="#TypeParser.is_int-348"><span class="linenos">348</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
+</span><span id="TypeParser.is_int-349"><a href="#TypeParser.is_int-349"><span class="linenos">349</span></a>		<span class="k">if</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_digit_separators</span> <span class="ow">or</span> <span class="n">value</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_digit_separators</span><span class="p">:</span>
+</span><span id="TypeParser.is_int-350"><a href="#TypeParser.is_int-350"><span class="linenos">350</span></a>			<span class="k">return</span> <span class="kc">False</span>
+</span><span id="TypeParser.is_int-351"><a href="#TypeParser.is_int-351"><span class="linenos">351</span></a>
+</span><span id="TypeParser.is_int-352"><a href="#TypeParser.is_int-352"><span class="linenos">352</span></a>		<span class="n">prev_separated</span> <span class="o">=</span> <span class="kc">False</span>
+</span><span id="TypeParser.is_int-353"><a href="#TypeParser.is_int-353"><span class="linenos">353</span></a>		<span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
+</span><span id="TypeParser.is_int-354"><a href="#TypeParser.is_int-354"><span class="linenos">354</span></a>			<span class="k">if</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_digit_separators</span><span class="p">:</span>
+</span><span id="TypeParser.is_int-355"><a href="#TypeParser.is_int-355"><span class="linenos">355</span></a>				<span class="k">if</span> <span class="n">prev_separated</span><span class="p">:</span>
+</span><span id="TypeParser.is_int-356"><a href="#TypeParser.is_int-356"><span class="linenos">356</span></a>					<span class="k">return</span> <span class="kc">False</span>
+</span><span id="TypeParser.is_int-357"><a href="#TypeParser.is_int-357"><span class="linenos">357</span></a>				<span class="n">prev_separated</span> <span class="o">=</span> <span class="kc">True</span>
+</span><span id="TypeParser.is_int-358"><a href="#TypeParser.is_int-358"><span class="linenos">358</span></a>			<span class="k">else</span><span class="p">:</span>
+</span><span id="TypeParser.is_int-359"><a href="#TypeParser.is_int-359"><span class="linenos">359</span></a>				<span class="n">prev_separated</span> <span class="o">=</span> <span class="kc">False</span>
+</span><span id="TypeParser.is_int-360"><a href="#TypeParser.is_int-360"><span class="linenos">360</span></a>				<span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_digit_chars</span><span class="p">:</span>
+</span><span id="TypeParser.is_int-361"><a href="#TypeParser.is_int-361"><span class="linenos">361</span></a>					<span class="k">return</span> <span class="kc">False</span>
+</span><span id="TypeParser.is_int-362"><a href="#TypeParser.is_int-362"><span class="linenos">362</span></a>		<span class="k">return</span> <span class="kc">True</span>
 </span></pre></div>
 
 
     <div class="docstring">
 <p>Check if a string represents an int</p>
 
 <h2 id="parameters">Parameters</h2>
@@ -1673,84 +1673,84 @@
         <span class="name">is_float</span><span class="signature pdoc-code multiline">(<span class="param">	<span class="bp">self</span>,</span><span class="param">	<span class="n">value</span><span class="p">:</span> <span class="nb">str</span>,</span><span class="param">	<span class="o">*</span>,</span><span class="param">	<span class="n">allow_scientific</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>,</span><span class="param">	<span class="n">allow_inf</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>,</span><span class="param">	<span class="n">allow_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span></span><span class="return-annotation">) -> <span class="nb">bool</span>:</span></span>
 
 
                 <label class="view-source-button" for="TypeParser.is_float-view-source"><span>View Source</span></label>
 
     </div>
     <a class="headerlink" href="#TypeParser.is_float"></a>
-            <div class="pdoc-code codehilite"><pre><span></span><span id="TypeParser.is_float-366"><a href="#TypeParser.is_float-366"><span class="linenos">366</span></a>	<span class="k">def</span> <span class="nf">is_float</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_inf</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_nan</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
-</span><span id="TypeParser.is_float-367"><a href="#TypeParser.is_float-367"><span class="linenos">367</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
-</span><span id="TypeParser.is_float-368"><a href="#TypeParser.is_float-368"><span class="linenos">368</span></a><span class="sd">			Check if a string represents a float (or equivalently, a Decimal)</span>
-</span><span id="TypeParser.is_float-369"><a href="#TypeParser.is_float-369"><span class="linenos">369</span></a>
-</span><span id="TypeParser.is_float-370"><a href="#TypeParser.is_float-370"><span class="linenos">370</span></a><span class="sd">			This function will also return True if the string represents an int.</span>
-</span><span id="TypeParser.is_float-371"><a href="#TypeParser.is_float-371"><span class="linenos">371</span></a>
-</span><span id="TypeParser.is_float-372"><a href="#TypeParser.is_float-372"><span class="linenos">372</span></a><span class="sd">			Alias: `is_decimal()`</span>
-</span><span id="TypeParser.is_float-373"><a href="#TypeParser.is_float-373"><span class="linenos">373</span></a>
-</span><span id="TypeParser.is_float-374"><a href="#TypeParser.is_float-374"><span class="linenos">374</span></a><span class="sd">			Parameters</span>
-</span><span id="TypeParser.is_float-375"><a href="#TypeParser.is_float-375"><span class="linenos">375</span></a><span class="sd">			----------</span>
-</span><span id="TypeParser.is_float-376"><a href="#TypeParser.is_float-376"><span class="linenos">376</span></a><span class="sd">			`value`</span>
-</span><span id="TypeParser.is_float-377"><a href="#TypeParser.is_float-377"><span class="linenos">377</span></a><span class="sd">			: string to be checked</span>
-</span><span id="TypeParser.is_float-378"><a href="#TypeParser.is_float-378"><span class="linenos">378</span></a>
-</span><span id="TypeParser.is_float-379"><a href="#TypeParser.is_float-379"><span class="linenos">379</span></a><span class="sd">			`allow_scientific`</span>
-</span><span id="TypeParser.is_float-380"><a href="#TypeParser.is_float-380"><span class="linenos">380</span></a><span class="sd">			: whether to accept scientific notation. If True, strings of the form `&quot;&lt;var&gt;M&lt;/var&gt;e&lt;var&gt;X&lt;/var&gt;&quot;` will be interpreted as the expression `&lt;var&gt;M&lt;/var&gt; * (10 ** &lt;var&gt;X&lt;/var&gt;)`, where &lt;var&gt;M&lt;/var&gt; is the mantissa/significand and &lt;var&gt;X&lt;/var&gt; is the exponent. Note that &lt;var&gt;X&lt;/var&gt; must be an integer, but can be negative.</span>
-</span><span id="TypeParser.is_float-381"><a href="#TypeParser.is_float-381"><span class="linenos">381</span></a>
-</span><span id="TypeParser.is_float-382"><a href="#TypeParser.is_float-382"><span class="linenos">382</span></a><span class="sd">			`allow_inf`</span>
-</span><span id="TypeParser.is_float-383"><a href="#TypeParser.is_float-383"><span class="linenos">383</span></a><span class="sd">			: whether to accept positive and negative infinity values. If True, strings that match the values in `self.inf_values` (empty by default) are interpreted as infinity, or as negative infinity if prepended by a negative sign. The case sensitivity of this matching depends on `self.float_case_sensitive`, which is False by default.</span>
-</span><span id="TypeParser.is_float-384"><a href="#TypeParser.is_float-384"><span class="linenos">384</span></a>
-</span><span id="TypeParser.is_float-385"><a href="#TypeParser.is_float-385"><span class="linenos">385</span></a><span class="sd">			`allow_nan`</span>
-</span><span id="TypeParser.is_float-386"><a href="#TypeParser.is_float-386"><span class="linenos">386</span></a><span class="sd">			: whether to accept NaN (not a number) representations. If True, strings that match the values in `self.nan_values` (empty by default) are interpeted as NaN. The case sensitivity of this matching depends on `self.float_case_sensitive`, which is False by default.</span>
-</span><span id="TypeParser.is_float-387"><a href="#TypeParser.is_float-387"><span class="linenos">387</span></a>
-</span><span id="TypeParser.is_float-388"><a href="#TypeParser.is_float-388"><span class="linenos">388</span></a><span class="sd">			Returns</span>
-</span><span id="TypeParser.is_float-389"><a href="#TypeParser.is_float-389"><span class="linenos">389</span></a><span class="sd">			-------</span>
-</span><span id="TypeParser.is_float-390"><a href="#TypeParser.is_float-390"><span class="linenos">390</span></a><span class="sd">			whether it is a float or Decimal</span>
-</span><span id="TypeParser.is_float-391"><a href="#TypeParser.is_float-391"><span class="linenos">391</span></a>
-</span><span id="TypeParser.is_float-392"><a href="#TypeParser.is_float-392"><span class="linenos">392</span></a><span class="sd">			Examples</span>
-</span><span id="TypeParser.is_float-393"><a href="#TypeParser.is_float-393"><span class="linenos">393</span></a><span class="sd">			--------</span>
-</span><span id="TypeParser.is_float-394"><a href="#TypeParser.is_float-394"><span class="linenos">394</span></a><span class="sd">			```python</span>
-</span><span id="TypeParser.is_float-395"><a href="#TypeParser.is_float-395"><span class="linenos">395</span></a><span class="sd">			parser = TypeParser()</span>
-</span><span id="TypeParser.is_float-396"><a href="#TypeParser.is_float-396"><span class="linenos">396</span></a><span class="sd">			parser.is_float(&quot;1.&quot;)       # True</span>
-</span><span id="TypeParser.is_float-397"><a href="#TypeParser.is_float-397"><span class="linenos">397</span></a><span class="sd">			parser.is_float(&quot;12.3e-2&quot;)  # True</span>
-</span><span id="TypeParser.is_float-398"><a href="#TypeParser.is_float-398"><span class="linenos">398</span></a><span class="sd">			parser.is_float(&quot;abc&quot;)      # False</span>
-</span><span id="TypeParser.is_float-399"><a href="#TypeParser.is_float-399"><span class="linenos">399</span></a><span class="sd">			parser.is_float(&quot;&quot;)         # False</span>
-</span><span id="TypeParser.is_float-400"><a href="#TypeParser.is_float-400"><span class="linenos">400</span></a><span class="sd">			```</span>
-</span><span id="TypeParser.is_float-401"><a href="#TypeParser.is_float-401"><span class="linenos">401</span></a><span class="sd">		&quot;&quot;&quot;</span>
-</span><span id="TypeParser.is_float-402"><a href="#TypeParser.is_float-402"><span class="linenos">402</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trim</span><span class="p">:</span>
-</span><span id="TypeParser.is_float-403"><a href="#TypeParser.is_float-403"><span class="linenos">403</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
-</span><span id="TypeParser.is_float-404"><a href="#TypeParser.is_float-404"><span class="linenos">404</span></a>
-</span><span id="TypeParser.is_float-405"><a href="#TypeParser.is_float-405"><span class="linenos">405</span></a>		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sign_chars</span><span class="p">:</span>
-</span><span id="TypeParser.is_float-406"><a href="#TypeParser.is_float-406"><span class="linenos">406</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
-</span><span id="TypeParser.is_float-407"><a href="#TypeParser.is_float-407"><span class="linenos">407</span></a>
-</span><span id="TypeParser.is_float-408"><a href="#TypeParser.is_float-408"><span class="linenos">408</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">float_case_sensitive</span><span class="p">:</span>
-</span><span id="TypeParser.is_float-409"><a href="#TypeParser.is_float-409"><span class="linenos">409</span></a>			<span class="n">special_value</span> <span class="o">=</span> <span class="n">value</span>
-</span><span id="TypeParser.is_float-410"><a href="#TypeParser.is_float-410"><span class="linenos">410</span></a>		<span class="k">else</span><span class="p">:</span>
-</span><span id="TypeParser.is_float-411"><a href="#TypeParser.is_float-411"><span class="linenos">411</span></a>			<span class="n">special_value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
-</span><span id="TypeParser.is_float-412"><a href="#TypeParser.is_float-412"><span class="linenos">412</span></a>		<span class="k">if</span> <span class="n">allow_inf</span> <span class="ow">and</span> <span class="n">special_value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inf_values</span><span class="p">:</span>
-</span><span id="TypeParser.is_float-413"><a href="#TypeParser.is_float-413"><span class="linenos">413</span></a>			<span class="k">return</span> <span class="kc">True</span>
-</span><span id="TypeParser.is_float-414"><a href="#TypeParser.is_float-414"><span class="linenos">414</span></a>		<span class="k">if</span> <span class="n">allow_nan</span> <span class="ow">and</span> <span class="n">special_value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nan_values</span><span class="p">:</span>
-</span><span id="TypeParser.is_float-415"><a href="#TypeParser.is_float-415"><span class="linenos">415</span></a>			<span class="k">return</span> <span class="kc">True</span>
-</span><span id="TypeParser.is_float-416"><a href="#TypeParser.is_float-416"><span class="linenos">416</span></a>
-</span><span id="TypeParser.is_float-417"><a href="#TypeParser.is_float-417"><span class="linenos">417</span></a>		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
-</span><span id="TypeParser.is_float-418"><a href="#TypeParser.is_float-418"><span class="linenos">418</span></a>			<span class="k">return</span> <span class="kc">False</span>
-</span><span id="TypeParser.is_float-419"><a href="#TypeParser.is_float-419"><span class="linenos">419</span></a>
-</span><span id="TypeParser.is_float-420"><a href="#TypeParser.is_float-420"><span class="linenos">420</span></a>		<span class="k">if</span> <span class="n">allow_scientific</span><span class="p">:</span>
-</span><span id="TypeParser.is_float-421"><a href="#TypeParser.is_float-421"><span class="linenos">421</span></a>			<span class="n">value</span><span class="p">,</span> <span class="n">exp</span> <span class="o">=</span> <span class="n">_decompose_string_pair</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scientific_char</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">float_case_sensitive</span><span class="p">)</span>
-</span><span id="TypeParser.is_float-422"><a href="#TypeParser.is_float-422"><span class="linenos">422</span></a>			<span class="k">if</span> <span class="n">exp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
-</span><span id="TypeParser.is_float-423"><a href="#TypeParser.is_float-423"><span class="linenos">423</span></a>				<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_float</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">allow_inf</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">allow_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_int</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">allow_sign</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_negative</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
-</span><span id="TypeParser.is_float-424"><a href="#TypeParser.is_float-424"><span class="linenos">424</span></a>
-</span><span id="TypeParser.is_float-425"><a href="#TypeParser.is_float-425"><span class="linenos">425</span></a>		<span class="n">value</span><span class="p">,</span> <span class="n">frac</span> <span class="o">=</span> <span class="n">_decompose_string_pair</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_float_separator</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">float_case_sensitive</span><span class="p">)</span>
-</span><span id="TypeParser.is_float-426"><a href="#TypeParser.is_float-426"><span class="linenos">426</span></a>		<span class="k">if</span> <span class="n">frac</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
-</span><span id="TypeParser.is_float-427"><a href="#TypeParser.is_float-427"><span class="linenos">427</span></a>			<span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span> <span class="ow">and</span> <span class="n">frac</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
-</span><span id="TypeParser.is_float-428"><a href="#TypeParser.is_float-428"><span class="linenos">428</span></a>				<span class="k">return</span> <span class="kc">False</span>
-</span><span id="TypeParser.is_float-429"><a href="#TypeParser.is_float-429"><span class="linenos">429</span></a>			<span class="k">return</span> <span class="p">(</span>
-</span><span id="TypeParser.is_float-430"><a href="#TypeParser.is_float-430"><span class="linenos">430</span></a>				<span class="bp">self</span><span class="o">.</span><span class="n">is_int</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">allow_sign</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_negative</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="ow">or</span> <span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span>
-</span><span id="TypeParser.is_float-431"><a href="#TypeParser.is_float-431"><span class="linenos">431</span></a>			<span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
-</span><span id="TypeParser.is_float-432"><a href="#TypeParser.is_float-432"><span class="linenos">432</span></a>				<span class="bp">self</span><span class="o">.</span><span class="n">is_int</span><span class="p">(</span><span class="n">frac</span><span class="p">,</span> <span class="n">allow_sign</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">allow_negative</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="ow">or</span> <span class="n">frac</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span>
-</span><span id="TypeParser.is_float-433"><a href="#TypeParser.is_float-433"><span class="linenos">433</span></a>			<span class="p">)</span>
-</span><span id="TypeParser.is_float-434"><a href="#TypeParser.is_float-434"><span class="linenos">434</span></a>
-</span><span id="TypeParser.is_float-435"><a href="#TypeParser.is_float-435"><span class="linenos">435</span></a>		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_int</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">allow_sign</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_negative</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
+            <div class="pdoc-code codehilite"><pre><span></span><span id="TypeParser.is_float-365"><a href="#TypeParser.is_float-365"><span class="linenos">365</span></a>	<span class="k">def</span> <span class="nf">is_float</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_inf</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_nan</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
+</span><span id="TypeParser.is_float-366"><a href="#TypeParser.is_float-366"><span class="linenos">366</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
+</span><span id="TypeParser.is_float-367"><a href="#TypeParser.is_float-367"><span class="linenos">367</span></a><span class="sd">			Check if a string represents a float (or equivalently, a Decimal)</span>
+</span><span id="TypeParser.is_float-368"><a href="#TypeParser.is_float-368"><span class="linenos">368</span></a>
+</span><span id="TypeParser.is_float-369"><a href="#TypeParser.is_float-369"><span class="linenos">369</span></a><span class="sd">			This function will also return True if the string represents an int.</span>
+</span><span id="TypeParser.is_float-370"><a href="#TypeParser.is_float-370"><span class="linenos">370</span></a>
+</span><span id="TypeParser.is_float-371"><a href="#TypeParser.is_float-371"><span class="linenos">371</span></a><span class="sd">			Alias: `is_decimal()`</span>
+</span><span id="TypeParser.is_float-372"><a href="#TypeParser.is_float-372"><span class="linenos">372</span></a>
+</span><span id="TypeParser.is_float-373"><a href="#TypeParser.is_float-373"><span class="linenos">373</span></a><span class="sd">			Parameters</span>
+</span><span id="TypeParser.is_float-374"><a href="#TypeParser.is_float-374"><span class="linenos">374</span></a><span class="sd">			----------</span>
+</span><span id="TypeParser.is_float-375"><a href="#TypeParser.is_float-375"><span class="linenos">375</span></a><span class="sd">			`value`</span>
+</span><span id="TypeParser.is_float-376"><a href="#TypeParser.is_float-376"><span class="linenos">376</span></a><span class="sd">			: string to be checked</span>
+</span><span id="TypeParser.is_float-377"><a href="#TypeParser.is_float-377"><span class="linenos">377</span></a>
+</span><span id="TypeParser.is_float-378"><a href="#TypeParser.is_float-378"><span class="linenos">378</span></a><span class="sd">			`allow_scientific`</span>
+</span><span id="TypeParser.is_float-379"><a href="#TypeParser.is_float-379"><span class="linenos">379</span></a><span class="sd">			: whether to accept scientific notation. If True, strings of the form `&quot;&lt;var&gt;M&lt;/var&gt;e&lt;var&gt;X&lt;/var&gt;&quot;` will be interpreted as the expression `&lt;var&gt;M&lt;/var&gt; * (10 ** &lt;var&gt;X&lt;/var&gt;)`, where &lt;var&gt;M&lt;/var&gt; is the mantissa/significand and &lt;var&gt;X&lt;/var&gt; is the exponent. Note that &lt;var&gt;X&lt;/var&gt; must be an integer, but can be negative.</span>
+</span><span id="TypeParser.is_float-380"><a href="#TypeParser.is_float-380"><span class="linenos">380</span></a>
+</span><span id="TypeParser.is_float-381"><a href="#TypeParser.is_float-381"><span class="linenos">381</span></a><span class="sd">			`allow_inf`</span>
+</span><span id="TypeParser.is_float-382"><a href="#TypeParser.is_float-382"><span class="linenos">382</span></a><span class="sd">			: whether to accept positive and negative infinity values. If True, strings that match the values in `self.inf_values` (empty by default) are interpreted as infinity, or as negative infinity if prepended by a negative sign. The case sensitivity of this matching depends on `self.float_case_sensitive`, which is False by default.</span>
+</span><span id="TypeParser.is_float-383"><a href="#TypeParser.is_float-383"><span class="linenos">383</span></a>
+</span><span id="TypeParser.is_float-384"><a href="#TypeParser.is_float-384"><span class="linenos">384</span></a><span class="sd">			`allow_nan`</span>
+</span><span id="TypeParser.is_float-385"><a href="#TypeParser.is_float-385"><span class="linenos">385</span></a><span class="sd">			: whether to accept NaN (not a number) representations. If True, strings that match the values in `self.nan_values` (empty by default) are interpeted as NaN. The case sensitivity of this matching depends on `self.float_case_sensitive`, which is False by default.</span>
+</span><span id="TypeParser.is_float-386"><a href="#TypeParser.is_float-386"><span class="linenos">386</span></a>
+</span><span id="TypeParser.is_float-387"><a href="#TypeParser.is_float-387"><span class="linenos">387</span></a><span class="sd">			Returns</span>
+</span><span id="TypeParser.is_float-388"><a href="#TypeParser.is_float-388"><span class="linenos">388</span></a><span class="sd">			-------</span>
+</span><span id="TypeParser.is_float-389"><a href="#TypeParser.is_float-389"><span class="linenos">389</span></a><span class="sd">			whether it is a float or Decimal</span>
+</span><span id="TypeParser.is_float-390"><a href="#TypeParser.is_float-390"><span class="linenos">390</span></a>
+</span><span id="TypeParser.is_float-391"><a href="#TypeParser.is_float-391"><span class="linenos">391</span></a><span class="sd">			Examples</span>
+</span><span id="TypeParser.is_float-392"><a href="#TypeParser.is_float-392"><span class="linenos">392</span></a><span class="sd">			--------</span>
+</span><span id="TypeParser.is_float-393"><a href="#TypeParser.is_float-393"><span class="linenos">393</span></a><span class="sd">			```python</span>
+</span><span id="TypeParser.is_float-394"><a href="#TypeParser.is_float-394"><span class="linenos">394</span></a><span class="sd">			parser = TypeParser()</span>
+</span><span id="TypeParser.is_float-395"><a href="#TypeParser.is_float-395"><span class="linenos">395</span></a><span class="sd">			parser.is_float(&quot;1.&quot;)       # True</span>
+</span><span id="TypeParser.is_float-396"><a href="#TypeParser.is_float-396"><span class="linenos">396</span></a><span class="sd">			parser.is_float(&quot;12.3e-2&quot;)  # True</span>
+</span><span id="TypeParser.is_float-397"><a href="#TypeParser.is_float-397"><span class="linenos">397</span></a><span class="sd">			parser.is_float(&quot;abc&quot;)      # False</span>
+</span><span id="TypeParser.is_float-398"><a href="#TypeParser.is_float-398"><span class="linenos">398</span></a><span class="sd">			parser.is_float(&quot;&quot;)         # False</span>
+</span><span id="TypeParser.is_float-399"><a href="#TypeParser.is_float-399"><span class="linenos">399</span></a><span class="sd">			```</span>
+</span><span id="TypeParser.is_float-400"><a href="#TypeParser.is_float-400"><span class="linenos">400</span></a><span class="sd">		&quot;&quot;&quot;</span>
+</span><span id="TypeParser.is_float-401"><a href="#TypeParser.is_float-401"><span class="linenos">401</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trim</span><span class="p">:</span>
+</span><span id="TypeParser.is_float-402"><a href="#TypeParser.is_float-402"><span class="linenos">402</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
+</span><span id="TypeParser.is_float-403"><a href="#TypeParser.is_float-403"><span class="linenos">403</span></a>
+</span><span id="TypeParser.is_float-404"><a href="#TypeParser.is_float-404"><span class="linenos">404</span></a>		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sign_chars</span><span class="p">:</span>
+</span><span id="TypeParser.is_float-405"><a href="#TypeParser.is_float-405"><span class="linenos">405</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
+</span><span id="TypeParser.is_float-406"><a href="#TypeParser.is_float-406"><span class="linenos">406</span></a>
+</span><span id="TypeParser.is_float-407"><a href="#TypeParser.is_float-407"><span class="linenos">407</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">float_case_sensitive</span><span class="p">:</span>
+</span><span id="TypeParser.is_float-408"><a href="#TypeParser.is_float-408"><span class="linenos">408</span></a>			<span class="n">special_value</span> <span class="o">=</span> <span class="n">value</span>
+</span><span id="TypeParser.is_float-409"><a href="#TypeParser.is_float-409"><span class="linenos">409</span></a>		<span class="k">else</span><span class="p">:</span>
+</span><span id="TypeParser.is_float-410"><a href="#TypeParser.is_float-410"><span class="linenos">410</span></a>			<span class="n">special_value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
+</span><span id="TypeParser.is_float-411"><a href="#TypeParser.is_float-411"><span class="linenos">411</span></a>		<span class="k">if</span> <span class="n">allow_inf</span> <span class="ow">and</span> <span class="n">special_value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">inf_values</span><span class="p">:</span>
+</span><span id="TypeParser.is_float-412"><a href="#TypeParser.is_float-412"><span class="linenos">412</span></a>			<span class="k">return</span> <span class="kc">True</span>
+</span><span id="TypeParser.is_float-413"><a href="#TypeParser.is_float-413"><span class="linenos">413</span></a>		<span class="k">if</span> <span class="n">allow_nan</span> <span class="ow">and</span> <span class="n">special_value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nan_values</span><span class="p">:</span>
+</span><span id="TypeParser.is_float-414"><a href="#TypeParser.is_float-414"><span class="linenos">414</span></a>			<span class="k">return</span> <span class="kc">True</span>
+</span><span id="TypeParser.is_float-415"><a href="#TypeParser.is_float-415"><span class="linenos">415</span></a>
+</span><span id="TypeParser.is_float-416"><a href="#TypeParser.is_float-416"><span class="linenos">416</span></a>		<span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
+</span><span id="TypeParser.is_float-417"><a href="#TypeParser.is_float-417"><span class="linenos">417</span></a>			<span class="k">return</span> <span class="kc">False</span>
+</span><span id="TypeParser.is_float-418"><a href="#TypeParser.is_float-418"><span class="linenos">418</span></a>
+</span><span id="TypeParser.is_float-419"><a href="#TypeParser.is_float-419"><span class="linenos">419</span></a>		<span class="k">if</span> <span class="n">allow_scientific</span><span class="p">:</span>
+</span><span id="TypeParser.is_float-420"><a href="#TypeParser.is_float-420"><span class="linenos">420</span></a>			<span class="n">value</span><span class="p">,</span> <span class="n">exp</span> <span class="o">=</span> <span class="n">_decompose_string_pair</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scientific_char</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">float_case_sensitive</span><span class="p">)</span>
+</span><span id="TypeParser.is_float-421"><a href="#TypeParser.is_float-421"><span class="linenos">421</span></a>			<span class="k">if</span> <span class="n">exp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
+</span><span id="TypeParser.is_float-422"><a href="#TypeParser.is_float-422"><span class="linenos">422</span></a>				<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_float</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">allow_inf</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">allow_nan</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_int</span><span class="p">(</span><span class="n">exp</span><span class="p">,</span> <span class="n">allow_sign</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_negative</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
+</span><span id="TypeParser.is_float-423"><a href="#TypeParser.is_float-423"><span class="linenos">423</span></a>
+</span><span id="TypeParser.is_float-424"><a href="#TypeParser.is_float-424"><span class="linenos">424</span></a>		<span class="n">value</span><span class="p">,</span> <span class="n">frac</span> <span class="o">=</span> <span class="n">_decompose_string_pair</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_float_separator</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">float_case_sensitive</span><span class="p">)</span>
+</span><span id="TypeParser.is_float-425"><a href="#TypeParser.is_float-425"><span class="linenos">425</span></a>		<span class="k">if</span> <span class="n">frac</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
+</span><span id="TypeParser.is_float-426"><a href="#TypeParser.is_float-426"><span class="linenos">426</span></a>			<span class="k">if</span> <span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span> <span class="ow">and</span> <span class="n">frac</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
+</span><span id="TypeParser.is_float-427"><a href="#TypeParser.is_float-427"><span class="linenos">427</span></a>				<span class="k">return</span> <span class="kc">False</span>
+</span><span id="TypeParser.is_float-428"><a href="#TypeParser.is_float-428"><span class="linenos">428</span></a>			<span class="k">return</span> <span class="p">(</span>
+</span><span id="TypeParser.is_float-429"><a href="#TypeParser.is_float-429"><span class="linenos">429</span></a>				<span class="bp">self</span><span class="o">.</span><span class="n">is_int</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">allow_sign</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_negative</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="ow">or</span> <span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span>
+</span><span id="TypeParser.is_float-430"><a href="#TypeParser.is_float-430"><span class="linenos">430</span></a>			<span class="p">)</span> <span class="ow">and</span> <span class="p">(</span>
+</span><span id="TypeParser.is_float-431"><a href="#TypeParser.is_float-431"><span class="linenos">431</span></a>				<span class="bp">self</span><span class="o">.</span><span class="n">is_int</span><span class="p">(</span><span class="n">frac</span><span class="p">,</span> <span class="n">allow_sign</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">allow_negative</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="ow">or</span> <span class="n">frac</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span>
+</span><span id="TypeParser.is_float-432"><a href="#TypeParser.is_float-432"><span class="linenos">432</span></a>			<span class="p">)</span>
+</span><span id="TypeParser.is_float-433"><a href="#TypeParser.is_float-433"><span class="linenos">433</span></a>
+</span><span id="TypeParser.is_float-434"><a href="#TypeParser.is_float-434"><span class="linenos">434</span></a>		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_int</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">allow_sign</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_negative</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
 </span></pre></div>
 
 
     <div class="docstring">
 <p>Check if a string represents a float (or equivalently, a Decimal)</p>
 
 <p>This function will also return True if the string represents an int.</p>
@@ -1797,19 +1797,19 @@
         <span class="name">is_decimal</span><span class="signature pdoc-code multiline">(<span class="param">	<span class="bp">self</span>,</span><span class="param">	<span class="n">value</span><span class="p">:</span> <span class="nb">str</span>,</span><span class="param">	<span class="o">*</span>,</span><span class="param">	<span class="n">allow_scientific</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>,</span><span class="param">	<span class="n">allow_inf</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>,</span><span class="param">	<span class="n">allow_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span></span><span class="return-annotation">) -> <span class="nb">bool</span>:</span></span>
 
 
                 <label class="view-source-button" for="TypeParser.is_decimal-view-source"><span>View Source</span></label>
 
     </div>
     <a class="headerlink" href="#TypeParser.is_decimal"></a>
-            <div class="pdoc-code codehilite"><pre><span></span><span id="TypeParser.is_decimal-438"><a href="#TypeParser.is_decimal-438"><span class="linenos">438</span></a>	<span class="k">def</span> <span class="nf">is_decimal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_inf</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_nan</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
-</span><span id="TypeParser.is_decimal-439"><a href="#TypeParser.is_decimal-439"><span class="linenos">439</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
-</span><span id="TypeParser.is_decimal-440"><a href="#TypeParser.is_decimal-440"><span class="linenos">440</span></a><span class="sd">			Alias of `is_float()`</span>
-</span><span id="TypeParser.is_decimal-441"><a href="#TypeParser.is_decimal-441"><span class="linenos">441</span></a><span class="sd">		&quot;&quot;&quot;</span>
-</span><span id="TypeParser.is_decimal-442"><a href="#TypeParser.is_decimal-442"><span class="linenos">442</span></a>		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_float</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="o">=</span><span class="n">allow_scientific</span><span class="p">,</span> <span class="n">allow_inf</span><span class="o">=</span><span class="n">allow_inf</span><span class="p">,</span> <span class="n">allow_nan</span><span class="o">=</span><span class="n">allow_nan</span><span class="p">)</span>
+            <div class="pdoc-code codehilite"><pre><span></span><span id="TypeParser.is_decimal-437"><a href="#TypeParser.is_decimal-437"><span class="linenos">437</span></a>	<span class="k">def</span> <span class="nf">is_decimal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_inf</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_nan</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
+</span><span id="TypeParser.is_decimal-438"><a href="#TypeParser.is_decimal-438"><span class="linenos">438</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
+</span><span id="TypeParser.is_decimal-439"><a href="#TypeParser.is_decimal-439"><span class="linenos">439</span></a><span class="sd">			Alias of `is_float()`</span>
+</span><span id="TypeParser.is_decimal-440"><a href="#TypeParser.is_decimal-440"><span class="linenos">440</span></a><span class="sd">		&quot;&quot;&quot;</span>
+</span><span id="TypeParser.is_decimal-441"><a href="#TypeParser.is_decimal-441"><span class="linenos">441</span></a>		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_float</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="o">=</span><span class="n">allow_scientific</span><span class="p">,</span> <span class="n">allow_inf</span><span class="o">=</span><span class="n">allow_inf</span><span class="p">,</span> <span class="n">allow_nan</span><span class="o">=</span><span class="n">allow_nan</span><span class="p">)</span>
 </span></pre></div>
 
 
     <div class="docstring">
 <p>Alias of <code><a href="#TypeParser.is_float">is_float()</a></code></p></div>
 
 
@@ -1823,45 +1823,45 @@
         <span class="name">parse_none</span><span class="signature pdoc-code condensed">(<span class="param"><span class="bp">self</span>, </span><span class="param"><span class="n">value</span><span class="p">:</span> <span class="nb">str</span></span><span class="return-annotation">) -> <span class="kc">None</span>:</span></span>
 
 
                 <label class="view-source-button" for="TypeParser.parse_none-view-source"><span>View Source</span></label>
 
     </div>
     <a class="headerlink" href="#TypeParser.parse_none"></a>
-            <div class="pdoc-code codehilite"><pre><span></span><span id="TypeParser.parse_none-445"><a href="#TypeParser.parse_none-445"><span class="linenos">445</span></a>	<span class="k">def</span> <span class="nf">parse_none</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
-</span><span id="TypeParser.parse_none-446"><a href="#TypeParser.parse_none-446"><span class="linenos">446</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
-</span><span id="TypeParser.parse_none-447"><a href="#TypeParser.parse_none-447"><span class="linenos">447</span></a><span class="sd">			Parse a string and return it as the value None if possible</span>
-</span><span id="TypeParser.parse_none-448"><a href="#TypeParser.parse_none-448"><span class="linenos">448</span></a>
-</span><span id="TypeParser.parse_none-449"><a href="#TypeParser.parse_none-449"><span class="linenos">449</span></a><span class="sd">			Only strings that match the values in `self.none_values` will be interpreted as None. The default accepted values are `[&quot;&quot;]`, i.e. an empty string. The case sensitivity of this matching depends on `self.none_case_sensitive`, which is False by default.</span>
-</span><span id="TypeParser.parse_none-450"><a href="#TypeParser.parse_none-450"><span class="linenos">450</span></a>
-</span><span id="TypeParser.parse_none-451"><a href="#TypeParser.parse_none-451"><span class="linenos">451</span></a><span class="sd">			Parameters</span>
-</span><span id="TypeParser.parse_none-452"><a href="#TypeParser.parse_none-452"><span class="linenos">452</span></a><span class="sd">			----------</span>
-</span><span id="TypeParser.parse_none-453"><a href="#TypeParser.parse_none-453"><span class="linenos">453</span></a><span class="sd">			`value`</span>
-</span><span id="TypeParser.parse_none-454"><a href="#TypeParser.parse_none-454"><span class="linenos">454</span></a><span class="sd">			: string to be parsed</span>
-</span><span id="TypeParser.parse_none-455"><a href="#TypeParser.parse_none-455"><span class="linenos">455</span></a>
-</span><span id="TypeParser.parse_none-456"><a href="#TypeParser.parse_none-456"><span class="linenos">456</span></a><span class="sd">			Returns</span>
-</span><span id="TypeParser.parse_none-457"><a href="#TypeParser.parse_none-457"><span class="linenos">457</span></a><span class="sd">			-------</span>
-</span><span id="TypeParser.parse_none-458"><a href="#TypeParser.parse_none-458"><span class="linenos">458</span></a><span class="sd">			parsed None value</span>
-</span><span id="TypeParser.parse_none-459"><a href="#TypeParser.parse_none-459"><span class="linenos">459</span></a>
-</span><span id="TypeParser.parse_none-460"><a href="#TypeParser.parse_none-460"><span class="linenos">460</span></a><span class="sd">			Raises</span>
-</span><span id="TypeParser.parse_none-461"><a href="#TypeParser.parse_none-461"><span class="linenos">461</span></a><span class="sd">			------</span>
-</span><span id="TypeParser.parse_none-462"><a href="#TypeParser.parse_none-462"><span class="linenos">462</span></a><span class="sd">			`ValueError` if `value` cannot be parsed</span>
-</span><span id="TypeParser.parse_none-463"><a href="#TypeParser.parse_none-463"><span class="linenos">463</span></a>
-</span><span id="TypeParser.parse_none-464"><a href="#TypeParser.parse_none-464"><span class="linenos">464</span></a><span class="sd">			Examples</span>
-</span><span id="TypeParser.parse_none-465"><a href="#TypeParser.parse_none-465"><span class="linenos">465</span></a><span class="sd">			--------</span>
-</span><span id="TypeParser.parse_none-466"><a href="#TypeParser.parse_none-466"><span class="linenos">466</span></a><span class="sd">			```python</span>
-</span><span id="TypeParser.parse_none-467"><a href="#TypeParser.parse_none-467"><span class="linenos">467</span></a><span class="sd">			parser = TypeParser()</span>
-</span><span id="TypeParser.parse_none-468"><a href="#TypeParser.parse_none-468"><span class="linenos">468</span></a><span class="sd">			parser.parse_bool(&quot;&quot;)     # None</span>
-</span><span id="TypeParser.parse_none-469"><a href="#TypeParser.parse_none-469"><span class="linenos">469</span></a><span class="sd">			parser.parse_bool(&quot;abc&quot;)  # raises ValueError</span>
-</span><span id="TypeParser.parse_none-470"><a href="#TypeParser.parse_none-470"><span class="linenos">470</span></a><span class="sd">			```</span>
-</span><span id="TypeParser.parse_none-471"><a href="#TypeParser.parse_none-471"><span class="linenos">471</span></a><span class="sd">		&quot;&quot;&quot;</span>
-</span><span id="TypeParser.parse_none-472"><a href="#TypeParser.parse_none-472"><span class="linenos">472</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_none</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
-</span><span id="TypeParser.parse_none-473"><a href="#TypeParser.parse_none-473"><span class="linenos">473</span></a>			<span class="k">return</span> <span class="kc">None</span>
-</span><span id="TypeParser.parse_none-474"><a href="#TypeParser.parse_none-474"><span class="linenos">474</span></a>		<span class="k">else</span><span class="p">:</span>
-</span><span id="TypeParser.parse_none-475"><a href="#TypeParser.parse_none-475"><span class="linenos">475</span></a>			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;not a none value: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
+            <div class="pdoc-code codehilite"><pre><span></span><span id="TypeParser.parse_none-444"><a href="#TypeParser.parse_none-444"><span class="linenos">444</span></a>	<span class="k">def</span> <span class="nf">parse_none</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
+</span><span id="TypeParser.parse_none-445"><a href="#TypeParser.parse_none-445"><span class="linenos">445</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
+</span><span id="TypeParser.parse_none-446"><a href="#TypeParser.parse_none-446"><span class="linenos">446</span></a><span class="sd">			Parse a string and return it as the value None if possible</span>
+</span><span id="TypeParser.parse_none-447"><a href="#TypeParser.parse_none-447"><span class="linenos">447</span></a>
+</span><span id="TypeParser.parse_none-448"><a href="#TypeParser.parse_none-448"><span class="linenos">448</span></a><span class="sd">			Only strings that match the values in `self.none_values` will be interpreted as None. The default accepted values are `[&quot;&quot;]`, i.e. an empty string. The case sensitivity of this matching depends on `self.none_case_sensitive`, which is False by default.</span>
+</span><span id="TypeParser.parse_none-449"><a href="#TypeParser.parse_none-449"><span class="linenos">449</span></a>
+</span><span id="TypeParser.parse_none-450"><a href="#TypeParser.parse_none-450"><span class="linenos">450</span></a><span class="sd">			Parameters</span>
+</span><span id="TypeParser.parse_none-451"><a href="#TypeParser.parse_none-451"><span class="linenos">451</span></a><span class="sd">			----------</span>
+</span><span id="TypeParser.parse_none-452"><a href="#TypeParser.parse_none-452"><span class="linenos">452</span></a><span class="sd">			`value`</span>
+</span><span id="TypeParser.parse_none-453"><a href="#TypeParser.parse_none-453"><span class="linenos">453</span></a><span class="sd">			: string to be parsed</span>
+</span><span id="TypeParser.parse_none-454"><a href="#TypeParser.parse_none-454"><span class="linenos">454</span></a>
+</span><span id="TypeParser.parse_none-455"><a href="#TypeParser.parse_none-455"><span class="linenos">455</span></a><span class="sd">			Returns</span>
+</span><span id="TypeParser.parse_none-456"><a href="#TypeParser.parse_none-456"><span class="linenos">456</span></a><span class="sd">			-------</span>
+</span><span id="TypeParser.parse_none-457"><a href="#TypeParser.parse_none-457"><span class="linenos">457</span></a><span class="sd">			parsed None value</span>
+</span><span id="TypeParser.parse_none-458"><a href="#TypeParser.parse_none-458"><span class="linenos">458</span></a>
+</span><span id="TypeParser.parse_none-459"><a href="#TypeParser.parse_none-459"><span class="linenos">459</span></a><span class="sd">			Raises</span>
+</span><span id="TypeParser.parse_none-460"><a href="#TypeParser.parse_none-460"><span class="linenos">460</span></a><span class="sd">			------</span>
+</span><span id="TypeParser.parse_none-461"><a href="#TypeParser.parse_none-461"><span class="linenos">461</span></a><span class="sd">			`ValueError` if `value` cannot be parsed</span>
+</span><span id="TypeParser.parse_none-462"><a href="#TypeParser.parse_none-462"><span class="linenos">462</span></a>
+</span><span id="TypeParser.parse_none-463"><a href="#TypeParser.parse_none-463"><span class="linenos">463</span></a><span class="sd">			Examples</span>
+</span><span id="TypeParser.parse_none-464"><a href="#TypeParser.parse_none-464"><span class="linenos">464</span></a><span class="sd">			--------</span>
+</span><span id="TypeParser.parse_none-465"><a href="#TypeParser.parse_none-465"><span class="linenos">465</span></a><span class="sd">			```python</span>
+</span><span id="TypeParser.parse_none-466"><a href="#TypeParser.parse_none-466"><span class="linenos">466</span></a><span class="sd">			parser = TypeParser()</span>
+</span><span id="TypeParser.parse_none-467"><a href="#TypeParser.parse_none-467"><span class="linenos">467</span></a><span class="sd">			parser.parse_bool(&quot;&quot;)     # None</span>
+</span><span id="TypeParser.parse_none-468"><a href="#TypeParser.parse_none-468"><span class="linenos">468</span></a><span class="sd">			parser.parse_bool(&quot;abc&quot;)  # raises ValueError</span>
+</span><span id="TypeParser.parse_none-469"><a href="#TypeParser.parse_none-469"><span class="linenos">469</span></a><span class="sd">			```</span>
+</span><span id="TypeParser.parse_none-470"><a href="#TypeParser.parse_none-470"><span class="linenos">470</span></a><span class="sd">		&quot;&quot;&quot;</span>
+</span><span id="TypeParser.parse_none-471"><a href="#TypeParser.parse_none-471"><span class="linenos">471</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_none</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
+</span><span id="TypeParser.parse_none-472"><a href="#TypeParser.parse_none-472"><span class="linenos">472</span></a>			<span class="k">return</span> <span class="kc">None</span>
+</span><span id="TypeParser.parse_none-473"><a href="#TypeParser.parse_none-473"><span class="linenos">473</span></a>		<span class="k">else</span><span class="p">:</span>
+</span><span id="TypeParser.parse_none-474"><a href="#TypeParser.parse_none-474"><span class="linenos">474</span></a>			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;not a none value: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
 </span></pre></div>
 
 
     <div class="docstring">
 <p>Parse a string and return it as the value None if possible</p>
 
 <p>Only strings that match the values in <code>self.none_values</code> will be interpreted as None. The default accepted values are <code>[""]</code>, i.e. an empty string. The case sensitivity of this matching depends on <code>self.none_case_sensitive</code>, which is False by default.</p>
@@ -1899,54 +1899,54 @@
         <span class="name">parse_bool</span><span class="signature pdoc-code condensed">(<span class="param"><span class="bp">self</span>, </span><span class="param"><span class="n">value</span><span class="p">:</span> <span class="nb">str</span></span><span class="return-annotation">) -> <span class="nb">bool</span>:</span></span>
 
 
                 <label class="view-source-button" for="TypeParser.parse_bool-view-source"><span>View Source</span></label>
 
     </div>
     <a class="headerlink" href="#TypeParser.parse_bool"></a>
-            <div class="pdoc-code codehilite"><pre><span></span><span id="TypeParser.parse_bool-478"><a href="#TypeParser.parse_bool-478"><span class="linenos">478</span></a>	<span class="k">def</span> <span class="nf">parse_bool</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
-</span><span id="TypeParser.parse_bool-479"><a href="#TypeParser.parse_bool-479"><span class="linenos">479</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
-</span><span id="TypeParser.parse_bool-480"><a href="#TypeParser.parse_bool-480"><span class="linenos">480</span></a><span class="sd">			Parse a string and return it as a bool if possible</span>
-</span><span id="TypeParser.parse_bool-481"><a href="#TypeParser.parse_bool-481"><span class="linenos">481</span></a>
-</span><span id="TypeParser.parse_bool-482"><a href="#TypeParser.parse_bool-482"><span class="linenos">482</span></a><span class="sd">			Only strings that match the values in `self.true_values` and `self.false_values` will be interpreted as booleans. The default accepted values are `[&quot;true&quot;]` and `[&quot;false&quot;]` respectively. The case sensitivity of this matching depends on `self.bool_case_sensitive`, which is False by default.</span>
-</span><span id="TypeParser.parse_bool-483"><a href="#TypeParser.parse_bool-483"><span class="linenos">483</span></a>
-</span><span id="TypeParser.parse_bool-484"><a href="#TypeParser.parse_bool-484"><span class="linenos">484</span></a><span class="sd">			Parameters</span>
-</span><span id="TypeParser.parse_bool-485"><a href="#TypeParser.parse_bool-485"><span class="linenos">485</span></a><span class="sd">			----------</span>
-</span><span id="TypeParser.parse_bool-486"><a href="#TypeParser.parse_bool-486"><span class="linenos">486</span></a><span class="sd">			`value`</span>
-</span><span id="TypeParser.parse_bool-487"><a href="#TypeParser.parse_bool-487"><span class="linenos">487</span></a><span class="sd">			: string to be parsed</span>
-</span><span id="TypeParser.parse_bool-488"><a href="#TypeParser.parse_bool-488"><span class="linenos">488</span></a>
-</span><span id="TypeParser.parse_bool-489"><a href="#TypeParser.parse_bool-489"><span class="linenos">489</span></a><span class="sd">			Returns</span>
-</span><span id="TypeParser.parse_bool-490"><a href="#TypeParser.parse_bool-490"><span class="linenos">490</span></a><span class="sd">			-------</span>
-</span><span id="TypeParser.parse_bool-491"><a href="#TypeParser.parse_bool-491"><span class="linenos">491</span></a><span class="sd">			parsed bool value</span>
-</span><span id="TypeParser.parse_bool-492"><a href="#TypeParser.parse_bool-492"><span class="linenos">492</span></a>
-</span><span id="TypeParser.parse_bool-493"><a href="#TypeParser.parse_bool-493"><span class="linenos">493</span></a><span class="sd">			Raises</span>
-</span><span id="TypeParser.parse_bool-494"><a href="#TypeParser.parse_bool-494"><span class="linenos">494</span></a><span class="sd">			------</span>
-</span><span id="TypeParser.parse_bool-495"><a href="#TypeParser.parse_bool-495"><span class="linenos">495</span></a><span class="sd">			`ValueError` if `value` cannot be parsed</span>
-</span><span id="TypeParser.parse_bool-496"><a href="#TypeParser.parse_bool-496"><span class="linenos">496</span></a>
-</span><span id="TypeParser.parse_bool-497"><a href="#TypeParser.parse_bool-497"><span class="linenos">497</span></a><span class="sd">			Examples</span>
-</span><span id="TypeParser.parse_bool-498"><a href="#TypeParser.parse_bool-498"><span class="linenos">498</span></a><span class="sd">			--------</span>
-</span><span id="TypeParser.parse_bool-499"><a href="#TypeParser.parse_bool-499"><span class="linenos">499</span></a><span class="sd">			```python</span>
-</span><span id="TypeParser.parse_bool-500"><a href="#TypeParser.parse_bool-500"><span class="linenos">500</span></a><span class="sd">			parser = TypeParser()</span>
-</span><span id="TypeParser.parse_bool-501"><a href="#TypeParser.parse_bool-501"><span class="linenos">501</span></a><span class="sd">			parser.parse_bool(&quot;true&quot;)   # True</span>
-</span><span id="TypeParser.parse_bool-502"><a href="#TypeParser.parse_bool-502"><span class="linenos">502</span></a><span class="sd">			parser.parse_bool(&quot;FALSE&quot;)  # False</span>
-</span><span id="TypeParser.parse_bool-503"><a href="#TypeParser.parse_bool-503"><span class="linenos">503</span></a><span class="sd">			```</span>
-</span><span id="TypeParser.parse_bool-504"><a href="#TypeParser.parse_bool-504"><span class="linenos">504</span></a><span class="sd">		&quot;&quot;&quot;</span>
-</span><span id="TypeParser.parse_bool-505"><a href="#TypeParser.parse_bool-505"><span class="linenos">505</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trim</span><span class="p">:</span>
-</span><span id="TypeParser.parse_bool-506"><a href="#TypeParser.parse_bool-506"><span class="linenos">506</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
-</span><span id="TypeParser.parse_bool-507"><a href="#TypeParser.parse_bool-507"><span class="linenos">507</span></a>
-</span><span id="TypeParser.parse_bool-508"><a href="#TypeParser.parse_bool-508"><span class="linenos">508</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bool_case_sensitive</span><span class="p">:</span>
-</span><span id="TypeParser.parse_bool-509"><a href="#TypeParser.parse_bool-509"><span class="linenos">509</span></a>			<span class="n">special_value</span> <span class="o">=</span> <span class="n">value</span>
-</span><span id="TypeParser.parse_bool-510"><a href="#TypeParser.parse_bool-510"><span class="linenos">510</span></a>		<span class="k">else</span><span class="p">:</span>
-</span><span id="TypeParser.parse_bool-511"><a href="#TypeParser.parse_bool-511"><span class="linenos">511</span></a>			<span class="n">special_value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
-</span><span id="TypeParser.parse_bool-512"><a href="#TypeParser.parse_bool-512"><span class="linenos">512</span></a>		<span class="k">if</span> <span class="n">special_value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">true_values</span><span class="p">:</span>
-</span><span id="TypeParser.parse_bool-513"><a href="#TypeParser.parse_bool-513"><span class="linenos">513</span></a>			<span class="k">return</span> <span class="kc">True</span>
-</span><span id="TypeParser.parse_bool-514"><a href="#TypeParser.parse_bool-514"><span class="linenos">514</span></a>		<span class="k">if</span> <span class="n">special_value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">false_values</span><span class="p">:</span>
-</span><span id="TypeParser.parse_bool-515"><a href="#TypeParser.parse_bool-515"><span class="linenos">515</span></a>			<span class="k">return</span> <span class="kc">False</span>
-</span><span id="TypeParser.parse_bool-516"><a href="#TypeParser.parse_bool-516"><span class="linenos">516</span></a>
-</span><span id="TypeParser.parse_bool-517"><a href="#TypeParser.parse_bool-517"><span class="linenos">517</span></a>		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;not a boolean: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
+            <div class="pdoc-code codehilite"><pre><span></span><span id="TypeParser.parse_bool-477"><a href="#TypeParser.parse_bool-477"><span class="linenos">477</span></a>	<span class="k">def</span> <span class="nf">parse_bool</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
+</span><span id="TypeParser.parse_bool-478"><a href="#TypeParser.parse_bool-478"><span class="linenos">478</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
+</span><span id="TypeParser.parse_bool-479"><a href="#TypeParser.parse_bool-479"><span class="linenos">479</span></a><span class="sd">			Parse a string and return it as a bool if possible</span>
+</span><span id="TypeParser.parse_bool-480"><a href="#TypeParser.parse_bool-480"><span class="linenos">480</span></a>
+</span><span id="TypeParser.parse_bool-481"><a href="#TypeParser.parse_bool-481"><span class="linenos">481</span></a><span class="sd">			Only strings that match the values in `self.true_values` and `self.false_values` will be interpreted as booleans. The default accepted values are `[&quot;true&quot;]` and `[&quot;false&quot;]` respectively. The case sensitivity of this matching depends on `self.bool_case_sensitive`, which is False by default.</span>
+</span><span id="TypeParser.parse_bool-482"><a href="#TypeParser.parse_bool-482"><span class="linenos">482</span></a>
+</span><span id="TypeParser.parse_bool-483"><a href="#TypeParser.parse_bool-483"><span class="linenos">483</span></a><span class="sd">			Parameters</span>
+</span><span id="TypeParser.parse_bool-484"><a href="#TypeParser.parse_bool-484"><span class="linenos">484</span></a><span class="sd">			----------</span>
+</span><span id="TypeParser.parse_bool-485"><a href="#TypeParser.parse_bool-485"><span class="linenos">485</span></a><span class="sd">			`value`</span>
+</span><span id="TypeParser.parse_bool-486"><a href="#TypeParser.parse_bool-486"><span class="linenos">486</span></a><span class="sd">			: string to be parsed</span>
+</span><span id="TypeParser.parse_bool-487"><a href="#TypeParser.parse_bool-487"><span class="linenos">487</span></a>
+</span><span id="TypeParser.parse_bool-488"><a href="#TypeParser.parse_bool-488"><span class="linenos">488</span></a><span class="sd">			Returns</span>
+</span><span id="TypeParser.parse_bool-489"><a href="#TypeParser.parse_bool-489"><span class="linenos">489</span></a><span class="sd">			-------</span>
+</span><span id="TypeParser.parse_bool-490"><a href="#TypeParser.parse_bool-490"><span class="linenos">490</span></a><span class="sd">			parsed bool value</span>
+</span><span id="TypeParser.parse_bool-491"><a href="#TypeParser.parse_bool-491"><span class="linenos">491</span></a>
+</span><span id="TypeParser.parse_bool-492"><a href="#TypeParser.parse_bool-492"><span class="linenos">492</span></a><span class="sd">			Raises</span>
+</span><span id="TypeParser.parse_bool-493"><a href="#TypeParser.parse_bool-493"><span class="linenos">493</span></a><span class="sd">			------</span>
+</span><span id="TypeParser.parse_bool-494"><a href="#TypeParser.parse_bool-494"><span class="linenos">494</span></a><span class="sd">			`ValueError` if `value` cannot be parsed</span>
+</span><span id="TypeParser.parse_bool-495"><a href="#TypeParser.parse_bool-495"><span class="linenos">495</span></a>
+</span><span id="TypeParser.parse_bool-496"><a href="#TypeParser.parse_bool-496"><span class="linenos">496</span></a><span class="sd">			Examples</span>
+</span><span id="TypeParser.parse_bool-497"><a href="#TypeParser.parse_bool-497"><span class="linenos">497</span></a><span class="sd">			--------</span>
+</span><span id="TypeParser.parse_bool-498"><a href="#TypeParser.parse_bool-498"><span class="linenos">498</span></a><span class="sd">			```python</span>
+</span><span id="TypeParser.parse_bool-499"><a href="#TypeParser.parse_bool-499"><span class="linenos">499</span></a><span class="sd">			parser = TypeParser()</span>
+</span><span id="TypeParser.parse_bool-500"><a href="#TypeParser.parse_bool-500"><span class="linenos">500</span></a><span class="sd">			parser.parse_bool(&quot;true&quot;)   # True</span>
+</span><span id="TypeParser.parse_bool-501"><a href="#TypeParser.parse_bool-501"><span class="linenos">501</span></a><span class="sd">			parser.parse_bool(&quot;FALSE&quot;)  # False</span>
+</span><span id="TypeParser.parse_bool-502"><a href="#TypeParser.parse_bool-502"><span class="linenos">502</span></a><span class="sd">			```</span>
+</span><span id="TypeParser.parse_bool-503"><a href="#TypeParser.parse_bool-503"><span class="linenos">503</span></a><span class="sd">		&quot;&quot;&quot;</span>
+</span><span id="TypeParser.parse_bool-504"><a href="#TypeParser.parse_bool-504"><span class="linenos">504</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trim</span><span class="p">:</span>
+</span><span id="TypeParser.parse_bool-505"><a href="#TypeParser.parse_bool-505"><span class="linenos">505</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
+</span><span id="TypeParser.parse_bool-506"><a href="#TypeParser.parse_bool-506"><span class="linenos">506</span></a>
+</span><span id="TypeParser.parse_bool-507"><a href="#TypeParser.parse_bool-507"><span class="linenos">507</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">bool_case_sensitive</span><span class="p">:</span>
+</span><span id="TypeParser.parse_bool-508"><a href="#TypeParser.parse_bool-508"><span class="linenos">508</span></a>			<span class="n">special_value</span> <span class="o">=</span> <span class="n">value</span>
+</span><span id="TypeParser.parse_bool-509"><a href="#TypeParser.parse_bool-509"><span class="linenos">509</span></a>		<span class="k">else</span><span class="p">:</span>
+</span><span id="TypeParser.parse_bool-510"><a href="#TypeParser.parse_bool-510"><span class="linenos">510</span></a>			<span class="n">special_value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
+</span><span id="TypeParser.parse_bool-511"><a href="#TypeParser.parse_bool-511"><span class="linenos">511</span></a>		<span class="k">if</span> <span class="n">special_value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">true_values</span><span class="p">:</span>
+</span><span id="TypeParser.parse_bool-512"><a href="#TypeParser.parse_bool-512"><span class="linenos">512</span></a>			<span class="k">return</span> <span class="kc">True</span>
+</span><span id="TypeParser.parse_bool-513"><a href="#TypeParser.parse_bool-513"><span class="linenos">513</span></a>		<span class="k">if</span> <span class="n">special_value</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">false_values</span><span class="p">:</span>
+</span><span id="TypeParser.parse_bool-514"><a href="#TypeParser.parse_bool-514"><span class="linenos">514</span></a>			<span class="k">return</span> <span class="kc">False</span>
+</span><span id="TypeParser.parse_bool-515"><a href="#TypeParser.parse_bool-515"><span class="linenos">515</span></a>
+</span><span id="TypeParser.parse_bool-516"><a href="#TypeParser.parse_bool-516"><span class="linenos">516</span></a>		<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;not a boolean: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
 </span></pre></div>
 
 
     <div class="docstring">
 <p>Parse a string and return it as a bool if possible</p>
 
 <p>Only strings that match the values in <code>self.true_values</code> and <code>self.false_values</code> will be interpreted as booleans. The default accepted values are <code>["true"]</code> and <code>["false"]</code> respectively. The case sensitivity of this matching depends on <code>self.bool_case_sensitive</code>, which is False by default.</p>
@@ -1984,64 +1984,64 @@
         <span class="name">parse_int</span><span class="signature pdoc-code condensed">(<span class="param"><span class="bp">self</span>, </span><span class="param"><span class="n">value</span><span class="p">:</span> <span class="nb">str</span>, </span><span class="param"><span class="o">*</span>, </span><span class="param"><span class="n">allow_scientific</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span></span><span class="return-annotation">) -> <span class="nb">int</span>:</span></span>
 
 
                 <label class="view-source-button" for="TypeParser.parse_int-view-source"><span>View Source</span></label>
 
     </div>
     <a class="headerlink" href="#TypeParser.parse_int"></a>
-            <div class="pdoc-code codehilite"><pre><span></span><span id="TypeParser.parse_int-520"><a href="#TypeParser.parse_int-520"><span class="linenos">520</span></a>	<span class="k">def</span> <span class="nf">parse_int</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
-</span><span id="TypeParser.parse_int-521"><a href="#TypeParser.parse_int-521"><span class="linenos">521</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
-</span><span id="TypeParser.parse_int-522"><a href="#TypeParser.parse_int-522"><span class="linenos">522</span></a><span class="sd">			Parse a string and return it as an int if possible</span>
-</span><span id="TypeParser.parse_int-523"><a href="#TypeParser.parse_int-523"><span class="linenos">523</span></a>
-</span><span id="TypeParser.parse_int-524"><a href="#TypeParser.parse_int-524"><span class="linenos">524</span></a><span class="sd">			If the string represents a bool, it will be converted to `1` for True and `0` for False.</span>
-</span><span id="TypeParser.parse_int-525"><a href="#TypeParser.parse_int-525"><span class="linenos">525</span></a>
-</span><span id="TypeParser.parse_int-526"><a href="#TypeParser.parse_int-526"><span class="linenos">526</span></a><span class="sd">			Parameters</span>
-</span><span id="TypeParser.parse_int-527"><a href="#TypeParser.parse_int-527"><span class="linenos">527</span></a><span class="sd">			----------</span>
-</span><span id="TypeParser.parse_int-528"><a href="#TypeParser.parse_int-528"><span class="linenos">528</span></a><span class="sd">			`value`</span>
-</span><span id="TypeParser.parse_int-529"><a href="#TypeParser.parse_int-529"><span class="linenos">529</span></a><span class="sd">			: string to be parsed</span>
-</span><span id="TypeParser.parse_int-530"><a href="#TypeParser.parse_int-530"><span class="linenos">530</span></a>
-</span><span id="TypeParser.parse_int-531"><a href="#TypeParser.parse_int-531"><span class="linenos">531</span></a><span class="sd">			`allow_scientific`</span>
-</span><span id="TypeParser.parse_int-532"><a href="#TypeParser.parse_int-532"><span class="linenos">532</span></a><span class="sd">			: whether to accept scientific notation. If True, strings of the form `&quot;&lt;var&gt;M&lt;/var&gt;e&lt;var&gt;X&lt;/var&gt;&quot;` will be interpreted as the expression `&lt;var&gt;M&lt;/var&gt; * (10 ** &lt;var&gt;X&lt;/var&gt;)`, where &lt;var&gt;M&lt;/var&gt; is the mantissa/significand and &lt;var&gt;X&lt;/var&gt; is the exponent. Note &lt;var&gt;M&lt;/var&gt; *must* be an integer and &lt;var&gt;X&lt;/var&gt; *must* be a non-negative integer, even in cases where the above expression evaluates mathematically to an integer.</span>
-</span><span id="TypeParser.parse_int-533"><a href="#TypeParser.parse_int-533"><span class="linenos">533</span></a>
-</span><span id="TypeParser.parse_int-534"><a href="#TypeParser.parse_int-534"><span class="linenos">534</span></a><span class="sd">			Returns</span>
-</span><span id="TypeParser.parse_int-535"><a href="#TypeParser.parse_int-535"><span class="linenos">535</span></a><span class="sd">			-------</span>
-</span><span id="TypeParser.parse_int-536"><a href="#TypeParser.parse_int-536"><span class="linenos">536</span></a><span class="sd">			parsed int value</span>
-</span><span id="TypeParser.parse_int-537"><a href="#TypeParser.parse_int-537"><span class="linenos">537</span></a>
-</span><span id="TypeParser.parse_int-538"><a href="#TypeParser.parse_int-538"><span class="linenos">538</span></a><span class="sd">			Raises</span>
-</span><span id="TypeParser.parse_int-539"><a href="#TypeParser.parse_int-539"><span class="linenos">539</span></a><span class="sd">			------</span>
-</span><span id="TypeParser.parse_int-540"><a href="#TypeParser.parse_int-540"><span class="linenos">540</span></a><span class="sd">			`ValueError` if `value` cannot be parsed</span>
-</span><span id="TypeParser.parse_int-541"><a href="#TypeParser.parse_int-541"><span class="linenos">541</span></a>
-</span><span id="TypeParser.parse_int-542"><a href="#TypeParser.parse_int-542"><span class="linenos">542</span></a><span class="sd">			Examples</span>
-</span><span id="TypeParser.parse_int-543"><a href="#TypeParser.parse_int-543"><span class="linenos">543</span></a><span class="sd">			--------</span>
-</span><span id="TypeParser.parse_int-544"><a href="#TypeParser.parse_int-544"><span class="linenos">544</span></a><span class="sd">			```python</span>
-</span><span id="TypeParser.parse_int-545"><a href="#TypeParser.parse_int-545"><span class="linenos">545</span></a><span class="sd">			parser = TypeParser()</span>
-</span><span id="TypeParser.parse_int-546"><a href="#TypeParser.parse_int-546"><span class="linenos">546</span></a><span class="sd">			parser.parse_int(&quot;0&quot;)    # 0</span>
-</span><span id="TypeParser.parse_int-547"><a href="#TypeParser.parse_int-547"><span class="linenos">547</span></a><span class="sd">			parser.parse_int(&quot;-1&quot;)   # -1</span>
-</span><span id="TypeParser.parse_int-548"><a href="#TypeParser.parse_int-548"><span class="linenos">548</span></a><span class="sd">			parser.parse_int(&quot;2e3&quot;)  # 2000</span>
-</span><span id="TypeParser.parse_int-549"><a href="#TypeParser.parse_int-549"><span class="linenos">549</span></a><span class="sd">			```</span>
-</span><span id="TypeParser.parse_int-550"><a href="#TypeParser.parse_int-550"><span class="linenos">550</span></a><span class="sd">		&quot;&quot;&quot;</span>
-</span><span id="TypeParser.parse_int-551"><a href="#TypeParser.parse_int-551"><span class="linenos">551</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trim</span><span class="p">:</span>
-</span><span id="TypeParser.parse_int-552"><a href="#TypeParser.parse_int-552"><span class="linenos">552</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
-</span><span id="TypeParser.parse_int-553"><a href="#TypeParser.parse_int-553"><span class="linenos">553</span></a>
-</span><span id="TypeParser.parse_int-554"><a href="#TypeParser.parse_int-554"><span class="linenos">554</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_int</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">allow_sign</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_negative</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="o">=</span><span class="n">allow_scientific</span><span class="p">):</span>
-</span><span id="TypeParser.parse_int-555"><a href="#TypeParser.parse_int-555"><span class="linenos">555</span></a>			<span class="k">if</span> <span class="n">allow_scientific</span><span class="p">:</span>
-</span><span id="TypeParser.parse_int-556"><a href="#TypeParser.parse_int-556"><span class="linenos">556</span></a>				<span class="n">value</span><span class="p">,</span> <span class="n">exp</span> <span class="o">=</span> <span class="n">_decompose_string_pair</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scientific_char</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">int_case_sensitive</span><span class="p">)</span>
-</span><span id="TypeParser.parse_int-557"><a href="#TypeParser.parse_int-557"><span class="linenos">557</span></a>				<span class="k">if</span> <span class="n">exp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
-</span><span id="TypeParser.parse_int-558"><a href="#TypeParser.parse_int-558"><span class="linenos">558</span></a>					<span class="k">if</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_negative_chars</span> <span class="o">-</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_negative_char</span><span class="p">}):</span>
-</span><span id="TypeParser.parse_int-559"><a href="#TypeParser.parse_int-559"><span class="linenos">559</span></a>						<span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_negative_char</span> <span class="o">+</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
-</span><span id="TypeParser.parse_int-560"><a href="#TypeParser.parse_int-560"><span class="linenos">560</span></a>					<span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">10</span> <span class="o">**</span> <span class="nb">int</span><span class="p">(</span><span class="n">exp</span><span class="p">))</span>
-</span><span id="TypeParser.parse_int-561"><a href="#TypeParser.parse_int-561"><span class="linenos">561</span></a>
-</span><span id="TypeParser.parse_int-562"><a href="#TypeParser.parse_int-562"><span class="linenos">562</span></a>			<span class="k">if</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_negative_chars</span> <span class="o">-</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_negative_char</span><span class="p">}):</span>
-</span><span id="TypeParser.parse_int-563"><a href="#TypeParser.parse_int-563"><span class="linenos">563</span></a>				<span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_negative_char</span> <span class="o">+</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
-</span><span id="TypeParser.parse_int-564"><a href="#TypeParser.parse_int-564"><span class="linenos">564</span></a>			<span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
-</span><span id="TypeParser.parse_int-565"><a href="#TypeParser.parse_int-565"><span class="linenos">565</span></a>
-</span><span id="TypeParser.parse_int-566"><a href="#TypeParser.parse_int-566"><span class="linenos">566</span></a>		<span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_bool</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
-</span><span id="TypeParser.parse_int-567"><a href="#TypeParser.parse_int-567"><span class="linenos">567</span></a>			<span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parse_bool</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
-</span><span id="TypeParser.parse_int-568"><a href="#TypeParser.parse_int-568"><span class="linenos">568</span></a>		<span class="k">else</span><span class="p">:</span>
-</span><span id="TypeParser.parse_int-569"><a href="#TypeParser.parse_int-569"><span class="linenos">569</span></a>			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;not an integer: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
+            <div class="pdoc-code codehilite"><pre><span></span><span id="TypeParser.parse_int-519"><a href="#TypeParser.parse_int-519"><span class="linenos">519</span></a>	<span class="k">def</span> <span class="nf">parse_int</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
+</span><span id="TypeParser.parse_int-520"><a href="#TypeParser.parse_int-520"><span class="linenos">520</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
+</span><span id="TypeParser.parse_int-521"><a href="#TypeParser.parse_int-521"><span class="linenos">521</span></a><span class="sd">			Parse a string and return it as an int if possible</span>
+</span><span id="TypeParser.parse_int-522"><a href="#TypeParser.parse_int-522"><span class="linenos">522</span></a>
+</span><span id="TypeParser.parse_int-523"><a href="#TypeParser.parse_int-523"><span class="linenos">523</span></a><span class="sd">			If the string represents a bool, it will be converted to `1` for True and `0` for False.</span>
+</span><span id="TypeParser.parse_int-524"><a href="#TypeParser.parse_int-524"><span class="linenos">524</span></a>
+</span><span id="TypeParser.parse_int-525"><a href="#TypeParser.parse_int-525"><span class="linenos">525</span></a><span class="sd">			Parameters</span>
+</span><span id="TypeParser.parse_int-526"><a href="#TypeParser.parse_int-526"><span class="linenos">526</span></a><span class="sd">			----------</span>
+</span><span id="TypeParser.parse_int-527"><a href="#TypeParser.parse_int-527"><span class="linenos">527</span></a><span class="sd">			`value`</span>
+</span><span id="TypeParser.parse_int-528"><a href="#TypeParser.parse_int-528"><span class="linenos">528</span></a><span class="sd">			: string to be parsed</span>
+</span><span id="TypeParser.parse_int-529"><a href="#TypeParser.parse_int-529"><span class="linenos">529</span></a>
+</span><span id="TypeParser.parse_int-530"><a href="#TypeParser.parse_int-530"><span class="linenos">530</span></a><span class="sd">			`allow_scientific`</span>
+</span><span id="TypeParser.parse_int-531"><a href="#TypeParser.parse_int-531"><span class="linenos">531</span></a><span class="sd">			: whether to accept scientific notation. If True, strings of the form `&quot;&lt;var&gt;M&lt;/var&gt;e&lt;var&gt;X&lt;/var&gt;&quot;` will be interpreted as the expression `&lt;var&gt;M&lt;/var&gt; * (10 ** &lt;var&gt;X&lt;/var&gt;)`, where &lt;var&gt;M&lt;/var&gt; is the mantissa/significand and &lt;var&gt;X&lt;/var&gt; is the exponent. Note &lt;var&gt;M&lt;/var&gt; *must* be an integer and &lt;var&gt;X&lt;/var&gt; *must* be a non-negative integer, even in cases where the above expression evaluates mathematically to an integer.</span>
+</span><span id="TypeParser.parse_int-532"><a href="#TypeParser.parse_int-532"><span class="linenos">532</span></a>
+</span><span id="TypeParser.parse_int-533"><a href="#TypeParser.parse_int-533"><span class="linenos">533</span></a><span class="sd">			Returns</span>
+</span><span id="TypeParser.parse_int-534"><a href="#TypeParser.parse_int-534"><span class="linenos">534</span></a><span class="sd">			-------</span>
+</span><span id="TypeParser.parse_int-535"><a href="#TypeParser.parse_int-535"><span class="linenos">535</span></a><span class="sd">			parsed int value</span>
+</span><span id="TypeParser.parse_int-536"><a href="#TypeParser.parse_int-536"><span class="linenos">536</span></a>
+</span><span id="TypeParser.parse_int-537"><a href="#TypeParser.parse_int-537"><span class="linenos">537</span></a><span class="sd">			Raises</span>
+</span><span id="TypeParser.parse_int-538"><a href="#TypeParser.parse_int-538"><span class="linenos">538</span></a><span class="sd">			------</span>
+</span><span id="TypeParser.parse_int-539"><a href="#TypeParser.parse_int-539"><span class="linenos">539</span></a><span class="sd">			`ValueError` if `value` cannot be parsed</span>
+</span><span id="TypeParser.parse_int-540"><a href="#TypeParser.parse_int-540"><span class="linenos">540</span></a>
+</span><span id="TypeParser.parse_int-541"><a href="#TypeParser.parse_int-541"><span class="linenos">541</span></a><span class="sd">			Examples</span>
+</span><span id="TypeParser.parse_int-542"><a href="#TypeParser.parse_int-542"><span class="linenos">542</span></a><span class="sd">			--------</span>
+</span><span id="TypeParser.parse_int-543"><a href="#TypeParser.parse_int-543"><span class="linenos">543</span></a><span class="sd">			```python</span>
+</span><span id="TypeParser.parse_int-544"><a href="#TypeParser.parse_int-544"><span class="linenos">544</span></a><span class="sd">			parser = TypeParser()</span>
+</span><span id="TypeParser.parse_int-545"><a href="#TypeParser.parse_int-545"><span class="linenos">545</span></a><span class="sd">			parser.parse_int(&quot;0&quot;)    # 0</span>
+</span><span id="TypeParser.parse_int-546"><a href="#TypeParser.parse_int-546"><span class="linenos">546</span></a><span class="sd">			parser.parse_int(&quot;-1&quot;)   # -1</span>
+</span><span id="TypeParser.parse_int-547"><a href="#TypeParser.parse_int-547"><span class="linenos">547</span></a><span class="sd">			parser.parse_int(&quot;2e3&quot;)  # 2000</span>
+</span><span id="TypeParser.parse_int-548"><a href="#TypeParser.parse_int-548"><span class="linenos">548</span></a><span class="sd">			```</span>
+</span><span id="TypeParser.parse_int-549"><a href="#TypeParser.parse_int-549"><span class="linenos">549</span></a><span class="sd">		&quot;&quot;&quot;</span>
+</span><span id="TypeParser.parse_int-550"><a href="#TypeParser.parse_int-550"><span class="linenos">550</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trim</span><span class="p">:</span>
+</span><span id="TypeParser.parse_int-551"><a href="#TypeParser.parse_int-551"><span class="linenos">551</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
+</span><span id="TypeParser.parse_int-552"><a href="#TypeParser.parse_int-552"><span class="linenos">552</span></a>
+</span><span id="TypeParser.parse_int-553"><a href="#TypeParser.parse_int-553"><span class="linenos">553</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_int</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">allow_sign</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_negative</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="o">=</span><span class="n">allow_scientific</span><span class="p">):</span>
+</span><span id="TypeParser.parse_int-554"><a href="#TypeParser.parse_int-554"><span class="linenos">554</span></a>			<span class="k">if</span> <span class="n">allow_scientific</span><span class="p">:</span>
+</span><span id="TypeParser.parse_int-555"><a href="#TypeParser.parse_int-555"><span class="linenos">555</span></a>				<span class="n">value</span><span class="p">,</span> <span class="n">exp</span> <span class="o">=</span> <span class="n">_decompose_string_pair</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_scientific_char</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">int_case_sensitive</span><span class="p">)</span>
+</span><span id="TypeParser.parse_int-556"><a href="#TypeParser.parse_int-556"><span class="linenos">556</span></a>				<span class="k">if</span> <span class="n">exp</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
+</span><span id="TypeParser.parse_int-557"><a href="#TypeParser.parse_int-557"><span class="linenos">557</span></a>					<span class="k">if</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_negative_chars</span> <span class="o">-</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_negative_char</span><span class="p">}):</span>
+</span><span id="TypeParser.parse_int-558"><a href="#TypeParser.parse_int-558"><span class="linenos">558</span></a>						<span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_negative_char</span> <span class="o">+</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
+</span><span id="TypeParser.parse_int-559"><a href="#TypeParser.parse_int-559"><span class="linenos">559</span></a>					<span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">10</span> <span class="o">**</span> <span class="nb">int</span><span class="p">(</span><span class="n">exp</span><span class="p">))</span>
+</span><span id="TypeParser.parse_int-560"><a href="#TypeParser.parse_int-560"><span class="linenos">560</span></a>
+</span><span id="TypeParser.parse_int-561"><a href="#TypeParser.parse_int-561"><span class="linenos">561</span></a>			<span class="k">if</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_negative_chars</span> <span class="o">-</span> <span class="p">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_negative_char</span><span class="p">}):</span>
+</span><span id="TypeParser.parse_int-562"><a href="#TypeParser.parse_int-562"><span class="linenos">562</span></a>				<span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_negative_char</span> <span class="o">+</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
+</span><span id="TypeParser.parse_int-563"><a href="#TypeParser.parse_int-563"><span class="linenos">563</span></a>			<span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
+</span><span id="TypeParser.parse_int-564"><a href="#TypeParser.parse_int-564"><span class="linenos">564</span></a>
+</span><span id="TypeParser.parse_int-565"><a href="#TypeParser.parse_int-565"><span class="linenos">565</span></a>		<span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_bool</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
+</span><span id="TypeParser.parse_int-566"><a href="#TypeParser.parse_int-566"><span class="linenos">566</span></a>			<span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parse_bool</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
+</span><span id="TypeParser.parse_int-567"><a href="#TypeParser.parse_int-567"><span class="linenos">567</span></a>		<span class="k">else</span><span class="p">:</span>
+</span><span id="TypeParser.parse_int-568"><a href="#TypeParser.parse_int-568"><span class="linenos">568</span></a>			<span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;not an integer: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
 </span></pre></div>
 
 
     <div class="docstring">
 <p>Parse a string and return it as an int if possible</p>
 
 <p>If the string represents a bool, it will be converted to <code>1</code> for True and <code>0</code> for False.</p>
@@ -2083,59 +2083,59 @@
         <span class="name">parse_float</span><span class="signature pdoc-code multiline">(<span class="param">	<span class="bp">self</span>,</span><span class="param">	<span class="n">value</span><span class="p">:</span> <span class="nb">str</span>,</span><span class="param">	<span class="o">*</span>,</span><span class="param">	<span class="n">allow_scientific</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>,</span><span class="param">	<span class="n">allow_inf</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>,</span><span class="param">	<span class="n">allow_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span></span><span class="return-annotation">) -> <span class="nb">float</span>:</span></span>
 
 
                 <label class="view-source-button" for="TypeParser.parse_float-view-source"><span>View Source</span></label>
 
     </div>
     <a class="headerlink" href="#TypeParser.parse_float"></a>
-            <div class="pdoc-code codehilite"><pre><span></span><span id="TypeParser.parse_float-617"><a href="#TypeParser.parse_float-617"><span class="linenos">617</span></a>	<span class="k">def</span> <span class="nf">parse_float</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_inf</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_nan</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
-</span><span id="TypeParser.parse_float-618"><a href="#TypeParser.parse_float-618"><span class="linenos">618</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
-</span><span id="TypeParser.parse_float-619"><a href="#TypeParser.parse_float-619"><span class="linenos">619</span></a><span class="sd">			Parse a string and return it as a (non-exact) float if possible</span>
-</span><span id="TypeParser.parse_float-620"><a href="#TypeParser.parse_float-620"><span class="linenos">620</span></a>
-</span><span id="TypeParser.parse_float-621"><a href="#TypeParser.parse_float-621"><span class="linenos">621</span></a><span class="sd">			If the string represents a bool, it will be converted to `1.` for True and `0.` for False. If the string represents an int, it will be converted to a float also.</span>
-</span><span id="TypeParser.parse_float-622"><a href="#TypeParser.parse_float-622"><span class="linenos">622</span></a>
-</span><span id="TypeParser.parse_float-623"><a href="#TypeParser.parse_float-623"><span class="linenos">623</span></a><span class="sd">			Behaves analogously to `parse_decimal()`, except that that returns an exact Decimal instead.</span>
-</span><span id="TypeParser.parse_float-624"><a href="#TypeParser.parse_float-624"><span class="linenos">624</span></a>
-</span><span id="TypeParser.parse_float-625"><a href="#TypeParser.parse_float-625"><span class="linenos">625</span></a><span class="sd">			Parameters</span>
-</span><span id="TypeParser.parse_float-626"><a href="#TypeParser.parse_float-626"><span class="linenos">626</span></a><span class="sd">			----------</span>
-</span><span id="TypeParser.parse_float-627"><a href="#TypeParser.parse_float-627"><span class="linenos">627</span></a><span class="sd">			`value`</span>
-</span><span id="TypeParser.parse_float-628"><a href="#TypeParser.parse_float-628"><span class="linenos">628</span></a><span class="sd">			: string to be parsed</span>
-</span><span id="TypeParser.parse_float-629"><a href="#TypeParser.parse_float-629"><span class="linenos">629</span></a>
-</span><span id="TypeParser.parse_float-630"><a href="#TypeParser.parse_float-630"><span class="linenos">630</span></a><span class="sd">			`allow_scientific`</span>
-</span><span id="TypeParser.parse_float-631"><a href="#TypeParser.parse_float-631"><span class="linenos">631</span></a><span class="sd">			: whether to accept scientific notation. If True, strings of the form `&quot;&lt;var&gt;M&lt;/var&gt;e&lt;var&gt;X&lt;/var&gt;&quot;` will be interpreted as the expression `&lt;var&gt;M&lt;/var&gt; * (10 ** &lt;var&gt;X&lt;/var&gt;)`, where &lt;var&gt;M&lt;/var&gt; is the mantissa/significand and &lt;var&gt;X&lt;/var&gt; is the exponent. Note that &lt;var&gt;X&lt;/var&gt; must be an integer, but can be negative.</span>
-</span><span id="TypeParser.parse_float-632"><a href="#TypeParser.parse_float-632"><span class="linenos">632</span></a>
-</span><span id="TypeParser.parse_float-633"><a href="#TypeParser.parse_float-633"><span class="linenos">633</span></a><span class="sd">			`allow_inf`</span>
-</span><span id="TypeParser.parse_float-634"><a href="#TypeParser.parse_float-634"><span class="linenos">634</span></a><span class="sd">			: whether to accept positive and negative infinity values. If True, strings that match the values in `self.inf_values` (empty by default) are interpreted as infinity, or as negative infinity if prepended by a negative sign. The case sensitivity of this matching depends on `self.float_case_sensitive`, which is False by default.</span>
-</span><span id="TypeParser.parse_float-635"><a href="#TypeParser.parse_float-635"><span class="linenos">635</span></a>
-</span><span id="TypeParser.parse_float-636"><a href="#TypeParser.parse_float-636"><span class="linenos">636</span></a><span class="sd">			`allow_nan`</span>
-</span><span id="TypeParser.parse_float-637"><a href="#TypeParser.parse_float-637"><span class="linenos">637</span></a><span class="sd">			: whether to accept NaN (not a number) representations. If True, strings that match the values in `self.nan_values` (empty by default) are interpeted as NaN. The case sensitivity of this matching depends on `self.float_case_sensitive`, which is False by default.</span>
-</span><span id="TypeParser.parse_float-638"><a href="#TypeParser.parse_float-638"><span class="linenos">638</span></a>
-</span><span id="TypeParser.parse_float-639"><a href="#TypeParser.parse_float-639"><span class="linenos">639</span></a><span class="sd">			Returns</span>
-</span><span id="TypeParser.parse_float-640"><a href="#TypeParser.parse_float-640"><span class="linenos">640</span></a><span class="sd">			-------</span>
-</span><span id="TypeParser.parse_float-641"><a href="#TypeParser.parse_float-641"><span class="linenos">641</span></a><span class="sd">			parsed float value</span>
-</span><span id="TypeParser.parse_float-642"><a href="#TypeParser.parse_float-642"><span class="linenos">642</span></a>
-</span><span id="TypeParser.parse_float-643"><a href="#TypeParser.parse_float-643"><span class="linenos">643</span></a><span class="sd">			Raises</span>
-</span><span id="TypeParser.parse_float-644"><a href="#TypeParser.parse_float-644"><span class="linenos">644</span></a><span class="sd">			------</span>
-</span><span id="TypeParser.parse_float-645"><a href="#TypeParser.parse_float-645"><span class="linenos">645</span></a><span class="sd">			`ValueError` if `value` cannot be parsed</span>
-</span><span id="TypeParser.parse_float-646"><a href="#TypeParser.parse_float-646"><span class="linenos">646</span></a>
-</span><span id="TypeParser.parse_float-647"><a href="#TypeParser.parse_float-647"><span class="linenos">647</span></a><span class="sd">			Examples</span>
-</span><span id="TypeParser.parse_float-648"><a href="#TypeParser.parse_float-648"><span class="linenos">648</span></a><span class="sd">			--------</span>
-</span><span id="TypeParser.parse_float-649"><a href="#TypeParser.parse_float-649"><span class="linenos">649</span></a><span class="sd">			```python</span>
-</span><span id="TypeParser.parse_float-650"><a href="#TypeParser.parse_float-650"><span class="linenos">650</span></a><span class="sd">			parser = TypeParser(inf_values=[&quot;inf&quot;], nan_values=[&quot;nan&quot;])</span>
-</span><span id="TypeParser.parse_float-651"><a href="#TypeParser.parse_float-651"><span class="linenos">651</span></a><span class="sd">			parser.parse_float(&quot;1.&quot;)       # 1.</span>
-</span><span id="TypeParser.parse_float-652"><a href="#TypeParser.parse_float-652"><span class="linenos">652</span></a><span class="sd">			parser.parse_float(&quot;1.23e2&quot;)   # 123.</span>
-</span><span id="TypeParser.parse_float-653"><a href="#TypeParser.parse_float-653"><span class="linenos">653</span></a><span class="sd">			parser.parse_float(&quot;1.23e-2&quot;)  # 0.0123</span>
-</span><span id="TypeParser.parse_float-654"><a href="#TypeParser.parse_float-654"><span class="linenos">654</span></a><span class="sd">			parser.parse_float(&quot;inf&quot;)      # math.inf</span>
-</span><span id="TypeParser.parse_float-655"><a href="#TypeParser.parse_float-655"><span class="linenos">655</span></a><span class="sd">			```</span>
-</span><span id="TypeParser.parse_float-656"><a href="#TypeParser.parse_float-656"><span class="linenos">656</span></a><span class="sd">		&quot;&quot;&quot;</span>
-</span><span id="TypeParser.parse_float-657"><a href="#TypeParser.parse_float-657"><span class="linenos">657</span></a>		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_floatlike</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
-</span><span id="TypeParser.parse_float-658"><a href="#TypeParser.parse_float-658"><span class="linenos">658</span></a>			<span class="n">allow_scientific</span><span class="o">=</span><span class="n">allow_scientific</span><span class="p">,</span>
-</span><span id="TypeParser.parse_float-659"><a href="#TypeParser.parse_float-659"><span class="linenos">659</span></a>			<span class="n">allow_inf</span><span class="o">=</span><span class="n">allow_inf</span><span class="p">,</span>
-</span><span id="TypeParser.parse_float-660"><a href="#TypeParser.parse_float-660"><span class="linenos">660</span></a>			<span class="n">allow_nan</span><span class="o">=</span><span class="n">allow_nan</span><span class="p">,</span>
-</span><span id="TypeParser.parse_float-661"><a href="#TypeParser.parse_float-661"><span class="linenos">661</span></a>		<span class="p">)</span>
+            <div class="pdoc-code codehilite"><pre><span></span><span id="TypeParser.parse_float-616"><a href="#TypeParser.parse_float-616"><span class="linenos">616</span></a>	<span class="k">def</span> <span class="nf">parse_float</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_inf</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_nan</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
+</span><span id="TypeParser.parse_float-617"><a href="#TypeParser.parse_float-617"><span class="linenos">617</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
+</span><span id="TypeParser.parse_float-618"><a href="#TypeParser.parse_float-618"><span class="linenos">618</span></a><span class="sd">			Parse a string and return it as a (non-exact) float if possible</span>
+</span><span id="TypeParser.parse_float-619"><a href="#TypeParser.parse_float-619"><span class="linenos">619</span></a>
+</span><span id="TypeParser.parse_float-620"><a href="#TypeParser.parse_float-620"><span class="linenos">620</span></a><span class="sd">			If the string represents a bool, it will be converted to `1.` for True and `0.` for False. If the string represents an int, it will be converted to a float also.</span>
+</span><span id="TypeParser.parse_float-621"><a href="#TypeParser.parse_float-621"><span class="linenos">621</span></a>
+</span><span id="TypeParser.parse_float-622"><a href="#TypeParser.parse_float-622"><span class="linenos">622</span></a><span class="sd">			Behaves analogously to `parse_decimal()`, except that that returns an exact Decimal instead.</span>
+</span><span id="TypeParser.parse_float-623"><a href="#TypeParser.parse_float-623"><span class="linenos">623</span></a>
+</span><span id="TypeParser.parse_float-624"><a href="#TypeParser.parse_float-624"><span class="linenos">624</span></a><span class="sd">			Parameters</span>
+</span><span id="TypeParser.parse_float-625"><a href="#TypeParser.parse_float-625"><span class="linenos">625</span></a><span class="sd">			----------</span>
+</span><span id="TypeParser.parse_float-626"><a href="#TypeParser.parse_float-626"><span class="linenos">626</span></a><span class="sd">			`value`</span>
+</span><span id="TypeParser.parse_float-627"><a href="#TypeParser.parse_float-627"><span class="linenos">627</span></a><span class="sd">			: string to be parsed</span>
+</span><span id="TypeParser.parse_float-628"><a href="#TypeParser.parse_float-628"><span class="linenos">628</span></a>
+</span><span id="TypeParser.parse_float-629"><a href="#TypeParser.parse_float-629"><span class="linenos">629</span></a><span class="sd">			`allow_scientific`</span>
+</span><span id="TypeParser.parse_float-630"><a href="#TypeParser.parse_float-630"><span class="linenos">630</span></a><span class="sd">			: whether to accept scientific notation. If True, strings of the form `&quot;&lt;var&gt;M&lt;/var&gt;e&lt;var&gt;X&lt;/var&gt;&quot;` will be interpreted as the expression `&lt;var&gt;M&lt;/var&gt; * (10 ** &lt;var&gt;X&lt;/var&gt;)`, where &lt;var&gt;M&lt;/var&gt; is the mantissa/significand and &lt;var&gt;X&lt;/var&gt; is the exponent. Note that &lt;var&gt;X&lt;/var&gt; must be an integer, but can be negative.</span>
+</span><span id="TypeParser.parse_float-631"><a href="#TypeParser.parse_float-631"><span class="linenos">631</span></a>
+</span><span id="TypeParser.parse_float-632"><a href="#TypeParser.parse_float-632"><span class="linenos">632</span></a><span class="sd">			`allow_inf`</span>
+</span><span id="TypeParser.parse_float-633"><a href="#TypeParser.parse_float-633"><span class="linenos">633</span></a><span class="sd">			: whether to accept positive and negative infinity values. If True, strings that match the values in `self.inf_values` (empty by default) are interpreted as infinity, or as negative infinity if prepended by a negative sign. The case sensitivity of this matching depends on `self.float_case_sensitive`, which is False by default.</span>
+</span><span id="TypeParser.parse_float-634"><a href="#TypeParser.parse_float-634"><span class="linenos">634</span></a>
+</span><span id="TypeParser.parse_float-635"><a href="#TypeParser.parse_float-635"><span class="linenos">635</span></a><span class="sd">			`allow_nan`</span>
+</span><span id="TypeParser.parse_float-636"><a href="#TypeParser.parse_float-636"><span class="linenos">636</span></a><span class="sd">			: whether to accept NaN (not a number) representations. If True, strings that match the values in `self.nan_values` (empty by default) are interpeted as NaN. The case sensitivity of this matching depends on `self.float_case_sensitive`, which is False by default.</span>
+</span><span id="TypeParser.parse_float-637"><a href="#TypeParser.parse_float-637"><span class="linenos">637</span></a>
+</span><span id="TypeParser.parse_float-638"><a href="#TypeParser.parse_float-638"><span class="linenos">638</span></a><span class="sd">			Returns</span>
+</span><span id="TypeParser.parse_float-639"><a href="#TypeParser.parse_float-639"><span class="linenos">639</span></a><span class="sd">			-------</span>
+</span><span id="TypeParser.parse_float-640"><a href="#TypeParser.parse_float-640"><span class="linenos">640</span></a><span class="sd">			parsed float value</span>
+</span><span id="TypeParser.parse_float-641"><a href="#TypeParser.parse_float-641"><span class="linenos">641</span></a>
+</span><span id="TypeParser.parse_float-642"><a href="#TypeParser.parse_float-642"><span class="linenos">642</span></a><span class="sd">			Raises</span>
+</span><span id="TypeParser.parse_float-643"><a href="#TypeParser.parse_float-643"><span class="linenos">643</span></a><span class="sd">			------</span>
+</span><span id="TypeParser.parse_float-644"><a href="#TypeParser.parse_float-644"><span class="linenos">644</span></a><span class="sd">			`ValueError` if `value` cannot be parsed</span>
+</span><span id="TypeParser.parse_float-645"><a href="#TypeParser.parse_float-645"><span class="linenos">645</span></a>
+</span><span id="TypeParser.parse_float-646"><a href="#TypeParser.parse_float-646"><span class="linenos">646</span></a><span class="sd">			Examples</span>
+</span><span id="TypeParser.parse_float-647"><a href="#TypeParser.parse_float-647"><span class="linenos">647</span></a><span class="sd">			--------</span>
+</span><span id="TypeParser.parse_float-648"><a href="#TypeParser.parse_float-648"><span class="linenos">648</span></a><span class="sd">			```python</span>
+</span><span id="TypeParser.parse_float-649"><a href="#TypeParser.parse_float-649"><span class="linenos">649</span></a><span class="sd">			parser = TypeParser(inf_values=[&quot;inf&quot;], nan_values=[&quot;nan&quot;])</span>
+</span><span id="TypeParser.parse_float-650"><a href="#TypeParser.parse_float-650"><span class="linenos">650</span></a><span class="sd">			parser.parse_float(&quot;1.&quot;)       # 1.</span>
+</span><span id="TypeParser.parse_float-651"><a href="#TypeParser.parse_float-651"><span class="linenos">651</span></a><span class="sd">			parser.parse_float(&quot;1.23e2&quot;)   # 123.</span>
+</span><span id="TypeParser.parse_float-652"><a href="#TypeParser.parse_float-652"><span class="linenos">652</span></a><span class="sd">			parser.parse_float(&quot;1.23e-2&quot;)  # 0.0123</span>
+</span><span id="TypeParser.parse_float-653"><a href="#TypeParser.parse_float-653"><span class="linenos">653</span></a><span class="sd">			parser.parse_float(&quot;inf&quot;)      # math.inf</span>
+</span><span id="TypeParser.parse_float-654"><a href="#TypeParser.parse_float-654"><span class="linenos">654</span></a><span class="sd">			```</span>
+</span><span id="TypeParser.parse_float-655"><a href="#TypeParser.parse_float-655"><span class="linenos">655</span></a><span class="sd">		&quot;&quot;&quot;</span>
+</span><span id="TypeParser.parse_float-656"><a href="#TypeParser.parse_float-656"><span class="linenos">656</span></a>		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_floatlike</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">,</span> <span class="n">math</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span>
+</span><span id="TypeParser.parse_float-657"><a href="#TypeParser.parse_float-657"><span class="linenos">657</span></a>			<span class="n">allow_scientific</span><span class="o">=</span><span class="n">allow_scientific</span><span class="p">,</span>
+</span><span id="TypeParser.parse_float-658"><a href="#TypeParser.parse_float-658"><span class="linenos">658</span></a>			<span class="n">allow_inf</span><span class="o">=</span><span class="n">allow_inf</span><span class="p">,</span>
+</span><span id="TypeParser.parse_float-659"><a href="#TypeParser.parse_float-659"><span class="linenos">659</span></a>			<span class="n">allow_nan</span><span class="o">=</span><span class="n">allow_nan</span><span class="p">,</span>
+</span><span id="TypeParser.parse_float-660"><a href="#TypeParser.parse_float-660"><span class="linenos">660</span></a>		<span class="p">)</span>
 </span></pre></div>
 
 
     <div class="docstring">
 <p>Parse a string and return it as a (non-exact) float if possible</p>
 
 <p>If the string represents a bool, it will be converted to <code>1.</code> for True and <code>0.</code> for False. If the string represents an int, it will be converted to a float also.</p>
@@ -2186,59 +2186,59 @@
         <span class="name">parse_decimal</span><span class="signature pdoc-code multiline">(<span class="param">	<span class="bp">self</span>,</span><span class="param">	<span class="n">value</span><span class="p">:</span> <span class="nb">str</span>,</span><span class="param">	<span class="o">*</span>,</span><span class="param">	<span class="n">allow_scientific</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>,</span><span class="param">	<span class="n">allow_inf</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>,</span><span class="param">	<span class="n">allow_nan</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span></span><span class="return-annotation">) -> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span>:</span></span>
 
 
                 <label class="view-source-button" for="TypeParser.parse_decimal-view-source"><span>View Source</span></label>
 
     </div>
     <a class="headerlink" href="#TypeParser.parse_decimal"></a>
-            <div class="pdoc-code codehilite"><pre><span></span><span id="TypeParser.parse_decimal-664"><a href="#TypeParser.parse_decimal-664"><span class="linenos">664</span></a>	<span class="k">def</span> <span class="nf">parse_decimal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_inf</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_nan</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Decimal</span><span class="p">:</span>
-</span><span id="TypeParser.parse_decimal-665"><a href="#TypeParser.parse_decimal-665"><span class="linenos">665</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
-</span><span id="TypeParser.parse_decimal-666"><a href="#TypeParser.parse_decimal-666"><span class="linenos">666</span></a><span class="sd">			Parse a string and return it as an exact Decimal if possible</span>
-</span><span id="TypeParser.parse_decimal-667"><a href="#TypeParser.parse_decimal-667"><span class="linenos">667</span></a>
-</span><span id="TypeParser.parse_decimal-668"><a href="#TypeParser.parse_decimal-668"><span class="linenos">668</span></a><span class="sd">			If the string represents a bool, it will be converted to `Decimal(1)` for True and `Decimal(0)` for False. If the string represents an int, it will be converted to a Decimal also.</span>
-</span><span id="TypeParser.parse_decimal-669"><a href="#TypeParser.parse_decimal-669"><span class="linenos">669</span></a>
-</span><span id="TypeParser.parse_decimal-670"><a href="#TypeParser.parse_decimal-670"><span class="linenos">670</span></a><span class="sd">			Behaves analogously to `parse_float()`, except that that returns a non-exact float instead.</span>
-</span><span id="TypeParser.parse_decimal-671"><a href="#TypeParser.parse_decimal-671"><span class="linenos">671</span></a>
-</span><span id="TypeParser.parse_decimal-672"><a href="#TypeParser.parse_decimal-672"><span class="linenos">672</span></a><span class="sd">			Parameters</span>
-</span><span id="TypeParser.parse_decimal-673"><a href="#TypeParser.parse_decimal-673"><span class="linenos">673</span></a><span class="sd">			----------</span>
-</span><span id="TypeParser.parse_decimal-674"><a href="#TypeParser.parse_decimal-674"><span class="linenos">674</span></a><span class="sd">			`value`</span>
-</span><span id="TypeParser.parse_decimal-675"><a href="#TypeParser.parse_decimal-675"><span class="linenos">675</span></a><span class="sd">			: string to be parsed</span>
-</span><span id="TypeParser.parse_decimal-676"><a href="#TypeParser.parse_decimal-676"><span class="linenos">676</span></a>
-</span><span id="TypeParser.parse_decimal-677"><a href="#TypeParser.parse_decimal-677"><span class="linenos">677</span></a><span class="sd">			`allow_scientific`</span>
-</span><span id="TypeParser.parse_decimal-678"><a href="#TypeParser.parse_decimal-678"><span class="linenos">678</span></a><span class="sd">			: whether to accept scientific notation. If True, strings of the form `&quot;&lt;var&gt;M&lt;/var&gt;e&lt;var&gt;X&lt;/var&gt;&quot;` will be interpreted as the expression `&lt;var&gt;M&lt;/var&gt; * (10 ** &lt;var&gt;X&lt;/var&gt;)`, where &lt;var&gt;M&lt;/var&gt; is the mantissa/significand and &lt;var&gt;X&lt;/var&gt; is the exponent. Note that &lt;var&gt;X&lt;/var&gt; must be an integer, but can be negative.</span>
-</span><span id="TypeParser.parse_decimal-679"><a href="#TypeParser.parse_decimal-679"><span class="linenos">679</span></a>
-</span><span id="TypeParser.parse_decimal-680"><a href="#TypeParser.parse_decimal-680"><span class="linenos">680</span></a><span class="sd">			`allow_inf`</span>
-</span><span id="TypeParser.parse_decimal-681"><a href="#TypeParser.parse_decimal-681"><span class="linenos">681</span></a><span class="sd">			: whether to accept positive and negative infinity values. If True, strings that match the values in `self.inf_values` (empty by default) are interpreted as infinity, or as negative infinity if prepended by a negative sign. The case sensitivity of this matching depends on `self.float_case_sensitive`, which is False by default.</span>
-</span><span id="TypeParser.parse_decimal-682"><a href="#TypeParser.parse_decimal-682"><span class="linenos">682</span></a>
-</span><span id="TypeParser.parse_decimal-683"><a href="#TypeParser.parse_decimal-683"><span class="linenos">683</span></a><span class="sd">			`allow_nan`</span>
-</span><span id="TypeParser.parse_decimal-684"><a href="#TypeParser.parse_decimal-684"><span class="linenos">684</span></a><span class="sd">			: whether to accept NaN (not a number) representations. If True, strings that match the values in `self.nan_values` (empty by default) are interpeted as NaN. The case sensitivity of this matching depends on `self.float_case_sensitive`, which is False by default.</span>
-</span><span id="TypeParser.parse_decimal-685"><a href="#TypeParser.parse_decimal-685"><span class="linenos">685</span></a>
-</span><span id="TypeParser.parse_decimal-686"><a href="#TypeParser.parse_decimal-686"><span class="linenos">686</span></a><span class="sd">			Returns</span>
-</span><span id="TypeParser.parse_decimal-687"><a href="#TypeParser.parse_decimal-687"><span class="linenos">687</span></a><span class="sd">			-------</span>
-</span><span id="TypeParser.parse_decimal-688"><a href="#TypeParser.parse_decimal-688"><span class="linenos">688</span></a><span class="sd">			parsed Decimal value</span>
-</span><span id="TypeParser.parse_decimal-689"><a href="#TypeParser.parse_decimal-689"><span class="linenos">689</span></a>
-</span><span id="TypeParser.parse_decimal-690"><a href="#TypeParser.parse_decimal-690"><span class="linenos">690</span></a><span class="sd">			Raises</span>
-</span><span id="TypeParser.parse_decimal-691"><a href="#TypeParser.parse_decimal-691"><span class="linenos">691</span></a><span class="sd">			------</span>
-</span><span id="TypeParser.parse_decimal-692"><a href="#TypeParser.parse_decimal-692"><span class="linenos">692</span></a><span class="sd">			`ValueError` if `value` cannot be parsed</span>
-</span><span id="TypeParser.parse_decimal-693"><a href="#TypeParser.parse_decimal-693"><span class="linenos">693</span></a>
-</span><span id="TypeParser.parse_decimal-694"><a href="#TypeParser.parse_decimal-694"><span class="linenos">694</span></a><span class="sd">			Examples</span>
-</span><span id="TypeParser.parse_decimal-695"><a href="#TypeParser.parse_decimal-695"><span class="linenos">695</span></a><span class="sd">			--------</span>
-</span><span id="TypeParser.parse_decimal-696"><a href="#TypeParser.parse_decimal-696"><span class="linenos">696</span></a><span class="sd">			```python</span>
-</span><span id="TypeParser.parse_decimal-697"><a href="#TypeParser.parse_decimal-697"><span class="linenos">697</span></a><span class="sd">			parser = TypeParser(inf_values=[&quot;inf&quot;], nan_values=[&quot;nan&quot;])</span>
-</span><span id="TypeParser.parse_decimal-698"><a href="#TypeParser.parse_decimal-698"><span class="linenos">698</span></a><span class="sd">			parser.parse_decimal(&quot;1.&quot;)       # Decimal(1)</span>
-</span><span id="TypeParser.parse_decimal-699"><a href="#TypeParser.parse_decimal-699"><span class="linenos">699</span></a><span class="sd">			parser.parse_decimal(&quot;1.23e2&quot;)   # Decimal(123)</span>
-</span><span id="TypeParser.parse_decimal-700"><a href="#TypeParser.parse_decimal-700"><span class="linenos">700</span></a><span class="sd">			parser.parse_decimal(&quot;1.23e-2&quot;)  # Decimal(123) / Decimal(10000)</span>
-</span><span id="TypeParser.parse_decimal-701"><a href="#TypeParser.parse_decimal-701"><span class="linenos">701</span></a><span class="sd">			parser.parse_decimal(&quot;inf&quot;)      # Decimal(math.inf)</span>
-</span><span id="TypeParser.parse_decimal-702"><a href="#TypeParser.parse_decimal-702"><span class="linenos">702</span></a><span class="sd">			```</span>
-</span><span id="TypeParser.parse_decimal-703"><a href="#TypeParser.parse_decimal-703"><span class="linenos">703</span></a><span class="sd">		&quot;&quot;&quot;</span>
-</span><span id="TypeParser.parse_decimal-704"><a href="#TypeParser.parse_decimal-704"><span class="linenos">704</span></a>		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_floatlike</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Decimal</span><span class="p">,</span> <span class="n">Decimal</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">nan</span><span class="p">),</span>
-</span><span id="TypeParser.parse_decimal-705"><a href="#TypeParser.parse_decimal-705"><span class="linenos">705</span></a>			<span class="n">allow_scientific</span><span class="o">=</span><span class="n">allow_scientific</span><span class="p">,</span>
-</span><span id="TypeParser.parse_decimal-706"><a href="#TypeParser.parse_decimal-706"><span class="linenos">706</span></a>			<span class="n">allow_inf</span><span class="o">=</span><span class="n">allow_inf</span><span class="p">,</span>
-</span><span id="TypeParser.parse_decimal-707"><a href="#TypeParser.parse_decimal-707"><span class="linenos">707</span></a>			<span class="n">allow_nan</span><span class="o">=</span><span class="n">allow_nan</span><span class="p">,</span>
-</span><span id="TypeParser.parse_decimal-708"><a href="#TypeParser.parse_decimal-708"><span class="linenos">708</span></a>		<span class="p">)</span>
+            <div class="pdoc-code codehilite"><pre><span></span><span id="TypeParser.parse_decimal-663"><a href="#TypeParser.parse_decimal-663"><span class="linenos">663</span></a>	<span class="k">def</span> <span class="nf">parse_decimal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">allow_scientific</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_inf</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_nan</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Decimal</span><span class="p">:</span>
+</span><span id="TypeParser.parse_decimal-664"><a href="#TypeParser.parse_decimal-664"><span class="linenos">664</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
+</span><span id="TypeParser.parse_decimal-665"><a href="#TypeParser.parse_decimal-665"><span class="linenos">665</span></a><span class="sd">			Parse a string and return it as an exact Decimal if possible</span>
+</span><span id="TypeParser.parse_decimal-666"><a href="#TypeParser.parse_decimal-666"><span class="linenos">666</span></a>
+</span><span id="TypeParser.parse_decimal-667"><a href="#TypeParser.parse_decimal-667"><span class="linenos">667</span></a><span class="sd">			If the string represents a bool, it will be converted to `Decimal(1)` for True and `Decimal(0)` for False. If the string represents an int, it will be converted to a Decimal also.</span>
+</span><span id="TypeParser.parse_decimal-668"><a href="#TypeParser.parse_decimal-668"><span class="linenos">668</span></a>
+</span><span id="TypeParser.parse_decimal-669"><a href="#TypeParser.parse_decimal-669"><span class="linenos">669</span></a><span class="sd">			Behaves analogously to `parse_float()`, except that that returns a non-exact float instead.</span>
+</span><span id="TypeParser.parse_decimal-670"><a href="#TypeParser.parse_decimal-670"><span class="linenos">670</span></a>
+</span><span id="TypeParser.parse_decimal-671"><a href="#TypeParser.parse_decimal-671"><span class="linenos">671</span></a><span class="sd">			Parameters</span>
+</span><span id="TypeParser.parse_decimal-672"><a href="#TypeParser.parse_decimal-672"><span class="linenos">672</span></a><span class="sd">			----------</span>
+</span><span id="TypeParser.parse_decimal-673"><a href="#TypeParser.parse_decimal-673"><span class="linenos">673</span></a><span class="sd">			`value`</span>
+</span><span id="TypeParser.parse_decimal-674"><a href="#TypeParser.parse_decimal-674"><span class="linenos">674</span></a><span class="sd">			: string to be parsed</span>
+</span><span id="TypeParser.parse_decimal-675"><a href="#TypeParser.parse_decimal-675"><span class="linenos">675</span></a>
+</span><span id="TypeParser.parse_decimal-676"><a href="#TypeParser.parse_decimal-676"><span class="linenos">676</span></a><span class="sd">			`allow_scientific`</span>
+</span><span id="TypeParser.parse_decimal-677"><a href="#TypeParser.parse_decimal-677"><span class="linenos">677</span></a><span class="sd">			: whether to accept scientific notation. If True, strings of the form `&quot;&lt;var&gt;M&lt;/var&gt;e&lt;var&gt;X&lt;/var&gt;&quot;` will be interpreted as the expression `&lt;var&gt;M&lt;/var&gt; * (10 ** &lt;var&gt;X&lt;/var&gt;)`, where &lt;var&gt;M&lt;/var&gt; is the mantissa/significand and &lt;var&gt;X&lt;/var&gt; is the exponent. Note that &lt;var&gt;X&lt;/var&gt; must be an integer, but can be negative.</span>
+</span><span id="TypeParser.parse_decimal-678"><a href="#TypeParser.parse_decimal-678"><span class="linenos">678</span></a>
+</span><span id="TypeParser.parse_decimal-679"><a href="#TypeParser.parse_decimal-679"><span class="linenos">679</span></a><span class="sd">			`allow_inf`</span>
+</span><span id="TypeParser.parse_decimal-680"><a href="#TypeParser.parse_decimal-680"><span class="linenos">680</span></a><span class="sd">			: whether to accept positive and negative infinity values. If True, strings that match the values in `self.inf_values` (empty by default) are interpreted as infinity, or as negative infinity if prepended by a negative sign. The case sensitivity of this matching depends on `self.float_case_sensitive`, which is False by default.</span>
+</span><span id="TypeParser.parse_decimal-681"><a href="#TypeParser.parse_decimal-681"><span class="linenos">681</span></a>
+</span><span id="TypeParser.parse_decimal-682"><a href="#TypeParser.parse_decimal-682"><span class="linenos">682</span></a><span class="sd">			`allow_nan`</span>
+</span><span id="TypeParser.parse_decimal-683"><a href="#TypeParser.parse_decimal-683"><span class="linenos">683</span></a><span class="sd">			: whether to accept NaN (not a number) representations. If True, strings that match the values in `self.nan_values` (empty by default) are interpeted as NaN. The case sensitivity of this matching depends on `self.float_case_sensitive`, which is False by default.</span>
+</span><span id="TypeParser.parse_decimal-684"><a href="#TypeParser.parse_decimal-684"><span class="linenos">684</span></a>
+</span><span id="TypeParser.parse_decimal-685"><a href="#TypeParser.parse_decimal-685"><span class="linenos">685</span></a><span class="sd">			Returns</span>
+</span><span id="TypeParser.parse_decimal-686"><a href="#TypeParser.parse_decimal-686"><span class="linenos">686</span></a><span class="sd">			-------</span>
+</span><span id="TypeParser.parse_decimal-687"><a href="#TypeParser.parse_decimal-687"><span class="linenos">687</span></a><span class="sd">			parsed Decimal value</span>
+</span><span id="TypeParser.parse_decimal-688"><a href="#TypeParser.parse_decimal-688"><span class="linenos">688</span></a>
+</span><span id="TypeParser.parse_decimal-689"><a href="#TypeParser.parse_decimal-689"><span class="linenos">689</span></a><span class="sd">			Raises</span>
+</span><span id="TypeParser.parse_decimal-690"><a href="#TypeParser.parse_decimal-690"><span class="linenos">690</span></a><span class="sd">			------</span>
+</span><span id="TypeParser.parse_decimal-691"><a href="#TypeParser.parse_decimal-691"><span class="linenos">691</span></a><span class="sd">			`ValueError` if `value` cannot be parsed</span>
+</span><span id="TypeParser.parse_decimal-692"><a href="#TypeParser.parse_decimal-692"><span class="linenos">692</span></a>
+</span><span id="TypeParser.parse_decimal-693"><a href="#TypeParser.parse_decimal-693"><span class="linenos">693</span></a><span class="sd">			Examples</span>
+</span><span id="TypeParser.parse_decimal-694"><a href="#TypeParser.parse_decimal-694"><span class="linenos">694</span></a><span class="sd">			--------</span>
+</span><span id="TypeParser.parse_decimal-695"><a href="#TypeParser.parse_decimal-695"><span class="linenos">695</span></a><span class="sd">			```python</span>
+</span><span id="TypeParser.parse_decimal-696"><a href="#TypeParser.parse_decimal-696"><span class="linenos">696</span></a><span class="sd">			parser = TypeParser(inf_values=[&quot;inf&quot;], nan_values=[&quot;nan&quot;])</span>
+</span><span id="TypeParser.parse_decimal-697"><a href="#TypeParser.parse_decimal-697"><span class="linenos">697</span></a><span class="sd">			parser.parse_decimal(&quot;1.&quot;)       # Decimal(1)</span>
+</span><span id="TypeParser.parse_decimal-698"><a href="#TypeParser.parse_decimal-698"><span class="linenos">698</span></a><span class="sd">			parser.parse_decimal(&quot;1.23e2&quot;)   # Decimal(123)</span>
+</span><span id="TypeParser.parse_decimal-699"><a href="#TypeParser.parse_decimal-699"><span class="linenos">699</span></a><span class="sd">			parser.parse_decimal(&quot;1.23e-2&quot;)  # Decimal(123) / Decimal(10000)</span>
+</span><span id="TypeParser.parse_decimal-700"><a href="#TypeParser.parse_decimal-700"><span class="linenos">700</span></a><span class="sd">			parser.parse_decimal(&quot;inf&quot;)      # Decimal(math.inf)</span>
+</span><span id="TypeParser.parse_decimal-701"><a href="#TypeParser.parse_decimal-701"><span class="linenos">701</span></a><span class="sd">			```</span>
+</span><span id="TypeParser.parse_decimal-702"><a href="#TypeParser.parse_decimal-702"><span class="linenos">702</span></a><span class="sd">		&quot;&quot;&quot;</span>
+</span><span id="TypeParser.parse_decimal-703"><a href="#TypeParser.parse_decimal-703"><span class="linenos">703</span></a>		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_floatlike</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">Decimal</span><span class="p">,</span> <span class="n">Decimal</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">inf</span><span class="p">),</span> <span class="n">Decimal</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">nan</span><span class="p">),</span>
+</span><span id="TypeParser.parse_decimal-704"><a href="#TypeParser.parse_decimal-704"><span class="linenos">704</span></a>			<span class="n">allow_scientific</span><span class="o">=</span><span class="n">allow_scientific</span><span class="p">,</span>
+</span><span id="TypeParser.parse_decimal-705"><a href="#TypeParser.parse_decimal-705"><span class="linenos">705</span></a>			<span class="n">allow_inf</span><span class="o">=</span><span class="n">allow_inf</span><span class="p">,</span>
+</span><span id="TypeParser.parse_decimal-706"><a href="#TypeParser.parse_decimal-706"><span class="linenos">706</span></a>			<span class="n">allow_nan</span><span class="o">=</span><span class="n">allow_nan</span><span class="p">,</span>
+</span><span id="TypeParser.parse_decimal-707"><a href="#TypeParser.parse_decimal-707"><span class="linenos">707</span></a>		<span class="p">)</span>
 </span></pre></div>
 
 
     <div class="docstring">
 <p>Parse a string and return it as an exact Decimal if possible</p>
 
 <p>If the string represents a bool, it will be converted to <code>Decimal(1)</code> for True and <code>Decimal(0)</code> for False. If the string represents an int, it will be converted to a Decimal also.</p>
@@ -2282,70 +2282,70 @@
 
                             </div>
                             <div id="TypeParser.infer" class="classattr">
                                         <input id="TypeParser.infer-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
 <div class="attr function">
             
         <span class="def">def</span>
-        <span class="name">infer</span><span class="signature pdoc-code multiline">(<span class="param">	<span class="bp">self</span>,</span><span class="param">	<span class="n">value</span><span class="p">:</span> <span class="nb">str</span></span><span class="return-annotation">) -> <span class="n">Type</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">NoneType</span><span class="p">,</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="n">NoneType</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="kc">None</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="nb">list</span><span class="p">[</span><span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="nb">list</span><span class="p">[</span><span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">float</span><span class="p">]],</span> <span class="nb">list</span><span class="p">[</span><span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">]],</span> <span class="nb">list</span><span class="p">[</span><span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">bool</span><span class="p">]],</span> <span class="nb">list</span><span class="p">[</span><span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="n">NoneType</span><span class="p">]]]]</span>:</span></span>
+        <span class="name">infer</span><span class="signature pdoc-code multiline">(<span class="param">	<span class="bp">self</span>,</span><span class="param">	<span class="n">value</span><span class="p">:</span> <span class="nb">str</span></span><span class="return-annotation">) -> <span class="n">Type</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">NoneType</span><span class="p">,</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="n">NoneType</span><span class="p">]]]</span>:</span></span>
 
 
                 <label class="view-source-button" for="TypeParser.infer-view-source"><span>View Source</span></label>
 
     </div>
     <a class="headerlink" href="#TypeParser.infer"></a>
-            <div class="pdoc-code codehilite"><pre><span></span><span id="TypeParser.infer-711"><a href="#TypeParser.infer-711"><span class="linenos">711</span></a>	<span class="k">def</span> <span class="nf">infer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AnyValueType</span><span class="p">:</span>
-</span><span id="TypeParser.infer-712"><a href="#TypeParser.infer-712"><span class="linenos">712</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
-</span><span id="TypeParser.infer-713"><a href="#TypeParser.infer-713"><span class="linenos">713</span></a><span class="sd">			Infer the underlying type of a string</span>
-</span><span id="TypeParser.infer-714"><a href="#TypeParser.infer-714"><span class="linenos">714</span></a>
-</span><span id="TypeParser.infer-715"><a href="#TypeParser.infer-715"><span class="linenos">715</span></a><span class="sd">			Also check for inline lists if `self.list_delimiter` is not None.</span>
-</span><span id="TypeParser.infer-716"><a href="#TypeParser.infer-716"><span class="linenos">716</span></a>
-</span><span id="TypeParser.infer-717"><a href="#TypeParser.infer-717"><span class="linenos">717</span></a><span class="sd">			Parameters</span>
-</span><span id="TypeParser.infer-718"><a href="#TypeParser.infer-718"><span class="linenos">718</span></a><span class="sd">			----------</span>
-</span><span id="TypeParser.infer-719"><a href="#TypeParser.infer-719"><span class="linenos">719</span></a><span class="sd">			`value`</span>
-</span><span id="TypeParser.infer-720"><a href="#TypeParser.infer-720"><span class="linenos">720</span></a><span class="sd">			: the string for which the type should be inferred</span>
-</span><span id="TypeParser.infer-721"><a href="#TypeParser.infer-721"><span class="linenos">721</span></a>
-</span><span id="TypeParser.infer-722"><a href="#TypeParser.infer-722"><span class="linenos">722</span></a><span class="sd">			Returns</span>
-</span><span id="TypeParser.infer-723"><a href="#TypeParser.infer-723"><span class="linenos">723</span></a><span class="sd">			-------</span>
-</span><span id="TypeParser.infer-724"><a href="#TypeParser.infer-724"><span class="linenos">724</span></a><span class="sd">			inferred type</span>
-</span><span id="TypeParser.infer-725"><a href="#TypeParser.infer-725"><span class="linenos">725</span></a>
-</span><span id="TypeParser.infer-726"><a href="#TypeParser.infer-726"><span class="linenos">726</span></a><span class="sd">			Examples</span>
-</span><span id="TypeParser.infer-727"><a href="#TypeParser.infer-727"><span class="linenos">727</span></a><span class="sd">			--------</span>
-</span><span id="TypeParser.infer-728"><a href="#TypeParser.infer-728"><span class="linenos">728</span></a><span class="sd">			```python</span>
-</span><span id="TypeParser.infer-729"><a href="#TypeParser.infer-729"><span class="linenos">729</span></a><span class="sd">			parser = TypeParser()</span>
-</span><span id="TypeParser.infer-730"><a href="#TypeParser.infer-730"><span class="linenos">730</span></a><span class="sd">			parser.infer(&quot;true&quot;)  # bool</span>
-</span><span id="TypeParser.infer-731"><a href="#TypeParser.infer-731"><span class="linenos">731</span></a><span class="sd">			parser.infer(&quot;2.0&quot;)   # float</span>
-</span><span id="TypeParser.infer-732"><a href="#TypeParser.infer-732"><span class="linenos">732</span></a><span class="sd">			parser.infer(&quot;abc&quot;)   # str</span>
-</span><span id="TypeParser.infer-733"><a href="#TypeParser.infer-733"><span class="linenos">733</span></a><span class="sd">			```</span>
-</span><span id="TypeParser.infer-734"><a href="#TypeParser.infer-734"><span class="linenos">734</span></a><span class="sd">		&quot;&quot;&quot;</span>
-</span><span id="TypeParser.infer-735"><a href="#TypeParser.infer-735"><span class="linenos">735</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_none</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
-</span><span id="TypeParser.infer-736"><a href="#TypeParser.infer-736"><span class="linenos">736</span></a>			<span class="k">return</span> <span class="n">NoneType</span>
-</span><span id="TypeParser.infer-737"><a href="#TypeParser.infer-737"><span class="linenos">737</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_bool</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
-</span><span id="TypeParser.infer-738"><a href="#TypeParser.infer-738"><span class="linenos">738</span></a>			<span class="k">return</span> <span class="nb">bool</span>
-</span><span id="TypeParser.infer-739"><a href="#TypeParser.infer-739"><span class="linenos">739</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_int</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
-</span><span id="TypeParser.infer-740"><a href="#TypeParser.infer-740"><span class="linenos">740</span></a>			<span class="k">return</span> <span class="nb">int</span>
-</span><span id="TypeParser.infer-741"><a href="#TypeParser.infer-741"><span class="linenos">741</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_float</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
-</span><span id="TypeParser.infer-742"><a href="#TypeParser.infer-742"><span class="linenos">742</span></a>			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_decimal</span><span class="p">:</span>
-</span><span id="TypeParser.infer-743"><a href="#TypeParser.infer-743"><span class="linenos">743</span></a>				<span class="k">return</span> <span class="n">Decimal</span>
-</span><span id="TypeParser.infer-744"><a href="#TypeParser.infer-744"><span class="linenos">744</span></a>			<span class="k">else</span><span class="p">:</span>
-</span><span id="TypeParser.infer-745"><a href="#TypeParser.infer-745"><span class="linenos">745</span></a>				<span class="k">return</span> <span class="nb">float</span>
-</span><span id="TypeParser.infer-746"><a href="#TypeParser.infer-746"><span class="linenos">746</span></a>
-</span><span id="TypeParser.infer-747"><a href="#TypeParser.infer-747"><span class="linenos">747</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trim</span><span class="p">:</span>
-</span><span id="TypeParser.infer-748"><a href="#TypeParser.infer-748"><span class="linenos">748</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
-</span><span id="TypeParser.infer-749"><a href="#TypeParser.infer-749"><span class="linenos">749</span></a>
-</span><span id="TypeParser.infer-750"><a href="#TypeParser.infer-750"><span class="linenos">750</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_delimiter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_delimiter</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
-</span><span id="TypeParser.infer-751"><a href="#TypeParser.infer-751"><span class="linenos">751</span></a>			<span class="n">subvalues</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">list_delimiter</span><span class="p">)</span>
-</span><span id="TypeParser.infer-752"><a href="#TypeParser.infer-752"><span class="linenos">752</span></a>			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trim</span><span class="p">:</span>
-</span><span id="TypeParser.infer-753"><a href="#TypeParser.infer-753"><span class="linenos">753</span></a>				<span class="n">subvalues</span> <span class="o">=</span> <span class="p">[</span><span class="n">subvalue</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">subvalue</span> <span class="ow">in</span> <span class="n">subvalues</span><span class="p">]</span>
-</span><span id="TypeParser.infer-754"><a href="#TypeParser.infer-754"><span class="linenos">754</span></a>			<span class="n">reduced_type</span> <span class="o">=</span> <span class="n">reduce_types</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">infer</span><span class="p">(</span><span class="n">subvalue</span><span class="p">)</span> <span class="k">for</span> <span class="n">subvalue</span> <span class="ow">in</span> <span class="n">subvalues</span><span class="p">)</span>
-</span><span id="TypeParser.infer-755"><a href="#TypeParser.infer-755"><span class="linenos">755</span></a>			<span class="n">reduced_type</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">AnyContainedType</span><span class="p">,</span> <span class="n">reduced_type</span><span class="p">)</span>
-</span><span id="TypeParser.infer-756"><a href="#TypeParser.infer-756"><span class="linenos">756</span></a>			<span class="n">r</span> <span class="o">=</span> <span class="nb">list</span><span class="p">[</span><span class="n">reduced_type</span><span class="p">]</span>
-</span><span id="TypeParser.infer-757"><a href="#TypeParser.infer-757"><span class="linenos">757</span></a>			<span class="k">return</span> <span class="n">r</span>  <span class="c1"># type: ignore</span>
-</span><span id="TypeParser.infer-758"><a href="#TypeParser.infer-758"><span class="linenos">758</span></a>
-</span><span id="TypeParser.infer-759"><a href="#TypeParser.infer-759"><span class="linenos">759</span></a>		<span class="k">return</span> <span class="n">GenericValue</span>
+            <div class="pdoc-code codehilite"><pre><span></span><span id="TypeParser.infer-710"><a href="#TypeParser.infer-710"><span class="linenos">710</span></a>	<span class="k">def</span> <span class="nf">infer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AnyValueType</span><span class="p">:</span>
+</span><span id="TypeParser.infer-711"><a href="#TypeParser.infer-711"><span class="linenos">711</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
+</span><span id="TypeParser.infer-712"><a href="#TypeParser.infer-712"><span class="linenos">712</span></a><span class="sd">			Infer the underlying type of a string</span>
+</span><span id="TypeParser.infer-713"><a href="#TypeParser.infer-713"><span class="linenos">713</span></a>
+</span><span id="TypeParser.infer-714"><a href="#TypeParser.infer-714"><span class="linenos">714</span></a><span class="sd">			Also check for inline lists if `self.list_delimiter` is not None.</span>
+</span><span id="TypeParser.infer-715"><a href="#TypeParser.infer-715"><span class="linenos">715</span></a>
+</span><span id="TypeParser.infer-716"><a href="#TypeParser.infer-716"><span class="linenos">716</span></a><span class="sd">			Parameters</span>
+</span><span id="TypeParser.infer-717"><a href="#TypeParser.infer-717"><span class="linenos">717</span></a><span class="sd">			----------</span>
+</span><span id="TypeParser.infer-718"><a href="#TypeParser.infer-718"><span class="linenos">718</span></a><span class="sd">			`value`</span>
+</span><span id="TypeParser.infer-719"><a href="#TypeParser.infer-719"><span class="linenos">719</span></a><span class="sd">			: the string for which the type should be inferred</span>
+</span><span id="TypeParser.infer-720"><a href="#TypeParser.infer-720"><span class="linenos">720</span></a>
+</span><span id="TypeParser.infer-721"><a href="#TypeParser.infer-721"><span class="linenos">721</span></a><span class="sd">			Returns</span>
+</span><span id="TypeParser.infer-722"><a href="#TypeParser.infer-722"><span class="linenos">722</span></a><span class="sd">			-------</span>
+</span><span id="TypeParser.infer-723"><a href="#TypeParser.infer-723"><span class="linenos">723</span></a><span class="sd">			inferred type</span>
+</span><span id="TypeParser.infer-724"><a href="#TypeParser.infer-724"><span class="linenos">724</span></a>
+</span><span id="TypeParser.infer-725"><a href="#TypeParser.infer-725"><span class="linenos">725</span></a><span class="sd">			Examples</span>
+</span><span id="TypeParser.infer-726"><a href="#TypeParser.infer-726"><span class="linenos">726</span></a><span class="sd">			--------</span>
+</span><span id="TypeParser.infer-727"><a href="#TypeParser.infer-727"><span class="linenos">727</span></a><span class="sd">			```python</span>
+</span><span id="TypeParser.infer-728"><a href="#TypeParser.infer-728"><span class="linenos">728</span></a><span class="sd">			parser = TypeParser()</span>
+</span><span id="TypeParser.infer-729"><a href="#TypeParser.infer-729"><span class="linenos">729</span></a><span class="sd">			parser.infer(&quot;true&quot;)  # bool</span>
+</span><span id="TypeParser.infer-730"><a href="#TypeParser.infer-730"><span class="linenos">730</span></a><span class="sd">			parser.infer(&quot;2.0&quot;)   # float</span>
+</span><span id="TypeParser.infer-731"><a href="#TypeParser.infer-731"><span class="linenos">731</span></a><span class="sd">			parser.infer(&quot;abc&quot;)   # str</span>
+</span><span id="TypeParser.infer-732"><a href="#TypeParser.infer-732"><span class="linenos">732</span></a><span class="sd">			```</span>
+</span><span id="TypeParser.infer-733"><a href="#TypeParser.infer-733"><span class="linenos">733</span></a><span class="sd">		&quot;&quot;&quot;</span>
+</span><span id="TypeParser.infer-734"><a href="#TypeParser.infer-734"><span class="linenos">734</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_none</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
+</span><span id="TypeParser.infer-735"><a href="#TypeParser.infer-735"><span class="linenos">735</span></a>			<span class="k">return</span> <span class="n">NoneType</span>
+</span><span id="TypeParser.infer-736"><a href="#TypeParser.infer-736"><span class="linenos">736</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_bool</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
+</span><span id="TypeParser.infer-737"><a href="#TypeParser.infer-737"><span class="linenos">737</span></a>			<span class="k">return</span> <span class="nb">bool</span>
+</span><span id="TypeParser.infer-738"><a href="#TypeParser.infer-738"><span class="linenos">738</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_int</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
+</span><span id="TypeParser.infer-739"><a href="#TypeParser.infer-739"><span class="linenos">739</span></a>			<span class="k">return</span> <span class="nb">int</span>
+</span><span id="TypeParser.infer-740"><a href="#TypeParser.infer-740"><span class="linenos">740</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_float</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
+</span><span id="TypeParser.infer-741"><a href="#TypeParser.infer-741"><span class="linenos">741</span></a>			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">use_decimal</span><span class="p">:</span>
+</span><span id="TypeParser.infer-742"><a href="#TypeParser.infer-742"><span class="linenos">742</span></a>				<span class="k">return</span> <span class="n">Decimal</span>
+</span><span id="TypeParser.infer-743"><a href="#TypeParser.infer-743"><span class="linenos">743</span></a>			<span class="k">else</span><span class="p">:</span>
+</span><span id="TypeParser.infer-744"><a href="#TypeParser.infer-744"><span class="linenos">744</span></a>				<span class="k">return</span> <span class="nb">float</span>
+</span><span id="TypeParser.infer-745"><a href="#TypeParser.infer-745"><span class="linenos">745</span></a>
+</span><span id="TypeParser.infer-746"><a href="#TypeParser.infer-746"><span class="linenos">746</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trim</span><span class="p">:</span>
+</span><span id="TypeParser.infer-747"><a href="#TypeParser.infer-747"><span class="linenos">747</span></a>			<span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
+</span><span id="TypeParser.infer-748"><a href="#TypeParser.infer-748"><span class="linenos">748</span></a>
+</span><span id="TypeParser.infer-749"><a href="#TypeParser.infer-749"><span class="linenos">749</span></a>		<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_delimiter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">list_delimiter</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
+</span><span id="TypeParser.infer-750"><a href="#TypeParser.infer-750"><span class="linenos">750</span></a>			<span class="n">subvalues</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">list_delimiter</span><span class="p">)</span>
+</span><span id="TypeParser.infer-751"><a href="#TypeParser.infer-751"><span class="linenos">751</span></a>			<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">trim</span><span class="p">:</span>
+</span><span id="TypeParser.infer-752"><a href="#TypeParser.infer-752"><span class="linenos">752</span></a>				<span class="n">subvalues</span> <span class="o">=</span> <span class="p">[</span><span class="n">subvalue</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">subvalue</span> <span class="ow">in</span> <span class="n">subvalues</span><span class="p">]</span>
+</span><span id="TypeParser.infer-753"><a href="#TypeParser.infer-753"><span class="linenos">753</span></a>			<span class="n">reduced_type</span> <span class="o">=</span> <span class="n">reduce_types</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">infer</span><span class="p">(</span><span class="n">subvalue</span><span class="p">)</span> <span class="k">for</span> <span class="n">subvalue</span> <span class="ow">in</span> <span class="n">subvalues</span><span class="p">)</span>
+</span><span id="TypeParser.infer-754"><a href="#TypeParser.infer-754"><span class="linenos">754</span></a>			<span class="n">reduced_type</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">AnyContainedType</span><span class="p">,</span> <span class="n">reduced_type</span><span class="p">)</span>
+</span><span id="TypeParser.infer-755"><a href="#TypeParser.infer-755"><span class="linenos">755</span></a>			<span class="n">r</span> <span class="o">=</span> <span class="nb">list</span><span class="p">[</span><span class="n">reduced_type</span><span class="p">]</span>
+</span><span id="TypeParser.infer-756"><a href="#TypeParser.infer-756"><span class="linenos">756</span></a>			<span class="k">return</span> <span class="n">r</span>  <span class="c1"># type: ignore</span>
+</span><span id="TypeParser.infer-757"><a href="#TypeParser.infer-757"><span class="linenos">757</span></a>
+</span><span id="TypeParser.infer-758"><a href="#TypeParser.infer-758"><span class="linenos">758</span></a>		<span class="k">return</span> <span class="n">GenericValue</span>
 </span></pre></div>
 
 
     <div class="docstring">
 <p>Infer the underlying type of a string</p>
 
 <p>Also check for inline lists if <code>self.list_delimiter</code> is not None.</p>
@@ -2373,46 +2373,46 @@
 
                             </div>
                             <div id="TypeParser.infer_series" class="classattr">
                                         <input id="TypeParser.infer_series-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
 <div class="attr function">
             
         <span class="def">def</span>
-        <span class="name">infer_series</span><span class="signature pdoc-code multiline">(<span class="param">	<span class="bp">self</span>,</span><span class="param">	<span class="n">values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span></span><span class="return-annotation">) -> <span class="n">Type</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">NoneType</span><span class="p">,</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="n">NoneType</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="kc">None</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="nb">list</span><span class="p">[</span><span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="nb">list</span><span class="p">[</span><span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">float</span><span class="p">]],</span> <span class="nb">list</span><span class="p">[</span><span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">]],</span> <span class="nb">list</span><span class="p">[</span><span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">bool</span><span class="p">]],</span> <span class="nb">list</span><span class="p">[</span><span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="n">NoneType</span><span class="p">]]]]</span>:</span></span>
+        <span class="name">infer_series</span><span class="signature pdoc-code multiline">(<span class="param">	<span class="bp">self</span>,</span><span class="param">	<span class="n">values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span></span><span class="return-annotation">) -> <span class="n">Type</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">NoneType</span><span class="p">,</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="n">NoneType</span><span class="p">]]]</span>:</span></span>
 
 
                 <label class="view-source-button" for="TypeParser.infer_series-view-source"><span>View Source</span></label>
 
     </div>
     <a class="headerlink" href="#TypeParser.infer_series"></a>
-            <div class="pdoc-code codehilite"><pre><span></span><span id="TypeParser.infer_series-762"><a href="#TypeParser.infer_series-762"><span class="linenos">762</span></a>	<span class="k">def</span> <span class="nf">infer_series</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">AnyValueType</span><span class="p">:</span>
-</span><span id="TypeParser.infer_series-763"><a href="#TypeParser.infer_series-763"><span class="linenos">763</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
-</span><span id="TypeParser.infer_series-764"><a href="#TypeParser.infer_series-764"><span class="linenos">764</span></a><span class="sd">			Infer the underlying common type of a series of strings</span>
-</span><span id="TypeParser.infer_series-765"><a href="#TypeParser.infer_series-765"><span class="linenos">765</span></a>
-</span><span id="TypeParser.infer_series-766"><a href="#TypeParser.infer_series-766"><span class="linenos">766</span></a><span class="sd">			If the values in the series do not have the same apparent type, the resulting type will be narrowest possible type that will encompass all values in the series. See `parsetypes.reduce_types()` for more information.</span>
-</span><span id="TypeParser.infer_series-767"><a href="#TypeParser.infer_series-767"><span class="linenos">767</span></a>
-</span><span id="TypeParser.infer_series-768"><a href="#TypeParser.infer_series-768"><span class="linenos">768</span></a><span class="sd">			Parameters</span>
-</span><span id="TypeParser.infer_series-769"><a href="#TypeParser.infer_series-769"><span class="linenos">769</span></a><span class="sd">			----------</span>
-</span><span id="TypeParser.infer_series-770"><a href="#TypeParser.infer_series-770"><span class="linenos">770</span></a><span class="sd">			`values`</span>
-</span><span id="TypeParser.infer_series-771"><a href="#TypeParser.infer_series-771"><span class="linenos">771</span></a><span class="sd">			: series of strings for which the type should be inferred</span>
-</span><span id="TypeParser.infer_series-772"><a href="#TypeParser.infer_series-772"><span class="linenos">772</span></a>
-</span><span id="TypeParser.infer_series-773"><a href="#TypeParser.infer_series-773"><span class="linenos">773</span></a><span class="sd">			Returns</span>
-</span><span id="TypeParser.infer_series-774"><a href="#TypeParser.infer_series-774"><span class="linenos">774</span></a><span class="sd">			-------</span>
-</span><span id="TypeParser.infer_series-775"><a href="#TypeParser.infer_series-775"><span class="linenos">775</span></a><span class="sd">			inferred type</span>
-</span><span id="TypeParser.infer_series-776"><a href="#TypeParser.infer_series-776"><span class="linenos">776</span></a>
-</span><span id="TypeParser.infer_series-777"><a href="#TypeParser.infer_series-777"><span class="linenos">777</span></a><span class="sd">			Examples</span>
-</span><span id="TypeParser.infer_series-778"><a href="#TypeParser.infer_series-778"><span class="linenos">778</span></a><span class="sd">			--------</span>
-</span><span id="TypeParser.infer_series-779"><a href="#TypeParser.infer_series-779"><span class="linenos">779</span></a><span class="sd">			```python</span>
-</span><span id="TypeParser.infer_series-780"><a href="#TypeParser.infer_series-780"><span class="linenos">780</span></a><span class="sd">			parser = TypeParser()</span>
-</span><span id="TypeParser.infer_series-781"><a href="#TypeParser.infer_series-781"><span class="linenos">781</span></a><span class="sd">			parser.infer_series([&quot;1&quot;, &quot;2&quot;, &quot;3.4&quot;])       # float</span>
-</span><span id="TypeParser.infer_series-782"><a href="#TypeParser.infer_series-782"><span class="linenos">782</span></a><span class="sd">			parser.infer_series([&quot;true&quot;, &quot;false&quot;, &quot;2&quot;])  # int</span>
-</span><span id="TypeParser.infer_series-783"><a href="#TypeParser.infer_series-783"><span class="linenos">783</span></a><span class="sd">			parser.infer_series([&quot;1&quot;, &quot;2.3&quot;, &quot;abc&quot;])     # str</span>
-</span><span id="TypeParser.infer_series-784"><a href="#TypeParser.infer_series-784"><span class="linenos">784</span></a><span class="sd">			```</span>
-</span><span id="TypeParser.infer_series-785"><a href="#TypeParser.infer_series-785"><span class="linenos">785</span></a><span class="sd">		&quot;&quot;&quot;</span>
-</span><span id="TypeParser.infer_series-786"><a href="#TypeParser.infer_series-786"><span class="linenos">786</span></a>		<span class="k">return</span> <span class="n">reduce_types</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">infer</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">)</span>
+            <div class="pdoc-code codehilite"><pre><span></span><span id="TypeParser.infer_series-761"><a href="#TypeParser.infer_series-761"><span class="linenos">761</span></a>	<span class="k">def</span> <span class="nf">infer_series</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">AnyValueType</span><span class="p">:</span>
+</span><span id="TypeParser.infer_series-762"><a href="#TypeParser.infer_series-762"><span class="linenos">762</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
+</span><span id="TypeParser.infer_series-763"><a href="#TypeParser.infer_series-763"><span class="linenos">763</span></a><span class="sd">			Infer the underlying common type of a series of strings</span>
+</span><span id="TypeParser.infer_series-764"><a href="#TypeParser.infer_series-764"><span class="linenos">764</span></a>
+</span><span id="TypeParser.infer_series-765"><a href="#TypeParser.infer_series-765"><span class="linenos">765</span></a><span class="sd">			If the values in the series do not have the same apparent type, the resulting type will be narrowest possible type that will encompass all values in the series. See `parsetypes.reduce_types()` for more information.</span>
+</span><span id="TypeParser.infer_series-766"><a href="#TypeParser.infer_series-766"><span class="linenos">766</span></a>
+</span><span id="TypeParser.infer_series-767"><a href="#TypeParser.infer_series-767"><span class="linenos">767</span></a><span class="sd">			Parameters</span>
+</span><span id="TypeParser.infer_series-768"><a href="#TypeParser.infer_series-768"><span class="linenos">768</span></a><span class="sd">			----------</span>
+</span><span id="TypeParser.infer_series-769"><a href="#TypeParser.infer_series-769"><span class="linenos">769</span></a><span class="sd">			`values`</span>
+</span><span id="TypeParser.infer_series-770"><a href="#TypeParser.infer_series-770"><span class="linenos">770</span></a><span class="sd">			: series of strings for which the type should be inferred</span>
+</span><span id="TypeParser.infer_series-771"><a href="#TypeParser.infer_series-771"><span class="linenos">771</span></a>
+</span><span id="TypeParser.infer_series-772"><a href="#TypeParser.infer_series-772"><span class="linenos">772</span></a><span class="sd">			Returns</span>
+</span><span id="TypeParser.infer_series-773"><a href="#TypeParser.infer_series-773"><span class="linenos">773</span></a><span class="sd">			-------</span>
+</span><span id="TypeParser.infer_series-774"><a href="#TypeParser.infer_series-774"><span class="linenos">774</span></a><span class="sd">			inferred type</span>
+</span><span id="TypeParser.infer_series-775"><a href="#TypeParser.infer_series-775"><span class="linenos">775</span></a>
+</span><span id="TypeParser.infer_series-776"><a href="#TypeParser.infer_series-776"><span class="linenos">776</span></a><span class="sd">			Examples</span>
+</span><span id="TypeParser.infer_series-777"><a href="#TypeParser.infer_series-777"><span class="linenos">777</span></a><span class="sd">			--------</span>
+</span><span id="TypeParser.infer_series-778"><a href="#TypeParser.infer_series-778"><span class="linenos">778</span></a><span class="sd">			```python</span>
+</span><span id="TypeParser.infer_series-779"><a href="#TypeParser.infer_series-779"><span class="linenos">779</span></a><span class="sd">			parser = TypeParser()</span>
+</span><span id="TypeParser.infer_series-780"><a href="#TypeParser.infer_series-780"><span class="linenos">780</span></a><span class="sd">			parser.infer_series([&quot;1&quot;, &quot;2&quot;, &quot;3.4&quot;])       # float</span>
+</span><span id="TypeParser.infer_series-781"><a href="#TypeParser.infer_series-781"><span class="linenos">781</span></a><span class="sd">			parser.infer_series([&quot;true&quot;, &quot;false&quot;, &quot;2&quot;])  # int</span>
+</span><span id="TypeParser.infer_series-782"><a href="#TypeParser.infer_series-782"><span class="linenos">782</span></a><span class="sd">			parser.infer_series([&quot;1&quot;, &quot;2.3&quot;, &quot;abc&quot;])     # str</span>
+</span><span id="TypeParser.infer_series-783"><a href="#TypeParser.infer_series-783"><span class="linenos">783</span></a><span class="sd">			```</span>
+</span><span id="TypeParser.infer_series-784"><a href="#TypeParser.infer_series-784"><span class="linenos">784</span></a><span class="sd">		&quot;&quot;&quot;</span>
+</span><span id="TypeParser.infer_series-785"><a href="#TypeParser.infer_series-785"><span class="linenos">785</span></a>		<span class="k">return</span> <span class="n">reduce_types</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">infer</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">)</span>
 </span></pre></div>
 
 
     <div class="docstring">
 <p>Infer the underlying common type of a series of strings</p>
 
 <p>If the values in the series do not have the same apparent type, the resulting type will be narrowest possible type that will encompass all values in the series. See <code><a href="#reduce_types">parsetypes.reduce_types()</a></code> for more information.</p>
@@ -2440,64 +2440,64 @@
 
                             </div>
                             <div id="TypeParser.infer_table" class="classattr">
                                         <input id="TypeParser.infer_table-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
 <div class="attr function">
             
         <span class="def">def</span>
-        <span class="name">infer_table</span><span class="signature pdoc-code multiline">(<span class="param">	<span class="bp">self</span>,</span><span class="param">	<span class="n">rows</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span></span><span class="return-annotation">) -> <span class="nb">list</span><span class="p">[</span><span class="n">Type</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">NoneType</span><span class="p">,</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="n">NoneType</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="kc">None</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="nb">list</span><span class="p">[</span><span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="nb">list</span><span class="p">[</span><span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">float</span><span class="p">]],</span> <span class="nb">list</span><span class="p">[</span><span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">]],</span> <span class="nb">list</span><span class="p">[</span><span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">bool</span><span class="p">]],</span> <span class="nb">list</span><span class="p">[</span><span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="n">NoneType</span><span class="p">]]]]]</span>:</span></span>
+        <span class="name">infer_table</span><span class="signature pdoc-code multiline">(<span class="param">	<span class="bp">self</span>,</span><span class="param">	<span class="n">rows</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span></span><span class="return-annotation">) -> <span class="nb">list</span><span class="p">[</span><span class="n">Type</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">NoneType</span><span class="p">,</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="n">NoneType</span><span class="p">]]]]</span>:</span></span>
 
 
                 <label class="view-source-button" for="TypeParser.infer_table-view-source"><span>View Source</span></label>
 
     </div>
     <a class="headerlink" href="#TypeParser.infer_table"></a>
-            <div class="pdoc-code codehilite"><pre><span></span><span id="TypeParser.infer_table-789"><a href="#TypeParser.infer_table-789"><span class="linenos">789</span></a>	<span class="k">def</span> <span class="nf">infer_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rows</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">AnyValueType</span><span class="p">]:</span>
-</span><span id="TypeParser.infer_table-790"><a href="#TypeParser.infer_table-790"><span class="linenos">790</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
-</span><span id="TypeParser.infer_table-791"><a href="#TypeParser.infer_table-791"><span class="linenos">791</span></a><span class="sd">			Infer the underlying common type for each column of a table of strings</span>
-</span><span id="TypeParser.infer_table-792"><a href="#TypeParser.infer_table-792"><span class="linenos">792</span></a>
-</span><span id="TypeParser.infer_table-793"><a href="#TypeParser.infer_table-793"><span class="linenos">793</span></a><span class="sd">			For each column, if the values do not have the same apparent type, the resulting type will be narrowest possible type that will encompass all values in the column. See `parsetypes.reduce_types()` for more information.</span>
-</span><span id="TypeParser.infer_table-794"><a href="#TypeParser.infer_table-794"><span class="linenos">794</span></a>
-</span><span id="TypeParser.infer_table-795"><a href="#TypeParser.infer_table-795"><span class="linenos">795</span></a><span class="sd">			Note that the inferred types of every individual value must all be able to fit into memory at once.</span>
-</span><span id="TypeParser.infer_table-796"><a href="#TypeParser.infer_table-796"><span class="linenos">796</span></a>
-</span><span id="TypeParser.infer_table-797"><a href="#TypeParser.infer_table-797"><span class="linenos">797</span></a><span class="sd">			Parameters</span>
-</span><span id="TypeParser.infer_table-798"><a href="#TypeParser.infer_table-798"><span class="linenos">798</span></a><span class="sd">			----------</span>
-</span><span id="TypeParser.infer_table-799"><a href="#TypeParser.infer_table-799"><span class="linenos">799</span></a><span class="sd">			`rows`</span>
-</span><span id="TypeParser.infer_table-800"><a href="#TypeParser.infer_table-800"><span class="linenos">800</span></a><span class="sd">			: table of strings for which the types should be inferred, in row-major order</span>
-</span><span id="TypeParser.infer_table-801"><a href="#TypeParser.infer_table-801"><span class="linenos">801</span></a>
-</span><span id="TypeParser.infer_table-802"><a href="#TypeParser.infer_table-802"><span class="linenos">802</span></a><span class="sd">			Returns</span>
-</span><span id="TypeParser.infer_table-803"><a href="#TypeParser.infer_table-803"><span class="linenos">803</span></a><span class="sd">			-------</span>
-</span><span id="TypeParser.infer_table-804"><a href="#TypeParser.infer_table-804"><span class="linenos">804</span></a><span class="sd">			inferred types</span>
-</span><span id="TypeParser.infer_table-805"><a href="#TypeParser.infer_table-805"><span class="linenos">805</span></a>
-</span><span id="TypeParser.infer_table-806"><a href="#TypeParser.infer_table-806"><span class="linenos">806</span></a><span class="sd">			Examples</span>
-</span><span id="TypeParser.infer_table-807"><a href="#TypeParser.infer_table-807"><span class="linenos">807</span></a><span class="sd">			--------</span>
-</span><span id="TypeParser.infer_table-808"><a href="#TypeParser.infer_table-808"><span class="linenos">808</span></a><span class="sd">			```python</span>
-</span><span id="TypeParser.infer_table-809"><a href="#TypeParser.infer_table-809"><span class="linenos">809</span></a><span class="sd">			parser = TypeParser()</span>
-</span><span id="TypeParser.infer_table-810"><a href="#TypeParser.infer_table-810"><span class="linenos">810</span></a><span class="sd">			parser.infer_table([</span>
-</span><span id="TypeParser.infer_table-811"><a href="#TypeParser.infer_table-811"><span class="linenos">811</span></a><span class="sd">				[&quot;1&quot;,   &quot;true&quot;,  &quot;1&quot;],</span>
-</span><span id="TypeParser.infer_table-812"><a href="#TypeParser.infer_table-812"><span class="linenos">812</span></a><span class="sd">				[&quot;2&quot;,   &quot;false&quot;, &quot;2.3&quot;],</span>
-</span><span id="TypeParser.infer_table-813"><a href="#TypeParser.infer_table-813"><span class="linenos">813</span></a><span class="sd">				[&quot;3.4&quot;, &quot;2&quot;,     &quot;abc&quot;],</span>
-</span><span id="TypeParser.infer_table-814"><a href="#TypeParser.infer_table-814"><span class="linenos">814</span></a><span class="sd">			])</span>
-</span><span id="TypeParser.infer_table-815"><a href="#TypeParser.infer_table-815"><span class="linenos">815</span></a><span class="sd">			# [float, int, str]</span>
-</span><span id="TypeParser.infer_table-816"><a href="#TypeParser.infer_table-816"><span class="linenos">816</span></a><span class="sd">			```</span>
-</span><span id="TypeParser.infer_table-817"><a href="#TypeParser.infer_table-817"><span class="linenos">817</span></a><span class="sd">		&quot;&quot;&quot;</span>
-</span><span id="TypeParser.infer_table-818"><a href="#TypeParser.infer_table-818"><span class="linenos">818</span></a>		<span class="n">rows_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>
-</span><span id="TypeParser.infer_table-819"><a href="#TypeParser.infer_table-819"><span class="linenos">819</span></a>		<span class="n">first_row</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">rows_iter</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
-</span><span id="TypeParser.infer_table-820"><a href="#TypeParser.infer_table-820"><span class="linenos">820</span></a>		<span class="k">if</span> <span class="n">first_row</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
-</span><span id="TypeParser.infer_table-821"><a href="#TypeParser.infer_table-821"><span class="linenos">821</span></a>			<span class="k">return</span> <span class="p">[]</span>
-</span><span id="TypeParser.infer_table-822"><a href="#TypeParser.infer_table-822"><span class="linenos">822</span></a>
-</span><span id="TypeParser.infer_table-823"><a href="#TypeParser.infer_table-823"><span class="linenos">823</span></a>		<span class="n">num_cols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">first_row</span><span class="p">)</span>
-</span><span id="TypeParser.infer_table-824"><a href="#TypeParser.infer_table-824"><span class="linenos">824</span></a>		<span class="k">if</span> <span class="n">num_cols</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
-</span><span id="TypeParser.infer_table-825"><a href="#TypeParser.infer_table-825"><span class="linenos">825</span></a>			<span class="k">return</span> <span class="p">[]</span>
-</span><span id="TypeParser.infer_table-826"><a href="#TypeParser.infer_table-826"><span class="linenos">826</span></a>
-</span><span id="TypeParser.infer_table-827"><a href="#TypeParser.infer_table-827"><span class="linenos">827</span></a>		<span class="n">table</span> <span class="o">=</span> <span class="n">_TypeTable</span><span class="p">([[</span><span class="bp">self</span><span class="o">.</span><span class="n">infer</span><span class="p">(</span><span class="n">value</span><span class="p">)]</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">first_row</span><span class="p">])</span>
-</span><span id="TypeParser.infer_table-828"><a href="#TypeParser.infer_table-828"><span class="linenos">828</span></a>		<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">rows_iter</span><span class="p">:</span>
-</span><span id="TypeParser.infer_table-829"><a href="#TypeParser.infer_table-829"><span class="linenos">829</span></a>			<span class="n">table</span><span class="o">.</span><span class="n">add_row</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">infer</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">row</span><span class="p">])</span>
-</span><span id="TypeParser.infer_table-830"><a href="#TypeParser.infer_table-830"><span class="linenos">830</span></a>
-</span><span id="TypeParser.infer_table-831"><a href="#TypeParser.infer_table-831"><span class="linenos">831</span></a>		<span class="k">return</span> <span class="p">[</span><span class="n">reduce_types</span><span class="p">(</span><span class="n">col</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">table</span><span class="o">.</span><span class="n">cols</span><span class="p">]</span>
+            <div class="pdoc-code codehilite"><pre><span></span><span id="TypeParser.infer_table-788"><a href="#TypeParser.infer_table-788"><span class="linenos">788</span></a>	<span class="k">def</span> <span class="nf">infer_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rows</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">AnyValueType</span><span class="p">]:</span>
+</span><span id="TypeParser.infer_table-789"><a href="#TypeParser.infer_table-789"><span class="linenos">789</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
+</span><span id="TypeParser.infer_table-790"><a href="#TypeParser.infer_table-790"><span class="linenos">790</span></a><span class="sd">			Infer the underlying common type for each column of a table of strings</span>
+</span><span id="TypeParser.infer_table-791"><a href="#TypeParser.infer_table-791"><span class="linenos">791</span></a>
+</span><span id="TypeParser.infer_table-792"><a href="#TypeParser.infer_table-792"><span class="linenos">792</span></a><span class="sd">			For each column, if the values do not have the same apparent type, the resulting type will be narrowest possible type that will encompass all values in the column. See `parsetypes.reduce_types()` for more information.</span>
+</span><span id="TypeParser.infer_table-793"><a href="#TypeParser.infer_table-793"><span class="linenos">793</span></a>
+</span><span id="TypeParser.infer_table-794"><a href="#TypeParser.infer_table-794"><span class="linenos">794</span></a><span class="sd">			Note that the inferred types of every individual value must all be able to fit into memory at once.</span>
+</span><span id="TypeParser.infer_table-795"><a href="#TypeParser.infer_table-795"><span class="linenos">795</span></a>
+</span><span id="TypeParser.infer_table-796"><a href="#TypeParser.infer_table-796"><span class="linenos">796</span></a><span class="sd">			Parameters</span>
+</span><span id="TypeParser.infer_table-797"><a href="#TypeParser.infer_table-797"><span class="linenos">797</span></a><span class="sd">			----------</span>
+</span><span id="TypeParser.infer_table-798"><a href="#TypeParser.infer_table-798"><span class="linenos">798</span></a><span class="sd">			`rows`</span>
+</span><span id="TypeParser.infer_table-799"><a href="#TypeParser.infer_table-799"><span class="linenos">799</span></a><span class="sd">			: table of strings for which the types should be inferred, in row-major order</span>
+</span><span id="TypeParser.infer_table-800"><a href="#TypeParser.infer_table-800"><span class="linenos">800</span></a>
+</span><span id="TypeParser.infer_table-801"><a href="#TypeParser.infer_table-801"><span class="linenos">801</span></a><span class="sd">			Returns</span>
+</span><span id="TypeParser.infer_table-802"><a href="#TypeParser.infer_table-802"><span class="linenos">802</span></a><span class="sd">			-------</span>
+</span><span id="TypeParser.infer_table-803"><a href="#TypeParser.infer_table-803"><span class="linenos">803</span></a><span class="sd">			inferred types</span>
+</span><span id="TypeParser.infer_table-804"><a href="#TypeParser.infer_table-804"><span class="linenos">804</span></a>
+</span><span id="TypeParser.infer_table-805"><a href="#TypeParser.infer_table-805"><span class="linenos">805</span></a><span class="sd">			Examples</span>
+</span><span id="TypeParser.infer_table-806"><a href="#TypeParser.infer_table-806"><span class="linenos">806</span></a><span class="sd">			--------</span>
+</span><span id="TypeParser.infer_table-807"><a href="#TypeParser.infer_table-807"><span class="linenos">807</span></a><span class="sd">			```python</span>
+</span><span id="TypeParser.infer_table-808"><a href="#TypeParser.infer_table-808"><span class="linenos">808</span></a><span class="sd">			parser = TypeParser()</span>
+</span><span id="TypeParser.infer_table-809"><a href="#TypeParser.infer_table-809"><span class="linenos">809</span></a><span class="sd">			parser.infer_table([</span>
+</span><span id="TypeParser.infer_table-810"><a href="#TypeParser.infer_table-810"><span class="linenos">810</span></a><span class="sd">				[&quot;1&quot;,   &quot;true&quot;,  &quot;1&quot;],</span>
+</span><span id="TypeParser.infer_table-811"><a href="#TypeParser.infer_table-811"><span class="linenos">811</span></a><span class="sd">				[&quot;2&quot;,   &quot;false&quot;, &quot;2.3&quot;],</span>
+</span><span id="TypeParser.infer_table-812"><a href="#TypeParser.infer_table-812"><span class="linenos">812</span></a><span class="sd">				[&quot;3.4&quot;, &quot;2&quot;,     &quot;abc&quot;],</span>
+</span><span id="TypeParser.infer_table-813"><a href="#TypeParser.infer_table-813"><span class="linenos">813</span></a><span class="sd">			])</span>
+</span><span id="TypeParser.infer_table-814"><a href="#TypeParser.infer_table-814"><span class="linenos">814</span></a><span class="sd">			# [float, int, str]</span>
+</span><span id="TypeParser.infer_table-815"><a href="#TypeParser.infer_table-815"><span class="linenos">815</span></a><span class="sd">			```</span>
+</span><span id="TypeParser.infer_table-816"><a href="#TypeParser.infer_table-816"><span class="linenos">816</span></a><span class="sd">		&quot;&quot;&quot;</span>
+</span><span id="TypeParser.infer_table-817"><a href="#TypeParser.infer_table-817"><span class="linenos">817</span></a>		<span class="n">rows_iter</span> <span class="o">=</span> <span class="nb">iter</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>
+</span><span id="TypeParser.infer_table-818"><a href="#TypeParser.infer_table-818"><span class="linenos">818</span></a>		<span class="n">first_row</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">rows_iter</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
+</span><span id="TypeParser.infer_table-819"><a href="#TypeParser.infer_table-819"><span class="linenos">819</span></a>		<span class="k">if</span> <span class="n">first_row</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
+</span><span id="TypeParser.infer_table-820"><a href="#TypeParser.infer_table-820"><span class="linenos">820</span></a>			<span class="k">return</span> <span class="p">[]</span>
+</span><span id="TypeParser.infer_table-821"><a href="#TypeParser.infer_table-821"><span class="linenos">821</span></a>
+</span><span id="TypeParser.infer_table-822"><a href="#TypeParser.infer_table-822"><span class="linenos">822</span></a>		<span class="n">num_cols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">first_row</span><span class="p">)</span>
+</span><span id="TypeParser.infer_table-823"><a href="#TypeParser.infer_table-823"><span class="linenos">823</span></a>		<span class="k">if</span> <span class="n">num_cols</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
+</span><span id="TypeParser.infer_table-824"><a href="#TypeParser.infer_table-824"><span class="linenos">824</span></a>			<span class="k">return</span> <span class="p">[]</span>
+</span><span id="TypeParser.infer_table-825"><a href="#TypeParser.infer_table-825"><span class="linenos">825</span></a>
+</span><span id="TypeParser.infer_table-826"><a href="#TypeParser.infer_table-826"><span class="linenos">826</span></a>		<span class="n">table</span> <span class="o">=</span> <span class="n">_TypeTable</span><span class="p">([[</span><span class="bp">self</span><span class="o">.</span><span class="n">infer</span><span class="p">(</span><span class="n">value</span><span class="p">)]</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">first_row</span><span class="p">])</span>
+</span><span id="TypeParser.infer_table-827"><a href="#TypeParser.infer_table-827"><span class="linenos">827</span></a>		<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">rows_iter</span><span class="p">:</span>
+</span><span id="TypeParser.infer_table-828"><a href="#TypeParser.infer_table-828"><span class="linenos">828</span></a>			<span class="n">table</span><span class="o">.</span><span class="n">add_row</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">infer</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">row</span><span class="p">])</span>
+</span><span id="TypeParser.infer_table-829"><a href="#TypeParser.infer_table-829"><span class="linenos">829</span></a>
+</span><span id="TypeParser.infer_table-830"><a href="#TypeParser.infer_table-830"><span class="linenos">830</span></a>		<span class="k">return</span> <span class="p">[</span><span class="n">reduce_types</span><span class="p">(</span><span class="n">col</span><span class="p">)</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">table</span><span class="o">.</span><span class="n">cols</span><span class="p">]</span>
 </span></pre></div>
 
 
     <div class="docstring">
 <p>Infer the underlying common type for each column of a table of strings</p>
 
 <p>For each column, if the values do not have the same apparent type, the resulting type will be narrowest possible type that will encompass all values in the column. See <code><a href="#reduce_types">parsetypes.reduce_types()</a></code> for more information.</p>
@@ -2530,44 +2530,44 @@
 
                             </div>
                             <div id="TypeParser.parse" class="classattr">
                                         <input id="TypeParser.parse-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
 <div class="attr function">
             
         <span class="def">def</span>
-        <span class="name">parse</span><span class="signature pdoc-code multiline">(<span class="param">	<span class="bp">self</span>,</span><span class="param">	<span class="n">value</span><span class="p">:</span> <span class="nb">str</span></span><span class="return-annotation">) -> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">NoneType</span><span class="p">,</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="n">NoneType</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="kc">None</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="nb">list</span><span class="p">[</span><span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="nb">list</span><span class="p">[</span><span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">float</span><span class="p">]],</span> <span class="nb">list</span><span class="p">[</span><span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">]],</span> <span class="nb">list</span><span class="p">[</span><span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">bool</span><span class="p">]],</span> <span class="nb">list</span><span class="p">[</span><span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="n">NoneType</span><span class="p">]]]</span>:</span></span>
+        <span class="name">parse</span><span class="signature pdoc-code multiline">(<span class="param">	<span class="bp">self</span>,</span><span class="param">	<span class="n">value</span><span class="p">:</span> <span class="nb">str</span></span><span class="return-annotation">) -> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">NoneType</span><span class="p">,</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="n">NoneType</span><span class="p">]]</span>:</span></span>
 
 
                 <label class="view-source-button" for="TypeParser.parse-view-source"><span>View Source</span></label>
 
     </div>
     <a class="headerlink" href="#TypeParser.parse"></a>
-            <div class="pdoc-code codehilite"><pre><span></span><span id="TypeParser.parse-870"><a href="#TypeParser.parse-870"><span class="linenos">870</span></a>	<span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AnyValue</span><span class="p">:</span>
-</span><span id="TypeParser.parse-871"><a href="#TypeParser.parse-871"><span class="linenos">871</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
-</span><span id="TypeParser.parse-872"><a href="#TypeParser.parse-872"><span class="linenos">872</span></a><span class="sd">			Parse a string and convert it to its underlying type</span>
-</span><span id="TypeParser.parse-873"><a href="#TypeParser.parse-873"><span class="linenos">873</span></a>
-</span><span id="TypeParser.parse-874"><a href="#TypeParser.parse-874"><span class="linenos">874</span></a><span class="sd">			Parameters</span>
-</span><span id="TypeParser.parse-875"><a href="#TypeParser.parse-875"><span class="linenos">875</span></a><span class="sd">			----------</span>
-</span><span id="TypeParser.parse-876"><a href="#TypeParser.parse-876"><span class="linenos">876</span></a><span class="sd">			`value`</span>
-</span><span id="TypeParser.parse-877"><a href="#TypeParser.parse-877"><span class="linenos">877</span></a><span class="sd">			: the string to be parsed</span>
-</span><span id="TypeParser.parse-878"><a href="#TypeParser.parse-878"><span class="linenos">878</span></a>
-</span><span id="TypeParser.parse-879"><a href="#TypeParser.parse-879"><span class="linenos">879</span></a><span class="sd">			Returns</span>
-</span><span id="TypeParser.parse-880"><a href="#TypeParser.parse-880"><span class="linenos">880</span></a><span class="sd">			-------</span>
-</span><span id="TypeParser.parse-881"><a href="#TypeParser.parse-881"><span class="linenos">881</span></a><span class="sd">			converted value</span>
-</span><span id="TypeParser.parse-882"><a href="#TypeParser.parse-882"><span class="linenos">882</span></a>
-</span><span id="TypeParser.parse-883"><a href="#TypeParser.parse-883"><span class="linenos">883</span></a><span class="sd">			Examples</span>
-</span><span id="TypeParser.parse-884"><a href="#TypeParser.parse-884"><span class="linenos">884</span></a><span class="sd">			--------</span>
-</span><span id="TypeParser.parse-885"><a href="#TypeParser.parse-885"><span class="linenos">885</span></a><span class="sd">			```python</span>
-</span><span id="TypeParser.parse-886"><a href="#TypeParser.parse-886"><span class="linenos">886</span></a><span class="sd">			parser = TypeParser()</span>
-</span><span id="TypeParser.parse-887"><a href="#TypeParser.parse-887"><span class="linenos">887</span></a><span class="sd">			parser.parse(&quot;true&quot;)  # True</span>
-</span><span id="TypeParser.parse-888"><a href="#TypeParser.parse-888"><span class="linenos">888</span></a><span class="sd">			parser.parse(&quot;2.0&quot;)   # 2.</span>
-</span><span id="TypeParser.parse-889"><a href="#TypeParser.parse-889"><span class="linenos">889</span></a><span class="sd">			parser.parse(&quot;abc&quot;)   # &quot;abc&quot;</span>
-</span><span id="TypeParser.parse-890"><a href="#TypeParser.parse-890"><span class="linenos">890</span></a><span class="sd">			```</span>
-</span><span id="TypeParser.parse-891"><a href="#TypeParser.parse-891"><span class="linenos">891</span></a><span class="sd">		&quot;&quot;&quot;</span>
-</span><span id="TypeParser.parse-892"><a href="#TypeParser.parse-892"><span class="linenos">892</span></a>		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">infer</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
+            <div class="pdoc-code codehilite"><pre><span></span><span id="TypeParser.parse-869"><a href="#TypeParser.parse-869"><span class="linenos">869</span></a>	<span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">AnyValue</span><span class="p">:</span>
+</span><span id="TypeParser.parse-870"><a href="#TypeParser.parse-870"><span class="linenos">870</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
+</span><span id="TypeParser.parse-871"><a href="#TypeParser.parse-871"><span class="linenos">871</span></a><span class="sd">			Parse a string and convert it to its underlying type</span>
+</span><span id="TypeParser.parse-872"><a href="#TypeParser.parse-872"><span class="linenos">872</span></a>
+</span><span id="TypeParser.parse-873"><a href="#TypeParser.parse-873"><span class="linenos">873</span></a><span class="sd">			Parameters</span>
+</span><span id="TypeParser.parse-874"><a href="#TypeParser.parse-874"><span class="linenos">874</span></a><span class="sd">			----------</span>
+</span><span id="TypeParser.parse-875"><a href="#TypeParser.parse-875"><span class="linenos">875</span></a><span class="sd">			`value`</span>
+</span><span id="TypeParser.parse-876"><a href="#TypeParser.parse-876"><span class="linenos">876</span></a><span class="sd">			: the string to be parsed</span>
+</span><span id="TypeParser.parse-877"><a href="#TypeParser.parse-877"><span class="linenos">877</span></a>
+</span><span id="TypeParser.parse-878"><a href="#TypeParser.parse-878"><span class="linenos">878</span></a><span class="sd">			Returns</span>
+</span><span id="TypeParser.parse-879"><a href="#TypeParser.parse-879"><span class="linenos">879</span></a><span class="sd">			-------</span>
+</span><span id="TypeParser.parse-880"><a href="#TypeParser.parse-880"><span class="linenos">880</span></a><span class="sd">			converted value</span>
+</span><span id="TypeParser.parse-881"><a href="#TypeParser.parse-881"><span class="linenos">881</span></a>
+</span><span id="TypeParser.parse-882"><a href="#TypeParser.parse-882"><span class="linenos">882</span></a><span class="sd">			Examples</span>
+</span><span id="TypeParser.parse-883"><a href="#TypeParser.parse-883"><span class="linenos">883</span></a><span class="sd">			--------</span>
+</span><span id="TypeParser.parse-884"><a href="#TypeParser.parse-884"><span class="linenos">884</span></a><span class="sd">			```python</span>
+</span><span id="TypeParser.parse-885"><a href="#TypeParser.parse-885"><span class="linenos">885</span></a><span class="sd">			parser = TypeParser()</span>
+</span><span id="TypeParser.parse-886"><a href="#TypeParser.parse-886"><span class="linenos">886</span></a><span class="sd">			parser.parse(&quot;true&quot;)  # True</span>
+</span><span id="TypeParser.parse-887"><a href="#TypeParser.parse-887"><span class="linenos">887</span></a><span class="sd">			parser.parse(&quot;2.0&quot;)   # 2.</span>
+</span><span id="TypeParser.parse-888"><a href="#TypeParser.parse-888"><span class="linenos">888</span></a><span class="sd">			parser.parse(&quot;abc&quot;)   # &quot;abc&quot;</span>
+</span><span id="TypeParser.parse-889"><a href="#TypeParser.parse-889"><span class="linenos">889</span></a><span class="sd">			```</span>
+</span><span id="TypeParser.parse-890"><a href="#TypeParser.parse-890"><span class="linenos">890</span></a><span class="sd">		&quot;&quot;&quot;</span>
+</span><span id="TypeParser.parse-891"><a href="#TypeParser.parse-891"><span class="linenos">891</span></a>		<span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">infer</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>
 </span></pre></div>
 
 
     <div class="docstring">
 <p>Parse a string and convert it to its underlying type</p>
 
 <h2 id="parameters">Parameters</h2>
@@ -2593,48 +2593,48 @@
 
                             </div>
                             <div id="TypeParser.parse_series" class="classattr">
                                         <input id="TypeParser.parse_series-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
 <div class="attr function">
             
         <span class="def">def</span>
-        <span class="name">parse_series</span><span class="signature pdoc-code multiline">(<span class="param">	<span class="bp">self</span>,</span><span class="param">	<span class="n">values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span></span><span class="return-annotation">) -> <span class="nb">list</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">NoneType</span><span class="p">,</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="n">NoneType</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="kc">None</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="nb">list</span><span class="p">[</span><span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="nb">list</span><span class="p">[</span><span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">float</span><span class="p">]],</span> <span class="nb">list</span><span class="p">[</span><span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">]],</span> <span class="nb">list</span><span class="p">[</span><span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">bool</span><span class="p">]],</span> <span class="nb">list</span><span class="p">[</span><span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="n">NoneType</span><span class="p">]]]]</span>:</span></span>
+        <span class="name">parse_series</span><span class="signature pdoc-code multiline">(<span class="param">	<span class="bp">self</span>,</span><span class="param">	<span class="n">values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span></span><span class="return-annotation">) -> <span class="nb">list</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">NoneType</span><span class="p">,</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="n">NoneType</span><span class="p">]]]</span>:</span></span>
 
 
                 <label class="view-source-button" for="TypeParser.parse_series-view-source"><span>View Source</span></label>
 
     </div>
     <a class="headerlink" href="#TypeParser.parse_series"></a>
-            <div class="pdoc-code codehilite"><pre><span></span><span id="TypeParser.parse_series-895"><a href="#TypeParser.parse_series-895"><span class="linenos">895</span></a>	<span class="k">def</span> <span class="nf">parse_series</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">AnyValue</span><span class="p">]:</span>
-</span><span id="TypeParser.parse_series-896"><a href="#TypeParser.parse_series-896"><span class="linenos">896</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
-</span><span id="TypeParser.parse_series-897"><a href="#TypeParser.parse_series-897"><span class="linenos">897</span></a><span class="sd">			Parse a series of strings and convert them to their underlying common type</span>
-</span><span id="TypeParser.parse_series-898"><a href="#TypeParser.parse_series-898"><span class="linenos">898</span></a>
-</span><span id="TypeParser.parse_series-899"><a href="#TypeParser.parse_series-899"><span class="linenos">899</span></a><span class="sd">			If the values in the series do not have the same apparent type, the common type is taken as the narrowest possible type that will encompass all values in the series. See `parsetypes.reduce_types()` for more information.</span>
-</span><span id="TypeParser.parse_series-900"><a href="#TypeParser.parse_series-900"><span class="linenos">900</span></a>
-</span><span id="TypeParser.parse_series-901"><a href="#TypeParser.parse_series-901"><span class="linenos">901</span></a><span class="sd">			Parameters</span>
-</span><span id="TypeParser.parse_series-902"><a href="#TypeParser.parse_series-902"><span class="linenos">902</span></a><span class="sd">			----------</span>
-</span><span id="TypeParser.parse_series-903"><a href="#TypeParser.parse_series-903"><span class="linenos">903</span></a><span class="sd">			`values`</span>
-</span><span id="TypeParser.parse_series-904"><a href="#TypeParser.parse_series-904"><span class="linenos">904</span></a><span class="sd">			: series of strings to be parsed</span>
-</span><span id="TypeParser.parse_series-905"><a href="#TypeParser.parse_series-905"><span class="linenos">905</span></a>
-</span><span id="TypeParser.parse_series-906"><a href="#TypeParser.parse_series-906"><span class="linenos">906</span></a><span class="sd">			Returns</span>
-</span><span id="TypeParser.parse_series-907"><a href="#TypeParser.parse_series-907"><span class="linenos">907</span></a><span class="sd">			-------</span>
-</span><span id="TypeParser.parse_series-908"><a href="#TypeParser.parse_series-908"><span class="linenos">908</span></a><span class="sd">			converted values</span>
-</span><span id="TypeParser.parse_series-909"><a href="#TypeParser.parse_series-909"><span class="linenos">909</span></a>
-</span><span id="TypeParser.parse_series-910"><a href="#TypeParser.parse_series-910"><span class="linenos">910</span></a><span class="sd">			Examples</span>
-</span><span id="TypeParser.parse_series-911"><a href="#TypeParser.parse_series-911"><span class="linenos">911</span></a><span class="sd">			--------</span>
-</span><span id="TypeParser.parse_series-912"><a href="#TypeParser.parse_series-912"><span class="linenos">912</span></a><span class="sd">			```python</span>
-</span><span id="TypeParser.parse_series-913"><a href="#TypeParser.parse_series-913"><span class="linenos">913</span></a><span class="sd">			parser = TypeParser()</span>
-</span><span id="TypeParser.parse_series-914"><a href="#TypeParser.parse_series-914"><span class="linenos">914</span></a><span class="sd">			parser.parse_series([&quot;1&quot;, &quot;2&quot;, &quot;3&quot;])        # [1, 2, 3]</span>
-</span><span id="TypeParser.parse_series-915"><a href="#TypeParser.parse_series-915"><span class="linenos">915</span></a><span class="sd">			parser.parse_series([&quot;5&quot;, &quot;6.7&quot;, &quot;8.&quot;])     # [5., 6.7, 8.]</span>
-</span><span id="TypeParser.parse_series-916"><a href="#TypeParser.parse_series-916"><span class="linenos">916</span></a><span class="sd">			parser.parse_series([&quot;true&quot;, &quot;false&quot;, &quot;&quot;])  # [True, False, None]</span>
-</span><span id="TypeParser.parse_series-917"><a href="#TypeParser.parse_series-917"><span class="linenos">917</span></a><span class="sd">			parser.parse_series([&quot;1&quot;, &quot;2.3&quot;, &quot;abc&quot;])    # [&quot;1&quot;, &quot;2.3&quot;, &quot;abc&quot;]</span>
-</span><span id="TypeParser.parse_series-918"><a href="#TypeParser.parse_series-918"><span class="linenos">918</span></a><span class="sd">			```</span>
-</span><span id="TypeParser.parse_series-919"><a href="#TypeParser.parse_series-919"><span class="linenos">919</span></a><span class="sd">		&quot;&quot;&quot;</span>
-</span><span id="TypeParser.parse_series-920"><a href="#TypeParser.parse_series-920"><span class="linenos">920</span></a>		<span class="n">inferred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">infer_series</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
-</span><span id="TypeParser.parse_series-921"><a href="#TypeParser.parse_series-921"><span class="linenos">921</span></a>		<span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_convert</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">inferred</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span>
+            <div class="pdoc-code codehilite"><pre><span></span><span id="TypeParser.parse_series-894"><a href="#TypeParser.parse_series-894"><span class="linenos">894</span></a>	<span class="k">def</span> <span class="nf">parse_series</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">AnyValue</span><span class="p">]:</span>
+</span><span id="TypeParser.parse_series-895"><a href="#TypeParser.parse_series-895"><span class="linenos">895</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
+</span><span id="TypeParser.parse_series-896"><a href="#TypeParser.parse_series-896"><span class="linenos">896</span></a><span class="sd">			Parse a series of strings and convert them to their underlying common type</span>
+</span><span id="TypeParser.parse_series-897"><a href="#TypeParser.parse_series-897"><span class="linenos">897</span></a>
+</span><span id="TypeParser.parse_series-898"><a href="#TypeParser.parse_series-898"><span class="linenos">898</span></a><span class="sd">			If the values in the series do not have the same apparent type, the common type is taken as the narrowest possible type that will encompass all values in the series. See `parsetypes.reduce_types()` for more information.</span>
+</span><span id="TypeParser.parse_series-899"><a href="#TypeParser.parse_series-899"><span class="linenos">899</span></a>
+</span><span id="TypeParser.parse_series-900"><a href="#TypeParser.parse_series-900"><span class="linenos">900</span></a><span class="sd">			Parameters</span>
+</span><span id="TypeParser.parse_series-901"><a href="#TypeParser.parse_series-901"><span class="linenos">901</span></a><span class="sd">			----------</span>
+</span><span id="TypeParser.parse_series-902"><a href="#TypeParser.parse_series-902"><span class="linenos">902</span></a><span class="sd">			`values`</span>
+</span><span id="TypeParser.parse_series-903"><a href="#TypeParser.parse_series-903"><span class="linenos">903</span></a><span class="sd">			: series of strings to be parsed</span>
+</span><span id="TypeParser.parse_series-904"><a href="#TypeParser.parse_series-904"><span class="linenos">904</span></a>
+</span><span id="TypeParser.parse_series-905"><a href="#TypeParser.parse_series-905"><span class="linenos">905</span></a><span class="sd">			Returns</span>
+</span><span id="TypeParser.parse_series-906"><a href="#TypeParser.parse_series-906"><span class="linenos">906</span></a><span class="sd">			-------</span>
+</span><span id="TypeParser.parse_series-907"><a href="#TypeParser.parse_series-907"><span class="linenos">907</span></a><span class="sd">			converted values</span>
+</span><span id="TypeParser.parse_series-908"><a href="#TypeParser.parse_series-908"><span class="linenos">908</span></a>
+</span><span id="TypeParser.parse_series-909"><a href="#TypeParser.parse_series-909"><span class="linenos">909</span></a><span class="sd">			Examples</span>
+</span><span id="TypeParser.parse_series-910"><a href="#TypeParser.parse_series-910"><span class="linenos">910</span></a><span class="sd">			--------</span>
+</span><span id="TypeParser.parse_series-911"><a href="#TypeParser.parse_series-911"><span class="linenos">911</span></a><span class="sd">			```python</span>
+</span><span id="TypeParser.parse_series-912"><a href="#TypeParser.parse_series-912"><span class="linenos">912</span></a><span class="sd">			parser = TypeParser()</span>
+</span><span id="TypeParser.parse_series-913"><a href="#TypeParser.parse_series-913"><span class="linenos">913</span></a><span class="sd">			parser.parse_series([&quot;1&quot;, &quot;2&quot;, &quot;3&quot;])        # [1, 2, 3]</span>
+</span><span id="TypeParser.parse_series-914"><a href="#TypeParser.parse_series-914"><span class="linenos">914</span></a><span class="sd">			parser.parse_series([&quot;5&quot;, &quot;6.7&quot;, &quot;8.&quot;])     # [5., 6.7, 8.]</span>
+</span><span id="TypeParser.parse_series-915"><a href="#TypeParser.parse_series-915"><span class="linenos">915</span></a><span class="sd">			parser.parse_series([&quot;true&quot;, &quot;false&quot;, &quot;&quot;])  # [True, False, None]</span>
+</span><span id="TypeParser.parse_series-916"><a href="#TypeParser.parse_series-916"><span class="linenos">916</span></a><span class="sd">			parser.parse_series([&quot;1&quot;, &quot;2.3&quot;, &quot;abc&quot;])    # [&quot;1&quot;, &quot;2.3&quot;, &quot;abc&quot;]</span>
+</span><span id="TypeParser.parse_series-917"><a href="#TypeParser.parse_series-917"><span class="linenos">917</span></a><span class="sd">			```</span>
+</span><span id="TypeParser.parse_series-918"><a href="#TypeParser.parse_series-918"><span class="linenos">918</span></a><span class="sd">		&quot;&quot;&quot;</span>
+</span><span id="TypeParser.parse_series-919"><a href="#TypeParser.parse_series-919"><span class="linenos">919</span></a>		<span class="n">inferred</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">infer_series</span><span class="p">(</span><span class="n">values</span><span class="p">)</span>
+</span><span id="TypeParser.parse_series-920"><a href="#TypeParser.parse_series-920"><span class="linenos">920</span></a>		<span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_convert</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">inferred</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">values</span><span class="p">]</span>
 </span></pre></div>
 
 
     <div class="docstring">
 <p>Parse a series of strings and convert them to their underlying common type</p>
 
 <p>If the values in the series do not have the same apparent type, the common type is taken as the narrowest possible type that will encompass all values in the series. See <code><a href="#reduce_types">parsetypes.reduce_types()</a></code> for more information.</p>
@@ -2663,60 +2663,60 @@
 
                             </div>
                             <div id="TypeParser.parse_table" class="classattr">
                                         <input id="TypeParser.parse_table-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
 <div class="attr function">
             
         <span class="def">def</span>
-        <span class="name">parse_table</span><span class="signature pdoc-code multiline">(<span class="param">	<span class="bp">self</span>,</span><span class="param">	<span class="n">rows</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span></span><span class="return-annotation">) -> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">NoneType</span><span class="p">,</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="n">NoneType</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="kc">None</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="nb">list</span><span class="p">[</span><span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="nb">list</span><span class="p">[</span><span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">float</span><span class="p">]],</span> <span class="nb">list</span><span class="p">[</span><span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">]],</span> <span class="nb">list</span><span class="p">[</span><span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">bool</span><span class="p">]],</span> <span class="nb">list</span><span class="p">[</span><span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="n">NoneType</span><span class="p">]]]]]</span>:</span></span>
+        <span class="name">parse_table</span><span class="signature pdoc-code multiline">(<span class="param">	<span class="bp">self</span>,</span><span class="param">	<span class="n">rows</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span></span><span class="return-annotation">) -> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">NoneType</span><span class="p">,</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="n">NoneType</span><span class="p">]]]]</span>:</span></span>
 
 
                 <label class="view-source-button" for="TypeParser.parse_table-view-source"><span>View Source</span></label>
 
     </div>
     <a class="headerlink" href="#TypeParser.parse_table"></a>
-            <div class="pdoc-code codehilite"><pre><span></span><span id="TypeParser.parse_table-924"><a href="#TypeParser.parse_table-924"><span class="linenos">924</span></a>	<span class="k">def</span> <span class="nf">parse_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rows</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">AnyValue</span><span class="p">]]:</span>
-</span><span id="TypeParser.parse_table-925"><a href="#TypeParser.parse_table-925"><span class="linenos">925</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
-</span><span id="TypeParser.parse_table-926"><a href="#TypeParser.parse_table-926"><span class="linenos">926</span></a><span class="sd">			Parse a table of strings and convert them to the underlying common type of each column</span>
-</span><span id="TypeParser.parse_table-927"><a href="#TypeParser.parse_table-927"><span class="linenos">927</span></a>
-</span><span id="TypeParser.parse_table-928"><a href="#TypeParser.parse_table-928"><span class="linenos">928</span></a><span class="sd">			For each column, if the values do not have the same apparent type, the common type is taken as the narrowest possible type that will encompass all values in the column. See `parsetypes.reduce_types()` for more information.</span>
-</span><span id="TypeParser.parse_table-929"><a href="#TypeParser.parse_table-929"><span class="linenos">929</span></a>
-</span><span id="TypeParser.parse_table-930"><a href="#TypeParser.parse_table-930"><span class="linenos">930</span></a><span class="sd">			Note that the type inference requires that the inferred types of every individual value must all be able to fit into memory at once.</span>
-</span><span id="TypeParser.parse_table-931"><a href="#TypeParser.parse_table-931"><span class="linenos">931</span></a>
-</span><span id="TypeParser.parse_table-932"><a href="#TypeParser.parse_table-932"><span class="linenos">932</span></a><span class="sd">			This is a function that computes the entire table and returns it all at once. The generator `iterate_table()` behaves analogously, except that it computes and yields each row one at a time.</span>
-</span><span id="TypeParser.parse_table-933"><a href="#TypeParser.parse_table-933"><span class="linenos">933</span></a>
-</span><span id="TypeParser.parse_table-934"><a href="#TypeParser.parse_table-934"><span class="linenos">934</span></a><span class="sd">			Parameters</span>
-</span><span id="TypeParser.parse_table-935"><a href="#TypeParser.parse_table-935"><span class="linenos">935</span></a><span class="sd">			----------</span>
-</span><span id="TypeParser.parse_table-936"><a href="#TypeParser.parse_table-936"><span class="linenos">936</span></a><span class="sd">			`rows`</span>
-</span><span id="TypeParser.parse_table-937"><a href="#TypeParser.parse_table-937"><span class="linenos">937</span></a><span class="sd">			: table of strings to be parsed, in row-major order</span>
-</span><span id="TypeParser.parse_table-938"><a href="#TypeParser.parse_table-938"><span class="linenos">938</span></a>
-</span><span id="TypeParser.parse_table-939"><a href="#TypeParser.parse_table-939"><span class="linenos">939</span></a><span class="sd">			`iterator`</span>
-</span><span id="TypeParser.parse_table-940"><a href="#TypeParser.parse_table-940"><span class="linenos">940</span></a><span class="sd">			: whether the parsed values should be yielded as an iterator. If False, which is the default, the entire table is computed and returned as a list of lists. If True, this function behaves as a generator, and the rows of the table are computed and yielded one at a time. However, note that even when set to True, the type inference requires that inferred type of each individual value must all be able to fit into memory at once.</span>
-</span><span id="TypeParser.parse_table-941"><a href="#TypeParser.parse_table-941"><span class="linenos">941</span></a>
-</span><span id="TypeParser.parse_table-942"><a href="#TypeParser.parse_table-942"><span class="linenos">942</span></a><span class="sd">			Returns</span>
-</span><span id="TypeParser.parse_table-943"><a href="#TypeParser.parse_table-943"><span class="linenos">943</span></a><span class="sd">			-------</span>
-</span><span id="TypeParser.parse_table-944"><a href="#TypeParser.parse_table-944"><span class="linenos">944</span></a><span class="sd">			converted table of values, in row-major order</span>
-</span><span id="TypeParser.parse_table-945"><a href="#TypeParser.parse_table-945"><span class="linenos">945</span></a>
-</span><span id="TypeParser.parse_table-946"><a href="#TypeParser.parse_table-946"><span class="linenos">946</span></a><span class="sd">			Examples</span>
-</span><span id="TypeParser.parse_table-947"><a href="#TypeParser.parse_table-947"><span class="linenos">947</span></a><span class="sd">			--------</span>
-</span><span id="TypeParser.parse_table-948"><a href="#TypeParser.parse_table-948"><span class="linenos">948</span></a><span class="sd">			```python</span>
-</span><span id="TypeParser.parse_table-949"><a href="#TypeParser.parse_table-949"><span class="linenos">949</span></a><span class="sd">			parser = TypeParser()</span>
-</span><span id="TypeParser.parse_table-950"><a href="#TypeParser.parse_table-950"><span class="linenos">950</span></a><span class="sd">			table = parser.parse_table([</span>
-</span><span id="TypeParser.parse_table-951"><a href="#TypeParser.parse_table-951"><span class="linenos">951</span></a><span class="sd">				[&quot;1&quot;, &quot;5&quot;,   &quot;true&quot;,  &quot;1&quot;],</span>
-</span><span id="TypeParser.parse_table-952"><a href="#TypeParser.parse_table-952"><span class="linenos">952</span></a><span class="sd">				[&quot;2&quot;, &quot;6.7&quot;, &quot;false&quot;, &quot;2.3&quot;],</span>
-</span><span id="TypeParser.parse_table-953"><a href="#TypeParser.parse_table-953"><span class="linenos">953</span></a><span class="sd">				[&quot;3&quot;, &quot;8.0&quot;, &quot;&quot;,     &quot;abc&quot;],</span>
-</span><span id="TypeParser.parse_table-954"><a href="#TypeParser.parse_table-954"><span class="linenos">954</span></a><span class="sd">			]):</span>
-</span><span id="TypeParser.parse_table-955"><a href="#TypeParser.parse_table-955"><span class="linenos">955</span></a><span class="sd">			assert table == [</span>
-</span><span id="TypeParser.parse_table-956"><a href="#TypeParser.parse_table-956"><span class="linenos">956</span></a><span class="sd">				[1, 5.,  True,  &quot;1&quot;],</span>
-</span><span id="TypeParser.parse_table-957"><a href="#TypeParser.parse_table-957"><span class="linenos">957</span></a><span class="sd">				[2, 6.7, False, &quot;2.3&quot;],</span>
-</span><span id="TypeParser.parse_table-958"><a href="#TypeParser.parse_table-958"><span class="linenos">958</span></a><span class="sd">				[3, 8.,  None,  &quot;abc&quot;],</span>
-</span><span id="TypeParser.parse_table-959"><a href="#TypeParser.parse_table-959"><span class="linenos">959</span></a><span class="sd">			]</span>
-</span><span id="TypeParser.parse_table-960"><a href="#TypeParser.parse_table-960"><span class="linenos">960</span></a><span class="sd">			```</span>
-</span><span id="TypeParser.parse_table-961"><a href="#TypeParser.parse_table-961"><span class="linenos">961</span></a><span class="sd">		&quot;&quot;&quot;</span>
-</span><span id="TypeParser.parse_table-962"><a href="#TypeParser.parse_table-962"><span class="linenos">962</span></a>		<span class="k">return</span> <span class="p">[</span><span class="n">converted_row</span> <span class="k">for</span> <span class="n">converted_row</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterate_table</span><span class="p">(</span><span class="n">rows</span><span class="p">)]</span>
+            <div class="pdoc-code codehilite"><pre><span></span><span id="TypeParser.parse_table-923"><a href="#TypeParser.parse_table-923"><span class="linenos">923</span></a>	<span class="k">def</span> <span class="nf">parse_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rows</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">AnyValue</span><span class="p">]]:</span>
+</span><span id="TypeParser.parse_table-924"><a href="#TypeParser.parse_table-924"><span class="linenos">924</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
+</span><span id="TypeParser.parse_table-925"><a href="#TypeParser.parse_table-925"><span class="linenos">925</span></a><span class="sd">			Parse a table of strings and convert them to the underlying common type of each column</span>
+</span><span id="TypeParser.parse_table-926"><a href="#TypeParser.parse_table-926"><span class="linenos">926</span></a>
+</span><span id="TypeParser.parse_table-927"><a href="#TypeParser.parse_table-927"><span class="linenos">927</span></a><span class="sd">			For each column, if the values do not have the same apparent type, the common type is taken as the narrowest possible type that will encompass all values in the column. See `parsetypes.reduce_types()` for more information.</span>
+</span><span id="TypeParser.parse_table-928"><a href="#TypeParser.parse_table-928"><span class="linenos">928</span></a>
+</span><span id="TypeParser.parse_table-929"><a href="#TypeParser.parse_table-929"><span class="linenos">929</span></a><span class="sd">			Note that the type inference requires that the inferred types of every individual value must all be able to fit into memory at once.</span>
+</span><span id="TypeParser.parse_table-930"><a href="#TypeParser.parse_table-930"><span class="linenos">930</span></a>
+</span><span id="TypeParser.parse_table-931"><a href="#TypeParser.parse_table-931"><span class="linenos">931</span></a><span class="sd">			This is a function that computes the entire table and returns it all at once. The generator `iterate_table()` behaves analogously, except that it computes and yields each row one at a time.</span>
+</span><span id="TypeParser.parse_table-932"><a href="#TypeParser.parse_table-932"><span class="linenos">932</span></a>
+</span><span id="TypeParser.parse_table-933"><a href="#TypeParser.parse_table-933"><span class="linenos">933</span></a><span class="sd">			Parameters</span>
+</span><span id="TypeParser.parse_table-934"><a href="#TypeParser.parse_table-934"><span class="linenos">934</span></a><span class="sd">			----------</span>
+</span><span id="TypeParser.parse_table-935"><a href="#TypeParser.parse_table-935"><span class="linenos">935</span></a><span class="sd">			`rows`</span>
+</span><span id="TypeParser.parse_table-936"><a href="#TypeParser.parse_table-936"><span class="linenos">936</span></a><span class="sd">			: table of strings to be parsed, in row-major order</span>
+</span><span id="TypeParser.parse_table-937"><a href="#TypeParser.parse_table-937"><span class="linenos">937</span></a>
+</span><span id="TypeParser.parse_table-938"><a href="#TypeParser.parse_table-938"><span class="linenos">938</span></a><span class="sd">			`iterator`</span>
+</span><span id="TypeParser.parse_table-939"><a href="#TypeParser.parse_table-939"><span class="linenos">939</span></a><span class="sd">			: whether the parsed values should be yielded as an iterator. If False, which is the default, the entire table is computed and returned as a list of lists. If True, this function behaves as a generator, and the rows of the table are computed and yielded one at a time. However, note that even when set to True, the type inference requires that inferred type of each individual value must all be able to fit into memory at once.</span>
+</span><span id="TypeParser.parse_table-940"><a href="#TypeParser.parse_table-940"><span class="linenos">940</span></a>
+</span><span id="TypeParser.parse_table-941"><a href="#TypeParser.parse_table-941"><span class="linenos">941</span></a><span class="sd">			Returns</span>
+</span><span id="TypeParser.parse_table-942"><a href="#TypeParser.parse_table-942"><span class="linenos">942</span></a><span class="sd">			-------</span>
+</span><span id="TypeParser.parse_table-943"><a href="#TypeParser.parse_table-943"><span class="linenos">943</span></a><span class="sd">			converted table of values, in row-major order</span>
+</span><span id="TypeParser.parse_table-944"><a href="#TypeParser.parse_table-944"><span class="linenos">944</span></a>
+</span><span id="TypeParser.parse_table-945"><a href="#TypeParser.parse_table-945"><span class="linenos">945</span></a><span class="sd">			Examples</span>
+</span><span id="TypeParser.parse_table-946"><a href="#TypeParser.parse_table-946"><span class="linenos">946</span></a><span class="sd">			--------</span>
+</span><span id="TypeParser.parse_table-947"><a href="#TypeParser.parse_table-947"><span class="linenos">947</span></a><span class="sd">			```python</span>
+</span><span id="TypeParser.parse_table-948"><a href="#TypeParser.parse_table-948"><span class="linenos">948</span></a><span class="sd">			parser = TypeParser()</span>
+</span><span id="TypeParser.parse_table-949"><a href="#TypeParser.parse_table-949"><span class="linenos">949</span></a><span class="sd">			table = parser.parse_table([</span>
+</span><span id="TypeParser.parse_table-950"><a href="#TypeParser.parse_table-950"><span class="linenos">950</span></a><span class="sd">				[&quot;1&quot;, &quot;5&quot;,   &quot;true&quot;,  &quot;1&quot;],</span>
+</span><span id="TypeParser.parse_table-951"><a href="#TypeParser.parse_table-951"><span class="linenos">951</span></a><span class="sd">				[&quot;2&quot;, &quot;6.7&quot;, &quot;false&quot;, &quot;2.3&quot;],</span>
+</span><span id="TypeParser.parse_table-952"><a href="#TypeParser.parse_table-952"><span class="linenos">952</span></a><span class="sd">				[&quot;3&quot;, &quot;8.0&quot;, &quot;&quot;,     &quot;abc&quot;],</span>
+</span><span id="TypeParser.parse_table-953"><a href="#TypeParser.parse_table-953"><span class="linenos">953</span></a><span class="sd">			]):</span>
+</span><span id="TypeParser.parse_table-954"><a href="#TypeParser.parse_table-954"><span class="linenos">954</span></a><span class="sd">			assert table == [</span>
+</span><span id="TypeParser.parse_table-955"><a href="#TypeParser.parse_table-955"><span class="linenos">955</span></a><span class="sd">				[1, 5.,  True,  &quot;1&quot;],</span>
+</span><span id="TypeParser.parse_table-956"><a href="#TypeParser.parse_table-956"><span class="linenos">956</span></a><span class="sd">				[2, 6.7, False, &quot;2.3&quot;],</span>
+</span><span id="TypeParser.parse_table-957"><a href="#TypeParser.parse_table-957"><span class="linenos">957</span></a><span class="sd">				[3, 8.,  None,  &quot;abc&quot;],</span>
+</span><span id="TypeParser.parse_table-958"><a href="#TypeParser.parse_table-958"><span class="linenos">958</span></a><span class="sd">			]</span>
+</span><span id="TypeParser.parse_table-959"><a href="#TypeParser.parse_table-959"><span class="linenos">959</span></a><span class="sd">			```</span>
+</span><span id="TypeParser.parse_table-960"><a href="#TypeParser.parse_table-960"><span class="linenos">960</span></a><span class="sd">		&quot;&quot;&quot;</span>
+</span><span id="TypeParser.parse_table-961"><a href="#TypeParser.parse_table-961"><span class="linenos">961</span></a>		<span class="k">return</span> <span class="p">[</span><span class="n">converted_row</span> <span class="k">for</span> <span class="n">converted_row</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iterate_table</span><span class="p">(</span><span class="n">rows</span><span class="p">)]</span>
 </span></pre></div>
 
 
     <div class="docstring">
 <p>Parse a table of strings and convert them to the underlying common type of each column</p>
 
 <p>For each column, if the values do not have the same apparent type, the common type is taken as the narrowest possible type that will encompass all values in the column. See <code><a href="#reduce_types">parsetypes.reduce_types()</a></code> for more information.</p>
@@ -2758,56 +2758,56 @@
 
                             </div>
                             <div id="TypeParser.iterate_table" class="classattr">
                                         <input id="TypeParser.iterate_table-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
 <div class="attr function">
             
         <span class="def">def</span>
-        <span class="name">iterate_table</span><span class="signature pdoc-code multiline">(<span class="param">	<span class="bp">self</span>,</span><span class="param">	<span class="n">rows</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span></span><span class="return-annotation">) -> <span class="n">Iterator</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">NoneType</span><span class="p">,</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="n">NoneType</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="kc">None</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="nb">list</span><span class="p">[</span><span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="nb">list</span><span class="p">[</span><span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">float</span><span class="p">]],</span> <span class="nb">list</span><span class="p">[</span><span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">]],</span> <span class="nb">list</span><span class="p">[</span><span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">bool</span><span class="p">]],</span> <span class="nb">list</span><span class="p">[</span><span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="n">NoneType</span><span class="p">]]]]]</span>:</span></span>
+        <span class="name">iterate_table</span><span class="signature pdoc-code multiline">(<span class="param">	<span class="bp">self</span>,</span><span class="param">	<span class="n">rows</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span></span><span class="return-annotation">) -> <span class="n">Iterator</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">NoneType</span><span class="p">,</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="n">NoneType</span><span class="p">]]]]</span>:</span></span>
 
 
                 <label class="view-source-button" for="TypeParser.iterate_table-view-source"><span>View Source</span></label>
 
     </div>
     <a class="headerlink" href="#TypeParser.iterate_table"></a>
-            <div class="pdoc-code codehilite"><pre><span></span><span id="TypeParser.iterate_table-965"><a href="#TypeParser.iterate_table-965"><span class="linenos">965</span></a>	<span class="k">def</span> <span class="nf">iterate_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rows</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">AnyValue</span><span class="p">]]:</span>
-</span><span id="TypeParser.iterate_table-966"><a href="#TypeParser.iterate_table-966"><span class="linenos">966</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
-</span><span id="TypeParser.iterate_table-967"><a href="#TypeParser.iterate_table-967"><span class="linenos">967</span></a><span class="sd">			Parse a table of strings for the underlying common type of each column, then convert and yield each row</span>
-</span><span id="TypeParser.iterate_table-968"><a href="#TypeParser.iterate_table-968"><span class="linenos">968</span></a>
-</span><span id="TypeParser.iterate_table-969"><a href="#TypeParser.iterate_table-969"><span class="linenos">969</span></a><span class="sd">			For each column, if the values do not have the same apparent type, the common type is taken as the narrowest possible type that will encompass all values in the column. See `parsetypes.reduce_types()` for more information.</span>
-</span><span id="TypeParser.iterate_table-970"><a href="#TypeParser.iterate_table-970"><span class="linenos">970</span></a>
-</span><span id="TypeParser.iterate_table-971"><a href="#TypeParser.iterate_table-971"><span class="linenos">971</span></a><span class="sd">			This is a generator that computes and yields each row one at a time. The function `parse_table()` behaves analogously, except that it computes the entire table and returns it as a list of lists. However, note that although this is a generator, the type inference still requires that the inferred types of every individual value must all be able to fit into memory at once.</span>
-</span><span id="TypeParser.iterate_table-972"><a href="#TypeParser.iterate_table-972"><span class="linenos">972</span></a>
-</span><span id="TypeParser.iterate_table-973"><a href="#TypeParser.iterate_table-973"><span class="linenos">973</span></a><span class="sd">			Parameters</span>
-</span><span id="TypeParser.iterate_table-974"><a href="#TypeParser.iterate_table-974"><span class="linenos">974</span></a><span class="sd">			----------</span>
-</span><span id="TypeParser.iterate_table-975"><a href="#TypeParser.iterate_table-975"><span class="linenos">975</span></a><span class="sd">			`rows`</span>
-</span><span id="TypeParser.iterate_table-976"><a href="#TypeParser.iterate_table-976"><span class="linenos">976</span></a><span class="sd">			: table of strings to be parsed, in row-major order</span>
-</span><span id="TypeParser.iterate_table-977"><a href="#TypeParser.iterate_table-977"><span class="linenos">977</span></a>
-</span><span id="TypeParser.iterate_table-978"><a href="#TypeParser.iterate_table-978"><span class="linenos">978</span></a><span class="sd">			Yields</span>
-</span><span id="TypeParser.iterate_table-979"><a href="#TypeParser.iterate_table-979"><span class="linenos">979</span></a><span class="sd">			-------</span>
-</span><span id="TypeParser.iterate_table-980"><a href="#TypeParser.iterate_table-980"><span class="linenos">980</span></a><span class="sd">			each row of converted table values</span>
-</span><span id="TypeParser.iterate_table-981"><a href="#TypeParser.iterate_table-981"><span class="linenos">981</span></a>
-</span><span id="TypeParser.iterate_table-982"><a href="#TypeParser.iterate_table-982"><span class="linenos">982</span></a><span class="sd">			Examples</span>
-</span><span id="TypeParser.iterate_table-983"><a href="#TypeParser.iterate_table-983"><span class="linenos">983</span></a><span class="sd">			--------</span>
-</span><span id="TypeParser.iterate_table-984"><a href="#TypeParser.iterate_table-984"><span class="linenos">984</span></a><span class="sd">			```python</span>
-</span><span id="TypeParser.iterate_table-985"><a href="#TypeParser.iterate_table-985"><span class="linenos">985</span></a><span class="sd">			parser = TypeParser()</span>
-</span><span id="TypeParser.iterate_table-986"><a href="#TypeParser.iterate_table-986"><span class="linenos">986</span></a><span class="sd">			table = parser.iterate_table([</span>
-</span><span id="TypeParser.iterate_table-987"><a href="#TypeParser.iterate_table-987"><span class="linenos">987</span></a><span class="sd">				[&quot;1&quot;,   &quot;true&quot;,  &quot;1&quot;],</span>
-</span><span id="TypeParser.iterate_table-988"><a href="#TypeParser.iterate_table-988"><span class="linenos">988</span></a><span class="sd">				[&quot;2&quot;,   &quot;false&quot;, &quot;2.3&quot;],</span>
-</span><span id="TypeParser.iterate_table-989"><a href="#TypeParser.iterate_table-989"><span class="linenos">989</span></a><span class="sd">				[&quot;3.4&quot;, &quot;2&quot;,     &quot;abc&quot;],</span>
-</span><span id="TypeParser.iterate_table-990"><a href="#TypeParser.iterate_table-990"><span class="linenos">990</span></a><span class="sd">			]):</span>
-</span><span id="TypeParser.iterate_table-991"><a href="#TypeParser.iterate_table-991"><span class="linenos">991</span></a><span class="sd">			assert next(table) == [1.,  1, &quot;1&quot;]</span>
-</span><span id="TypeParser.iterate_table-992"><a href="#TypeParser.iterate_table-992"><span class="linenos">992</span></a><span class="sd">			assert next(table) == [2.,  0, &quot;2.3&quot;]</span>
-</span><span id="TypeParser.iterate_table-993"><a href="#TypeParser.iterate_table-993"><span class="linenos">993</span></a><span class="sd">			assert next(table) == [3.4, 2, &quot;abc&quot;]</span>
-</span><span id="TypeParser.iterate_table-994"><a href="#TypeParser.iterate_table-994"><span class="linenos">994</span></a><span class="sd">			```</span>
-</span><span id="TypeParser.iterate_table-995"><a href="#TypeParser.iterate_table-995"><span class="linenos">995</span></a><span class="sd">		&quot;&quot;&quot;</span>
-</span><span id="TypeParser.iterate_table-996"><a href="#TypeParser.iterate_table-996"><span class="linenos">996</span></a>		<span class="n">inferred_types</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">infer_table</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>
-</span><span id="TypeParser.iterate_table-997"><a href="#TypeParser.iterate_table-997"><span class="linenos">997</span></a>
-</span><span id="TypeParser.iterate_table-998"><a href="#TypeParser.iterate_table-998"><span class="linenos">998</span></a>		<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">rows</span><span class="p">:</span>
-</span><span id="TypeParser.iterate_table-999"><a href="#TypeParser.iterate_table-999"><span class="linenos">999</span></a>			<span class="k">yield</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_convert</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">inferred</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span><span class="p">,</span> <span class="n">inferred</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">inferred_types</span><span class="p">)]</span>
+            <div class="pdoc-code codehilite"><pre><span></span><span id="TypeParser.iterate_table-964"><a href="#TypeParser.iterate_table-964"><span class="linenos">964</span></a>	<span class="k">def</span> <span class="nf">iterate_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rows</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">str</span><span class="p">]])</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">list</span><span class="p">[</span><span class="n">AnyValue</span><span class="p">]]:</span>
+</span><span id="TypeParser.iterate_table-965"><a href="#TypeParser.iterate_table-965"><span class="linenos">965</span></a><span class="w">		</span><span class="sd">&quot;&quot;&quot;</span>
+</span><span id="TypeParser.iterate_table-966"><a href="#TypeParser.iterate_table-966"><span class="linenos">966</span></a><span class="sd">			Parse a table of strings for the underlying common type of each column, then convert and yield each row</span>
+</span><span id="TypeParser.iterate_table-967"><a href="#TypeParser.iterate_table-967"><span class="linenos">967</span></a>
+</span><span id="TypeParser.iterate_table-968"><a href="#TypeParser.iterate_table-968"><span class="linenos">968</span></a><span class="sd">			For each column, if the values do not have the same apparent type, the common type is taken as the narrowest possible type that will encompass all values in the column. See `parsetypes.reduce_types()` for more information.</span>
+</span><span id="TypeParser.iterate_table-969"><a href="#TypeParser.iterate_table-969"><span class="linenos">969</span></a>
+</span><span id="TypeParser.iterate_table-970"><a href="#TypeParser.iterate_table-970"><span class="linenos">970</span></a><span class="sd">			This is a generator that computes and yields each row one at a time. The function `parse_table()` behaves analogously, except that it computes the entire table and returns it as a list of lists. However, note that although this is a generator, the type inference still requires that the inferred types of every individual value must all be able to fit into memory at once.</span>
+</span><span id="TypeParser.iterate_table-971"><a href="#TypeParser.iterate_table-971"><span class="linenos">971</span></a>
+</span><span id="TypeParser.iterate_table-972"><a href="#TypeParser.iterate_table-972"><span class="linenos">972</span></a><span class="sd">			Parameters</span>
+</span><span id="TypeParser.iterate_table-973"><a href="#TypeParser.iterate_table-973"><span class="linenos">973</span></a><span class="sd">			----------</span>
+</span><span id="TypeParser.iterate_table-974"><a href="#TypeParser.iterate_table-974"><span class="linenos">974</span></a><span class="sd">			`rows`</span>
+</span><span id="TypeParser.iterate_table-975"><a href="#TypeParser.iterate_table-975"><span class="linenos">975</span></a><span class="sd">			: table of strings to be parsed, in row-major order</span>
+</span><span id="TypeParser.iterate_table-976"><a href="#TypeParser.iterate_table-976"><span class="linenos">976</span></a>
+</span><span id="TypeParser.iterate_table-977"><a href="#TypeParser.iterate_table-977"><span class="linenos">977</span></a><span class="sd">			Yields</span>
+</span><span id="TypeParser.iterate_table-978"><a href="#TypeParser.iterate_table-978"><span class="linenos">978</span></a><span class="sd">			-------</span>
+</span><span id="TypeParser.iterate_table-979"><a href="#TypeParser.iterate_table-979"><span class="linenos">979</span></a><span class="sd">			each row of converted table values</span>
+</span><span id="TypeParser.iterate_table-980"><a href="#TypeParser.iterate_table-980"><span class="linenos">980</span></a>
+</span><span id="TypeParser.iterate_table-981"><a href="#TypeParser.iterate_table-981"><span class="linenos">981</span></a><span class="sd">			Examples</span>
+</span><span id="TypeParser.iterate_table-982"><a href="#TypeParser.iterate_table-982"><span class="linenos">982</span></a><span class="sd">			--------</span>
+</span><span id="TypeParser.iterate_table-983"><a href="#TypeParser.iterate_table-983"><span class="linenos">983</span></a><span class="sd">			```python</span>
+</span><span id="TypeParser.iterate_table-984"><a href="#TypeParser.iterate_table-984"><span class="linenos">984</span></a><span class="sd">			parser = TypeParser()</span>
+</span><span id="TypeParser.iterate_table-985"><a href="#TypeParser.iterate_table-985"><span class="linenos">985</span></a><span class="sd">			table = parser.iterate_table([</span>
+</span><span id="TypeParser.iterate_table-986"><a href="#TypeParser.iterate_table-986"><span class="linenos">986</span></a><span class="sd">				[&quot;1&quot;,   &quot;true&quot;,  &quot;1&quot;],</span>
+</span><span id="TypeParser.iterate_table-987"><a href="#TypeParser.iterate_table-987"><span class="linenos">987</span></a><span class="sd">				[&quot;2&quot;,   &quot;false&quot;, &quot;2.3&quot;],</span>
+</span><span id="TypeParser.iterate_table-988"><a href="#TypeParser.iterate_table-988"><span class="linenos">988</span></a><span class="sd">				[&quot;3.4&quot;, &quot;2&quot;,     &quot;abc&quot;],</span>
+</span><span id="TypeParser.iterate_table-989"><a href="#TypeParser.iterate_table-989"><span class="linenos">989</span></a><span class="sd">			]):</span>
+</span><span id="TypeParser.iterate_table-990"><a href="#TypeParser.iterate_table-990"><span class="linenos">990</span></a><span class="sd">			assert next(table) == [1.,  1, &quot;1&quot;]</span>
+</span><span id="TypeParser.iterate_table-991"><a href="#TypeParser.iterate_table-991"><span class="linenos">991</span></a><span class="sd">			assert next(table) == [2.,  0, &quot;2.3&quot;]</span>
+</span><span id="TypeParser.iterate_table-992"><a href="#TypeParser.iterate_table-992"><span class="linenos">992</span></a><span class="sd">			assert next(table) == [3.4, 2, &quot;abc&quot;]</span>
+</span><span id="TypeParser.iterate_table-993"><a href="#TypeParser.iterate_table-993"><span class="linenos">993</span></a><span class="sd">			```</span>
+</span><span id="TypeParser.iterate_table-994"><a href="#TypeParser.iterate_table-994"><span class="linenos">994</span></a><span class="sd">		&quot;&quot;&quot;</span>
+</span><span id="TypeParser.iterate_table-995"><a href="#TypeParser.iterate_table-995"><span class="linenos">995</span></a>		<span class="n">inferred_types</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">infer_table</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>
+</span><span id="TypeParser.iterate_table-996"><a href="#TypeParser.iterate_table-996"><span class="linenos">996</span></a>
+</span><span id="TypeParser.iterate_table-997"><a href="#TypeParser.iterate_table-997"><span class="linenos">997</span></a>		<span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">rows</span><span class="p">:</span>
+</span><span id="TypeParser.iterate_table-998"><a href="#TypeParser.iterate_table-998"><span class="linenos">998</span></a>			<span class="k">yield</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_convert</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">inferred</span><span class="p">)</span> <span class="k">for</span> <span class="n">value</span><span class="p">,</span> <span class="n">inferred</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">inferred_types</span><span class="p">)]</span>
 </span></pre></div>
 
 
     <div class="docstring">
 <p>Parse a table of strings for the underlying common type of each column, then convert and yield each row</p>
 
 <p>For each column, if the values do not have the same apparent type, the common type is taken as the narrowest possible type that will encompass all values in the column. See <code><a href="#reduce_types">parsetypes.reduce_types()</a></code> for more information.</p>
@@ -2872,15 +2872,15 @@
                             </div>
                 </section>
                 <section id="reduce_types">
                             <input id="reduce_types-view-source" class="view-source-toggle-state" type="checkbox" aria-hidden="true" tabindex="-1">
 <div class="attr function">
             
         <span class="def">def</span>
-        <span class="name">reduce_types</span><span class="signature pdoc-code multiline">(<span class="param">	<span class="n">types</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Type</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">NoneType</span><span class="p">,</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="n">NoneType</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="kc">None</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="nb">list</span><span class="p">[</span><span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="nb">list</span><span class="p">[</span><span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">float</span><span class="p">]],</span> <span class="nb">list</span><span class="p">[</span><span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">]],</span> <span class="nb">list</span><span class="p">[</span><span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">bool</span><span class="p">]],</span> <span class="nb">list</span><span class="p">[</span><span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="n">NoneType</span><span class="p">]]]]]</span></span><span class="return-annotation">) -> <span class="n">Type</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">NoneType</span><span class="p">,</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="n">NoneType</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="kc">None</span><span class="p">],</span> <span class="nb">list</span><span class="p">[</span><span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="nb">list</span><span class="p">[</span><span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">int</span><span class="p">]],</span> <span class="nb">list</span><span class="p">[</span><span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">float</span><span class="p">]],</span> <span class="nb">list</span><span class="p">[</span><span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">]],</span> <span class="nb">list</span><span class="p">[</span><span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">bool</span><span class="p">]],</span> <span class="nb">list</span><span class="p">[</span><span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="n">NoneType</span><span class="p">]]]]</span>:</span></span>
+        <span class="name">reduce_types</span><span class="signature pdoc-code multiline">(<span class="param">	<span class="n">types</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Type</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">NoneType</span><span class="p">,</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="n">NoneType</span><span class="p">]]]]</span></span><span class="return-annotation">) -> <span class="n">Type</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">,</span> <span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">NoneType</span><span class="p">,</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">int</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="n">decimal</span><span class="o">.</span><span class="n">Decimal</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">parsetypes</span><span class="o">.</span><span class="n">_common</span><span class="o">.</span><span class="n">Nullable</span><span class="p">[</span><span class="n">NoneType</span><span class="p">]]]</span>:</span></span>
 
 
                 <label class="view-source-button" for="reduce_types-view-source"><span>View Source</span></label>
 
     </div>
     <a class="headerlink" href="#reduce_types"></a>
             <div class="pdoc-code codehilite"><pre><span></span><span id="reduce_types-157"><a href="#reduce_types-157"><span class="linenos">157</span></a><span class="k">def</span> <span class="nf">reduce_types</span><span class="p">(</span><span class="n">types</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">AnyValueType</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">AnyValueType</span><span class="p">:</span>
@@ -2904,15 +2904,15 @@
 </span><span id="reduce_types-175"><a href="#reduce_types-175"><span class="linenos">175</span></a><span class="sd">		--------</span>
 </span><span id="reduce_types-176"><a href="#reduce_types-176"><span class="linenos">176</span></a><span class="sd">		```python</span>
 </span><span id="reduce_types-177"><a href="#reduce_types-177"><span class="linenos">177</span></a><span class="sd">		reduce_types([int, float])        # float</span>
 </span><span id="reduce_types-178"><a href="#reduce_types-178"><span class="linenos">178</span></a><span class="sd">		reduce_types([bool, int])         # int</span>
 </span><span id="reduce_types-179"><a href="#reduce_types-179"><span class="linenos">179</span></a><span class="sd">		reduce_types([int, float, str])   # str</span>
 </span><span id="reduce_types-180"><a href="#reduce_types-180"><span class="linenos">180</span></a><span class="sd">		```</span>
 </span><span id="reduce_types-181"><a href="#reduce_types-181"><span class="linenos">181</span></a><span class="sd">	&quot;&quot;&quot;</span>
-</span><span id="reduce_types-182"><a href="#reduce_types-182"><span class="linenos">182</span></a>	<span class="n">reduced_type</span><span class="p">:</span> <span class="n">AnyValueType</span> <span class="o">|</span> <span class="kc">None</span> <span class="o">=</span> <span class="kc">None</span>
+</span><span id="reduce_types-182"><a href="#reduce_types-182"><span class="linenos">182</span></a>	<span class="n">reduced_type</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">AnyValueType</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
 </span><span id="reduce_types-183"><a href="#reduce_types-183"><span class="linenos">183</span></a>	<span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">types</span><span class="p">:</span>
 </span><span id="reduce_types-184"><a href="#reduce_types-184"><span class="linenos">184</span></a>		<span class="k">if</span> <span class="n">reduced_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
 </span><span id="reduce_types-185"><a href="#reduce_types-185"><span class="linenos">185</span></a>			<span class="n">reduced_type</span> <span class="o">=</span> <span class="n">t</span>
 </span><span id="reduce_types-186"><a href="#reduce_types-186"><span class="linenos">186</span></a>		<span class="k">elif</span> <span class="n">t</span> <span class="o">!=</span> <span class="n">reduced_type</span><span class="p">:</span>
 </span><span id="reduce_types-187"><a href="#reduce_types-187"><span class="linenos">187</span></a>			<span class="n">reduced_type</span> <span class="o">=</span> <span class="n">_merge_types</span><span class="p">(</span><span class="n">reduced_type</span><span class="p">,</span> <span class="n">t</span><span class="p">)</span>
 </span><span id="reduce_types-188"><a href="#reduce_types-188"><span class="linenos">188</span></a>		<span class="k">if</span> <span class="n">reduced_type</span> <span class="o">==</span> <span class="n">_TerminalValue</span><span class="p">:</span>
 </span><span id="reduce_types-189"><a href="#reduce_types-189"><span class="linenos">189</span></a>			<span class="k">return</span> <span class="n">_TerminalValue</span>
```

#### html2text {}

```diff
@@ -46,2184 +46,2184 @@
 _6
 - give exact Decimal values instead of floats
 _7
 - detect inline lists
 _8"""
 _9
 10
-11__version__ = "0.1.1"
+11__version__ = "0.2"
 12
 13from ._common import AnyScalar, AnyScalarType, AnyValue, AnyValueType,
 GenericValue, Nullable
 14from ._parser import TypeParser
 15from ._reduce_types import reduce_types
 16
 17__all__ = ('TypeParser', 'reduce_types')
   ⁰
 class TypeParser: View Source
-_61class TypeParser:
-_62
+_60class TypeParser:
+_61
 """
-_63
+_62
 A parser that can be used to infer the underlying types of data serialised as
 strings, and to convert them into their original underlying types.
+_63
 _64
-_65
 Instances of this class can be configured with different settings for the
 parser and inferrer. See the constructor for more details about the available
 options.
-_66
+_65
 """
+_66
 _67
-_68
 def __init__(self,
-_69
+_68
     *,
-_70
+_69
 trim: bool=True,
-_71
+_70
 use_decimal: bool=False,
+_71
+list_delimiter: Optional[str]=None,
 _72
-list_delimiter: str | None=None,
-_73
 none_values: Iterable[str]=[""],
-_74
+_73
 none_case_sensitive: bool=False,
-_75
+_74
 true_values: Iterable[str]=["true"],
-_76
+_75
 false_values: Iterable[str]=["false"],
-_77
+_76
 bool_case_sensitive: bool=False,
-_78
+_77
 int_case_sensitive: bool=False,
-_79
+_78
 inf_values: Iterable[str]=[],
-_80
+_79
 nan_values: Iterable[str]=[],
-_81
+_80
 float_case_sensitive: bool=False,
+_81
+case_sensitive: Optional[bool]=None,
 _82
-case_sensitive: bool | None=None,
-_83
 ):
-_84
+_83
 """
-_85
+_84
 Initialise a new parser
+_85
 _86
-_87
 Parameters
-_88
+_87
 ----------
-_89
+_88
 `trim`
-_90
+_89
 : whether leading and trailing whitespace should be stripped from strings
+_90
 _91
-_92
 `use_decimal`
-_93
+_92
 : whether non-integer numeric values should be inferred as Decimal (exact
 values) instead of float (non-exact values). Note that this only applies to
 methods that attempt to infer type (`infer()` and `infer_*()`), and does not
 affect methods where the type is explicitly specified (`is_float()`,
 `is_decimal()`, `parse_float()`, `parse_decimal()`).
+_93
 _94
-_95
 `list_delimiter`
-_96
+_95
 : the delimiter used for identifying lists and for separating list items. If
 set to None, the parser will not attempt to identify lists when inferring
 types, which usually causes the value to be treated as a str instead.
+_96
 _97
-_98
 `none_values`
-_99
+_98
 : list of strings that represent the value None
+_99
 100
-101
 `none_case_sensitive`
-102
+101
 : whether matches against `none_values` should be made in a case-sensitive
 manner
+102
 103
-104
 `true_values`
-105
+104
 : list of strings that represent the bool value True
+105
 106
-107
 `false_values`
-108
+107
 : list of strings that represent the bool value False
+108
 109
-110
 `bool_case_sensitive`
-111
+110
 : whether matches against `true_values` and `false_values` should be made in a
 case-sensitive manner
+111
 112
-113
 `int_case_sensitive`
-114
+113
 : whether checks for int should be done in a case-sensitive manner. This
 usually only applies to values given in scientific notation, where the mantissa
 and exponent usually are separated by `e`.
+114
 115
-116
 `inf_values`
-117
+116
 : list of strings that represent the float or Decimal value of infinity. Each
 of the strings can be prepended with a negative sign to represent negative
 infinity also.
+117
 118
-119
 `nan_values`
-120
+119
 : list of strings that represent a float or Decimal that is NaN (not a number)
+120
 121
-122
 `float_case_sensitive`
-123
+122
 : whether checks for float should be done in a case-sensitive manner. This
 applies to matches against `inf_values` and `nan_values`, as well as to values
 given in scientific notation, where the mantissa and exponent are usually
 separated by `e`.
+123
 124
-125
 `case_sensitive`
-126
+125
 : whether all matches should be made in a case-sensitive manner. Sets all of
 `none_case_sensitive`, `bool_case_sensitive`, `int_case_sensitive`,
 `float_case_sensitive` to the same value, ignoring any individual settings.
+126
 127
-128
 Raises
-129
+128
 ------
-130
+129
 `ValueError` if any of the options would lead to ambiguities during parsing
-131
+130
 """
+131
 132
-133
 if case_sensitive is not None:
-134
+133
 none_case_sensitive = case_sensitive
-135
+134
 int_case_sensitive = case_sensitive
-136
+135
 bool_case_sensitive = case_sensitive
-137
+136
 float_case_sensitive = case_sensitive
+137
 138
-139
 self.trim = trim
-140
+139
 if self.trim:
-141
+140
 none_values = (value.strip() for value in none_values)
-142
+141
 true_values = (value.strip() for value in true_values)
-143
+142
 false_values = (value.strip() for value in false_values)
-144
+143
 inf_values = (value.strip() for value in inf_values)
-145
+144
 nan_values = (value.strip() for value in nan_values)
+145
 146
-147
 self.use_decimal = use_decimal
-148
+147
 self.list_delimiter = list_delimiter
+148
 149
-150
 self.none_case_sensitive = none_case_sensitive
-151
+150
 if not self.none_case_sensitive:
-152
+151
 none_values = (value.lower() for value in none_values)
-153
+152
 self.none_values = set(none_values)
+153
 154
-155
 self.bool_case_sensitive = bool_case_sensitive
-156
+155
 if not self.bool_case_sensitive:
-157
+156
 true_values = (value.lower() for value in true_values)
-158
+157
 false_values = (value.lower() for value in false_values)
-159
+158
 self.true_values = set(true_values)
-160
+159
 self.false_values = set(false_values)
+160
 161
-162
 self.int_case_sensitive = int_case_sensitive
+162
 163
-164
 self.float_case_sensitive = float_case_sensitive
-165
+164
 if not self.float_case_sensitive:
-166
+165
 inf_values = (value.lower() for value in inf_values)
-167
+166
 nan_values = (value.lower() for value in nan_values)
-168
+167
 self.inf_values = set(inf_values)
-169
+168
 self.nan_values = set(nan_values)
+169
 170
-171
 # Unconfigurable default values
-172
+171
 self._negative_char = "-"
-173
+172
 self._negative_chars = {self._negative_char, "â"}
-174
+173
 self._sign_chars = self._negative_chars | {"+"}
-175
+174
 self._digit_chars = {"0", "1", "2", "3", "4", "5", "6", "7", "8", "9"}  #
 Because isdigit("Â²") == True, but int("Â²") is invalid
-176
+175
 self._digit_separators = {"_"}
-177
+176
 self._scientific_char = "e"
-178
+177
 self._float_separator = "."
-179
+178
 self._reserved_chars = self._sign_chars | self._digit_chars |
 self._digit_separators | {self._scientific_char} | {self._float_separator}
-180
+179
 # special_chars = self._reserved_chars | self.list_delimiter
+180
 181
-182
 # Check if any special values conflict
-183
+182
 for name, special_values in [
-184
+183
 (_SpecialValue.LIST, [self.list_delimiter] if self.list_delimiter is not None
 else []),
-185
+184
 (_SpecialValue.NONE, self.none_values),
-186
+185
 (_SpecialValue.TRUE, self.true_values),
-187
+186
 (_SpecialValue.FALSE, self.false_values),
-188
+187
 (_SpecialValue.INF, self.inf_values),
-189
+188
 (_SpecialValue.NAN, self.nan_values),
-190
+189
 ]:
-191
+190
 for special_value in special_values:
-192
+191
 if special_value in self._reserved_chars:
-193
+192
 raise ValueError(f"cannot use reserved char as {name.value}: {special_value}")
+193
 194
-195
 if name != _SpecialValue.NONE and self.is_none(special_value):
-196
+195
 raise ValueError(f"cannot use None value as {name.value}: {special_value}")
+196
 197
-198
 if (
-199
+198
 (name == _SpecialValue.TRUE and self.parse_bool(special_value) != True) or
-200
+199
 (name == _SpecialValue.FALSE and self.parse_bool(special_value) != False) or
-201
+200
 (name != _SpecialValue.TRUE and name != _SpecialValue.FALSE and self.is_bool
 (special_value))
-202
+201
 ):
-203
+202
 raise ValueError(f"cannot use bool value as {name.value}: {special_value}")
+203
 204
-205
 if self.is_int(special_value):
-206
+205
 raise ValueError(f"cannot use int value as {name.value}: {special_value}")
+206
 207
-208
 if self.use_decimal:
-209
+208
 if (
-210
+209
 (name == _SpecialValue.INF and self.parse_decimal(special_value) != Decimal
 (math.inf)) or
-211
+210
 (name == _SpecialValue.NAN and not self.parse_decimal(special_value).is_nan())
 or
-212
+211
 (name != _SpecialValue.INF and name != _SpecialValue.NAN and self.is_float
 (special_value))
-213
+212
 ):
-214
+213
 raise ValueError(f"cannot use Decimal value as {name}: {special_value}")
-215
+214
 else:
-216
+215
 if (
-217
+216
 (name == _SpecialValue.INF and self.parse_float(special_value) != math.inf) or
-218
+217
 (name == _SpecialValue.NAN and self.parse_float(special_value) is not math.nan)
 or
-219
+218
 (name != _SpecialValue.INF and name != _SpecialValue.NAN and self.is_float
 (special_value))
-220
+219
 ):
-221
+220
 raise ValueError(f"cannot use float value as {name}: {special_value}")
+221
 222
 223
-224
 def is_none(self, value: str) -> bool:
-225
+224
 """
-226
+225
 Check if a string represents the value None
+226
 227
-228
 Only strings that match the values in `self.none_values` will be interpreted as
 None. The default accepted values are `[""]`, i.e. an empty string. The case
 sensitivity of this matching depends on `self.none_case_sensitive`, which is
 False by default.
+228
 229
-230
 Parameters
-231
+230
 ----------
-232
+231
 `value`
-233
+232
 : string to be checked
+233
 234
-235
 Returns
-236
+235
 -------
-237
+236
 whether it is None
+237
 238
-239
 Examples
-240
+239
 --------
-241
+240
 ```python
-242
+241
 parser = TypeParser()
-243
+242
 parser.parse_bool("")     # True
-244
+243
 parser.parse_bool("abc")  # False
-245
+244
 ```
-246
+245
 """
-247
+246
 if self.trim:
-248
+247
 value = value.strip()
-249
+248
 if not self.bool_case_sensitive:
-250
+249
 value = value.lower()
+250
 251
-252
 if value in self.none_values:
-253
+252
 return True
-254
+253
 else:
-255
+254
 return False
+255
 256
 257
-258
 def is_bool(self, value: str) -> bool:
-259
+258
 """
-260
+259
 Check if a string represents a bool
+260
 261
-262
 Only strings that match the values in `self.true_values` and
 `self.false_values` will be interpreted as booleans. The default accepted
 values are `["true"]` and `["false"]` respectively. The case sensitivity of
 this matching depends on `self.bool_case_sensitive`, which is False by default.
+262
 263
-264
 Parameters
-265
+264
 ----------
-266
+265
 `value`
-267
+266
 : string to be checked
+267
 268
-269
 Returns
-270
+269
 -------
-271
+270
 whether it is a bool
+271
 272
-273
 Examples
-274
+273
 --------
-275
+274
 ```python
-276
+275
 parser = TypeParser()
-277
+276
 parser.is_bool("true")  # True
-278
+277
 parser.is_bool("")      # True
-279
+278
 parser.is_bool("abc")   # False
-280
+279
 ```
-281
+280
 """
-282
+281
 if self.trim:
-283
+282
 value = value.strip()
+283
 284
-285
 if not self.bool_case_sensitive:
-286
+285
 value = value.lower()
-287
+286
 if value in self.true_values:
-288
+287
 return True
-289
+288
 if value in self.false_values:
-290
+289
 return True
+290
 291
-292
 return False
+292
 293
 294
-295
 def is_int(self, value: str, *, allow_sign: bool=True, allow_negative:
 bool=True, allow_scientific: bool=True) -> bool:
-296
+295
 """
-297
+296
 Check if a string represents an int
+297
 298
-299
 Parameters
-300
+299
 ----------
-301
+300
 `value`
-302
+301
 : string to be checked
+302
 303
-304
 `allow_negative`
-305
+304
 : whether to accept negative values
+305
 306
-307
 `allow_sign`
-308
+307
 : whether to accept signed values. If False, it implies that `allow_negative`
 is False also.
+308
 309
-310
 `allow_scientific`
-311
+310
 : whether to accept scientific notation. If True, strings of the form
 `"<var>M</var>e<var>X</var>"` will be interpreted as the expression `<var>M</
 var> * (10 ** <var>X</var>)`, where <var>M</var> is the mantissa/significand
 and <var>X</var> is the exponent. Note <var>M</var> *must* be an integer and
 <var>X</var> *must* be a non-negative integer, even in cases where the above
 expression evaluates mathematically to an integer.
+311
 312
-313
 Returns
-314
+313
 -------
-315
+314
 whether it is an int
+315
 316
-317
 Examples
-318
+317
 --------
-319
+318
 ```python
-320
+319
 parser = TypeParser()
-321
+320
 parser.is_int("0")    # True
-322
+321
 parser.is_int("-1")   # True
-323
+322
 parser.is_int("abc")  # False
-324
+323
 parser.is_int("")     # False
-325
+324
 ```
-326
+325
 """
-327
+326
 if self.trim:
-328
+327
 value = value.strip()
+328
 329
-330
 if len(value) == 0:
-331
+330
 return False
+331
 332
-333
 if allow_scientific:
-334
+333
 value, exp = _decompose_string_pair(value, self._scientific_char,
 self.int_case_sensitive)
-335
+334
 if exp is not None:
-336
+335
 return self.is_int(
-337
+336
 value, allow_sign=True, allow_negative=allow_negative, allow_scientific=False
-338
+337
 ) and self.is_int(
-339
+338
 exp, allow_sign=True, allow_negative=False, allow_scientific=False
-340
+339
 )
+340
 341
-342
 if value[0] in self._sign_chars:
-343
+342
 if len(value) == 1:
-344
+343
 return False
-345
+344
 if not allow_sign:
-346
+345
 return False
-347
+346
 if not allow_negative and value[0] in self._negative_chars:
-348
+347
 return False
-349
+348
 value = value[1:]
-350
+349
 if value[0] in self._digit_separators or value[-1] in self._digit_separators:
-351
+350
 return False
+351
 352
-353
 prev_separated = False
-354
+353
 for c in value:
-355
+354
 if c in self._digit_separators:
-356
+355
 if prev_separated:
-357
+356
 return False
-358
+357
 prev_separated = True
-359
+358
 else:
-360
+359
 prev_separated = False
-361
+360
 if c not in self._digit_chars:
-362
+361
 return False
-363
+362
 return True
+363
 364
 365
-366
 def is_float(self, value: str, *, allow_scientific: bool=True, allow_inf:
 bool=True, allow_nan: bool=True) -> bool:
-367
+366
 """
-368
+367
 Check if a string represents a float (or equivalently, a Decimal)
+368
 369
-370
 This function will also return True if the string represents an int.
+370
 371
-372
 Alias: `is_decimal()`
+372
 373
-374
 Parameters
-375
+374
 ----------
-376
+375
 `value`
-377
+376
 : string to be checked
+377
 378
-379
 `allow_scientific`
-380
+379
 : whether to accept scientific notation. If True, strings of the form
 `"<var>M</var>e<var>X</var>"` will be interpreted as the expression `<var>M</
 var> * (10 ** <var>X</var>)`, where <var>M</var> is the mantissa/significand
 and <var>X</var> is the exponent. Note that <var>X</var> must be an integer,
 but can be negative.
+380
 381
-382
 `allow_inf`
-383
+382
 : whether to accept positive and negative infinity values. If True, strings
 that match the values in `self.inf_values` (empty by default) are interpreted
 as infinity, or as negative infinity if prepended by a negative sign. The case
 sensitivity of this matching depends on `self.float_case_sensitive`, which is
 False by default.
+383
 384
-385
 `allow_nan`
-386
+385
 : whether to accept NaN (not a number) representations. If True, strings that
 match the values in `self.nan_values` (empty by default) are interpeted as NaN.
 The case sensitivity of this matching depends on `self.float_case_sensitive`,
 which is False by default.
+386
 387
-388
 Returns
-389
+388
 -------
-390
+389
 whether it is a float or Decimal
+390
 391
-392
 Examples
-393
+392
 --------
-394
+393
 ```python
-395
+394
 parser = TypeParser()
-396
+395
 parser.is_float("1.")       # True
-397
+396
 parser.is_float("12.3e-2")  # True
-398
+397
 parser.is_float("abc")      # False
-399
+398
 parser.is_float("")         # False
-400
+399
 ```
-401
+400
 """
-402
+401
 if self.trim:
-403
+402
 value = value.strip()
+403
 404
-405
 if len(value) > 0 and value[0] in self._sign_chars:
-406
+405
 value = value[1:]
+406
 407
-408
 if self.float_case_sensitive:
-409
+408
 special_value = value
-410
+409
 else:
-411
+410
 special_value = value.lower()
-412
+411
 if allow_inf and special_value in self.inf_values:
-413
+412
 return True
-414
+413
 if allow_nan and special_value in self.nan_values:
-415
+414
 return True
+415
 416
-417
 if len(value) == 0:
-418
+417
 return False
+418
 419
-420
 if allow_scientific:
-421
+420
 value, exp = _decompose_string_pair(value, self._scientific_char,
 self.float_case_sensitive)
-422
+421
 if exp is not None:
-423
+422
 return self.is_float(value, allow_scientific=False, allow_inf=False,
 allow_nan=False) and self.is_int(exp, allow_sign=True, allow_negative=True,
 allow_scientific=False)
+423
 424
-425
 value, frac = _decompose_string_pair(value, self._float_separator,
 self.float_case_sensitive)
-426
+425
 if frac is not None:
-427
+426
 if value == "" and frac == "":
-428
+427
 return False
-429
+428
 return (
-430
+429
 self.is_int(value, allow_sign=True, allow_negative=False,
 allow_scientific=False) or value == ""
-431
+430
 ) and (
-432
+431
 self.is_int(frac, allow_sign=False, allow_negative=False,
 allow_scientific=False) or frac == ""
-433
+432
 )
+433
 434
-435
 return self.is_int(value, allow_sign=True, allow_negative=True,
 allow_scientific=False)
+435
 436
 437
-438
 def is_decimal(self, value: str, *, allow_scientific: bool=True, allow_inf:
 bool=True, allow_nan: bool=True) -> bool:
-439
+438
 """
-440
+439
 Alias of `is_float()`
-441
+440
 """
-442
+441
 return self.is_float(value, allow_scientific=allow_scientific,
 allow_inf=allow_inf, allow_nan=allow_nan)
+442
 443
 444
-445
 def parse_none(self, value: str) -> None:
-446
+445
 """
-447
+446
 Parse a string and return it as the value None if possible
+447
 448
-449
 Only strings that match the values in `self.none_values` will be interpreted as
 None. The default accepted values are `[""]`, i.e. an empty string. The case
 sensitivity of this matching depends on `self.none_case_sensitive`, which is
 False by default.
+449
 450
-451
 Parameters
-452
+451
 ----------
-453
+452
 `value`
-454
+453
 : string to be parsed
+454
 455
-456
 Returns
-457
+456
 -------
-458
+457
 parsed None value
+458
 459
-460
 Raises
-461
+460
 ------
-462
+461
 `ValueError` if `value` cannot be parsed
+462
 463
-464
 Examples
-465
+464
 --------
-466
+465
 ```python
-467
+466
 parser = TypeParser()
-468
+467
 parser.parse_bool("")     # None
-469
+468
 parser.parse_bool("abc")  # raises ValueError
-470
+469
 ```
-471
+470
 """
-472
+471
 if self.is_none(value):
-473
+472
 return None
-474
+473
 else:
-475
+474
 raise ValueError(f"not a none value: {value}")
+475
 476
 477
-478
 def parse_bool(self, value: str) -> bool:
-479
+478
 """
-480
+479
 Parse a string and return it as a bool if possible
+480
 481
-482
 Only strings that match the values in `self.true_values` and
 `self.false_values` will be interpreted as booleans. The default accepted
 values are `["true"]` and `["false"]` respectively. The case sensitivity of
 this matching depends on `self.bool_case_sensitive`, which is False by default.
+482
 483
-484
 Parameters
-485
+484
 ----------
-486
+485
 `value`
-487
+486
 : string to be parsed
+487
 488
-489
 Returns
-490
+489
 -------
-491
+490
 parsed bool value
+491
 492
-493
 Raises
-494
+493
 ------
-495
+494
 `ValueError` if `value` cannot be parsed
+495
 496
-497
 Examples
-498
+497
 --------
-499
+498
 ```python
-500
+499
 parser = TypeParser()
-501
+500
 parser.parse_bool("true")   # True
-502
+501
 parser.parse_bool("FALSE")  # False
-503
+502
 ```
-504
+503
 """
-505
+504
 if self.trim:
-506
+505
 value = value.strip()
+506
 507
-508
 if self.bool_case_sensitive:
-509
+508
 special_value = value
-510
+509
 else:
-511
+510
 special_value = value.lower()
-512
+511
 if special_value in self.true_values:
-513
+512
 return True
-514
+513
 if special_value in self.false_values:
-515
+514
 return False
+515
 516
-517
 raise ValueError(f"not a boolean: {value}")
+517
 518
 519
-520
 def parse_int(self, value: str, *, allow_scientific: bool=True) -> int:
-521
+520
 """
-522
+521
 Parse a string and return it as an int if possible
+522
 523
-524
 If the string represents a bool, it will be converted to `1` for True and `0`
 for False.
+524
 525
-526
 Parameters
-527
+526
 ----------
-528
+527
 `value`
-529
+528
 : string to be parsed
+529
 530
-531
 `allow_scientific`
-532
+531
 : whether to accept scientific notation. If True, strings of the form
 `"<var>M</var>e<var>X</var>"` will be interpreted as the expression `<var>M</
 var> * (10 ** <var>X</var>)`, where <var>M</var> is the mantissa/significand
 and <var>X</var> is the exponent. Note <var>M</var> *must* be an integer and
 <var>X</var> *must* be a non-negative integer, even in cases where the above
 expression evaluates mathematically to an integer.
+532
 533
-534
 Returns
-535
+534
 -------
-536
+535
 parsed int value
+536
 537
-538
 Raises
-539
+538
 ------
-540
+539
 `ValueError` if `value` cannot be parsed
+540
 541
-542
 Examples
-543
+542
 --------
-544
+543
 ```python
-545
+544
 parser = TypeParser()
-546
+545
 parser.parse_int("0")    # 0
-547
+546
 parser.parse_int("-1")   # -1
-548
+547
 parser.parse_int("2e3")  # 2000
-549
+548
 ```
-550
+549
 """
-551
+550
 if self.trim:
-552
+551
 value = value.strip()
+552
 553
-554
 if self.is_int(value, allow_sign=True, allow_negative=True,
 allow_scientific=allow_scientific):
-555
+554
 if allow_scientific:
-556
+555
 value, exp = _decompose_string_pair(value, self._scientific_char,
 self.int_case_sensitive)
-557
+556
 if exp is not None:
-558
+557
 if value[0] in (self._negative_chars - {self._negative_char}):
-559
+558
 value = self._negative_char + value[1:]
-560
+559
 return int(value) * (10 ** int(exp))
+560
 561
-562
 if value[0] in (self._negative_chars - {self._negative_char}):
-563
+562
 value = self._negative_char + value[1:]
-564
+563
 return int(value)
+564
 565
-566
 elif self.is_bool(value):
-567
+566
 return int(self.parse_bool(value))
-568
+567
 else:
-569
+568
 raise ValueError(f"not an integer: {value}")
+569
 570
 571
-572
 def _parse_floatlike(self,
-573
+572
 value: str,
-574
+573
 converter: Callable[[Union[str, bool]], _FloatLike],
-575
+574
 inf_value: _FloatLike,
-576
+575
 nan_value: _FloatLike,
-577
+576
 *,
-578
+577
 allow_scientific: bool=True,
-579
+578
 allow_inf: bool=True,
-580
+579
 allow_nan: bool=True
-581
+580
 ) -> _FloatLike:
-582
+581
 if self.trim:
-583
+582
 value = value.strip()
-584
+583
 if self.is_float(value, allow_scientific=allow_scientific, allow_inf=allow_inf,
 allow_nan=allow_nan):
-585
+584
 if self.float_case_sensitive:
-586
+585
 special_value = value
-587
+586
 else:
-588
+587
 special_value = value.lower()
-589
+588
 if allow_inf and special_value in self.inf_values:
-590
+589
 return inf_value
-591
+590
 if allow_nan and special_value in self.nan_values:
-592
+591
 return nan_value
+592
 593
-594
 if len(value) > 0 and value[0] in self._sign_chars:
-595
+594
 positive_part = value[1:]
-596
+595
 if self.float_case_sensitive:
-597
+596
 special_value = positive_part
-598
+597
 else:
-599
+598
 special_value = positive_part.lower()
-600
+599
 if allow_inf and special_value in self.inf_values:
-601
+600
 if value[0] in self._negative_chars:
-602
+601
 return -1 * inf_value
-603
+602
 else:
-604
+603
 return inf_value
-605
+604
 if allow_nan and special_value in self.nan_values:
-606
+605
 return nan_value
+606
 607
-608
 if value[0] in self._negative_chars:
-609
+608
 value = self._negative_char + positive_part
-610
+609
 return converter(value)
-611
+610
 elif self.is_bool(value):
-612
+611
 return converter(self.parse_bool(value))
-613
+612
 else:
-614
+613
 raise ValueError(f"not a {_FloatLike.__name__}: {value}")
+614
 615
 616
-617
 def parse_float(self, value: str, *, allow_scientific: bool=True, allow_inf:
 bool=True, allow_nan: bool=True) -> float:
-618
+617
 """
-619
+618
 Parse a string and return it as a (non-exact) float if possible
+619
 620
-621
 If the string represents a bool, it will be converted to `1.` for True and `0.`
 for False. If the string represents an int, it will be converted to a float
 also.
+621
 622
-623
 Behaves analogously to `parse_decimal()`, except that that returns an exact
 Decimal instead.
+623
 624
-625
 Parameters
-626
+625
 ----------
-627
+626
 `value`
-628
+627
 : string to be parsed
+628
 629
-630
 `allow_scientific`
-631
+630
 : whether to accept scientific notation. If True, strings of the form
 `"<var>M</var>e<var>X</var>"` will be interpreted as the expression `<var>M</
 var> * (10 ** <var>X</var>)`, where <var>M</var> is the mantissa/significand
 and <var>X</var> is the exponent. Note that <var>X</var> must be an integer,
 but can be negative.
+631
 632
-633
 `allow_inf`
-634
+633
 : whether to accept positive and negative infinity values. If True, strings
 that match the values in `self.inf_values` (empty by default) are interpreted
 as infinity, or as negative infinity if prepended by a negative sign. The case
 sensitivity of this matching depends on `self.float_case_sensitive`, which is
 False by default.
+634
 635
-636
 `allow_nan`
-637
+636
 : whether to accept NaN (not a number) representations. If True, strings that
 match the values in `self.nan_values` (empty by default) are interpeted as NaN.
 The case sensitivity of this matching depends on `self.float_case_sensitive`,
 which is False by default.
+637
 638
-639
 Returns
-640
+639
 -------
-641
+640
 parsed float value
+641
 642
-643
 Raises
-644
+643
 ------
-645
+644
 `ValueError` if `value` cannot be parsed
+645
 646
-647
 Examples
-648
+647
 --------
-649
+648
 ```python
-650
+649
 parser = TypeParser(inf_values=["inf"], nan_values=["nan"])
-651
+650
 parser.parse_float("1.")       # 1.
-652
+651
 parser.parse_float("1.23e2")   # 123.
-653
+652
 parser.parse_float("1.23e-2")  # 0.0123
-654
+653
 parser.parse_float("inf")      # math.inf
-655
+654
 ```
-656
+655
 """
-657
+656
 return self._parse_floatlike(value, float, math.inf, math.nan,
-658
+657
 allow_scientific=allow_scientific,
-659
+658
 allow_inf=allow_inf,
-660
+659
 allow_nan=allow_nan,
-661
+660
 )
+661
 662
 663
-664
 def parse_decimal(self, value: str, *, allow_scientific: bool=True, allow_inf:
 bool=True, allow_nan: bool=True) -> Decimal:
-665
+664
 """
-666
+665
 Parse a string and return it as an exact Decimal if possible
+666
 667
-668
 If the string represents a bool, it will be converted to `Decimal(1)` for True
 and `Decimal(0)` for False. If the string represents an int, it will be
 converted to a Decimal also.
+668
 669
-670
 Behaves analogously to `parse_float()`, except that that returns a non-exact
 float instead.
+670
 671
-672
 Parameters
-673
+672
 ----------
-674
+673
 `value`
-675
+674
 : string to be parsed
+675
 676
-677
 `allow_scientific`
-678
+677
 : whether to accept scientific notation. If True, strings of the form
 `"<var>M</var>e<var>X</var>"` will be interpreted as the expression `<var>M</
 var> * (10 ** <var>X</var>)`, where <var>M</var> is the mantissa/significand
 and <var>X</var> is the exponent. Note that <var>X</var> must be an integer,
 but can be negative.
+678
 679
-680
 `allow_inf`
-681
+680
 : whether to accept positive and negative infinity values. If True, strings
 that match the values in `self.inf_values` (empty by default) are interpreted
 as infinity, or as negative infinity if prepended by a negative sign. The case
 sensitivity of this matching depends on `self.float_case_sensitive`, which is
 False by default.
+681
 682
-683
 `allow_nan`
-684
+683
 : whether to accept NaN (not a number) representations. If True, strings that
 match the values in `self.nan_values` (empty by default) are interpeted as NaN.
 The case sensitivity of this matching depends on `self.float_case_sensitive`,
 which is False by default.
+684
 685
-686
 Returns
-687
+686
 -------
-688
+687
 parsed Decimal value
+688
 689
-690
 Raises
-691
+690
 ------
-692
+691
 `ValueError` if `value` cannot be parsed
+692
 693
-694
 Examples
-695
+694
 --------
-696
+695
 ```python
-697
+696
 parser = TypeParser(inf_values=["inf"], nan_values=["nan"])
-698
+697
 parser.parse_decimal("1.")       # Decimal(1)
-699
+698
 parser.parse_decimal("1.23e2")   # Decimal(123)
-700
+699
 parser.parse_decimal("1.23e-2")  # Decimal(123) / Decimal(10000)
-701
+700
 parser.parse_decimal("inf")      # Decimal(math.inf)
-702
+701
 ```
-703
+702
 """
-704
+703
 return self._parse_floatlike(value, Decimal, Decimal(math.inf), Decimal
 (math.nan),
-705
+704
 allow_scientific=allow_scientific,
-706
+705
 allow_inf=allow_inf,
-707
+706
 allow_nan=allow_nan,
-708
+707
 )
+708
 709
 710
-711
 def infer(self, value: str) -> AnyValueType:
-712
+711
 """
-713
+712
 Infer the underlying type of a string
+713
 714
-715
 Also check for inline lists if `self.list_delimiter` is not None.
+715
 716
-717
 Parameters
-718
+717
 ----------
-719
+718
 `value`
-720
+719
 : the string for which the type should be inferred
+720
 721
-722
 Returns
-723
+722
 -------
-724
+723
 inferred type
+724
 725
-726
 Examples
-727
+726
 --------
-728
+727
 ```python
-729
+728
 parser = TypeParser()
-730
+729
 parser.infer("true")  # bool
-731
+730
 parser.infer("2.0")   # float
-732
+731
 parser.infer("abc")   # str
-733
+732
 ```
-734
+733
 """
-735
+734
 if self.is_none(value):
-736
+735
 return NoneType
-737
+736
 if self.is_bool(value):
-738
+737
 return bool
-739
+738
 if self.is_int(value):
-740
+739
 return int
-741
+740
 if self.is_float(value):
-742
+741
 if self.use_decimal:
-743
+742
 return Decimal
-744
+743
 else:
-745
+744
 return float
+745
 746
-747
 if self.trim:
-748
+747
 value = value.strip()
+748
 749
-750
 if self.list_delimiter is not None and self.list_delimiter in value:
-751
+750
 subvalues = value.split(self.list_delimiter)
-752
+751
 if self.trim:
-753
+752
 subvalues = [subvalue.strip() for subvalue in subvalues]
-754
+753
 reduced_type = reduce_types(self.infer(subvalue) for subvalue in subvalues)
-755
+754
 reduced_type = cast(AnyContainedType, reduced_type)
-756
+755
 r = list[reduced_type]
-757
+756
 return r  # type: ignore
+757
 758
-759
 return GenericValue
+759
 760
 761
-762
 def infer_series(self, values: Iterable[str]) -> AnyValueType:
-763
+762
 """
-764
+763
 Infer the underlying common type of a series of strings
+764
 765
-766
 If the values in the series do not have the same apparent type, the resulting
 type will be narrowest possible type that will encompass all values in the
 series. See `parsetypes.reduce_types()` for more information.
+766
 767
-768
 Parameters
-769
+768
 ----------
-770
+769
 `values`
-771
+770
 : series of strings for which the type should be inferred
+771
 772
-773
 Returns
-774
+773
 -------
-775
+774
 inferred type
+775
 776
-777
 Examples
-778
+777
 --------
-779
+778
 ```python
-780
+779
 parser = TypeParser()
-781
+780
 parser.infer_series(["1", "2", "3.4"])       # float
-782
+781
 parser.infer_series(["true", "false", "2"])  # int
-783
+782
 parser.infer_series(["1", "2.3", "abc"])     # str
-784
+783
 ```
-785
+784
 """
-786
+785
 return reduce_types(self.infer(value) for value in values)
+786
 787
 788
-789
 def infer_table(self, rows: Iterable[Sequence[str]]) -> list[AnyValueType]:
-790
+789
 """
-791
+790
 Infer the underlying common type for each column of a table of strings
+791
 792
-793
 For each column, if the values do not have the same apparent type, the
 resulting type will be narrowest possible type that will encompass all values
 in the column. See `parsetypes.reduce_types()` for more information.
+793
 794
-795
 Note that the inferred types of every individual value must all be able to fit
 into memory at once.
+795
 796
-797
 Parameters
-798
+797
 ----------
-799
+798
 `rows`
-800
+799
 : table of strings for which the types should be inferred, in row-major order
+800
 801
-802
 Returns
-803
+802
 -------
-804
+803
 inferred types
+804
 805
-806
 Examples
-807
+806
 --------
-808
+807
 ```python
-809
+808
 parser = TypeParser()
-810
+809
 parser.infer_table([
-811
+810
 ["1",   "true",  "1"],
-812
+811
 ["2",   "false", "2.3"],
-813
+812
 ["3.4", "2",     "abc"],
-814
+813
 ])
-815
+814
 # [float, int, str]
-816
+815
 ```
-817
+816
 """
-818
+817
 rows_iter = iter(rows)
-819
+818
 first_row = next(rows_iter, None)
-820
+819
 if first_row is None:
-821
+820
 return []
+821
 822
-823
 num_cols = len(first_row)
-824
+823
 if num_cols == 0:
-825
+824
 return []
+825
 826
-827
 table = _TypeTable([[self.infer(value)] for value in first_row])
-828
+827
 for row in rows_iter:
-829
+828
 table.add_row([self.infer(value) for value in row])
+829
 830
-831
 return [reduce_types(col) for col in table.cols]
+831
 832
 833
-834
 def _convert(self, value: str, t: AnyValueType) -> AnyValue:
-835
+834
 base, type_args = _decompose_type(t)
-836
+835
 if base == NoneType:
-837
+836
 return None
-838
+837
 elif base == bool:
-839
+838
 return self.parse_bool(value)
-840
+839
 elif base == int:
-841
+840
 return self.parse_int(value)
-842
+841
 elif base == Decimal:
-843
+842
 return self.parse_decimal(value)
-844
+843
 elif base == float:
-845
+844
 return self.parse_float(value)
-846
+845
 elif base == str:
-847
+846
 return value
-848
+847
 elif base == Nullable:
-849
+848
 if self.is_none(value):
-850
+849
 return None
-851
+850
 else:
-852
+851
 if type_args is not  None and len(type_args) == 1 and type_args[0] != str:
-853
+852
 inner_type = type_args[0]
-854
+853
 return self._convert(value, inner_type)
-855
+854
 else:
-856
+855
 return value
-857
+856
 elif base == list:
-858
+857
 subvalues = value.split(self.list_delimiter)
-859
+858
 if self.trim:
-860
+859
 subvalues = [subvalue.strip() for subvalue in subvalues]
-861
+860
 if type_args is not None and len(type_args) == 1 and type_args[0] != str:
-862
+861
 subtype = type_args[0]
-863
+862
 return cast(AnyContained, [self._convert(subvalue, subtype) for subvalue in
 subvalues])
-864
+863
 else:
-865
+864
 return subvalues
-866
+865
 else:
-867
+866
 return value
+867
 868
 869
-870
 def parse(self, value: str) -> AnyValue:
-871
+870
 """
-872
+871
 Parse a string and convert it to its underlying type
+872
 873
-874
 Parameters
-875
+874
 ----------
-876
+875
 `value`
-877
+876
 : the string to be parsed
+877
 878
-879
 Returns
-880
+879
 -------
-881
+880
 converted value
+881
 882
-883
 Examples
-884
+883
 --------
-885
+884
 ```python
-886
+885
 parser = TypeParser()
-887
+886
 parser.parse("true")  # True
-888
+887
 parser.parse("2.0")   # 2.
-889
+888
 parser.parse("abc")   # "abc"
-890
+889
 ```
-891
+890
 """
-892
+891
 return self._convert(value, self.infer(value))
+892
 893
 894
-895
 def parse_series(self, values: Iterable[str]) -> list[AnyValue]:
-896
+895
 """
-897
+896
 Parse a series of strings and convert them to their underlying common type
+897
 898
-899
 If the values in the series do not have the same apparent type, the common type
 is taken as the narrowest possible type that will encompass all values in the
 series. See `parsetypes.reduce_types()` for more information.
+899
 900
-901
 Parameters
-902
+901
 ----------
-903
+902
 `values`
-904
+903
 : series of strings to be parsed
+904
 905
-906
 Returns
-907
+906
 -------
-908
+907
 converted values
+908
 909
-910
 Examples
-911
+910
 --------
-912
+911
 ```python
-913
+912
 parser = TypeParser()
-914
+913
 parser.parse_series(["1", "2", "3"])        # [1, 2, 3]
-915
+914
 parser.parse_series(["5", "6.7", "8."])     # [5., 6.7, 8.]
-916
+915
 parser.parse_series(["true", "false", ""])  # [True, False, None]
-917
+916
 parser.parse_series(["1", "2.3", "abc"])    # ["1", "2.3", "abc"]
-918
+917
 ```
-919
+918
 """
-920
+919
 inferred = self.infer_series(values)
-921
+920
 return [self._convert(value, inferred) for value in values]
+921
 922
 923
-924
 def parse_table(self, rows: Iterable[Sequence[str]]) -> list[list[AnyValue]]:
-925
+924
 """
-926
+925
 Parse a table of strings and convert them to the underlying common type of each
 column
+926
 927
-928
 For each column, if the values do not have the same apparent type, the common
 type is taken as the narrowest possible type that will encompass all values in
 the column. See `parsetypes.reduce_types()` for more information.
+928
 929
-930
 Note that the type inference requires that the inferred types of every
 individual value must all be able to fit into memory at once.
+930
 931
-932
 This is a function that computes the entire table and returns it all at once.
 The generator `iterate_table()` behaves analogously, except that it computes
 and yields each row one at a time.
+932
 933
-934
 Parameters
-935
+934
 ----------
-936
+935
 `rows`
-937
+936
 : table of strings to be parsed, in row-major order
+937
 938
-939
 `iterator`
-940
+939
 : whether the parsed values should be yielded as an iterator. If False, which
 is the default, the entire table is computed and returned as a list of lists.
 If True, this function behaves as a generator, and the rows of the table are
 computed and yielded one at a time. However, note that even when set to True,
 the type inference requires that inferred type of each individual value must
 all be able to fit into memory at once.
+940
 941
-942
 Returns
-943
+942
 -------
-944
+943
 converted table of values, in row-major order
+944
 945
-946
 Examples
-947
+946
 --------
-948
+947
 ```python
-949
+948
 parser = TypeParser()
-950
+949
 table = parser.parse_table([
-951
+950
 ["1", "5",   "true",  "1"],
-952
+951
 ["2", "6.7", "false", "2.3"],
-953
+952
 ["3", "8.0", "",     "abc"],
-954
+953
 ]):
-955
+954
 assert table == [
-956
+955
 [1, 5.,  True,  "1"],
-957
+956
 [2, 6.7, False, "2.3"],
-958
+957
 [3, 8.,  None,  "abc"],
-959
+958
 ]
-960
+959
 ```
-961
+960
 """
-962
+961
 return [converted_row for converted_row in self.iterate_table(rows)]
+962
 963
 964
-965
 def iterate_table(self, rows: Iterable[Sequence[str]]) -> Iterator[list
 [AnyValue]]:
-966
+965
 """
-967
+966
 Parse a table of strings for the underlying common type of each column, then
 convert and yield each row
+967
 968
-969
 For each column, if the values do not have the same apparent type, the common
 type is taken as the narrowest possible type that will encompass all values in
 the column. See `parsetypes.reduce_types()` for more information.
+969
 970
-971
 This is a generator that computes and yields each row one at a time. The
 function `parse_table()` behaves analogously, except that it computes the
 entire table and returns it as a list of lists. However, note that although
 this is a generator, the type inference still requires that the inferred types
 of every individual value must all be able to fit into memory at once.
+971
 972
-973
 Parameters
-974
+973
 ----------
-975
+974
 `rows`
-976
+975
 : table of strings to be parsed, in row-major order
+976
 977
-978
 Yields
-979
+978
 -------
-980
+979
 each row of converted table values
+980
 981
-982
 Examples
-983
+982
 --------
-984
+983
 ```python
-985
+984
 parser = TypeParser()
-986
+985
 table = parser.iterate_table([
-987
+986
 ["1",   "true",  "1"],
-988
+987
 ["2",   "false", "2.3"],
-989
+988
 ["3.4", "2",     "abc"],
-990
+989
 ]):
-991
+990
 assert next(table) == [1.,  1, "1"]
-992
+991
 assert next(table) == [2.,  0, "2.3"]
-993
+992
 assert next(table) == [3.4, 2, "abc"]
-994
+993
 ```
-995
+994
 """
-996
+995
 inferred_types = self.infer_table(rows)
+996
 997
-998
 for row in rows:
-999
+998
 yield [self._convert(value, inferred) for value, inferred in zip(row,
 inferred_types)]
 A parser that can be used to infer the underlying types of data serialised as
 strings, and to convert them into their original underlying types.
 Instances of this class can be configured with different settings for the
 parser and inferrer. See the constructor for more details about the available
 options.
 ⁰
 TypeParser(
 *,
 trim: bool = True,
 use_decimal: bool = False,
-list_delimiter: str | None = None,
+list_delimiter: Optional[str] = None,
 none_values: Iterable[str] = [''],
 none_case_sensitive: bool = False,
 true_values: Iterable[str] = ['true'],
 false_values: Iterable[str] = ['false'],
 bool_case_sensitive: bool = False,
 int_case_sensitive: bool = False,
 inf_values: Iterable[str] = [],
 nan_values: Iterable[str] = [],
 float_case_sensitive: bool = False,
-case_sensitive: bool | None = None) View Source
-_68
+case_sensitive: Optional[bool] = None) View Source
+_67
 def __init__(self,
-_69
+_68
     *,
-_70
+_69
 trim: bool=True,
-_71
+_70
 use_decimal: bool=False,
+_71
+list_delimiter: Optional[str]=None,
 _72
-list_delimiter: str | None=None,
-_73
 none_values: Iterable[str]=[""],
-_74
+_73
 none_case_sensitive: bool=False,
-_75
+_74
 true_values: Iterable[str]=["true"],
-_76
+_75
 false_values: Iterable[str]=["false"],
-_77
+_76
 bool_case_sensitive: bool=False,
-_78
+_77
 int_case_sensitive: bool=False,
-_79
+_78
 inf_values: Iterable[str]=[],
-_80
+_79
 nan_values: Iterable[str]=[],
-_81
+_80
 float_case_sensitive: bool=False,
+_81
+case_sensitive: Optional[bool]=None,
 _82
-case_sensitive: bool | None=None,
-_83
 ):
-_84
+_83
 """
-_85
+_84
 Initialise a new parser
+_85
 _86
-_87
 Parameters
-_88
+_87
 ----------
-_89
+_88
 `trim`
-_90
+_89
 : whether leading and trailing whitespace should be stripped from strings
+_90
 _91
-_92
 `use_decimal`
-_93
+_92
 : whether non-integer numeric values should be inferred as Decimal (exact
 values) instead of float (non-exact values). Note that this only applies to
 methods that attempt to infer type (`infer()` and `infer_*()`), and does not
 affect methods where the type is explicitly specified (`is_float()`,
 `is_decimal()`, `parse_float()`, `parse_decimal()`).
+_93
 _94
-_95
 `list_delimiter`
-_96
+_95
 : the delimiter used for identifying lists and for separating list items. If
 set to None, the parser will not attempt to identify lists when inferring
 types, which usually causes the value to be treated as a str instead.
+_96
 _97
-_98
 `none_values`
-_99
+_98
 : list of strings that represent the value None
+_99
 100
-101
 `none_case_sensitive`
-102
+101
 : whether matches against `none_values` should be made in a case-sensitive
 manner
+102
 103
-104
 `true_values`
-105
+104
 : list of strings that represent the bool value True
+105
 106
-107
 `false_values`
-108
+107
 : list of strings that represent the bool value False
+108
 109
-110
 `bool_case_sensitive`
-111
+110
 : whether matches against `true_values` and `false_values` should be made in a
 case-sensitive manner
+111
 112
-113
 `int_case_sensitive`
-114
+113
 : whether checks for int should be done in a case-sensitive manner. This
 usually only applies to values given in scientific notation, where the mantissa
 and exponent usually are separated by `e`.
+114
 115
-116
 `inf_values`
-117
+116
 : list of strings that represent the float or Decimal value of infinity. Each
 of the strings can be prepended with a negative sign to represent negative
 infinity also.
+117
 118
-119
 `nan_values`
-120
+119
 : list of strings that represent a float or Decimal that is NaN (not a number)
+120
 121
-122
 `float_case_sensitive`
-123
+122
 : whether checks for float should be done in a case-sensitive manner. This
 applies to matches against `inf_values` and `nan_values`, as well as to values
 given in scientific notation, where the mantissa and exponent are usually
 separated by `e`.
+123
 124
-125
 `case_sensitive`
-126
+125
 : whether all matches should be made in a case-sensitive manner. Sets all of
 `none_case_sensitive`, `bool_case_sensitive`, `int_case_sensitive`,
 `float_case_sensitive` to the same value, ignoring any individual settings.
+126
 127
-128
 Raises
-129
+128
 ------
-130
+129
 `ValueError` if any of the options would lead to ambiguities during parsing
-131
+130
 """
+131
 132
-133
 if case_sensitive is not None:
-134
+133
 none_case_sensitive = case_sensitive
-135
+134
 int_case_sensitive = case_sensitive
-136
+135
 bool_case_sensitive = case_sensitive
-137
+136
 float_case_sensitive = case_sensitive
+137
 138
-139
 self.trim = trim
-140
+139
 if self.trim:
-141
+140
 none_values = (value.strip() for value in none_values)
-142
+141
 true_values = (value.strip() for value in true_values)
-143
+142
 false_values = (value.strip() for value in false_values)
-144
+143
 inf_values = (value.strip() for value in inf_values)
-145
+144
 nan_values = (value.strip() for value in nan_values)
+145
 146
-147
 self.use_decimal = use_decimal
-148
+147
 self.list_delimiter = list_delimiter
+148
 149
-150
 self.none_case_sensitive = none_case_sensitive
-151
+150
 if not self.none_case_sensitive:
-152
+151
 none_values = (value.lower() for value in none_values)
-153
+152
 self.none_values = set(none_values)
+153
 154
-155
 self.bool_case_sensitive = bool_case_sensitive
-156
+155
 if not self.bool_case_sensitive:
-157
+156
 true_values = (value.lower() for value in true_values)
-158
+157
 false_values = (value.lower() for value in false_values)
-159
+158
 self.true_values = set(true_values)
-160
+159
 self.false_values = set(false_values)
+160
 161
-162
 self.int_case_sensitive = int_case_sensitive
+162
 163
-164
 self.float_case_sensitive = float_case_sensitive
-165
+164
 if not self.float_case_sensitive:
-166
+165
 inf_values = (value.lower() for value in inf_values)
-167
+166
 nan_values = (value.lower() for value in nan_values)
-168
+167
 self.inf_values = set(inf_values)
-169
+168
 self.nan_values = set(nan_values)
+169
 170
-171
 # Unconfigurable default values
-172
+171
 self._negative_char = "-"
-173
+172
 self._negative_chars = {self._negative_char, "â"}
-174
+173
 self._sign_chars = self._negative_chars | {"+"}
-175
+174
 self._digit_chars = {"0", "1", "2", "3", "4", "5", "6", "7", "8", "9"}  #
 Because isdigit("Â²") == True, but int("Â²") is invalid
-176
+175
 self._digit_separators = {"_"}
-177
+176
 self._scientific_char = "e"
-178
+177
 self._float_separator = "."
-179
+178
 self._reserved_chars = self._sign_chars | self._digit_chars |
 self._digit_separators | {self._scientific_char} | {self._float_separator}
-180
+179
 # special_chars = self._reserved_chars | self.list_delimiter
+180
 181
-182
 # Check if any special values conflict
-183
+182
 for name, special_values in [
-184
+183
 (_SpecialValue.LIST, [self.list_delimiter] if self.list_delimiter is not None
 else []),
-185
+184
 (_SpecialValue.NONE, self.none_values),
-186
+185
 (_SpecialValue.TRUE, self.true_values),
-187
+186
 (_SpecialValue.FALSE, self.false_values),
-188
+187
 (_SpecialValue.INF, self.inf_values),
-189
+188
 (_SpecialValue.NAN, self.nan_values),
-190
+189
 ]:
-191
+190
 for special_value in special_values:
-192
+191
 if special_value in self._reserved_chars:
-193
+192
 raise ValueError(f"cannot use reserved char as {name.value}: {special_value}")
+193
 194
-195
 if name != _SpecialValue.NONE and self.is_none(special_value):
-196
+195
 raise ValueError(f"cannot use None value as {name.value}: {special_value}")
+196
 197
-198
 if (
-199
+198
 (name == _SpecialValue.TRUE and self.parse_bool(special_value) != True) or
-200
+199
 (name == _SpecialValue.FALSE and self.parse_bool(special_value) != False) or
-201
+200
 (name != _SpecialValue.TRUE and name != _SpecialValue.FALSE and self.is_bool
 (special_value))
-202
+201
 ):
-203
+202
 raise ValueError(f"cannot use bool value as {name.value}: {special_value}")
+203
 204
-205
 if self.is_int(special_value):
-206
+205
 raise ValueError(f"cannot use int value as {name.value}: {special_value}")
+206
 207
-208
 if self.use_decimal:
-209
+208
 if (
-210
+209
 (name == _SpecialValue.INF and self.parse_decimal(special_value) != Decimal
 (math.inf)) or
-211
+210
 (name == _SpecialValue.NAN and not self.parse_decimal(special_value).is_nan())
 or
-212
+211
 (name != _SpecialValue.INF and name != _SpecialValue.NAN and self.is_float
 (special_value))
-213
+212
 ):
-214
+213
 raise ValueError(f"cannot use Decimal value as {name}: {special_value}")
-215
+214
 else:
-216
+215
 if (
-217
+216
 (name == _SpecialValue.INF and self.parse_float(special_value) != math.inf) or
-218
+217
 (name == _SpecialValue.NAN and self.parse_float(special_value) is not math.nan)
 or
-219
+218
 (name != _SpecialValue.INF and name != _SpecialValue.NAN and self.is_float
 (special_value))
-220
+219
 ):
-221
+220
 raise ValueError(f"cannot use float value as {name}: {special_value}")
 Initialise a new parser
 ***** Parameters *****
 trim : whether leading and trailing whitespace should be stripped from strings
 use_decimal : whether non-integer numeric values should be inferred as Decimal
 (exact values) instead of float (non-exact values). Note that this only applies
 to methods that attempt to infer type (infer() and infer_*()), and does not
@@ -2254,75 +2254,75 @@
 case_sensitive : whether all matches should be made in a case-sensitive manner.
 Sets all of none_case_sensitive, bool_case_sensitive, int_case_sensitive,
 float_case_sensitive to the same value, ignoring any individual settings.
 ***** Raises *****
 ValueError if any of the options would lead to ambiguities during parsing
 ⁰
 def is_none(self, value: str) -> bool: View Source
-224
+223
 def is_none(self, value: str) -> bool:
-225
+224
 """
-226
+225
 Check if a string represents the value None
+226
 227
-228
 Only strings that match the values in `self.none_values` will be interpreted as
 None. The default accepted values are `[""]`, i.e. an empty string. The case
 sensitivity of this matching depends on `self.none_case_sensitive`, which is
 False by default.
+228
 229
-230
 Parameters
-231
+230
 ----------
-232
+231
 `value`
-233
+232
 : string to be checked
+233
 234
-235
 Returns
-236
+235
 -------
-237
+236
 whether it is None
+237
 238
-239
 Examples
-240
+239
 --------
-241
+240
 ```python
-242
+241
 parser = TypeParser()
-243
+242
 parser.parse_bool("")     # True
-244
+243
 parser.parse_bool("abc")  # False
-245
+244
 ```
-246
+245
 """
-247
+246
 if self.trim:
-248
+247
 value = value.strip()
-249
+248
 if not self.bool_case_sensitive:
-250
+249
 value = value.lower()
+250
 251
-252
 if value in self.none_values:
-253
+252
 return True
-254
+253
 else:
-255
+254
 return False
 Check if a string represents the value None
 Only strings that match the values in self.none_values will be interpreted as
 None. The default accepted values are [""], i.e. an empty string. The case
 sensitivity of this matching depends on self.none_case_sensitive, which is
 False by default.
 ***** Parameters *****
@@ -2331,80 +2331,80 @@
 whether it is None
 ***** Examples *****
 parser = TypeParser()
 parser.parse_bool("")     # True
 parser.parse_bool("abc")  # False
 ⁰
 def is_bool(self, value: str) -> bool: View Source
-258
+257
 def is_bool(self, value: str) -> bool:
-259
+258
 """
-260
+259
 Check if a string represents a bool
+260
 261
-262
 Only strings that match the values in `self.true_values` and
 `self.false_values` will be interpreted as booleans. The default accepted
 values are `["true"]` and `["false"]` respectively. The case sensitivity of
 this matching depends on `self.bool_case_sensitive`, which is False by default.
+262
 263
-264
 Parameters
-265
+264
 ----------
-266
+265
 `value`
-267
+266
 : string to be checked
+267
 268
-269
 Returns
-270
+269
 -------
-271
+270
 whether it is a bool
+271
 272
-273
 Examples
-274
+273
 --------
-275
+274
 ```python
-276
+275
 parser = TypeParser()
-277
+276
 parser.is_bool("true")  # True
-278
+277
 parser.is_bool("")      # True
-279
+278
 parser.is_bool("abc")   # False
-280
+279
 ```
-281
+280
 """
-282
+281
 if self.trim:
-283
+282
 value = value.strip()
+283
 284
-285
 if not self.bool_case_sensitive:
-286
+285
 value = value.lower()
-287
+286
 if value in self.true_values:
-288
+287
 return True
-289
+288
 if value in self.false_values:
-290
+289
 return True
+290
 291
-292
 return False
 Check if a string represents a bool
 Only strings that match the values in self.true_values and self.false_values
 will be interpreted as booleans. The default accepted values are ["true"] and
 ["false"] respectively. The case sensitivity of this matching depends on
 self.bool_case_sensitive, which is False by default.
 ***** Parameters *****
@@ -2420,149 +2420,149 @@
 def is_int(
 self,
 value: str,
 *,
 allow_sign: bool = True,
 allow_negative: bool = True,
 allow_scientific: bool = True) -> bool: View Source
-295
+294
 def is_int(self, value: str, *, allow_sign: bool=True, allow_negative:
 bool=True, allow_scientific: bool=True) -> bool:
-296
+295
 """
-297
+296
 Check if a string represents an int
+297
 298
-299
 Parameters
-300
+299
 ----------
-301
+300
 `value`
-302
+301
 : string to be checked
+302
 303
-304
 `allow_negative`
-305
+304
 : whether to accept negative values
+305
 306
-307
 `allow_sign`
-308
+307
 : whether to accept signed values. If False, it implies that `allow_negative`
 is False also.
+308
 309
-310
 `allow_scientific`
-311
+310
 : whether to accept scientific notation. If True, strings of the form
 `"<var>M</var>e<var>X</var>"` will be interpreted as the expression `<var>M</
 var> * (10 ** <var>X</var>)`, where <var>M</var> is the mantissa/significand
 and <var>X</var> is the exponent. Note <var>M</var> *must* be an integer and
 <var>X</var> *must* be a non-negative integer, even in cases where the above
 expression evaluates mathematically to an integer.
+311
 312
-313
 Returns
-314
+313
 -------
-315
+314
 whether it is an int
+315
 316
-317
 Examples
-318
+317
 --------
-319
+318
 ```python
-320
+319
 parser = TypeParser()
-321
+320
 parser.is_int("0")    # True
-322
+321
 parser.is_int("-1")   # True
-323
+322
 parser.is_int("abc")  # False
-324
+323
 parser.is_int("")     # False
-325
+324
 ```
-326
+325
 """
-327
+326
 if self.trim:
-328
+327
 value = value.strip()
+328
 329
-330
 if len(value) == 0:
-331
+330
 return False
+331
 332
-333
 if allow_scientific:
-334
+333
 value, exp = _decompose_string_pair(value, self._scientific_char,
 self.int_case_sensitive)
-335
+334
 if exp is not None:
-336
+335
 return self.is_int(
-337
+336
 value, allow_sign=True, allow_negative=allow_negative, allow_scientific=False
-338
+337
 ) and self.is_int(
-339
+338
 exp, allow_sign=True, allow_negative=False, allow_scientific=False
-340
+339
 )
+340
 341
-342
 if value[0] in self._sign_chars:
-343
+342
 if len(value) == 1:
-344
+343
 return False
-345
+344
 if not allow_sign:
-346
+345
 return False
-347
+346
 if not allow_negative and value[0] in self._negative_chars:
-348
+347
 return False
-349
+348
 value = value[1:]
-350
+349
 if value[0] in self._digit_separators or value[-1] in self._digit_separators:
-351
+350
 return False
+351
 352
-353
 prev_separated = False
-354
+353
 for c in value:
-355
+354
 if c in self._digit_separators:
-356
+355
 if prev_separated:
-357
+356
 return False
-358
+357
 prev_separated = True
-359
+358
 else:
-360
+359
 prev_separated = False
-361
+360
 if c not in self._digit_chars:
-362
+361
 return False
-363
+362
 return True
 Check if a string represents an int
 ***** Parameters *****
 value : string to be checked
 allow_negative : whether to accept negative values
 allow_sign : whether to accept signed values. If False, it implies that
 allow_negative is False also.
@@ -2584,157 +2584,157 @@
 def is_float(
 self,
 value: str,
 *,
 allow_scientific: bool = True,
 allow_inf: bool = True,
 allow_nan: bool = True) -> bool: View Source
-366
+365
 def is_float(self, value: str, *, allow_scientific: bool=True, allow_inf:
 bool=True, allow_nan: bool=True) -> bool:
-367
+366
 """
-368
+367
 Check if a string represents a float (or equivalently, a Decimal)
+368
 369
-370
 This function will also return True if the string represents an int.
+370
 371
-372
 Alias: `is_decimal()`
+372
 373
-374
 Parameters
-375
+374
 ----------
-376
+375
 `value`
-377
+376
 : string to be checked
+377
 378
-379
 `allow_scientific`
-380
+379
 : whether to accept scientific notation. If True, strings of the form
 `"<var>M</var>e<var>X</var>"` will be interpreted as the expression `<var>M</
 var> * (10 ** <var>X</var>)`, where <var>M</var> is the mantissa/significand
 and <var>X</var> is the exponent. Note that <var>X</var> must be an integer,
 but can be negative.
+380
 381
-382
 `allow_inf`
-383
+382
 : whether to accept positive and negative infinity values. If True, strings
 that match the values in `self.inf_values` (empty by default) are interpreted
 as infinity, or as negative infinity if prepended by a negative sign. The case
 sensitivity of this matching depends on `self.float_case_sensitive`, which is
 False by default.
+383
 384
-385
 `allow_nan`
-386
+385
 : whether to accept NaN (not a number) representations. If True, strings that
 match the values in `self.nan_values` (empty by default) are interpeted as NaN.
 The case sensitivity of this matching depends on `self.float_case_sensitive`,
 which is False by default.
+386
 387
-388
 Returns
-389
+388
 -------
-390
+389
 whether it is a float or Decimal
+390
 391
-392
 Examples
-393
+392
 --------
-394
+393
 ```python
-395
+394
 parser = TypeParser()
-396
+395
 parser.is_float("1.")       # True
-397
+396
 parser.is_float("12.3e-2")  # True
-398
+397
 parser.is_float("abc")      # False
-399
+398
 parser.is_float("")         # False
-400
+399
 ```
-401
+400
 """
-402
+401
 if self.trim:
-403
+402
 value = value.strip()
+403
 404
-405
 if len(value) > 0 and value[0] in self._sign_chars:
-406
+405
 value = value[1:]
+406
 407
-408
 if self.float_case_sensitive:
-409
+408
 special_value = value
-410
+409
 else:
-411
+410
 special_value = value.lower()
-412
+411
 if allow_inf and special_value in self.inf_values:
-413
+412
 return True
-414
+413
 if allow_nan and special_value in self.nan_values:
-415
+414
 return True
+415
 416
-417
 if len(value) == 0:
-418
+417
 return False
+418
 419
-420
 if allow_scientific:
-421
+420
 value, exp = _decompose_string_pair(value, self._scientific_char,
 self.float_case_sensitive)
-422
+421
 if exp is not None:
-423
+422
 return self.is_float(value, allow_scientific=False, allow_inf=False,
 allow_nan=False) and self.is_int(exp, allow_sign=True, allow_negative=True,
 allow_scientific=False)
+423
 424
-425
 value, frac = _decompose_string_pair(value, self._float_separator,
 self.float_case_sensitive)
-426
+425
 if frac is not None:
-427
+426
 if value == "" and frac == "":
-428
+427
 return False
-429
+428
 return (
-430
+429
 self.is_int(value, allow_sign=True, allow_negative=False,
 allow_scientific=False) or value == ""
-431
+430
 ) and (
-432
+431
 self.is_int(frac, allow_sign=False, allow_negative=False,
 allow_scientific=False) or frac == ""
-433
+432
 )
+433
 434
-435
 return self.is_int(value, allow_sign=True, allow_negative=True,
 allow_scientific=False)
 Check if a string represents a float (or equivalently, a Decimal)
 This function will also return True if the string represents an int.
 Alias: is_decimal()
 ***** Parameters *****
 value : string to be checked
@@ -2763,88 +2763,88 @@
 def is_decimal(
 self,
 value: str,
 *,
 allow_scientific: bool = True,
 allow_inf: bool = True,
 allow_nan: bool = True) -> bool: View Source
-438
+437
 def is_decimal(self, value: str, *, allow_scientific: bool=True, allow_inf:
 bool=True, allow_nan: bool=True) -> bool:
-439
+438
 """
-440
+439
 Alias of `is_float()`
-441
+440
 """
-442
+441
 return self.is_float(value, allow_scientific=allow_scientific,
 allow_inf=allow_inf, allow_nan=allow_nan)
 Alias of is_float()
 ⁰
 def parse_none(self, value: str) -> None: View Source
-445
+444
 def parse_none(self, value: str) -> None:
-446
+445
 """
-447
+446
 Parse a string and return it as the value None if possible
+447
 448
-449
 Only strings that match the values in `self.none_values` will be interpreted as
 None. The default accepted values are `[""]`, i.e. an empty string. The case
 sensitivity of this matching depends on `self.none_case_sensitive`, which is
 False by default.
+449
 450
-451
 Parameters
-452
+451
 ----------
-453
+452
 `value`
-454
+453
 : string to be parsed
+454
 455
-456
 Returns
-457
+456
 -------
-458
+457
 parsed None value
+458
 459
-460
 Raises
-461
+460
 ------
-462
+461
 `ValueError` if `value` cannot be parsed
+462
 463
-464
 Examples
-465
+464
 --------
-466
+465
 ```python
-467
+466
 parser = TypeParser()
-468
+467
 parser.parse_bool("")     # None
-469
+468
 parser.parse_bool("abc")  # raises ValueError
-470
+469
 ```
-471
+470
 """
-472
+471
 if self.is_none(value):
-473
+472
 return None
-474
+473
 else:
-475
+474
 raise ValueError(f"not a none value: {value}")
 Parse a string and return it as the value None if possible
 Only strings that match the values in self.none_values will be interpreted as
 None. The default accepted values are [""], i.e. an empty string. The case
 sensitivity of this matching depends on self.none_case_sensitive, which is
 False by default.
 ***** Parameters *****
@@ -2855,89 +2855,89 @@
 ValueError if value cannot be parsed
 ***** Examples *****
 parser = TypeParser()
 parser.parse_bool("")     # None
 parser.parse_bool("abc")  # raises ValueError
 ⁰
 def parse_bool(self, value: str) -> bool: View Source
-478
+477
 def parse_bool(self, value: str) -> bool:
-479
+478
 """
-480
+479
 Parse a string and return it as a bool if possible
+480
 481
-482
 Only strings that match the values in `self.true_values` and
 `self.false_values` will be interpreted as booleans. The default accepted
 values are `["true"]` and `["false"]` respectively. The case sensitivity of
 this matching depends on `self.bool_case_sensitive`, which is False by default.
+482
 483
-484
 Parameters
-485
+484
 ----------
-486
+485
 `value`
-487
+486
 : string to be parsed
+487
 488
-489
 Returns
-490
+489
 -------
-491
+490
 parsed bool value
+491
 492
-493
 Raises
-494
+493
 ------
-495
+494
 `ValueError` if `value` cannot be parsed
+495
 496
-497
 Examples
-498
+497
 --------
-499
+498
 ```python
-500
+499
 parser = TypeParser()
-501
+500
 parser.parse_bool("true")   # True
-502
+501
 parser.parse_bool("FALSE")  # False
-503
+502
 ```
-504
+503
 """
-505
+504
 if self.trim:
-506
+505
 value = value.strip()
+506
 507
-508
 if self.bool_case_sensitive:
-509
+508
 special_value = value
-510
+509
 else:
-511
+510
 special_value = value.lower()
-512
+511
 if special_value in self.true_values:
-513
+512
 return True
-514
+513
 if special_value in self.false_values:
-515
+514
 return False
+515
 516
-517
 raise ValueError(f"not a boolean: {value}")
 Parse a string and return it as a bool if possible
 Only strings that match the values in self.true_values and self.false_values
 will be interpreted as booleans. The default accepted values are ["true"] and
 ["false"] respectively. The case sensitivity of this matching depends on
 self.bool_case_sensitive, which is False by default.
 ***** Parameters *****
@@ -2949,112 +2949,112 @@
 ***** Examples *****
 parser = TypeParser()
 parser.parse_bool("true")   # True
 parser.parse_bool("FALSE")  # False
 ⁰
 def parse_int(self, value: str, *, allow_scientific: bool = True) -> int: View
 Source
-520
+519
 def parse_int(self, value: str, *, allow_scientific: bool=True) -> int:
-521
+520
 """
-522
+521
 Parse a string and return it as an int if possible
+522
 523
-524
 If the string represents a bool, it will be converted to `1` for True and `0`
 for False.
+524
 525
-526
 Parameters
-527
+526
 ----------
-528
+527
 `value`
-529
+528
 : string to be parsed
+529
 530
-531
 `allow_scientific`
-532
+531
 : whether to accept scientific notation. If True, strings of the form
 `"<var>M</var>e<var>X</var>"` will be interpreted as the expression `<var>M</
 var> * (10 ** <var>X</var>)`, where <var>M</var> is the mantissa/significand
 and <var>X</var> is the exponent. Note <var>M</var> *must* be an integer and
 <var>X</var> *must* be a non-negative integer, even in cases where the above
 expression evaluates mathematically to an integer.
+532
 533
-534
 Returns
-535
+534
 -------
-536
+535
 parsed int value
+536
 537
-538
 Raises
-539
+538
 ------
-540
+539
 `ValueError` if `value` cannot be parsed
+540
 541
-542
 Examples
-543
+542
 --------
-544
+543
 ```python
-545
+544
 parser = TypeParser()
-546
+545
 parser.parse_int("0")    # 0
-547
+546
 parser.parse_int("-1")   # -1
-548
+547
 parser.parse_int("2e3")  # 2000
-549
+548
 ```
-550
+549
 """
-551
+550
 if self.trim:
-552
+551
 value = value.strip()
+552
 553
-554
 if self.is_int(value, allow_sign=True, allow_negative=True,
 allow_scientific=allow_scientific):
-555
+554
 if allow_scientific:
-556
+555
 value, exp = _decompose_string_pair(value, self._scientific_char,
 self.int_case_sensitive)
-557
+556
 if exp is not None:
-558
+557
 if value[0] in (self._negative_chars - {self._negative_char}):
-559
+558
 value = self._negative_char + value[1:]
-560
+559
 return int(value) * (10 ** int(exp))
+560
 561
-562
 if value[0] in (self._negative_chars - {self._negative_char}):
-563
+562
 value = self._negative_char + value[1:]
-564
+563
 return int(value)
+564
 565
-566
 elif self.is_bool(value):
-567
+566
 return int(self.parse_bool(value))
-568
+567
 else:
-569
+568
 raise ValueError(f"not an integer: {value}")
 Parse a string and return it as an int if possible
 If the string represents a bool, it will be converted to 1 for True and 0 for
 False.
 ***** Parameters *****
 value : string to be parsed
 allow_scientific : whether to accept scientific notation. If True, strings of
@@ -3076,109 +3076,109 @@
 def parse_float(
 self,
 value: str,
 *,
 allow_scientific: bool = True,
 allow_inf: bool = True,
 allow_nan: bool = True) -> float: View Source
-617
+616
 def parse_float(self, value: str, *, allow_scientific: bool=True, allow_inf:
 bool=True, allow_nan: bool=True) -> float:
-618
+617
 """
-619
+618
 Parse a string and return it as a (non-exact) float if possible
+619
 620
-621
 If the string represents a bool, it will be converted to `1.` for True and `0.`
 for False. If the string represents an int, it will be converted to a float
 also.
+621
 622
-623
 Behaves analogously to `parse_decimal()`, except that that returns an exact
 Decimal instead.
+623
 624
-625
 Parameters
-626
+625
 ----------
-627
+626
 `value`
-628
+627
 : string to be parsed
+628
 629
-630
 `allow_scientific`
-631
+630
 : whether to accept scientific notation. If True, strings of the form
 `"<var>M</var>e<var>X</var>"` will be interpreted as the expression `<var>M</
 var> * (10 ** <var>X</var>)`, where <var>M</var> is the mantissa/significand
 and <var>X</var> is the exponent. Note that <var>X</var> must be an integer,
 but can be negative.
+631
 632
-633
 `allow_inf`
-634
+633
 : whether to accept positive and negative infinity values. If True, strings
 that match the values in `self.inf_values` (empty by default) are interpreted
 as infinity, or as negative infinity if prepended by a negative sign. The case
 sensitivity of this matching depends on `self.float_case_sensitive`, which is
 False by default.
+634
 635
-636
 `allow_nan`
-637
+636
 : whether to accept NaN (not a number) representations. If True, strings that
 match the values in `self.nan_values` (empty by default) are interpeted as NaN.
 The case sensitivity of this matching depends on `self.float_case_sensitive`,
 which is False by default.
+637
 638
-639
 Returns
-640
+639
 -------
-641
+640
 parsed float value
+641
 642
-643
 Raises
-644
+643
 ------
-645
+644
 `ValueError` if `value` cannot be parsed
+645
 646
-647
 Examples
-648
+647
 --------
-649
+648
 ```python
-650
+649
 parser = TypeParser(inf_values=["inf"], nan_values=["nan"])
-651
+650
 parser.parse_float("1.")       # 1.
-652
+651
 parser.parse_float("1.23e2")   # 123.
-653
+652
 parser.parse_float("1.23e-2")  # 0.0123
-654
+653
 parser.parse_float("inf")      # math.inf
-655
+654
 ```
-656
+655
 """
-657
+656
 return self._parse_floatlike(value, float, math.inf, math.nan,
-658
+657
 allow_scientific=allow_scientific,
-659
+658
 allow_inf=allow_inf,
-660
+659
 allow_nan=allow_nan,
-661
+660
 )
 Parse a string and return it as a (non-exact) float if possible
 If the string represents a bool, it will be converted to 1. for True and 0. for
 False. If the string represents an int, it will be converted to a float also.
 Behaves analogously to parse_decimal(), except that that returns an exact
 Decimal instead.
 ***** Parameters *****
@@ -3210,110 +3210,110 @@
 def parse_decimal(
 self,
 value: str,
 *,
 allow_scientific: bool = True,
 allow_inf: bool = True,
 allow_nan: bool = True) -> decimal.Decimal: View Source
-664
+663
 def parse_decimal(self, value: str, *, allow_scientific: bool=True, allow_inf:
 bool=True, allow_nan: bool=True) -> Decimal:
-665
+664
 """
-666
+665
 Parse a string and return it as an exact Decimal if possible
+666
 667
-668
 If the string represents a bool, it will be converted to `Decimal(1)` for True
 and `Decimal(0)` for False. If the string represents an int, it will be
 converted to a Decimal also.
+668
 669
-670
 Behaves analogously to `parse_float()`, except that that returns a non-exact
 float instead.
+670
 671
-672
 Parameters
-673
+672
 ----------
-674
+673
 `value`
-675
+674
 : string to be parsed
+675
 676
-677
 `allow_scientific`
-678
+677
 : whether to accept scientific notation. If True, strings of the form
 `"<var>M</var>e<var>X</var>"` will be interpreted as the expression `<var>M</
 var> * (10 ** <var>X</var>)`, where <var>M</var> is the mantissa/significand
 and <var>X</var> is the exponent. Note that <var>X</var> must be an integer,
 but can be negative.
+678
 679
-680
 `allow_inf`
-681
+680
 : whether to accept positive and negative infinity values. If True, strings
 that match the values in `self.inf_values` (empty by default) are interpreted
 as infinity, or as negative infinity if prepended by a negative sign. The case
 sensitivity of this matching depends on `self.float_case_sensitive`, which is
 False by default.
+681
 682
-683
 `allow_nan`
-684
+683
 : whether to accept NaN (not a number) representations. If True, strings that
 match the values in `self.nan_values` (empty by default) are interpeted as NaN.
 The case sensitivity of this matching depends on `self.float_case_sensitive`,
 which is False by default.
+684
 685
-686
 Returns
-687
+686
 -------
-688
+687
 parsed Decimal value
+688
 689
-690
 Raises
-691
+690
 ------
-692
+691
 `ValueError` if `value` cannot be parsed
+692
 693
-694
 Examples
-695
+694
 --------
-696
+695
 ```python
-697
+696
 parser = TypeParser(inf_values=["inf"], nan_values=["nan"])
-698
+697
 parser.parse_decimal("1.")       # Decimal(1)
-699
+698
 parser.parse_decimal("1.23e2")   # Decimal(123)
-700
+699
 parser.parse_decimal("1.23e-2")  # Decimal(123) / Decimal(10000)
-701
+700
 parser.parse_decimal("inf")      # Decimal(math.inf)
-702
+701
 ```
-703
+702
 """
-704
+703
 return self._parse_floatlike(value, Decimal, Decimal(math.inf), Decimal
 (math.nan),
-705
+704
 allow_scientific=allow_scientific,
-706
+705
 allow_inf=allow_inf,
-707
+706
 allow_nan=allow_nan,
-708
+707
 )
 Parse a string and return it as an exact Decimal if possible
 If the string represents a bool, it will be converted to Decimal(1) for True
 and Decimal(0) for False. If the string represents an int, it will be converted
 to a Decimal also.
 Behaves analogously to parse_float(), except that that returns a non-exact
 float instead.
@@ -3345,110 +3345,105 @@
 ⁰
 def infer(
 self,
 value: str) -> Type[Union[str, int, float, decimal.Decimal, bool, NoneType,
 parsetypes._common.Nullable[str], parsetypes._common.Nullable[int],
 parsetypes._common.Nullable[float], parsetypes._common.Nullable
 [decimal.Decimal], parsetypes._common.Nullable[bool],
-parsetypes._common.Nullable[NoneType], list[str], list[int], list[float], list
-[decimal.Decimal], list[bool], list[None], list[parsetypes._common.Nullable
-[str]], list[parsetypes._common.Nullable[int]], list
-[parsetypes._common.Nullable[float]], list[parsetypes._common.Nullable
-[decimal.Decimal]], list[parsetypes._common.Nullable[bool]], list
-[parsetypes._common.Nullable[NoneType]]]]: View Source
-711
+parsetypes._common.Nullable[NoneType]]]: View Source
+710
 def infer(self, value: str) -> AnyValueType:
-712
+711
 """
-713
+712
 Infer the underlying type of a string
+713
 714
-715
 Also check for inline lists if `self.list_delimiter` is not None.
+715
 716
-717
 Parameters
-718
+717
 ----------
-719
+718
 `value`
-720
+719
 : the string for which the type should be inferred
+720
 721
-722
 Returns
-723
+722
 -------
-724
+723
 inferred type
+724
 725
-726
 Examples
-727
+726
 --------
-728
+727
 ```python
-729
+728
 parser = TypeParser()
-730
+729
 parser.infer("true")  # bool
-731
+730
 parser.infer("2.0")   # float
-732
+731
 parser.infer("abc")   # str
-733
+732
 ```
-734
+733
 """
-735
+734
 if self.is_none(value):
-736
+735
 return NoneType
-737
+736
 if self.is_bool(value):
-738
+737
 return bool
-739
+738
 if self.is_int(value):
-740
+739
 return int
-741
+740
 if self.is_float(value):
-742
+741
 if self.use_decimal:
-743
+742
 return Decimal
-744
+743
 else:
-745
+744
 return float
+745
 746
-747
 if self.trim:
-748
+747
 value = value.strip()
+748
 749
-750
 if self.list_delimiter is not None and self.list_delimiter in value:
-751
+750
 subvalues = value.split(self.list_delimiter)
-752
+751
 if self.trim:
-753
+752
 subvalues = [subvalue.strip() for subvalue in subvalues]
-754
+753
 reduced_type = reduce_types(self.infer(subvalue) for subvalue in subvalues)
-755
+754
 reduced_type = cast(AnyContainedType, reduced_type)
-756
+755
 r = list[reduced_type]
-757
+756
 return r  # type: ignore
+757
 758
-759
 return GenericValue
 Infer the underlying type of a string
 Also check for inline lists if self.list_delimiter is not None.
 ***** Parameters *****
 value : the string for which the type should be inferred
 ***** Returns *****
 inferred type
@@ -3460,67 +3455,62 @@
 ⁰
 def infer_series(
 self,
 values: Iterable[str]) -> Type[Union[str, int, float, decimal.Decimal, bool,
 NoneType, parsetypes._common.Nullable[str], parsetypes._common.Nullable[int],
 parsetypes._common.Nullable[float], parsetypes._common.Nullable
 [decimal.Decimal], parsetypes._common.Nullable[bool],
-parsetypes._common.Nullable[NoneType], list[str], list[int], list[float], list
-[decimal.Decimal], list[bool], list[None], list[parsetypes._common.Nullable
-[str]], list[parsetypes._common.Nullable[int]], list
-[parsetypes._common.Nullable[float]], list[parsetypes._common.Nullable
-[decimal.Decimal]], list[parsetypes._common.Nullable[bool]], list
-[parsetypes._common.Nullable[NoneType]]]]: View Source
-762
+parsetypes._common.Nullable[NoneType]]]: View Source
+761
 def infer_series(self, values: Iterable[str]) -> AnyValueType:
-763
+762
 """
-764
+763
 Infer the underlying common type of a series of strings
+764
 765
-766
 If the values in the series do not have the same apparent type, the resulting
 type will be narrowest possible type that will encompass all values in the
 series. See `parsetypes.reduce_types()` for more information.
+766
 767
-768
 Parameters
-769
+768
 ----------
-770
+769
 `values`
-771
+770
 : series of strings for which the type should be inferred
+771
 772
-773
 Returns
-774
+773
 -------
-775
+774
 inferred type
+775
 776
-777
 Examples
-778
+777
 --------
-779
+778
 ```python
-780
+779
 parser = TypeParser()
-781
+780
 parser.infer_series(["1", "2", "3.4"])       # float
-782
+781
 parser.infer_series(["true", "false", "2"])  # int
-783
+782
 parser.infer_series(["1", "2.3", "abc"])     # str
-784
+783
 ```
-785
+784
 """
-786
+785
 return reduce_types(self.infer(value) for value in values)
 Infer the underlying common type of a series of strings
 If the values in the series do not have the same apparent type, the resulting
 type will be narrowest possible type that will encompass all values in the
 series. See parsetypes.reduce_types() for more information.
 ***** Parameters *****
 values : series of strings for which the type should be inferred
@@ -3534,100 +3524,95 @@
 ⁰
 def infer_table(
 self,
 rows: Iterable[Sequence[str]]) -> list[Type[Union[str, int, float,
 decimal.Decimal, bool, NoneType, parsetypes._common.Nullable[str],
 parsetypes._common.Nullable[int], parsetypes._common.Nullable[float],
 parsetypes._common.Nullable[decimal.Decimal], parsetypes._common.Nullable
-[bool], parsetypes._common.Nullable[NoneType], list[str], list[int], list
-[float], list[decimal.Decimal], list[bool], list[None], list
-[parsetypes._common.Nullable[str]], list[parsetypes._common.Nullable[int]],
-list[parsetypes._common.Nullable[float]], list[parsetypes._common.Nullable
-[decimal.Decimal]], list[parsetypes._common.Nullable[bool]], list
-[parsetypes._common.Nullable[NoneType]]]]]: View Source
-789
+[bool], parsetypes._common.Nullable[NoneType]]]]: View Source
+788
 def infer_table(self, rows: Iterable[Sequence[str]]) -> list[AnyValueType]:
-790
+789
 """
-791
+790
 Infer the underlying common type for each column of a table of strings
+791
 792
-793
 For each column, if the values do not have the same apparent type, the
 resulting type will be narrowest possible type that will encompass all values
 in the column. See `parsetypes.reduce_types()` for more information.
+793
 794
-795
 Note that the inferred types of every individual value must all be able to fit
 into memory at once.
+795
 796
-797
 Parameters
-798
+797
 ----------
-799
+798
 `rows`
-800
+799
 : table of strings for which the types should be inferred, in row-major order
+800
 801
-802
 Returns
-803
+802
 -------
-804
+803
 inferred types
+804
 805
-806
 Examples
-807
+806
 --------
-808
+807
 ```python
-809
+808
 parser = TypeParser()
-810
+809
 parser.infer_table([
-811
+810
 ["1",   "true",  "1"],
-812
+811
 ["2",   "false", "2.3"],
-813
+812
 ["3.4", "2",     "abc"],
-814
+813
 ])
-815
+814
 # [float, int, str]
-816
+815
 ```
-817
+816
 """
-818
+817
 rows_iter = iter(rows)
-819
+818
 first_row = next(rows_iter, None)
-820
+819
 if first_row is None:
-821
+820
 return []
+821
 822
-823
 num_cols = len(first_row)
-824
+823
 if num_cols == 0:
-825
+824
 return []
+825
 826
-827
 table = _TypeTable([[self.infer(value)] for value in first_row])
-828
+827
 for row in rows_iter:
-829
+828
 table.add_row([self.infer(value) for value in row])
+829
 830
-831
 return [reduce_types(col) for col in table.cols]
 Infer the underlying common type for each column of a table of strings
 For each column, if the values do not have the same apparent type, the
 resulting type will be narrowest possible type that will encompass all values
 in the column. See parsetypes.reduce_types() for more information.
 Note that the inferred types of every individual value must all be able to fit
 into memory at once.
@@ -3647,62 +3632,57 @@
 ⁰
 def parse(
 self,
 value: str) -> Union[str, int, float, decimal.Decimal, bool, NoneType,
 parsetypes._common.Nullable[str], parsetypes._common.Nullable[int],
 parsetypes._common.Nullable[float], parsetypes._common.Nullable
 [decimal.Decimal], parsetypes._common.Nullable[bool],
-parsetypes._common.Nullable[NoneType], list[str], list[int], list[float], list
-[decimal.Decimal], list[bool], list[None], list[parsetypes._common.Nullable
-[str]], list[parsetypes._common.Nullable[int]], list
-[parsetypes._common.Nullable[float]], list[parsetypes._common.Nullable
-[decimal.Decimal]], list[parsetypes._common.Nullable[bool]], list
-[parsetypes._common.Nullable[NoneType]]]: View Source
-870
+parsetypes._common.Nullable[NoneType]]: View Source
+869
 def parse(self, value: str) -> AnyValue:
-871
+870
 """
-872
+871
 Parse a string and convert it to its underlying type
+872
 873
-874
 Parameters
-875
+874
 ----------
-876
+875
 `value`
-877
+876
 : the string to be parsed
+877
 878
-879
 Returns
-880
+879
 -------
-881
+880
 converted value
+881
 882
-883
 Examples
-884
+883
 --------
-885
+884
 ```python
-886
+885
 parser = TypeParser()
-887
+886
 parser.parse("true")  # True
-888
+887
 parser.parse("2.0")   # 2.
-889
+888
 parser.parse("abc")   # "abc"
-890
+889
 ```
-891
+890
 """
-892
+891
 return self._convert(value, self.infer(value))
 Parse a string and convert it to its underlying type
 ***** Parameters *****
 value : the string to be parsed
 ***** Returns *****
 converted value
 ***** Examples *****
@@ -3713,71 +3693,66 @@
 ⁰
 def parse_series(
 self,
 values: Iterable[str]) -> list[Union[str, int, float, decimal.Decimal, bool,
 NoneType, parsetypes._common.Nullable[str], parsetypes._common.Nullable[int],
 parsetypes._common.Nullable[float], parsetypes._common.Nullable
 [decimal.Decimal], parsetypes._common.Nullable[bool],
-parsetypes._common.Nullable[NoneType], list[str], list[int], list[float], list
-[decimal.Decimal], list[bool], list[None], list[parsetypes._common.Nullable
-[str]], list[parsetypes._common.Nullable[int]], list
-[parsetypes._common.Nullable[float]], list[parsetypes._common.Nullable
-[decimal.Decimal]], list[parsetypes._common.Nullable[bool]], list
-[parsetypes._common.Nullable[NoneType]]]]: View Source
-895
+parsetypes._common.Nullable[NoneType]]]: View Source
+894
 def parse_series(self, values: Iterable[str]) -> list[AnyValue]:
-896
+895
 """
-897
+896
 Parse a series of strings and convert them to their underlying common type
+897
 898
-899
 If the values in the series do not have the same apparent type, the common type
 is taken as the narrowest possible type that will encompass all values in the
 series. See `parsetypes.reduce_types()` for more information.
+899
 900
-901
 Parameters
-902
+901
 ----------
-903
+902
 `values`
-904
+903
 : series of strings to be parsed
+904
 905
-906
 Returns
-907
+906
 -------
-908
+907
 converted values
+908
 909
-910
 Examples
-911
+910
 --------
-912
+911
 ```python
-913
+912
 parser = TypeParser()
-914
+913
 parser.parse_series(["1", "2", "3"])        # [1, 2, 3]
-915
+914
 parser.parse_series(["5", "6.7", "8."])     # [5., 6.7, 8.]
-916
+915
 parser.parse_series(["true", "false", ""])  # [True, False, None]
-917
+916
 parser.parse_series(["1", "2.3", "abc"])    # ["1", "2.3", "abc"]
-918
+917
 ```
-919
+918
 """
-920
+919
 inferred = self.infer_series(values)
-921
+920
 return [self._convert(value, inferred) for value in values]
 Parse a series of strings and convert them to their underlying common type
 If the values in the series do not have the same apparent type, the common type
 is taken as the narrowest possible type that will encompass all values in the
 series. See parsetypes.reduce_types() for more information.
 ***** Parameters *****
 values : series of strings to be parsed
@@ -3792,101 +3767,96 @@
 ⁰
 def parse_table(
 self,
 rows: Iterable[Sequence[str]]) -> list[list[Union[str, int, float,
 decimal.Decimal, bool, NoneType, parsetypes._common.Nullable[str],
 parsetypes._common.Nullable[int], parsetypes._common.Nullable[float],
 parsetypes._common.Nullable[decimal.Decimal], parsetypes._common.Nullable
-[bool], parsetypes._common.Nullable[NoneType], list[str], list[int], list
-[float], list[decimal.Decimal], list[bool], list[None], list
-[parsetypes._common.Nullable[str]], list[parsetypes._common.Nullable[int]],
-list[parsetypes._common.Nullable[float]], list[parsetypes._common.Nullable
-[decimal.Decimal]], list[parsetypes._common.Nullable[bool]], list
-[parsetypes._common.Nullable[NoneType]]]]]: View Source
-924
+[bool], parsetypes._common.Nullable[NoneType]]]]: View Source
+923
 def parse_table(self, rows: Iterable[Sequence[str]]) -> list[list[AnyValue]]:
-925
+924
 """
-926
+925
 Parse a table of strings and convert them to the underlying common type of each
 column
+926
 927
-928
 For each column, if the values do not have the same apparent type, the common
 type is taken as the narrowest possible type that will encompass all values in
 the column. See `parsetypes.reduce_types()` for more information.
+928
 929
-930
 Note that the type inference requires that the inferred types of every
 individual value must all be able to fit into memory at once.
+930
 931
-932
 This is a function that computes the entire table and returns it all at once.
 The generator `iterate_table()` behaves analogously, except that it computes
 and yields each row one at a time.
+932
 933
-934
 Parameters
-935
+934
 ----------
-936
+935
 `rows`
-937
+936
 : table of strings to be parsed, in row-major order
+937
 938
-939
 `iterator`
-940
+939
 : whether the parsed values should be yielded as an iterator. If False, which
 is the default, the entire table is computed and returned as a list of lists.
 If True, this function behaves as a generator, and the rows of the table are
 computed and yielded one at a time. However, note that even when set to True,
 the type inference requires that inferred type of each individual value must
 all be able to fit into memory at once.
+940
 941
-942
 Returns
-943
+942
 -------
-944
+943
 converted table of values, in row-major order
+944
 945
-946
 Examples
-947
+946
 --------
-948
+947
 ```python
-949
+948
 parser = TypeParser()
-950
+949
 table = parser.parse_table([
-951
+950
 ["1", "5",   "true",  "1"],
-952
+951
 ["2", "6.7", "false", "2.3"],
-953
+952
 ["3", "8.0", "",     "abc"],
-954
+953
 ]):
-955
+954
 assert table == [
-956
+955
 [1, 5.,  True,  "1"],
-957
+956
 [2, 6.7, False, "2.3"],
-958
+957
 [3, 8.,  None,  "abc"],
-959
+958
 ]
-960
+959
 ```
-961
+960
 """
-962
+961
 return [converted_row for converted_row in self.iterate_table(rows)]
 Parse a table of strings and convert them to the underlying common type of each
 column
 For each column, if the values do not have the same apparent type, the common
 type is taken as the narrowest possible type that will encompass all values in
 the column. See parsetypes.reduce_types() for more information.
 Note that the type inference requires that the inferred types of every
@@ -3919,91 +3889,86 @@
 ⁰
 def iterate_table(
 self,
 rows: Iterable[Sequence[str]]) -> Iterator[list[Union[str, int, float,
 decimal.Decimal, bool, NoneType, parsetypes._common.Nullable[str],
 parsetypes._common.Nullable[int], parsetypes._common.Nullable[float],
 parsetypes._common.Nullable[decimal.Decimal], parsetypes._common.Nullable
-[bool], parsetypes._common.Nullable[NoneType], list[str], list[int], list
-[float], list[decimal.Decimal], list[bool], list[None], list
-[parsetypes._common.Nullable[str]], list[parsetypes._common.Nullable[int]],
-list[parsetypes._common.Nullable[float]], list[parsetypes._common.Nullable
-[decimal.Decimal]], list[parsetypes._common.Nullable[bool]], list
-[parsetypes._common.Nullable[NoneType]]]]]: View Source
-965
+[bool], parsetypes._common.Nullable[NoneType]]]]: View Source
+964
 def iterate_table(self, rows: Iterable[Sequence[str]]) -> Iterator[list
 [AnyValue]]:
-966
+965
 """
-967
+966
 Parse a table of strings for the underlying common type of each column, then
 convert and yield each row
+967
 968
-969
 For each column, if the values do not have the same apparent type, the common
 type is taken as the narrowest possible type that will encompass all values in
 the column. See `parsetypes.reduce_types()` for more information.
+969
 970
-971
 This is a generator that computes and yields each row one at a time. The
 function `parse_table()` behaves analogously, except that it computes the
 entire table and returns it as a list of lists. However, note that although
 this is a generator, the type inference still requires that the inferred types
 of every individual value must all be able to fit into memory at once.
+971
 972
-973
 Parameters
-974
+973
 ----------
-975
+974
 `rows`
-976
+975
 : table of strings to be parsed, in row-major order
+976
 977
-978
 Yields
-979
+978
 -------
-980
+979
 each row of converted table values
+980
 981
-982
 Examples
-983
+982
 --------
-984
+983
 ```python
-985
+984
 parser = TypeParser()
-986
+985
 table = parser.iterate_table([
-987
+986
 ["1",   "true",  "1"],
-988
+987
 ["2",   "false", "2.3"],
-989
+988
 ["3.4", "2",     "abc"],
-990
+989
 ]):
-991
+990
 assert next(table) == [1.,  1, "1"]
-992
+991
 assert next(table) == [2.,  0, "2.3"]
-993
+992
 assert next(table) == [3.4, 2, "abc"]
-994
+993
 ```
-995
+994
 """
-996
+995
 inferred_types = self.infer_table(rows)
+996
 997
-998
 for row in rows:
-999
+998
 yield [self._convert(value, inferred) for value, inferred in zip(row,
 inferred_types)]
 Parse a table of strings for the underlying common type of each column, then
 convert and yield each row
 For each column, if the values do not have the same apparent type, the common
 type is taken as the narrowest possible type that will encompass all values in
 the column. See parsetypes.reduce_types() for more information.
@@ -4029,29 +3994,19 @@
 ** Inherited Members **
   ⁰
 def reduce_types(
 types: Iterable[Type[Union[str, int, float, decimal.Decimal, bool, NoneType,
 parsetypes._common.Nullable[str], parsetypes._common.Nullable[int],
 parsetypes._common.Nullable[float], parsetypes._common.Nullable
 [decimal.Decimal], parsetypes._common.Nullable[bool],
-parsetypes._common.Nullable[NoneType], list[str], list[int], list[float], list
-[decimal.Decimal], list[bool], list[None], list[parsetypes._common.Nullable
-[str]], list[parsetypes._common.Nullable[int]], list
-[parsetypes._common.Nullable[float]], list[parsetypes._common.Nullable
-[decimal.Decimal]], list[parsetypes._common.Nullable[bool]], list
-[parsetypes._common.Nullable[NoneType]]]]]) -> Type[Union[str, int, float,
+parsetypes._common.Nullable[NoneType]]]]) -> Type[Union[str, int, float,
 decimal.Decimal, bool, NoneType, parsetypes._common.Nullable[str],
 parsetypes._common.Nullable[int], parsetypes._common.Nullable[float],
 parsetypes._common.Nullable[decimal.Decimal], parsetypes._common.Nullable
-[bool], parsetypes._common.Nullable[NoneType], list[str], list[int], list
-[float], list[decimal.Decimal], list[bool], list[None], list
-[parsetypes._common.Nullable[str]], list[parsetypes._common.Nullable[int]],
-list[parsetypes._common.Nullable[float]], list[parsetypes._common.Nullable
-[decimal.Decimal]], list[parsetypes._common.Nullable[bool]], list
-[parsetypes._common.Nullable[NoneType]]]]: View Source
+[bool], parsetypes._common.Nullable[NoneType]]]: View Source
 157def reduce_types(types: Iterable[AnyValueType]) -> AnyValueType:
 158
 """
 159
 Reduce multiple types into a single common type.
 160
 161
@@ -4092,15 +4047,15 @@
 179
 reduce_types([int, float, str])   # str
 180
 ```
 181
 """
 182
-reduced_type: AnyValueType | None = None
+reduced_type: Union[AnyValueType, None] = None
 183
 for t in types:
 184
 if reduced_type is None:
 185
 reduced_type = t
 186
```

### Comparing `parsetypes-0.1.1/docs/html/search.js` & `parsetypes-0.2/docs/html/search.js`

 * *Files 11% similar despite different names*

#### js-beautify {}

```diff
@@ -703,15 +703,15 @@
                 },
                 "parsetypes.TypeParser.__init__": {
                     "fullname": "parsetypes.TypeParser.__init__",
                     "modulename": "parsetypes",
                     "qualname": "TypeParser.__init__",
                     "kind": "function",
                     "doc": "<p>Initialise a new parser</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p><code>trim</code>\n: whether leading and trailing whitespace should be stripped from strings</p>\n\n<p><code>use_decimal</code>\n: whether non-integer numeric values should be inferred as Decimal (exact values) instead of float (non-exact values). Note that this only applies to methods that attempt to infer type (<code>infer()</code> and <code>infer_*()</code>), and does not affect methods where the type is explicitly specified (<code>is_float()</code>, <code>is_decimal()</code>, <code>parse_float()</code>, <code>parse_decimal()</code>).</p>\n\n<p><code>list_delimiter</code>\n: the delimiter used for identifying lists and for separating list items. If set to None, the parser will not attempt to identify lists when inferring types, which usually causes the value to be treated as a str instead.</p>\n\n<p><code>none_values</code>\n: list of strings that represent the value None</p>\n\n<p><code>none_case_sensitive</code>\n: whether matches against <code>none_values</code> should be made in a case-sensitive manner</p>\n\n<p><code>true_values</code>\n: list of strings that represent the bool value True</p>\n\n<p><code>false_values</code>\n: list of strings that represent the bool value False</p>\n\n<p><code>bool_case_sensitive</code>\n: whether matches against <code>true_values</code> and <code>false_values</code> should be made in a case-sensitive manner</p>\n\n<p><code>int_case_sensitive</code>\n: whether checks for int should be done in a case-sensitive manner. This usually only applies to values given in scientific notation, where the mantissa and exponent usually are separated by <code>e</code>.</p>\n\n<p><code>inf_values</code>\n: list of strings that represent the float or Decimal value of infinity. Each of the strings can be prepended with a negative sign to represent negative infinity also.</p>\n\n<p><code>nan_values</code>\n: list of strings that represent a float or Decimal that is NaN (not a number)</p>\n\n<p><code>float_case_sensitive</code>\n: whether checks for float should be done in a case-sensitive manner. This applies to matches against <code>inf_values</code> and <code>nan_values</code>, as well as to values given in scientific notation, where the mantissa and exponent are usually separated by <code>e</code>.</p>\n\n<p><code>case_sensitive</code>\n: whether all matches should be made in a case-sensitive manner. Sets all of <code>none_case_sensitive</code>, <code>bool_case_sensitive</code>, <code>int_case_sensitive</code>, <code>float_case_sensitive</code> to the same value, ignoring any individual settings.</p>\n\n<h2 id=\"raises\">Raises</h2>\n\n<p><code>ValueError</code> if any of the options would lead to ambiguities during parsing</p>\n",
-                    "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">trim</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">use_decimal</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">list_delimiter</span><span class=\"p\">:</span> <span class=\"nb\">str</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">none_values</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s1\">&#39;&#39;</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">none_case_sensitive</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">true_values</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s1\">&#39;true&#39;</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">false_values</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s1\">&#39;false&#39;</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">bool_case_sensitive</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">int_case_sensitive</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">inf_values</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>,</span><span class=\"param\">\t<span class=\"n\">nan_values</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>,</span><span class=\"param\">\t<span class=\"n\">float_case_sensitive</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">case_sensitive</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">|</span> <span class=\"kc\">None</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"
+                    "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"o\">*</span>,</span><span class=\"param\">\t<span class=\"n\">trim</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">True</span>,</span><span class=\"param\">\t<span class=\"n\">use_decimal</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">list_delimiter</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>,</span><span class=\"param\">\t<span class=\"n\">none_values</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s1\">&#39;&#39;</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">none_case_sensitive</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">true_values</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s1\">&#39;true&#39;</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">false_values</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"s1\">&#39;false&#39;</span><span class=\"p\">]</span>,</span><span class=\"param\">\t<span class=\"n\">bool_case_sensitive</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">int_case_sensitive</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">inf_values</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>,</span><span class=\"param\">\t<span class=\"n\">nan_values</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>,</span><span class=\"param\">\t<span class=\"n\">float_case_sensitive</span><span class=\"p\">:</span> <span class=\"nb\">bool</span> <span class=\"o\">=</span> <span class=\"kc\">False</span>,</span><span class=\"param\">\t<span class=\"n\">case_sensitive</span><span class=\"p\">:</span> <span class=\"n\">Optional</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"kc\">None</span></span>)</span>"
                 },
                 "parsetypes.TypeParser.is_none": {
                     "fullname": "parsetypes.TypeParser.is_none",
                     "modulename": "parsetypes",
                     "qualname": "TypeParser.is_none",
                     "kind": "function",
                     "doc": "<p>Check if a string represents the value None</p>\n\n<p>Only strings that match the values in <code>self.none_values</code> will be interpreted as None. The default accepted values are <code>[\"\"]</code>, i.e. an empty string. The case sensitivity of this matching depends on <code>self.none_case_sensitive</code>, which is False by default.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p><code>value</code>\n: string to be checked</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>whether it is None</p>\n\n<h2 id=\"examples\">Examples</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"n\">parser</span> <span class=\"o\">=</span> <span class=\"n\">TypeParser</span><span class=\"p\">()</span>\n<span class=\"n\">parser</span><span class=\"o\">.</span><span class=\"n\">parse_bool</span><span class=\"p\">(</span><span class=\"s2\">&quot;&quot;</span><span class=\"p\">)</span>     <span class=\"c1\"># True</span>\n<span class=\"n\">parser</span><span class=\"o\">.</span><span class=\"n\">parse_bool</span><span class=\"p\">(</span><span class=\"s2\">&quot;abc&quot;</span><span class=\"p\">)</span>  <span class=\"c1\"># False</span>\n</code></pre>\n</div>\n",
@@ -801,78 +801,78 @@
                 },
                 "parsetypes.TypeParser.infer": {
                     "fullname": "parsetypes.TypeParser.infer",
                     "modulename": "parsetypes",
                     "qualname": "TypeParser.infer",
                     "kind": "function",
                     "doc": "<p>Infer the underlying type of a string</p>\n\n<p>Also check for inline lists if <code>self.list_delimiter</code> is not None.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p><code>value</code>\n: the string for which the type should be inferred</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>inferred type</p>\n\n<h2 id=\"examples\">Examples</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"n\">parser</span> <span class=\"o\">=</span> <span class=\"n\">TypeParser</span><span class=\"p\">()</span>\n<span class=\"n\">parser</span><span class=\"o\">.</span><span class=\"n\">infer</span><span class=\"p\">(</span><span class=\"s2\">&quot;true&quot;</span><span class=\"p\">)</span>  <span class=\"c1\"># bool</span>\n<span class=\"n\">parser</span><span class=\"o\">.</span><span class=\"n\">infer</span><span class=\"p\">(</span><span class=\"s2\">&quot;2.0&quot;</span><span class=\"p\">)</span>   <span class=\"c1\"># float</span>\n<span class=\"n\">parser</span><span class=\"o\">.</span><span class=\"n\">infer</span><span class=\"p\">(</span><span class=\"s2\">&quot;abc&quot;</span><span class=\"p\">)</span>   <span class=\"c1\"># str</span>\n</code></pre>\n</div>\n",
-                    "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">value</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Type</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">decimal</span><span class=\"o\">.</span><span class=\"n\">Decimal</span><span class=\"p\">,</span> <span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">,</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"n\">decimal</span><span class=\"o\">.</span><span class=\"n\">Decimal</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"n\">NoneType</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">decimal</span><span class=\"o\">.</span><span class=\"n\">Decimal</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"kc\">None</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"n\">decimal</span><span class=\"o\">.</span><span class=\"n\">Decimal</span><span class=\"p\">]],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">]],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"n\">NoneType</span><span class=\"p\">]]]]</span>:</span></span>",
+                    "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">value</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Type</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">decimal</span><span class=\"o\">.</span><span class=\"n\">Decimal</span><span class=\"p\">,</span> <span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">,</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"n\">decimal</span><span class=\"o\">.</span><span class=\"n\">Decimal</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"n\">NoneType</span><span class=\"p\">]]]</span>:</span></span>",
                     "funcdef": "def"
                 },
                 "parsetypes.TypeParser.infer_series": {
                     "fullname": "parsetypes.TypeParser.infer_series",
                     "modulename": "parsetypes",
                     "qualname": "TypeParser.infer_series",
                     "kind": "function",
                     "doc": "<p>Infer the underlying common type of a series of strings</p>\n\n<p>If the values in the series do not have the same apparent type, the resulting type will be narrowest possible type that will encompass all values in the series. See <code>parsetypes.reduce_types()</code> for more information.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p><code>values</code>\n: series of strings for which the type should be inferred</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>inferred type</p>\n\n<h2 id=\"examples\">Examples</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"n\">parser</span> <span class=\"o\">=</span> <span class=\"n\">TypeParser</span><span class=\"p\">()</span>\n<span class=\"n\">parser</span><span class=\"o\">.</span><span class=\"n\">infer_series</span><span class=\"p\">([</span><span class=\"s2\">&quot;1&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;2&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;3.4&quot;</span><span class=\"p\">])</span>       <span class=\"c1\"># float</span>\n<span class=\"n\">parser</span><span class=\"o\">.</span><span class=\"n\">infer_series</span><span class=\"p\">([</span><span class=\"s2\">&quot;true&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;false&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;2&quot;</span><span class=\"p\">])</span>  <span class=\"c1\"># int</span>\n<span class=\"n\">parser</span><span class=\"o\">.</span><span class=\"n\">infer_series</span><span class=\"p\">([</span><span class=\"s2\">&quot;1&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;2.3&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;abc&quot;</span><span class=\"p\">])</span>     <span class=\"c1\"># str</span>\n</code></pre>\n</div>\n",
-                    "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">values</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Type</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">decimal</span><span class=\"o\">.</span><span class=\"n\">Decimal</span><span class=\"p\">,</span> <span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">,</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"n\">decimal</span><span class=\"o\">.</span><span class=\"n\">Decimal</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"n\">NoneType</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">decimal</span><span class=\"o\">.</span><span class=\"n\">Decimal</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"kc\">None</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"n\">decimal</span><span class=\"o\">.</span><span class=\"n\">Decimal</span><span class=\"p\">]],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">]],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"n\">NoneType</span><span class=\"p\">]]]]</span>:</span></span>",
+                    "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">values</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Type</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">decimal</span><span class=\"o\">.</span><span class=\"n\">Decimal</span><span class=\"p\">,</span> <span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">,</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"n\">decimal</span><span class=\"o\">.</span><span class=\"n\">Decimal</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"n\">NoneType</span><span class=\"p\">]]]</span>:</span></span>",
                     "funcdef": "def"
                 },
                 "parsetypes.TypeParser.infer_table": {
                     "fullname": "parsetypes.TypeParser.infer_table",
                     "modulename": "parsetypes",
                     "qualname": "TypeParser.infer_table",
                     "kind": "function",
                     "doc": "<p>Infer the underlying common type for each column of a table of strings</p>\n\n<p>For each column, if the values do not have the same apparent type, the resulting type will be narrowest possible type that will encompass all values in the column. See <code>parsetypes.reduce_types()</code> for more information.</p>\n\n<p>Note that the inferred types of every individual value must all be able to fit into memory at once.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p><code>rows</code>\n: table of strings for which the types should be inferred, in row-major order</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>inferred types</p>\n\n<h2 id=\"examples\">Examples</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"n\">parser</span> <span class=\"o\">=</span> <span class=\"n\">TypeParser</span><span class=\"p\">()</span>\n<span class=\"n\">parser</span><span class=\"o\">.</span><span class=\"n\">infer_table</span><span class=\"p\">([</span>\n        <span class=\"p\">[</span><span class=\"s2\">&quot;1&quot;</span><span class=\"p\">,</span>   <span class=\"s2\">&quot;true&quot;</span><span class=\"p\">,</span>  <span class=\"s2\">&quot;1&quot;</span><span class=\"p\">],</span>\n        <span class=\"p\">[</span><span class=\"s2\">&quot;2&quot;</span><span class=\"p\">,</span>   <span class=\"s2\">&quot;false&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;2.3&quot;</span><span class=\"p\">],</span>\n        <span class=\"p\">[</span><span class=\"s2\">&quot;3.4&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;2&quot;</span><span class=\"p\">,</span>     <span class=\"s2\">&quot;abc&quot;</span><span class=\"p\">],</span>\n<span class=\"p\">])</span>\n<span class=\"c1\"># [float, int, str]</span>\n</code></pre>\n</div>\n",
-                    "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">rows</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Type</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">decimal</span><span class=\"o\">.</span><span class=\"n\">Decimal</span><span class=\"p\">,</span> <span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">,</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"n\">decimal</span><span class=\"o\">.</span><span class=\"n\">Decimal</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"n\">NoneType</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">decimal</span><span class=\"o\">.</span><span class=\"n\">Decimal</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"kc\">None</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"n\">decimal</span><span class=\"o\">.</span><span class=\"n\">Decimal</span><span class=\"p\">]],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">]],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"n\">NoneType</span><span class=\"p\">]]]]]</span>:</span></span>",
+                    "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">rows</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Type</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">decimal</span><span class=\"o\">.</span><span class=\"n\">Decimal</span><span class=\"p\">,</span> <span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">,</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"n\">decimal</span><span class=\"o\">.</span><span class=\"n\">Decimal</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"n\">NoneType</span><span class=\"p\">]]]]</span>:</span></span>",
                     "funcdef": "def"
                 },
                 "parsetypes.TypeParser.parse": {
                     "fullname": "parsetypes.TypeParser.parse",
                     "modulename": "parsetypes",
                     "qualname": "TypeParser.parse",
                     "kind": "function",
                     "doc": "<p>Parse a string and convert it to its underlying type</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p><code>value</code>\n: the string to be parsed</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>converted value</p>\n\n<h2 id=\"examples\">Examples</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"n\">parser</span> <span class=\"o\">=</span> <span class=\"n\">TypeParser</span><span class=\"p\">()</span>\n<span class=\"n\">parser</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s2\">&quot;true&quot;</span><span class=\"p\">)</span>  <span class=\"c1\"># True</span>\n<span class=\"n\">parser</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s2\">&quot;2.0&quot;</span><span class=\"p\">)</span>   <span class=\"c1\"># 2.</span>\n<span class=\"n\">parser</span><span class=\"o\">.</span><span class=\"n\">parse</span><span class=\"p\">(</span><span class=\"s2\">&quot;abc&quot;</span><span class=\"p\">)</span>   <span class=\"c1\"># &quot;abc&quot;</span>\n</code></pre>\n</div>\n",
-                    "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">value</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">decimal</span><span class=\"o\">.</span><span class=\"n\">Decimal</span><span class=\"p\">,</span> <span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">,</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"n\">decimal</span><span class=\"o\">.</span><span class=\"n\">Decimal</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"n\">NoneType</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">decimal</span><span class=\"o\">.</span><span class=\"n\">Decimal</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"kc\">None</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"n\">decimal</span><span class=\"o\">.</span><span class=\"n\">Decimal</span><span class=\"p\">]],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">]],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"n\">NoneType</span><span class=\"p\">]]]</span>:</span></span>",
+                    "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">value</span><span class=\"p\">:</span> <span class=\"nb\">str</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">decimal</span><span class=\"o\">.</span><span class=\"n\">Decimal</span><span class=\"p\">,</span> <span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">,</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"n\">decimal</span><span class=\"o\">.</span><span class=\"n\">Decimal</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"n\">NoneType</span><span class=\"p\">]]</span>:</span></span>",
                     "funcdef": "def"
                 },
                 "parsetypes.TypeParser.parse_series": {
                     "fullname": "parsetypes.TypeParser.parse_series",
                     "modulename": "parsetypes",
                     "qualname": "TypeParser.parse_series",
                     "kind": "function",
                     "doc": "<p>Parse a series of strings and convert them to their underlying common type</p>\n\n<p>If the values in the series do not have the same apparent type, the common type is taken as the narrowest possible type that will encompass all values in the series. See <code>parsetypes.reduce_types()</code> for more information.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p><code>values</code>\n: series of strings to be parsed</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>converted values</p>\n\n<h2 id=\"examples\">Examples</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"n\">parser</span> <span class=\"o\">=</span> <span class=\"n\">TypeParser</span><span class=\"p\">()</span>\n<span class=\"n\">parser</span><span class=\"o\">.</span><span class=\"n\">parse_series</span><span class=\"p\">([</span><span class=\"s2\">&quot;1&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;2&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;3&quot;</span><span class=\"p\">])</span>        <span class=\"c1\"># [1, 2, 3]</span>\n<span class=\"n\">parser</span><span class=\"o\">.</span><span class=\"n\">parse_series</span><span class=\"p\">([</span><span class=\"s2\">&quot;5&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;6.7&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;8.&quot;</span><span class=\"p\">])</span>     <span class=\"c1\"># [5., 6.7, 8.]</span>\n<span class=\"n\">parser</span><span class=\"o\">.</span><span class=\"n\">parse_series</span><span class=\"p\">([</span><span class=\"s2\">&quot;true&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;false&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;&quot;</span><span class=\"p\">])</span>  <span class=\"c1\"># [True, False, None]</span>\n<span class=\"n\">parser</span><span class=\"o\">.</span><span class=\"n\">parse_series</span><span class=\"p\">([</span><span class=\"s2\">&quot;1&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;2.3&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;abc&quot;</span><span class=\"p\">])</span>    <span class=\"c1\"># [&quot;1&quot;, &quot;2.3&quot;, &quot;abc&quot;]</span>\n</code></pre>\n</div>\n",
-                    "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">values</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">decimal</span><span class=\"o\">.</span><span class=\"n\">Decimal</span><span class=\"p\">,</span> <span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">,</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"n\">decimal</span><span class=\"o\">.</span><span class=\"n\">Decimal</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"n\">NoneType</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">decimal</span><span class=\"o\">.</span><span class=\"n\">Decimal</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"kc\">None</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"n\">decimal</span><span class=\"o\">.</span><span class=\"n\">Decimal</span><span class=\"p\">]],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">]],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"n\">NoneType</span><span class=\"p\">]]]]</span>:</span></span>",
+                    "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">values</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">decimal</span><span class=\"o\">.</span><span class=\"n\">Decimal</span><span class=\"p\">,</span> <span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">,</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"n\">decimal</span><span class=\"o\">.</span><span class=\"n\">Decimal</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"n\">NoneType</span><span class=\"p\">]]]</span>:</span></span>",
                     "funcdef": "def"
                 },
                 "parsetypes.TypeParser.parse_table": {
                     "fullname": "parsetypes.TypeParser.parse_table",
                     "modulename": "parsetypes",
                     "qualname": "TypeParser.parse_table",
                     "kind": "function",
                     "doc": "<p>Parse a table of strings and convert them to the underlying common type of each column</p>\n\n<p>For each column, if the values do not have the same apparent type, the common type is taken as the narrowest possible type that will encompass all values in the column. See <code>parsetypes.reduce_types()</code> for more information.</p>\n\n<p>Note that the type inference requires that the inferred types of every individual value must all be able to fit into memory at once.</p>\n\n<p>This is a function that computes the entire table and returns it all at once. The generator <code>iterate_table()</code> behaves analogously, except that it computes and yields each row one at a time.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p><code>rows</code>\n: table of strings to be parsed, in row-major order</p>\n\n<p><code>iterator</code>\n: whether the parsed values should be yielded as an iterator. If False, which is the default, the entire table is computed and returned as a list of lists. If True, this function behaves as a generator, and the rows of the table are computed and yielded one at a time. However, note that even when set to True, the type inference requires that inferred type of each individual value must all be able to fit into memory at once.</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>converted table of values, in row-major order</p>\n\n<h2 id=\"examples\">Examples</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"n\">parser</span> <span class=\"o\">=</span> <span class=\"n\">TypeParser</span><span class=\"p\">()</span>\n<span class=\"n\">table</span> <span class=\"o\">=</span> <span class=\"n\">parser</span><span class=\"o\">.</span><span class=\"n\">parse_table</span><span class=\"p\">([</span>\n        <span class=\"p\">[</span><span class=\"s2\">&quot;1&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;5&quot;</span><span class=\"p\">,</span>   <span class=\"s2\">&quot;true&quot;</span><span class=\"p\">,</span>  <span class=\"s2\">&quot;1&quot;</span><span class=\"p\">],</span>\n        <span class=\"p\">[</span><span class=\"s2\">&quot;2&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;6.7&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;false&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;2.3&quot;</span><span class=\"p\">],</span>\n        <span class=\"p\">[</span><span class=\"s2\">&quot;3&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;8.0&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;&quot;</span><span class=\"p\">,</span>     <span class=\"s2\">&quot;abc&quot;</span><span class=\"p\">],</span>\n<span class=\"p\">]):</span>\n<span class=\"k\">assert</span> <span class=\"n\">table</span> <span class=\"o\">==</span> <span class=\"p\">[</span>\n        <span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mf\">5.</span><span class=\"p\">,</span>  <span class=\"kc\">True</span><span class=\"p\">,</span>  <span class=\"s2\">&quot;1&quot;</span><span class=\"p\">],</span>\n        <span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mf\">6.7</span><span class=\"p\">,</span> <span class=\"kc\">False</span><span class=\"p\">,</span> <span class=\"s2\">&quot;2.3&quot;</span><span class=\"p\">],</span>\n        <span class=\"p\">[</span><span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mf\">8.</span><span class=\"p\">,</span>  <span class=\"kc\">None</span><span class=\"p\">,</span>  <span class=\"s2\">&quot;abc&quot;</span><span class=\"p\">],</span>\n<span class=\"p\">]</span>\n</code></pre>\n</div>\n",
-                    "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">rows</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">decimal</span><span class=\"o\">.</span><span class=\"n\">Decimal</span><span class=\"p\">,</span> <span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">,</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"n\">decimal</span><span class=\"o\">.</span><span class=\"n\">Decimal</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"n\">NoneType</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">decimal</span><span class=\"o\">.</span><span class=\"n\">Decimal</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"kc\">None</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"n\">decimal</span><span class=\"o\">.</span><span class=\"n\">Decimal</span><span class=\"p\">]],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">]],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"n\">NoneType</span><span class=\"p\">]]]]]</span>:</span></span>",
+                    "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">rows</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">) -> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">typing</span><span class=\"o\">.</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">decimal</span><span class=\"o\">.</span><span class=\"n\">Decimal</span><span class=\"p\">,</span> <span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">,</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"n\">decimal</span><span class=\"o\">.</span><span class=\"n\">Decimal</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"n\">NoneType</span><span class=\"p\">]]]]</span>:</span></span>",
                     "funcdef": "def"
                 },
                 "parsetypes.TypeParser.iterate_table": {
                     "fullname": "parsetypes.TypeParser.iterate_table",
                     "modulename": "parsetypes",
                     "qualname": "TypeParser.iterate_table",
                     "kind": "function",
                     "doc": "<p>Parse a table of strings for the underlying common type of each column, then convert and yield each row</p>\n\n<p>For each column, if the values do not have the same apparent type, the common type is taken as the narrowest possible type that will encompass all values in the column. See <code>parsetypes.reduce_types()</code> for more information.</p>\n\n<p>This is a generator that computes and yields each row one at a time. The function <code>parse_table()</code> behaves analogously, except that it computes the entire table and returns it as a list of lists. However, note that although this is a generator, the type inference still requires that the inferred types of every individual value must all be able to fit into memory at once.</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p><code>rows</code>\n: table of strings to be parsed, in row-major order</p>\n\n<h2 id=\"yields\">Yields</h2>\n\n<p>each row of converted table values</p>\n\n<h2 id=\"examples\">Examples</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"n\">parser</span> <span class=\"o\">=</span> <span class=\"n\">TypeParser</span><span class=\"p\">()</span>\n<span class=\"n\">table</span> <span class=\"o\">=</span> <span class=\"n\">parser</span><span class=\"o\">.</span><span class=\"n\">iterate_table</span><span class=\"p\">([</span>\n        <span class=\"p\">[</span><span class=\"s2\">&quot;1&quot;</span><span class=\"p\">,</span>   <span class=\"s2\">&quot;true&quot;</span><span class=\"p\">,</span>  <span class=\"s2\">&quot;1&quot;</span><span class=\"p\">],</span>\n        <span class=\"p\">[</span><span class=\"s2\">&quot;2&quot;</span><span class=\"p\">,</span>   <span class=\"s2\">&quot;false&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;2.3&quot;</span><span class=\"p\">],</span>\n        <span class=\"p\">[</span><span class=\"s2\">&quot;3.4&quot;</span><span class=\"p\">,</span> <span class=\"s2\">&quot;2&quot;</span><span class=\"p\">,</span>     <span class=\"s2\">&quot;abc&quot;</span><span class=\"p\">],</span>\n<span class=\"p\">]):</span>\n<span class=\"k\">assert</span> <span class=\"nb\">next</span><span class=\"p\">(</span><span class=\"n\">table</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"p\">[</span><span class=\"mf\">1.</span><span class=\"p\">,</span>  <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"s2\">&quot;1&quot;</span><span class=\"p\">]</span>\n<span class=\"k\">assert</span> <span class=\"nb\">next</span><span class=\"p\">(</span><span class=\"n\">table</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"p\">[</span><span class=\"mf\">2.</span><span class=\"p\">,</span>  <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"s2\">&quot;2.3&quot;</span><span class=\"p\">]</span>\n<span class=\"k\">assert</span> <span class=\"nb\">next</span><span class=\"p\">(</span><span class=\"n\">table</span><span class=\"p\">)</span> <span class=\"o\">==</span> <span class=\"p\">[</span><span class=\"mf\">3.4</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"s2\">&quot;abc&quot;</span><span class=\"p\">]</span>\n</code></pre>\n</div>\n",
-                    "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">rows</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Iterator</span><span class=\"p\">[</span><span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">decimal</span><span class=\"o\">.</span><span class=\"n\">Decimal</span><span class=\"p\">,</span> <span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">,</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"n\">decimal</span><span class=\"o\">.</span><span class=\"n\">Decimal</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"n\">NoneType</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">decimal</span><span class=\"o\">.</span><span class=\"n\">Decimal</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"kc\">None</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"n\">decimal</span><span class=\"o\">.</span><span class=\"n\">Decimal</span><span class=\"p\">]],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">]],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"n\">NoneType</span><span class=\"p\">]]]]]</span>:</span></span>",
+                    "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"bp\">self</span>,</span><span class=\"param\">\t<span class=\"n\">rows</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">Sequence</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Iterator</span><span class=\"p\">[</span><span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">decimal</span><span class=\"o\">.</span><span class=\"n\">Decimal</span><span class=\"p\">,</span> <span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">,</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"n\">decimal</span><span class=\"o\">.</span><span class=\"n\">Decimal</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"n\">NoneType</span><span class=\"p\">]]]]</span>:</span></span>",
                     "funcdef": "def"
                 },
                 "parsetypes.reduce_types": {
                     "fullname": "parsetypes.reduce_types",
                     "modulename": "parsetypes",
                     "qualname": "reduce_types",
                     "kind": "function",
                     "doc": "<p>Reduce multiple types into a single common type.</p>\n\n<p>If the input types are not all the same, the resulting type will be narrowest possible type that will encompass all of the input types.</p>\n\n<p>This operation is useful in cases such as parsing a CSV file where each column should have a consistent type, but where the individual values in a column could be interpreted variously as ints or floats (or other types).</p>\n\n<h2 id=\"parameters\">Parameters</h2>\n\n<p><code>types</code>\n: types to be reduced</p>\n\n<h2 id=\"returns\">Returns</h2>\n\n<p>common reduced type</p>\n\n<h2 id=\"examples\">Examples</h2>\n\n<div class=\"pdoc-code codehilite\">\n<pre><span></span><code><span class=\"n\">reduce_types</span><span class=\"p\">([</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">])</span>        <span class=\"c1\"># float</span>\n<span class=\"n\">reduce_types</span><span class=\"p\">([</span><span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">])</span>         <span class=\"c1\"># int</span>\n<span class=\"n\">reduce_types</span><span class=\"p\">([</span><span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"nb\">str</span><span class=\"p\">])</span>   <span class=\"c1\"># str</span>\n</code></pre>\n</div>\n",
-                    "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">types</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">Type</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">decimal</span><span class=\"o\">.</span><span class=\"n\">Decimal</span><span class=\"p\">,</span> <span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">,</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"n\">decimal</span><span class=\"o\">.</span><span class=\"n\">Decimal</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"n\">NoneType</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">decimal</span><span class=\"o\">.</span><span class=\"n\">Decimal</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"kc\">None</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"n\">decimal</span><span class=\"o\">.</span><span class=\"n\">Decimal</span><span class=\"p\">]],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">]],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"n\">NoneType</span><span class=\"p\">]]]]]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Type</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">decimal</span><span class=\"o\">.</span><span class=\"n\">Decimal</span><span class=\"p\">,</span> <span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">,</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"n\">decimal</span><span class=\"o\">.</span><span class=\"n\">Decimal</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"n\">NoneType</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">decimal</span><span class=\"o\">.</span><span class=\"n\">Decimal</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"kc\">None</span><span class=\"p\">],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">]],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">]],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">]],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"n\">decimal</span><span class=\"o\">.</span><span class=\"n\">Decimal</span><span class=\"p\">]],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">]],</span> <span class=\"nb\">list</span><span class=\"p\">[</span><span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"n\">NoneType</span><span class=\"p\">]]]]</span>:</span></span>",
+                    "signature": "<span class=\"signature pdoc-code multiline\">(<span class=\"param\">\t<span class=\"n\">types</span><span class=\"p\">:</span> <span class=\"n\">Iterable</span><span class=\"p\">[</span><span class=\"n\">Type</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">decimal</span><span class=\"o\">.</span><span class=\"n\">Decimal</span><span class=\"p\">,</span> <span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">,</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"n\">decimal</span><span class=\"o\">.</span><span class=\"n\">Decimal</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"n\">NoneType</span><span class=\"p\">]]]]</span></span><span class=\"return-annotation\">) -> <span class=\"n\">Type</span><span class=\"p\">[</span><span class=\"n\">Union</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"nb\">int</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">decimal</span><span class=\"o\">.</span><span class=\"n\">Decimal</span><span class=\"p\">,</span> <span class=\"nb\">bool</span><span class=\"p\">,</span> <span class=\"n\">NoneType</span><span class=\"p\">,</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">str</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">int</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">float</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"n\">decimal</span><span class=\"o\">.</span><span class=\"n\">Decimal</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"nb\">bool</span><span class=\"p\">],</span> <span class=\"n\">parsetypes</span><span class=\"o\">.</span><span class=\"n\">_common</span><span class=\"o\">.</span><span class=\"n\">Nullable</span><span class=\"p\">[</span><span class=\"n\">NoneType</span><span class=\"p\">]]]</span>:</span></span>",
                     "funcdef": "def"
                 }
             },
             "docInfo": {
                 "parsetypes": {
                     "qualname": 0,
                     "fullname": 1,
@@ -991,78 +991,78 @@
                     "doc": 502
                 },
                 "parsetypes.TypeParser.infer": {
                     "qualname": 2,
                     "fullname": 3,
                     "annotation": 0,
                     "default_value": 0,
-                    "signature": 422,
+                    "signature": 202,
                     "bases": 0,
                     "doc": 151
                 },
                 "parsetypes.TypeParser.infer_series": {
                     "qualname": 3,
                     "fullname": 4,
                     "annotation": 0,
                     "default_value": 0,
-                    "signature": 428,
+                    "signature": 208,
                     "bases": 0,
                     "doc": 244
                 },
                 "parsetypes.TypeParser.infer_table": {
                     "qualname": 3,
                     "fullname": 4,
                     "annotation": 0,
                     "default_value": 0,
-                    "signature": 446,
+                    "signature": 226,
                     "bases": 0,
                     "doc": 256
                 },
                 "parsetypes.TypeParser.parse": {
                     "qualname": 2,
                     "fullname": 3,
                     "annotation": 0,
                     "default_value": 0,
-                    "signature": 418,
+                    "signature": 198,
                     "bases": 0,
                     "doc": 137
                 },
                 "parsetypes.TypeParser.parse_series": {
                     "qualname": 3,
                     "fullname": 4,
                     "annotation": 0,
                     "default_value": 0,
-                    "signature": 433,
+                    "signature": 213,
                     "bases": 0,
                     "doc": 308
                 },
                 "parsetypes.TypeParser.parse_table": {
                     "qualname": 3,
                     "fullname": 4,
                     "annotation": 0,
                     "default_value": 0,
-                    "signature": 441,
+                    "signature": 221,
                     "bases": 0,
                     "doc": 534
                 },
                 "parsetypes.TypeParser.iterate_table": {
                     "qualname": 3,
                     "fullname": 4,
                     "annotation": 0,
                     "default_value": 0,
-                    "signature": 436,
+                    "signature": 216,
                     "bases": 0,
                     "doc": 442
                 },
                 "parsetypes.reduce_types": {
                     "qualname": 2,
                     "fullname": 3,
                     "annotation": 0,
                     "default_value": 0,
-                    "signature": 816,
+                    "signature": 376,
                     "bases": 0,
                     "doc": 188
                 }
             },
             "length": 21,
             "save": true
         },
@@ -2118,36 +2118,36 @@
                         "parsetypes.TypeParser.parse_float": {
                             "tf": 8.54400374531753
                         },
                         "parsetypes.TypeParser.parse_decimal": {
                             "tf": 8.774964387392123
                         },
                         "parsetypes.TypeParser.infer": {
-                            "tf": 18.466185312619388
+                            "tf": 12.84523257866513
                         },
                         "parsetypes.TypeParser.infer_series": {
-                            "tf": 18.601075237738275
+                            "tf": 13.038404810405298
                         },
                         "parsetypes.TypeParser.infer_table": {
-                            "tf": 18.973665961010276
+                            "tf": 13.564659966250536
                         },
                         "parsetypes.TypeParser.parse": {
-                            "tf": 18.384776310850235
+                            "tf": 12.727922061357855
                         },
                         "parsetypes.TypeParser.parse_series": {
-                            "tf": 18.708286933869708
+                            "tf": 13.19090595827292
                         },
                         "parsetypes.TypeParser.parse_table": {
-                            "tf": 18.867962264113206
+                            "tf": 13.416407864998739
                         },
                         "parsetypes.TypeParser.iterate_table": {
-                            "tf": 18.76166303929372
+                            "tf": 13.2664991614216
                         },
                         "parsetypes.reduce_types": {
-                            "tf": 25.65151067676132
+                            "tf": 17.4928556845359
                         }
                     },
                     "df": 19,
                     "t": {
                         "docs": {},
                         "df": 0,
                         "r": {
@@ -2290,36 +2290,36 @@
                                         "parsetypes.TypeParser.parse_float": {
                                             "tf": 1.7320508075688772
                                         },
                                         "parsetypes.TypeParser.parse_decimal": {
                                             "tf": 1.7320508075688772
                                         },
                                         "parsetypes.TypeParser.infer": {
-                                            "tf": 2
+                                            "tf": 1.4142135623730951
                                         },
                                         "parsetypes.TypeParser.infer_series": {
-                                            "tf": 2
+                                            "tf": 1.4142135623730951
                                         },
                                         "parsetypes.TypeParser.infer_table": {
-                                            "tf": 2
+                                            "tf": 1.4142135623730951
                                         },
                                         "parsetypes.TypeParser.parse": {
-                                            "tf": 2
+                                            "tf": 1.4142135623730951
                                         },
                                         "parsetypes.TypeParser.parse_series": {
-                                            "tf": 2
+                                            "tf": 1.4142135623730951
                                         },
                                         "parsetypes.TypeParser.parse_table": {
-                                            "tf": 2
+                                            "tf": 1.4142135623730951
                                         },
                                         "parsetypes.TypeParser.iterate_table": {
-                                            "tf": 2
+                                            "tf": 1.4142135623730951
                                         },
                                         "parsetypes.reduce_types": {
-                                            "tf": 2.8284271247461903
+                                            "tf": 2
                                         }
                                     },
                                     "df": 18
                                 }
                             }
                         }
                     },
@@ -2403,36 +2403,36 @@
                                                     "parsetypes.TypeParser.__init__": {
                                                         "tf": 1
                                                     },
                                                     "parsetypes.TypeParser.parse_decimal": {
                                                         "tf": 1.4142135623730951
                                                     },
                                                     "parsetypes.TypeParser.infer": {
-                                                        "tf": 2.8284271247461903
+                                                        "tf": 2
                                                     },
                                                     "parsetypes.TypeParser.infer_series": {
-                                                        "tf": 2.8284271247461903
+                                                        "tf": 2
                                                     },
                                                     "parsetypes.TypeParser.infer_table": {
-                                                        "tf": 2.8284271247461903
+                                                        "tf": 2
                                                     },
                                                     "parsetypes.TypeParser.parse": {
-                                                        "tf": 2.8284271247461903
+                                                        "tf": 2
                                                     },
                                                     "parsetypes.TypeParser.parse_series": {
-                                                        "tf": 2.8284271247461903
+                                                        "tf": 2
                                                     },
                                                     "parsetypes.TypeParser.parse_table": {
-                                                        "tf": 2.8284271247461903
+                                                        "tf": 2
                                                     },
                                                     "parsetypes.TypeParser.iterate_table": {
-                                                        "tf": 2.8284271247461903
+                                                        "tf": 2
                                                     },
                                                     "parsetypes.reduce_types": {
-                                                        "tf": 4
+                                                        "tf": 2.8284271247461903
                                                     }
                                                 },
                                                 "df": 10
                                             }
                                         }
                                     }
                                 }
@@ -2508,36 +2508,36 @@
                                             "parsetypes.TypeParser.__init__": {
                                                 "tf": 1
                                             },
                                             "parsetypes.TypeParser.parse_float": {
                                                 "tf": 1
                                             },
                                             "parsetypes.TypeParser.infer": {
-                                                "tf": 2
+                                                "tf": 1.4142135623730951
                                             },
                                             "parsetypes.TypeParser.infer_series": {
-                                                "tf": 2
+                                                "tf": 1.4142135623730951
                                             },
                                             "parsetypes.TypeParser.infer_table": {
-                                                "tf": 2
+                                                "tf": 1.4142135623730951
                                             },
                                             "parsetypes.TypeParser.parse": {
-                                                "tf": 2
+                                                "tf": 1.4142135623730951
                                             },
                                             "parsetypes.TypeParser.parse_series": {
-                                                "tf": 2
+                                                "tf": 1.4142135623730951
                                             },
                                             "parsetypes.TypeParser.parse_table": {
-                                                "tf": 2
+                                                "tf": 1.4142135623730951
                                             },
                                             "parsetypes.TypeParser.iterate_table": {
-                                                "tf": 2
+                                                "tf": 1.4142135623730951
                                             },
                                             "parsetypes.reduce_types": {
-                                                "tf": 2.8284271247461903
+                                                "tf": 2
                                             }
                                         },
                                         "df": 10
                                     }
                                 }
                             }
                         }
@@ -2552,40 +2552,64 @@
                                 "docs": {},
                                 "df": 0,
                                 "t": {
                                     "docs": {
                                         "parsetypes.TypeParser.__init__": {
                                             "tf": 1
                                         },
-                                        "parsetypes.TypeParser.infer": {
-                                            "tf": 3.4641016151377544
-                                        },
-                                        "parsetypes.TypeParser.infer_series": {
-                                            "tf": 3.4641016151377544
-                                        },
                                         "parsetypes.TypeParser.infer_table": {
-                                            "tf": 3.605551275463989
-                                        },
-                                        "parsetypes.TypeParser.parse": {
-                                            "tf": 3.4641016151377544
+                                            "tf": 1
                                         },
                                         "parsetypes.TypeParser.parse_series": {
-                                            "tf": 3.605551275463989
+                                            "tf": 1
                                         },
                                         "parsetypes.TypeParser.parse_table": {
-                                            "tf": 3.7416573867739413
+                                            "tf": 1.4142135623730951
                                         },
                                         "parsetypes.TypeParser.iterate_table": {
-                                            "tf": 3.605551275463989
-                                        },
-                                        "parsetypes.reduce_types": {
-                                            "tf": 4.898979485566356
+                                            "tf": 1
                                         }
                                     },
-                                    "df": 9
+                                    "df": 5
+                                }
+                            }
+                        }
+                    },
+                    "o": {
+                        "docs": {},
+                        "df": 0,
+                        "p": {
+                            "docs": {},
+                            "df": 0,
+                            "t": {
+                                "docs": {},
+                                "df": 0,
+                                "i": {
+                                    "docs": {},
+                                    "df": 0,
+                                    "o": {
+                                        "docs": {},
+                                        "df": 0,
+                                        "n": {
+                                            "docs": {},
+                                            "df": 0,
+                                            "a": {
+                                                "docs": {},
+                                                "df": 0,
+                                                "l": {
+                                                    "docs": {
+                                                        "parsetypes.TypeParser.__init__": {
+                                                            "tf": 1.4142135623730951
+                                                        }
+                                                    },
+                                                    "df": 1
+                                                }
+                                            }
+                                        }
+                                    }
                                 }
                             }
                         }
                     },
                     "s": {
                         "docs": {},
                         "df": 0,
@@ -2624,36 +2648,36 @@
                                     "parsetypes.TypeParser.parse_float": {
                                         "tf": 1
                                     },
                                     "parsetypes.TypeParser.parse_decimal": {
                                         "tf": 1
                                     },
                                     "parsetypes.TypeParser.infer": {
-                                        "tf": 2.23606797749979
+                                        "tf": 1.7320508075688772
                                     },
                                     "parsetypes.TypeParser.infer_series": {
-                                        "tf": 2.23606797749979
+                                        "tf": 1.7320508075688772
                                     },
                                     "parsetypes.TypeParser.infer_table": {
-                                        "tf": 2.23606797749979
+                                        "tf": 1.7320508075688772
                                     },
                                     "parsetypes.TypeParser.parse": {
-                                        "tf": 2.23606797749979
+                                        "tf": 1.7320508075688772
                                     },
                                     "parsetypes.TypeParser.parse_series": {
-                                        "tf": 2.23606797749979
+                                        "tf": 1.7320508075688772
                                     },
                                     "parsetypes.TypeParser.parse_table": {
-                                        "tf": 2.23606797749979
+                                        "tf": 1.7320508075688772
                                     },
                                     "parsetypes.TypeParser.iterate_table": {
-                                        "tf": 2.23606797749979
+                                        "tf": 1.7320508075688772
                                     },
                                     "parsetypes.reduce_types": {
-                                        "tf": 2.8284271247461903
+                                        "tf": 2
                                     }
                                 },
                                 "df": 19
                             }
                         },
                         "e": {
                             "docs": {},
@@ -2865,79 +2889,55 @@
                             "df": 0,
                             "n": {
                                 "docs": {},
                                 "df": 0,
                                 "e": {
                                     "docs": {
                                         "parsetypes.TypeParser.__init__": {
-                                            "tf": 2.449489742783178
+                                            "tf": 2
                                         },
                                         "parsetypes.TypeParser.parse_none": {
                                             "tf": 1
-                                        },
-                                        "parsetypes.TypeParser.infer": {
-                                            "tf": 1
-                                        },
-                                        "parsetypes.TypeParser.infer_series": {
-                                            "tf": 1
-                                        },
-                                        "parsetypes.TypeParser.infer_table": {
-                                            "tf": 1
-                                        },
-                                        "parsetypes.TypeParser.parse": {
-                                            "tf": 1
-                                        },
-                                        "parsetypes.TypeParser.parse_series": {
-                                            "tf": 1
-                                        },
-                                        "parsetypes.TypeParser.parse_table": {
-                                            "tf": 1
-                                        },
-                                        "parsetypes.TypeParser.iterate_table": {
-                                            "tf": 1
-                                        },
-                                        "parsetypes.reduce_types": {
-                                            "tf": 1.4142135623730951
                                         }
                                     },
-                                    "df": 10,
+                                    "df": 2,
                                     "t": {
                                         "docs": {},
                                         "df": 0,
                                         "y": {
                                             "docs": {},
                                             "df": 0,
                                             "p": {
                                                 "docs": {},
                                                 "df": 0,
                                                 "e": {
                                                     "docs": {
                                                         "parsetypes.TypeParser.infer": {
-                                                            "tf": 1.7320508075688772
+                                                            "tf": 1.4142135623730951
                                                         },
                                                         "parsetypes.TypeParser.infer_series": {
-                                                            "tf": 1.7320508075688772
+                                                            "tf": 1.4142135623730951
                                                         },
                                                         "parsetypes.TypeParser.infer_table": {
-                                                            "tf": 1.7320508075688772
+                                                            "tf": 1.4142135623730951
                                                         },
                                                         "parsetypes.TypeParser.parse": {
-                                                            "tf": 1.7320508075688772
+                                                            "tf": 1.4142135623730951
                                                         },
                                                         "parsetypes.TypeParser.parse_series": {
-                                                            "tf": 1.7320508075688772
+                                                            "tf": 1.4142135623730951
                                                         },
                                                         "parsetypes.TypeParser.parse_table": {
-                                                            "tf": 1.7320508075688772
+                                                            "tf": 1.4142135623730951
                                                         },
                                                         "parsetypes.TypeParser.iterate_table": {
-                                                            "tf": 1.7320508075688772
+                                                            "tf": 1.4142135623730951
                                                         },
                                                         "parsetypes.reduce_types": {
-                                                            "tf": 2.449489742783178
+                                                            "tf": 2
                                                         }
                                                     },
                                                     "df": 8
                                                 }
                                             }
                                         }
                                     }
@@ -3017,36 +3017,36 @@
                                             "df": 0,
                                             "l": {
                                                 "docs": {},
                                                 "df": 0,
                                                 "e": {
                                                     "docs": {
                                                         "parsetypes.TypeParser.infer": {
-                                                            "tf": 3.4641016151377544
+                                                            "tf": 2.449489742783178
                                                         },
                                                         "parsetypes.TypeParser.infer_series": {
-                                                            "tf": 3.4641016151377544
+                                                            "tf": 2.449489742783178
                                                         },
                                                         "parsetypes.TypeParser.infer_table": {
-                                                            "tf": 3.4641016151377544
+                                                            "tf": 2.449489742783178
                                                         },
                                                         "parsetypes.TypeParser.parse": {
-                                                            "tf": 3.4641016151377544
+                                                            "tf": 2.449489742783178
                                                         },
                                                         "parsetypes.TypeParser.parse_series": {
-                                                            "tf": 3.4641016151377544
+                                                            "tf": 2.449489742783178
                                                         },
                                                         "parsetypes.TypeParser.parse_table": {
-                                                            "tf": 3.4641016151377544
+                                                            "tf": 2.449489742783178
                                                         },
                                                         "parsetypes.TypeParser.iterate_table": {
-                                                            "tf": 3.4641016151377544
+                                                            "tf": 2.449489742783178
                                                         },
                                                         "parsetypes.reduce_types": {
-                                                            "tf": 4.898979485566356
+                                                            "tf": 3.4641016151377544
                                                         }
                                                     },
                                                     "df": 8
                                                 }
                                             }
                                         }
                                     }
@@ -3202,36 +3202,36 @@
                                     "parsetypes.TypeParser.__init__": {
                                         "tf": 1
                                     },
                                     "parsetypes.TypeParser.parse_int": {
                                         "tf": 1
                                     },
                                     "parsetypes.TypeParser.infer": {
-                                        "tf": 2
+                                        "tf": 1.4142135623730951
                                     },
                                     "parsetypes.TypeParser.infer_series": {
-                                        "tf": 2
+                                        "tf": 1.4142135623730951
                                     },
                                     "parsetypes.TypeParser.infer_table": {
-                                        "tf": 2
+                                        "tf": 1.4142135623730951
                                     },
                                     "parsetypes.TypeParser.parse": {
-                                        "tf": 2
+                                        "tf": 1.4142135623730951
                                     },
                                     "parsetypes.TypeParser.parse_series": {
-                                        "tf": 2
+                                        "tf": 1.4142135623730951
                                     },
                                     "parsetypes.TypeParser.parse_table": {
-                                        "tf": 2
+                                        "tf": 1.4142135623730951
                                     },
                                     "parsetypes.TypeParser.iterate_table": {
-                                        "tf": 2
+                                        "tf": 1.4142135623730951
                                     },
                                     "parsetypes.reduce_types": {
-                                        "tf": 2.8284271247461903
+                                        "tf": 2
                                     }
                                 },
                                 "df": 10
                             },
                             "f": {
                                 "docs": {
                                     "parsetypes.TypeParser.__init__": {
@@ -3284,36 +3284,36 @@
                                     "df": 0,
                                     "o": {
                                         "docs": {},
                                         "df": 0,
                                         "n": {
                                             "docs": {
                                                 "parsetypes.TypeParser.infer": {
-                                                    "tf": 3.4641016151377544
+                                                    "tf": 2.449489742783178
                                                 },
                                                 "parsetypes.TypeParser.infer_series": {
-                                                    "tf": 3.4641016151377544
+                                                    "tf": 2.449489742783178
                                                 },
                                                 "parsetypes.TypeParser.infer_table": {
-                                                    "tf": 3.4641016151377544
+                                                    "tf": 2.449489742783178
                                                 },
                                                 "parsetypes.TypeParser.parse": {
-                                                    "tf": 3.4641016151377544
+                                                    "tf": 2.449489742783178
                                                 },
                                                 "parsetypes.TypeParser.parse_series": {
-                                                    "tf": 3.4641016151377544
+                                                    "tf": 2.449489742783178
                                                 },
                                                 "parsetypes.TypeParser.parse_table": {
-                                                    "tf": 3.4641016151377544
+                                                    "tf": 2.449489742783178
                                                 },
                                                 "parsetypes.TypeParser.iterate_table": {
-                                                    "tf": 3.4641016151377544
+                                                    "tf": 2.449489742783178
                                                 },
                                                 "parsetypes.reduce_types": {
-                                                    "tf": 4.898979485566356
+                                                    "tf": 3.4641016151377544
                                                 }
                                             },
                                             "df": 8
                                         }
                                     }
                                 }
                             }
@@ -3384,36 +3384,36 @@
                                                     "df": 0,
                                                     "e": {
                                                         "docs": {},
                                                         "df": 0,
                                                         "s": {
                                                             "docs": {
                                                                 "parsetypes.TypeParser.infer": {
-                                                                    "tf": 3.4641016151377544
+                                                                    "tf": 2.449489742783178
                                                                 },
                                                                 "parsetypes.TypeParser.infer_series": {
-                                                                    "tf": 3.4641016151377544
+                                                                    "tf": 2.449489742783178
                                                                 },
                                                                 "parsetypes.TypeParser.infer_table": {
-                                                                    "tf": 3.4641016151377544
+                                                                    "tf": 2.449489742783178
                                                                 },
                                                                 "parsetypes.TypeParser.parse": {
-                                                                    "tf": 3.4641016151377544
+                                                                    "tf": 2.449489742783178
                                                                 },
                                                                 "parsetypes.TypeParser.parse_series": {
-                                                                    "tf": 3.4641016151377544
+                                                                    "tf": 2.449489742783178
                                                                 },
                                                                 "parsetypes.TypeParser.parse_table": {
-                                                                    "tf": 3.4641016151377544
+                                                                    "tf": 2.449489742783178
                                                                 },
                                                                 "parsetypes.TypeParser.iterate_table": {
-                                                                    "tf": 3.4641016151377544
+                                                                    "tf": 2.449489742783178
                                                                 },
                                                                 "parsetypes.reduce_types": {
-                                                                    "tf": 4.898979485566356
+                                                                    "tf": 3.4641016151377544
                                                                 }
                                                             },
                                                             "df": 8
                                                         }
                                                     }
                                                 }
                                             }
```

### Comparing `parsetypes-0.1.1/pyproject.toml` & `parsetypes-0.2/pyproject.toml`

 * *Files 4% similar despite different names*

```diff
@@ -15,27 +15,28 @@
 	"Intended Audience :: Developers",
 	"Intended Audience :: Information Technology",
 	"Intended Audience :: Science/Research",
 	"Intended Audience :: System Administrators",
 	"License :: OSI Approved :: Mozilla Public License 2.0 (MPL 2.0)",
 	"Operating System :: OS Independent",
 	"Programming Language :: Python :: 3 :: Only",
+	"Programming Language :: Python :: 3.9",
 	"Programming Language :: Python :: 3.10",
 	"Programming Language :: Python :: 3.11",
 	"Programming Language :: Python :: 3.12",
 	"Topic :: File Formats",
 	"Topic :: Office/Business",
 	"Topic :: Scientific/Engineering :: Information Analysis",
 	"Topic :: Scientific/Engineering :: Interface Engine/Protocol Translator",
 	"Topic :: Software Development :: Libraries :: Python Modules",
 	"Topic :: Utilities",
 	"Typing :: Typed",
 ]
 keywords = ["python", "str", "string", "types", "conversion"]
-requires-python = ">=3.10"
+requires-python = ">=3.9"
 
 [project.optional-dependencies]
 dev = ["pytest ~= 7.3.1", "coverage ~= 7.2", "pdoc ~= 13.1.1", "pyroma ~= 4.2", "build ~= 0.10.0", "tox ~= 4.5.1", "tox-extras ~= 0.0.1"]
 test = ["pytest ~= 7.3.1", "coverage ~= 7.2"]
 docs = ["pdoc ~= 13.1.1"]
 metadata = ["pyroma ~= 4.2"]
 package = ["build ~= 0.10.0"]
```

### Comparing `parsetypes-0.1.1/src/parsetypes/__init__.py` & `parsetypes-0.2/src/parsetypes/__init__.py`

 * *Files 1% similar despite different names*

```diff
@@ -4,14 +4,14 @@
 	The `TypeParser` class provides configurable type inference and parsing. This can be initialised with different settings to, for example:
 	- treat `inf` as either a float or a normal string
 	- give exact Decimal values instead of floats
 	- detect inline lists
 """
 
 
-__version__ = "0.1.1"
+__version__ = "0.2"
 
 from ._common import AnyScalar, AnyScalarType, AnyValue, AnyValueType, GenericValue, Nullable
 from ._parser import TypeParser
 from ._reduce_types import reduce_types
 
 __all__ = ('TypeParser', 'reduce_types')
```

### Comparing `parsetypes-0.1.1/src/parsetypes/_common.py` & `parsetypes-0.2/src/parsetypes/_common.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,11 +1,11 @@
-from __future__ import annotations
-
 from decimal import Decimal
-from typing import Generic, Type, TypeAlias, TypeVar, Union
+from typing import Generic, Type, TypeVar, Union
+
+from ._compat import TypeAlias
 
 
 AnyScalar = Union[str, int, float, Decimal, bool, None]
 AnyScalarType = Type[AnyScalar]
 
 
 GenericValue: TypeAlias = str
@@ -38,14 +38,14 @@
 AnyContainedType: TypeAlias = Type[AnyContained]
 
 
 
 AnyValue = Union[
 	str, int, float, Decimal, bool, None,
 	Nullable[str], Nullable[int], Nullable[float], Nullable[Decimal], Nullable[bool], Nullable[None],
-	list[str], list[int], list[float], list[Decimal], list[bool], list[None],
-	list[Nullable[str]], list[Nullable[int]], list[Nullable[float]], list[Nullable[Decimal]], list[Nullable[bool]], list[Nullable[None]],
+	#list[str], list[int], list[float], list[Decimal], list[bool], list[None],
+	#list[Nullable[str]], list[Nullable[int]], list[Nullable[float]], list[Nullable[Decimal]], list[Nullable[bool]], list[Nullable[None]],
 ]
 """Union of all types recognised by `parsetypes`"""
 
 AnyValueType: TypeAlias = Type[AnyValue]
 """Type alias for all types recognised by `parsetypes`"""
```

### Comparing `parsetypes-0.1.1/src/parsetypes/_parser.py` & `parsetypes-0.2/src/parsetypes/_parser.py`

 * *Files 1% similar despite different names*

```diff
@@ -1,40 +1,39 @@
-from __future__ import annotations
-
 import math
 from decimal import Decimal
 from enum import Enum
-from types import NoneType
-from typing import Callable, Iterable, Iterator, Sequence, Type, TypeVar, Union, cast
+from typing import Callable, Iterable, Iterator, Optional, Sequence, TypeVar, cast
 
 from ._common import AnyContained, AnyContainedType, AnyValue, AnyValueType, GenericValue, Nullable
 from ._reduce_types import reduce_types, _decompose_type
 
+from ._compat import NoneType, Union
+
 
 _FloatLike = TypeVar('_FloatLike', float, Decimal)
 
 
 class _TypeTable:
 	__slots__ = ('cols')
 
-	def __init__(self, cols: int | list[list[AnyValueType]]):
+	def __init__(self, cols: Union[int, list[list[AnyValueType]]]):
 		self.cols: list[list[AnyValueType]]
 		if isinstance(cols, int):
 			self.cols = [[] for i in range(cols)]
 		else:
 			self.cols = cols
 
 	def add_row(self, row: Sequence[AnyValueType]):
 		if len(row) != len(self.cols):
 			raise ValueError(f"incorrect row length: expected {len(self.cols)}, got {len(row)}")
 		for i, t in enumerate(row):
 			self.cols[i].append(t)
 
 
-def _decompose_string_pair(string: str, delimiter: str, case_sensitive: bool) -> tuple[str, str | None]:
+def _decompose_string_pair(string: str, delimiter: str, case_sensitive: bool) -> tuple[str, Union[str, None]]:
 	if not case_sensitive:
 		delimiter = delimiter.lower()
 		operative_string = string.lower()
 	else:
 		operative_string = string
 	if delimiter in operative_string:
 		operative_parts = operative_string.split(delimiter)
@@ -64,25 +63,25 @@
 		Instances of this class can be configured with different settings for the parser and inferrer. See the constructor for more details about the available options.
 	"""
 
 	def __init__(self,
 	    *,
 		trim: bool=True,
 		use_decimal: bool=False,
-		list_delimiter: str | None=None,
+		list_delimiter: Optional[str]=None,
 		none_values: Iterable[str]=[""],
 		none_case_sensitive: bool=False,
 		true_values: Iterable[str]=["true"],
 		false_values: Iterable[str]=["false"],
 		bool_case_sensitive: bool=False,
 		int_case_sensitive: bool=False,
 		inf_values: Iterable[str]=[],
 		nan_values: Iterable[str]=[],
 		float_case_sensitive: bool=False,
-		case_sensitive: bool | None=None,
+		case_sensitive: Optional[bool]=None,
 	):
 		"""
 			Initialise a new parser
 
 			Parameters
 			----------
 			`trim`
```

### Comparing `parsetypes-0.1.1/src/parsetypes/_reduce_types.py` & `parsetypes-0.2/src/parsetypes/_reduce_types.py`

 * *Files 7% similar despite different names*

```diff
@@ -1,27 +1,27 @@
-
 import typing
 from decimal import Decimal
-from types import NoneType
-from typing import Final, Iterable, cast
+from typing import Iterable, Optional, cast
 
 from ._common import AnyBaseType, AnyContainedType, AnyContainerBaseType, AnyNullableType, AnyScalarType, AnyValueType, GenericValue, Nullable
 
+from ._compat import Final, NoneType, Union
+
 
-_TerminalValue: Final[AnyBaseType] = list
+_TerminalValue: 'Final[AnyBaseType]' = list
 
-_scalar_hierarchy: Final[dict[AnyBaseType, AnyBaseType | None]] = {
+_scalar_hierarchy: 'Final[dict[AnyBaseType, Union[AnyBaseType, None]]]' = {
 	bool: int,
 	int: Decimal,
 	Decimal: float,
 	float: str,
 	str: None,
 }
-_containers: Final[set[AnyBaseType]] = {Nullable, list}
-_type_hierarchy: Final[dict[AnyBaseType, AnyBaseType | None]] = {
+_containers: 'Final[set[AnyBaseType]]' = {Nullable, list}
+_type_hierarchy: 'Final[dict[AnyBaseType, Union[AnyBaseType, None]]]' = {
 	bool: int,
 	int: Decimal,
 	Decimal: float,
 	float: str,
 	str: Nullable,
 	Nullable: list,
 	list: None,
@@ -39,23 +39,23 @@
 			return False
 		for arg in typing.get_args(t):
 			if not _is_valid_type(arg):
 				return False
 		return True
 
 
-def _decompose_type(t: AnyValueType) -> tuple[AnyBaseType, tuple[AnyContainedType, ...] | None]:
+def _decompose_type(t: AnyValueType) -> tuple[AnyBaseType, Union[tuple[AnyContainedType, ...], None]]:
 	base = typing.get_origin(t)
 	if base is None:
 		return t, None
 	else:
 		return base, typing.get_args(t)
 
 
-def _broaden_type(t: AnyValueType, cue: AnyValueType | None=None) -> AnyValueType | None:
+def _broaden_type(t: AnyValueType, cue: Optional[AnyValueType]=None) -> Union[AnyValueType, None]:
 	"""
 		`cue` should always come before `t` in `_type_hierarchy`
 	"""
 	base, type_args = _decompose_type(t)
 	if base == str:
 		if cue is None:
 			return Nullable
@@ -100,16 +100,16 @@
 
 def _merge_types(t1: AnyValueType, t2: AnyValueType) -> AnyValueType:
 	if t1 == t2:
 		return t1
 	if (not _is_valid_type(t1)) or (not _is_valid_type(t2)):
 		return GenericValue
 
-	c: AnyValueType | None = t1
-	visited: dict[AnyValueType, tuple[AnyValueType, ...] | None] = {}
+	c: Union[AnyValueType, None] = t1
+	visited: dict[AnyValueType, Union[tuple[AnyValueType, ...], None]] = {}
 	if t1 == NoneType:
 		visited[NoneType] = None
 		visited[Nullable] = None
 	else:
 		while c is not None:
 			base, type_args = _decompose_type(c)
 			if base not in visited:
@@ -174,15 +174,15 @@
 		--------
 		```python
 		reduce_types([int, float])        # float
 		reduce_types([bool, int])         # int
 		reduce_types([int, float, str])   # str
 		```
 	"""
-	reduced_type: AnyValueType | None = None
+	reduced_type: Union[AnyValueType, None] = None
 	for t in types:
 		if reduced_type is None:
 			reduced_type = t
 		elif t != reduced_type:
 			reduced_type = _merge_types(reduced_type, t)
 		if reduced_type == _TerminalValue:
 			return _TerminalValue
```

### Comparing `parsetypes-0.1.1/src/parsetypes.egg-info/PKG-INFO` & `parsetypes-0.2/src/parsetypes.egg-info/PKG-INFO`

 * *Files 2% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: parsetypes
-Version: 0.1.1
+Version: 0.2
 Summary: Parse serialised data to recover their original underlying types
 Author-email: Yu Shiyang <yu.shiyang@gnayihs.uy>
 License: MPL-2.0
 Project-URL: Homepage, https://github.com/yushiyangk/parsetypes
 Project-URL: Documentation, https://parsetypes.gnayihs.uy/
 Project-URL: Issues, https://github.com/yushiyangk/parsetypes/issues
 Keywords: python,str,string,types,conversion
@@ -12,25 +12,26 @@
 Classifier: Intended Audience :: Developers
 Classifier: Intended Audience :: Information Technology
 Classifier: Intended Audience :: Science/Research
 Classifier: Intended Audience :: System Administrators
 Classifier: License :: OSI Approved :: Mozilla Public License 2.0 (MPL 2.0)
 Classifier: Operating System :: OS Independent
 Classifier: Programming Language :: Python :: 3 :: Only
+Classifier: Programming Language :: Python :: 3.9
 Classifier: Programming Language :: Python :: 3.10
 Classifier: Programming Language :: Python :: 3.11
 Classifier: Programming Language :: Python :: 3.12
 Classifier: Topic :: File Formats
 Classifier: Topic :: Office/Business
 Classifier: Topic :: Scientific/Engineering :: Information Analysis
 Classifier: Topic :: Scientific/Engineering :: Interface Engine/Protocol Translator
 Classifier: Topic :: Software Development :: Libraries :: Python Modules
 Classifier: Topic :: Utilities
 Classifier: Typing :: Typed
-Requires-Python: >=3.10
+Requires-Python: >=3.9
 Description-Content-Type: text/markdown
 Provides-Extra: dev
 Provides-Extra: test
 Provides-Extra: docs
 Provides-Extra: metadata
 Provides-Extra: package
 Provides-Extra: packagetest
@@ -157,14 +158,18 @@
 
 ## Changelog
 
 This project follows [PEP 440](https://peps.python.org/pep-0440/) and [Semantic Versioning (SemVer)](https://semver.org/spec/v2.0.0.html). In addition to the guarantees specified by SemVer, for versions before 1.0, this project guarantees backwards compatibility of the API for patch version updates (0.<var>y</var>.<b><var>z</var></b>).
 
 The recommended version specifier is <code>generic-path ~= <var>x</var>.<var>y</var></code> for version 1.0 and later, and <code>generic-path ~= <var>0</var>.<var>y</var>.<var>z</var></code> for versions prior to 1.0.
 
+### 0.2
+
+- Added support for Python version 3.9; previously only 3.10 and 3.11 were supported
+
 ### 0.1.1
 
 - Updated documentation
 
 ### 0.1
 
 - Initial version
```

### Comparing `parsetypes-0.1.1/tests/test_parser.py` & `parsetypes-0.2/tests/test_parser.py`

 * *Files 2% similar despite different names*

```diff
@@ -1,20 +1,19 @@
-from __future__ import annotations
-
 import itertools
 import math
 from decimal import Decimal
-from types import NoneType
 from unittest.mock import call, patch
 
 import pytest
 
 import parsetypes
 from parsetypes import AnyScalar, AnyScalarType, AnyValue, AnyValueType, Nullable, TypeParser
 
+from parsetypes._compat import NoneType, Union
+
 
 @pytest.fixture
 def default_parser():
 	return TypeParser()
 
 
 @pytest.fixture
@@ -155,15 +154,15 @@
 	not_bool_test_cases = [
 		("1", False, None),
 		("", False, None),
 	]
 
 	@staticmethod
 	@pytest.mark.parametrize(('value', 'is_bool_expected', 'expected_bool'), bool_test_cases + not_bool_test_cases)
-	def test_default(default_parser: TypeParser, value: str, is_bool_expected: bool, expected_bool: bool | None):
+	def test_default(default_parser: TypeParser, value: str, is_bool_expected: bool, expected_bool: Union[bool, None]):
 		is_bool_result = default_parser.is_bool(value)
 		assert is_bool_result == is_bool_expected
 
 		if expected_bool is None:
 			with pytest.raises(ValueError):
 				default_parser.parse_bool(value)
 		else:
@@ -208,15 +207,15 @@
 		],
 		indirect=['bool_values_parser']
 	)
 	def test_bool_values(
 		value: str,
 		bool_values_parser: TypeParser,
 		is_bool_expected: bool,
-		expected_bool: bool | None
+		expected_bool: Union[bool, None]
 	):
 		is_bool_result = bool_values_parser.is_bool(value)
 		assert is_bool_result == is_bool_expected
 
 		if expected_bool is None:
 			with pytest.raises(ValueError):
 				bool_values_parser.parse_bool(value)
@@ -254,15 +253,15 @@
 		],
 		indirect=['bool_case_sensitive_parser']
 	)
 	def test_case_sensitive(
 		value: str,
 		bool_case_sensitive_parser: TypeParser,
 		is_bool_expected: bool,
-		expected_bool: bool | None
+		expected_bool: Union[bool, None],
 	):
 		is_bool_result = bool_case_sensitive_parser.is_bool(value)
 		assert is_bool_result == is_bool_expected
 
 		if expected_bool is None:
 			with pytest.raises(ValueError):
 				bool_case_sensitive_parser.parse_bool(value)
@@ -303,15 +302,15 @@
 		],
 		indirect=['bool_trim_parser']
 	)
 	def test_trim(
 		value: str,
 		bool_trim_parser: TypeParser,
 		is_bool_expected: bool,
-		expected_bool: bool | None,
+		expected_bool: Union[bool, None],
 	):
 		is_bool_result = bool_trim_parser.is_bool(value)
 		assert is_bool_result == is_bool_expected
 
 		if expected_bool is None:
 			with pytest.raises(ValueError):
 				bool_trim_parser.parse_bool(value)
@@ -354,29 +353,29 @@
 		("0.1", False, None),
 		(".1", False, None),
 	]
 
 
 	@staticmethod
 	@pytest.mark.parametrize(('value', 'is_int_expected', 'expected_int'), int_test_cases + not_int_test_cases)
-	def test_default(default_parser: TypeParser, value: str, is_int_expected: bool, expected_int: int | None):
+	def test_default(default_parser: TypeParser, value: str, is_int_expected: bool, expected_int: Union[int, None]):
 		is_int_result = default_parser.is_int(value)
 		assert is_int_result == is_int_expected
 
 		if expected_int is None:
 			with pytest.raises(ValueError):
 				default_parser.parse_int(value)
 		else:
 			result = default_parser.parse_int(value)
 			assert result == expected_int
 
 
 	@staticmethod
 	@pytest.mark.parametrize(('value', 'is_bool_expected', 'expected_bool'), TestBool.bool_test_cases)
-	def test_default_bool_to_float(default_parser: TypeParser, value: str, is_bool_expected: bool, expected_bool: bool | None):
+	def test_default_bool_to_float(default_parser: TypeParser, value: str, is_bool_expected: bool, expected_bool: Union[bool, None]):
 		if expected_bool is None:
 			with pytest.raises(ValueError):
 				default_parser.parse_int(value)
 		else:
 			int_result = default_parser.parse_int(value)
 			assert int_result == (1 if expected_bool == True else 0)
 
@@ -467,15 +466,15 @@
 			("1__0e2", False, None),
 			("1e1__0", False, None),
 			("1e", False, None),
 			("e1", False, None),
 			("e", False, None),
 		]
 	)
-	def test_allow_scientific(default_parser: TypeParser, value: str, is_int_allow_scientific_expected: bool, allow_scientific_expected: int | None):
+	def test_allow_scientific(default_parser: TypeParser, value: str, is_int_allow_scientific_expected: bool, allow_scientific_expected: Union[int, None]):
 		is_int_allow_scientific_result = default_parser.is_int(value, allow_scientific=True)
 		assert is_int_allow_scientific_result == is_int_allow_scientific_expected
 		is_int_disallow_scientific_result = default_parser.is_int(value, allow_scientific=False)
 		assert is_int_disallow_scientific_result == False
 
 		if allow_scientific_expected is None:
 			with pytest.raises(ValueError):
@@ -501,15 +500,15 @@
 			("1e2", False, True, 100),
 			("1E2", False, True, 100),
 			("1e2", True, True, 100),
 			("1E2", True, False, None),
 		],
 		indirect=['int_case_sensitive_parser']
 	)
-	def test_case_sensitive(value: str, int_case_sensitive_parser: TypeParser, is_int_expected: bool, expected_int: int | None):
+	def test_case_sensitive(value: str, int_case_sensitive_parser: TypeParser, is_int_expected: bool, expected_int: Union[int, None]):
 		is_int_result = int_case_sensitive_parser.is_int(value)
 		assert is_int_result == is_int_expected
 		if expected_int is None:
 			with pytest.raises(ValueError):
 				int_case_sensitive_parser.parse_int(value)
 		else:
 			int_result = int_case_sensitive_parser.parse_int(value)
@@ -539,15 +538,15 @@
 		],
 		indirect=['int_trim_parser']
 	)
 	def test_trim(
 		value: str,
 		int_trim_parser: TypeParser,
 		is_int_expected: bool,
-		expected_int: int | None,
+		expected_int: Union[int, None],
 	):
 		is_int_result = int_trim_parser.is_int(value)
 		assert is_int_result == is_int_expected
 
 		if expected_int is None:
 			with pytest.raises(ValueError):
 				int_trim_parser.parse_int(value)
@@ -570,30 +569,30 @@
 			return result.is_nan()
 		else:
 			return result == expected
 
 
 	@staticmethod
 	@pytest.mark.parametrize(('value', 'is_bool_expected', 'expected_bool'), TestBool.bool_test_cases)
-	def test_default_bool_to_float(default_parser: TypeParser, value: str, is_bool_expected: bool, expected_bool: bool | None):
+	def test_default_bool_to_float(default_parser: TypeParser, value: str, is_bool_expected: bool, expected_bool: Union[bool, None]):
 		if expected_bool is None:
 			with pytest.raises(ValueError):
 				default_parser.parse_float(value)
 			with pytest.raises(ValueError):
 				default_parser.parse_decimal(value)
 		else:
 			float_result = default_parser.parse_float(value)
 			assert float_result == (1. if expected_bool == True else 0.)
 			decimal_result = default_parser.parse_decimal(value)
 			assert decimal_result == (Decimal(1) if expected_bool == True else Decimal(0))
 
 
 	@staticmethod
 	@pytest.mark.parametrize(('value', 'is_float_expected', 'expected_int'), TestInt.int_test_cases)
-	def test_default_int_as_float(default_parser: TypeParser, value: str, is_float_expected: bool, expected_int: int | None):
+	def test_default_int_as_float(default_parser: TypeParser, value: str, is_float_expected: bool, expected_int: Union[int, None]):
 		is_float_result = default_parser.is_float(value)
 		assert is_float_result == is_float_expected
 		is_decimal_result = default_parser.is_decimal(value)
 		assert is_decimal_result == is_float_expected
 
 		if expected_int is None:
 			with pytest.raises(ValueError):
@@ -658,15 +657,15 @@
 			("1.1__1", False, None, None),
 			("inf", False, None, None),
 			("-inf", False, None, None),
 			("nan", False, None, None),
 			("", False, None, None),
 		]
 	)
-	def test_default(default_parser: TypeParser, value: str, is_float_expected: bool, expected_float: float | None, expected_decimal: Decimal | None):
+	def test_default(default_parser: TypeParser, value: str, is_float_expected: bool, expected_float: Union[float, None], expected_decimal: Union[Decimal, None]):
 		is_float_result = default_parser.is_float(value)
 		assert is_float_result == is_float_expected
 		is_decimal_result = default_parser.is_decimal(value)
 		assert is_decimal_result == is_float_expected
 
 		if expected_float is None:
 			with pytest.raises(ValueError):
@@ -719,15 +718,15 @@
 			("e1", False, None, None),
 			("e1.", False, None, None),
 			("e1.0", False, None, None),
 			("e.1", False, None, None),
 			("e0.1", False, None, None),
 		]
 	)
-	def test_allow_scientific(default_parser: TypeParser, value: str, is_float_expected: bool, expected_float: float | None, expected_decimal: Decimal | None):
+	def test_allow_scientific(default_parser: TypeParser, value: str, is_float_expected: bool, expected_float: Union[float, None], expected_decimal: Union[Decimal, None]):
 		is_float_result = default_parser.is_float(value, allow_scientific=True)
 		assert is_float_result == is_float_expected
 		is_decimal_result = default_parser.is_decimal(value, allow_scientific=True)
 		assert is_decimal_result == is_float_expected
 
 		if expected_float is None:
 			with pytest.raises(ValueError):
@@ -785,16 +784,16 @@
 		],
 		indirect=['float_values_parser']
 	)
 	def test_float_values(
 		value: str,
 		float_values_parser: TypeParser,
 		is_float_expected: bool,
-		expected_float: bool | None,
-		expected_decimal: Decimal | None,
+		expected_float: Union[bool, None],
+		expected_decimal: Union[Decimal, None],
 	):
 		is_float_result = float_values_parser.is_float(value)
 		assert is_float_result == is_float_expected
 		is_decimal_result = float_values_parser.is_decimal(value)
 		assert is_decimal_result == is_float_expected
 
 		if expected_float is None:
@@ -821,15 +820,15 @@
 			("+inf", float_values, True, math.inf, Decimal(math.inf)),
 			("-inf", float_values, True, -1 * math.inf, -1 * Decimal(math.inf)),
 			("−inf", float_values, True, -1 * math.inf, -1 * Decimal(math.inf)),
 			("inff", float_values, False, None, None),
 		],
 		indirect=['float_values_parser']
 	)
-	def test_allow_inf(float_values_parser: TypeParser, value: str, is_float_expected: bool, expected_float: float | None, expected_decimal: Decimal | None):
+	def test_allow_inf(float_values_parser: TypeParser, value: str, is_float_expected: bool, expected_float: Union[float, None], expected_decimal: Union[Decimal, None]):
 		is_float_result = float_values_parser.is_float(value, allow_inf=True)
 		assert is_float_result == is_float_expected
 		is_decimal_result = float_values_parser.is_decimal(value, allow_inf=True)
 		assert is_decimal_result == is_float_expected
 
 		if expected_float is None:
 			with pytest.raises(ValueError):
@@ -859,15 +858,15 @@
 			("+nan", float_values, True, math.nan, Decimal(math.nan)),
 			("-nan", float_values, True, math.nan, Decimal(math.nan)),
 			("−nan", float_values, True, math.nan, Decimal(math.nan)),
 			("nann", float_values, False, None, None),
 		],
 		indirect=['float_values_parser']
 	)
-	def test_allow_nan(float_values_parser: TypeParser, value: str, is_float_expected: bool, expected_float: float | None, expected_decimal: Decimal | None):
+	def test_allow_nan(float_values_parser: TypeParser, value: str, is_float_expected: bool, expected_float: Union[float, None], expected_decimal: Union[Decimal, None]):
 		is_float_result = float_values_parser.is_float(value, allow_nan=True)
 		assert is_float_result == is_float_expected
 		is_decimal_result = float_values_parser.is_decimal(value, allow_nan=True)
 		assert is_decimal_result == is_float_expected
 
 		if expected_float is None:
 			with pytest.raises(ValueError):
@@ -933,16 +932,16 @@
 		],
 		indirect=['float_case_sensitive_parser']
 	)
 	def test_case_sensitive(
 		value: str,
 		float_case_sensitive_parser: TypeParser,
 		is_float_expected: bool,
-		expected_float: float | None,
-		expected_decimal: Decimal | None
+		expected_float: Union[float, None],
+		expected_decimal: Union[Decimal, None]
 	):
 		is_float_result = float_case_sensitive_parser.is_float(value)
 		assert is_float_result == is_float_expected
 		is_decimal_result = float_case_sensitive_parser.is_decimal(value)
 		assert is_decimal_result == is_float_expected
 
 		if expected_float is None:
@@ -1016,16 +1015,16 @@
 		],
 		indirect=['float_trim_parser']
 	)
 	def test_trim(
 		value: str,
 		float_trim_parser: TypeParser,
 		is_float_expected: bool,
-		expected_float: float | None,
-		expected_decimal: Decimal | None,
+		expected_float: Union[float, None],
+		expected_decimal: Union[Decimal, None],
 	):
 		is_float_result = float_trim_parser.is_float(value)
 		assert is_float_result == is_float_expected
 		is_decimal_result = float_trim_parser.is_decimal(value)
 		assert is_decimal_result == is_float_expected
 
 		if expected_float is None:
@@ -1613,15 +1612,15 @@
 
 
 	@staticmethod
 	@pytest.mark.parametrize('none_case_sensitive', [True, False])
 	@pytest.mark.parametrize('bool_case_sensitive', [True, False])
 	@pytest.mark.parametrize('float_case_sensitive', [True, False])
 	@pytest.mark.parametrize('case_sensitive', [True, False, None])
-	def test_case_sensitive(none_case_sensitive: bool, bool_case_sensitive: bool, float_case_sensitive: bool, case_sensitive: bool | None):
+	def test_case_sensitive(none_case_sensitive: bool, bool_case_sensitive: bool, float_case_sensitive: bool, case_sensitive: Union[bool, None]):
 		parser = TypeParser(
 			none_case_sensitive=none_case_sensitive,
 			bool_case_sensitive=bool_case_sensitive,
 			float_case_sensitive=float_case_sensitive,
 			case_sensitive=case_sensitive,
 		)
```

### Comparing `parsetypes-0.1.1/tests/test_reduce_types.py` & `parsetypes-0.2/tests/test_reduce_types.py`

 * *Files 0% similar despite different names*

```diff
@@ -1,14 +1,15 @@
 from decimal import Decimal
-from types import NoneType
 
 import pytest
 
 from parsetypes import reduce_types, AnyValueType, Nullable
 
+from parsetypes._compat import NoneType
+
 
 @pytest.mark.parametrize(
 	('types', 'expected'),
 	[
 		([bool], bool),
 		([int], int),
 		([float], float),
```

