# Comparing `tmp/featurewiz-0.3.1.tar.gz` & `tmp/featurewiz-0.3.2.tar.gz`

## filetype from file(1)

```diff
@@ -1 +1 @@
-gzip compressed data, was "featurewiz-0.3.1.tar", last modified: Tue May 16 02:17:12 2023, max compression
+gzip compressed data, was "featurewiz-0.3.2.tar", last modified: Sun May 28 18:58:16 2023, max compression
```

## Comparing `featurewiz-0.3.1.tar` & `featurewiz-0.3.2.tar`

### file list

```diff
@@ -1,23 +1,23 @@
-drwxrwxrwx   0 ram       (1000) ram       (1000)        0 2023-05-16 02:17:12.184747 featurewiz-0.3.1/
--rwxrwxrwx   0 ram       (1000) ram       (1000)    23246 2023-05-16 02:17:12.180758 featurewiz-0.3.1/PKG-INFO
--rwxrwxrwx   0 ram       (1000) ram       (1000)    21082 2023-05-01 01:06:57.000000 featurewiz-0.3.1/README.md
-drwxrwxrwx   0 ram       (1000) ram       (1000)        0 2023-05-16 02:17:12.048746 featurewiz-0.3.1/featurewiz/
--rwxrwxrwx   0 ram       (1000) ram       (1000)     3563 2023-05-07 11:29:05.000000 featurewiz-0.3.1/featurewiz/__init__.py
--rwxrwxrwx   0 ram       (1000) ram       (1000)      387 2023-05-06 20:33:06.000000 featurewiz-0.3.1/featurewiz/__version__.py
--rwxrwxrwx   0 ram       (1000) ram       (1000)    18411 2023-05-02 11:13:48.000000 featurewiz-0.3.1/featurewiz/classify_method.py
--rwxrwxrwx   0 ram       (1000) ram       (1000)    32382 2023-05-02 11:13:48.000000 featurewiz-0.3.1/featurewiz/databunch.py
--rwxrwxrwx   0 ram       (1000) ram       (1000)     4414 2023-05-02 11:13:48.000000 featurewiz-0.3.1/featurewiz/encoders.py
--rwxrwxrwx   0 ram       (1000) ram       (1000)   168809 2023-05-16 02:16:07.000000 featurewiz-0.3.1/featurewiz/featurewiz.py
--rwxrwxrwx   0 ram       (1000) ram       (1000)    87877 2023-05-02 11:13:48.000000 featurewiz-0.3.1/featurewiz/ml_models.py
--rwxrwxrwx   0 ram       (1000) ram       (1000)   110950 2023-05-08 14:22:12.000000 featurewiz-0.3.1/featurewiz/my_encoders.py
--rwxrwxrwx   0 ram       (1000) ram       (1000)     2584 2023-05-02 11:13:48.000000 featurewiz-0.3.1/featurewiz/settings.py
--rwxrwxrwx   0 ram       (1000) ram       (1000)    22089 2023-05-02 11:13:48.000000 featurewiz-0.3.1/featurewiz/stacking_models.py
--rwxrwxrwx   0 ram       (1000) ram       (1000)    14954 2023-05-02 11:13:48.000000 featurewiz-0.3.1/featurewiz/sulov_method.py
-drwxrwxrwx   0 ram       (1000) ram       (1000)        0 2023-05-16 02:17:12.156744 featurewiz-0.3.1/featurewiz.egg-info/
--rwxrwxrwx   0 ram       (1000) ram       (1000)    23246 2023-05-16 02:17:11.000000 featurewiz-0.3.1/featurewiz.egg-info/PKG-INFO
--rwxrwxrwx   0 ram       (1000) ram       (1000)      468 2023-05-16 02:17:11.000000 featurewiz-0.3.1/featurewiz.egg-info/SOURCES.txt
--rwxrwxrwx   0 ram       (1000) ram       (1000)        1 2023-05-16 02:17:11.000000 featurewiz-0.3.1/featurewiz.egg-info/dependency_links.txt
--rwxrwxrwx   0 ram       (1000) ram       (1000)      289 2023-05-16 02:17:11.000000 featurewiz-0.3.1/featurewiz.egg-info/requires.txt
--rwxrwxrwx   0 ram       (1000) ram       (1000)       11 2023-05-16 02:17:11.000000 featurewiz-0.3.1/featurewiz.egg-info/top_level.txt
--rwxrwxrwx   0 ram       (1000) ram       (1000)       38 2023-05-16 02:17:12.184747 featurewiz-0.3.1/setup.cfg
--rwxrwxrwx   0 ram       (1000) ram       (1000)     1274 2023-05-09 10:55:09.000000 featurewiz-0.3.1/setup.py
+drwxrwxrwx   0 ram       (1000) ram       (1000)        0 2023-05-28 18:58:16.733243 featurewiz-0.3.2/
+-rwxrwxrwx   0 ram       (1000) ram       (1000)    23296 2023-05-28 18:58:16.717607 featurewiz-0.3.2/PKG-INFO
+-rwxrwxrwx   0 ram       (1000) ram       (1000)    21167 2023-05-28 18:52:09.000000 featurewiz-0.3.2/README.md
+drwxrwxrwx   0 ram       (1000) ram       (1000)        0 2023-05-28 18:58:16.595154 featurewiz-0.3.2/featurewiz/
+-rwxrwxrwx   0 ram       (1000) ram       (1000)     3583 2023-05-28 18:22:50.000000 featurewiz-0.3.2/featurewiz/__init__.py
+-rwxrwxrwx   0 ram       (1000) ram       (1000)      387 2023-05-28 18:42:06.000000 featurewiz-0.3.2/featurewiz/__version__.py
+-rwxrwxrwx   0 ram       (1000) ram       (1000)    18411 2023-05-02 11:13:48.000000 featurewiz-0.3.2/featurewiz/classify_method.py
+-rwxrwxrwx   0 ram       (1000) ram       (1000)    32382 2023-05-02 11:13:48.000000 featurewiz-0.3.2/featurewiz/databunch.py
+-rwxrwxrwx   0 ram       (1000) ram       (1000)     4414 2023-05-02 11:13:48.000000 featurewiz-0.3.2/featurewiz/encoders.py
+-rwxrwxrwx   0 ram       (1000) ram       (1000)   170255 2023-05-28 18:48:03.000000 featurewiz-0.3.2/featurewiz/featurewiz.py
+-rwxrwxrwx   0 ram       (1000) ram       (1000)    87877 2023-05-02 11:13:48.000000 featurewiz-0.3.2/featurewiz/ml_models.py
+-rwxrwxrwx   0 ram       (1000) ram       (1000)   110950 2023-05-08 14:22:12.000000 featurewiz-0.3.2/featurewiz/my_encoders.py
+-rwxrwxrwx   0 ram       (1000) ram       (1000)     2584 2023-05-02 11:13:48.000000 featurewiz-0.3.2/featurewiz/settings.py
+-rwxrwxrwx   0 ram       (1000) ram       (1000)    22089 2023-05-02 11:13:48.000000 featurewiz-0.3.2/featurewiz/stacking_models.py
+-rwxrwxrwx   0 ram       (1000) ram       (1000)    14954 2023-05-02 11:13:48.000000 featurewiz-0.3.2/featurewiz/sulov_method.py
+drwxrwxrwx   0 ram       (1000) ram       (1000)        0 2023-05-28 18:58:16.695449 featurewiz-0.3.2/featurewiz.egg-info/
+-rwxrwxrwx   0 ram       (1000) ram       (1000)    23296 2023-05-28 18:58:16.000000 featurewiz-0.3.2/featurewiz.egg-info/PKG-INFO
+-rwxrwxrwx   0 ram       (1000) ram       (1000)      468 2023-05-28 18:58:16.000000 featurewiz-0.3.2/featurewiz.egg-info/SOURCES.txt
+-rwxrwxrwx   0 ram       (1000) ram       (1000)        1 2023-05-28 18:58:16.000000 featurewiz-0.3.2/featurewiz.egg-info/dependency_links.txt
+-rwxrwxrwx   0 ram       (1000) ram       (1000)      289 2023-05-28 18:58:16.000000 featurewiz-0.3.2/featurewiz.egg-info/requires.txt
+-rwxrwxrwx   0 ram       (1000) ram       (1000)       11 2023-05-28 18:58:16.000000 featurewiz-0.3.2/featurewiz.egg-info/top_level.txt
+-rwxrwxrwx   0 ram       (1000) ram       (1000)       38 2023-05-28 18:58:16.733243 featurewiz-0.3.2/setup.cfg
+-rwxrwxrwx   0 ram       (1000) ram       (1000)     1274 2023-05-28 18:58:00.000000 featurewiz-0.3.2/setup.py
```

### Comparing `featurewiz-0.3.1/PKG-INFO` & `featurewiz-0.3.2/PKG-INFO`

 * *Files 3% similar despite different names*

```diff
@@ -1,91 +1,91 @@
 Metadata-Version: 2.1
 Name: featurewiz
-Version: 0.3.1
+Version: 0.3.2
 Summary: Select Best Features from your data set - any size - now with XGBoost!
 Home-page: https://github.com/AutoViML/featurewiz
 Author: Ram Seshadri
 Author-email: rsesha2001@yahoo.com
 License: Apache License 2.0
 Description: # featurewiz
-        `featurewiz` is a powerful feature selection library that has a number of features that make it stand out from the competition, including:
-        <ol>
-        <li>It provides one of the best automatic feature selection algorithms (Minimum Redundancy Maximum Relevance (MRMR)) described by wikipedia as: <a href="https://en.wikipedia.org/wiki/Minimum_redundancy_feature_selection">"The MRMR selection has been found to be more powerful than the maximum relevance feature selection"</a> such as Boruta.</li>
-        <li>It selects the best number of un-correlated features that have maximum mutual information about the target without having to specify the number of features</li>
-        <li>It is fast and easy to use, and comes with a number of helpful features, such as a built-in categorical-to-numeric encoder and a powerful feature engineering module</li>
-        <li>It is well-documented, and it comes with a number of <a href="https://github.com/AutoViML/featurewiz/tree/main/examples">examples</a>.</li>
-        <li>It is actively maintained, and it is regularly updated with new features and bug fixes.</li>
-        </ol>
+        `featurewiz` is the best feature selection library for boosting your machine learning performance with minimal effort and maximum relevance using the famous MRMR algorithm.
         
-        ## Latest Updates
-        If you are looking for the latest and greatest updates about the library, we would definitely recommend checking out our <a href="https://github.com/AutoViML/featurewiz/blob/main/updates.md">updates page</a> often. It is a powerful tool that can help you improve the performance of your machine learning models with constant new capabilities from featurewiz.
+        ![banner](images/featurewiz_logos.png)
         
         # Table of Contents
         <ul>
+        <li><a href="#Latest">Latest updates</a></li>
         <li><a href="#introduction">What is featurewiz</a></li>
         <li><a href="#working">How it works</a></li>
         <li><a href="#tips">Tips for using featurewiz</a></li>
         <li><a href="#install">How to install featurewiz</a></li>
         <li><a href="#usage">Usage</a></li>
         <li><a href="#api">API</a></li>
         <li><a href="#additional">Additional Tips</a></li>
         <li><a href="#maintainers">Maintainers</a></li>
         <li><a href="#contributing">Contributing</a></li>
         <li><a href="#license">License</a></li>
         <li><a href="#disclaimer">Disclaimer</a></li>
         </ul>
-        <p>
         
-        ![banner](featurewiz_logos.png)
+        ## Latest
+        If you are looking for the latest and greatest updates about our library, we would definitely recommend checking out our <a href="https://github.com/AutoViML/featurewiz/blob/main/updates.md">updates page</a> often. 
         
         ## Introduction
         `featurewiz` a new python library for creating and selecting the best features in your data set fast!
         `featurewiz` can be used in one or two ways. Both are explained below.
+        <ol>
+        <li>It provides one of the best automatic feature selection algorithms (Minimum Redundancy Maximum Relevance (MRMR)) described by wikipedia as: <a href="https://en.wikipedia.org/wiki/Minimum_redundancy_feature_selection">"The MRMR selection has been found to be more powerful than the maximum relevance feature selection"</a> such as Boruta.</li>
+        <li>It selects the best number of un-correlated features that have maximum mutual information about the target without having to specify the number of features</li>
+        <li>It is fast and easy to use, and comes with a number of helpful features, such as a built-in categorical-to-numeric encoder and a powerful feature engineering module</li>
+        <li>It is well-documented, and it comes with a number of <a href="https://github.com/AutoViML/featurewiz/tree/main/examples">examples</a>.</li>
+        <li>It is actively maintained, and it is regularly updated with <a href="https://github.com/AutoViML/featurewiz/blob/main/updates.md">new features and bug fixes</a>.</li>
+        </ol>
         
         ### 1.  Feature Engineering
         <p>The first step is not absolutely necessary but it can be used to create new features that may or may not be helpful (be careful with automated feature engineering tools!).<p>
         1. <b>Performing Feature Engineering</b>: One of the gaps in open source AutoML tools and especially Auto_ViML has been the lack of feature engineering capabilities that high powered competitions such as Kaggle required. The ability to create "interaction" variables or adding "group-by" features or "target-encoding" categorical variables was difficult and sifting through those hundreds of new features to find best features was difficult and left only to "experts" or "professionals". featurewiz was created to help you in this endeavor.<br>
         <p>featurewiz now enables you to add hundreds of such features with a single line of code. Set the "feature_engg" flag to "interactions", "groupby" or "target" and featurewiz will select the best encoders for each of those options and create hundreds (perhaps thousands) of features in one go. Not only that, using the next step, featurewiz will sift through numerous such variables and find only the least correlated and most relevant features to your model. All in one step!.<br>
         
-        ![feature_engg](feature_engg.jpg)
+        ![feature_engg](images/feature_engg.jpg)
         
         ### 2.  Feature Selection
         <p>The second step is Feature Selection. `featurewiz` uses the MRMR (Minimum Redundancy Maximum Relevance) algorithm as the basis for its feature selection. <br>
         <b> Why do Feature Selection</b>? Once you have created 100's of new features, you still have three questions left to answer:
         1. How do we interpret those newly created features?
         2. Which of these features is important and which are useless? How many of them are highly correlated to each other causing redundancy?
         3. Does the model overfit now on these new features and perform better or worse than before?
         <br>
         All are very important questions and featurewiz answers them by using the SULOV method and Recursive XGBoost to reduce features in your dataset to the best "minimum optimal" features for the model.<br>
-        <p><b>SULOV</b>: SULOV stands for `Searching for Uncorrelated List of Variables`. The SULOV algorithm is based on the Minimum-Redundancy-Maximum-Relevance (MRMR) <a href="https://towardsdatascience.com/mrmr-explained-exactly-how-you-wished-someone-explained-to-you-9cf4ed27458b">algorithm explained in this article</a> as one of the best feature selection methods. To understand how MRMR works and how it is different from `Boruta` and other feature selection methods, see the chart below. Here "Minimal Optimal" refers to the MRMR and featurewiz kind of algorithms while "all-relevant" refers to Boruta kind of algorithms.<br>
+        <p><b>SULOV</b>: SULOV stands for `Searching for Uncorrelated List of Variables`. The SULOV algorithm is based on the Minimum-Redundancy-Maximum-Relevance (MRMR) <a href="https://towardsdatascience.com/mrmr-explained-exactly-how-you-wished-someone-explained-to-you-9cf4ed27458b">algorithm explained in this article</a> as one of the best feature selection methods. To understand how MRMR works and how it is different from `Boruta` and other feature selection methods, see the chart below. Here "Minimal Optimal" refers to MRMR  (featurewiz) while "all-relevant" refers to Boruta.<br>
         
-        ![MRMR_chart](MRMR.png)
+        ![MRMR_chart](images/MRMR.png)
         
         ## Working
         `featurewiz` performs feature selection in 2 steps. Each step is explained below.
         <b>The working of the `SULOV` algorithm</b> is as follows:
         <ol>
         <li>Find all the pairs of highly correlated variables exceeding a correlation threshold (say absolute(0.7)).</li>
         <li>Then find their MIS score (Mutual Information Score) to the target variable. MIS is a non-parametric scoring method. So its suitable for all kinds of variables and target.</li>
         <li>Now take each pair of correlated variables, then knock off the one with the lower MIS score.</li>
         <li>What’s left is the ones with the highest Information scores and least correlation with each other.</li>
         </ol>
         
-        ![sulov](SULOV.jpg)
+        ![sulov](images/SULOV.jpg)
         
         <b>The working of the Recursive XGBoost</b> is as follows: 
         Once SULOV has selected variables that have high mutual information scores with least less correlation amongst them, featurewiz uses XGBoost to repeatedly find the best features among the remaining variables after SULOV. 
         <ol>
         <li>Select all variables in data set and the full data split into train and valid sets.</li>
         <li>Find top X features (could be 10) on train using valid for early stopping (to prevent over-fitting)</li>
         <li>Then take next set of vars and find top X</li>
         <li>Do this 5 times. Combine all selected features and de-duplicate them.</li>
         </ol>
         
-        ![xgboost](xgboost.jpg)
+        ![xgboost](images/xgboost.jpg)
         
         ## Tips
         Here are some additional tips for ML engineers and data scientists when using featurewiz:
         <ol>
         <li><b>Always cross-validate your results</b>: When you use a feature selection tool, it is important to cross-validate your results. This means that you should split your data into a training set and a test set. Use the training set to select features, and then evaluate your model on the test set. This will help you to ensure that your model is not overfitting to the training data.</li>
         <li><b>Use multiple feature selection tools</b>: It is a good idea to use multiple feature selection tools and compare the results. This will help you to get a better understanding of which features are most important for your data.</li>
         <li><b>Don't forget to engineer new features</b>: Feature selection is only one part of the process of building a good machine learning model. You should also spend time engineering your features to make them as informative as possible. This can involve things like creating new features, transforming existing features, and removing irrelevant features.</li>
@@ -117,25 +117,18 @@
         As of June 2022, thanks to [arturdaraujo](https://github.com/arturdaraujo), featurewiz is now available on conda-forge. You can try:<br>
         
         ```
          conda install -c conda-forge featurewiz
         ```
         
         ### If the above conda install fails, you can try installing featurewiz this way:
-        ##Step 1: Install featurewiz first<br>
-        
-        ```
-         !pip install featurewiz --ignore-installed --no-deps
-         !pip install xlrd --ignore-installed --no-deps 
-        ```
-        
-        ##Step 2: Next, install Pillow since Kaggle has an incompatible version. <br>
+        ##### Install featurewiz using git+<br>
         
         ```
-         !pip install Pillow==9.0.0
+        !pip install git+https://github.com/AutoViML/featurewiz.git
         ```
         
         ## Usage
         
         For feature selection, you must use the newer syntax which is similar to the scikit-learn fit and predict transformer syntax below.
         
         ```
@@ -149,15 +142,15 @@
         
         Alternatively, you can use featurewiz for feature engineering using this older syntax. Otherwise, it will give an error. If you want to combine feature engg and then feature selection, you must use this older syntax:
         
         ```
         import featurewiz as fwiz
         outputs = fwiz.featurewiz(dataname=train, target=target, corr_limit=0.70, verbose=2, sep=',', 
         		header=0, test_data='',feature_engg='', category_encoders='',
-        		dask_xgboost_flag=False, nrows=None)
+        		dask_xgboost_flag=False, nrows=None, skip_sulov=False, skip_xgboost=False)
         ```
         
         `outputs`: There will always be multiple objects in output. The objects in that tuple can vary:
         1. "features" and "trainm": It be a list (of selected features) and one dataframe (if you sent in train only)
         2. "trainm" and "testm": It can be two dataframes when you send in both test and train but with selected features.
         <ol>
         <li>Both the selected features and dataframes are ready for you to now to do further modeling.
@@ -201,27 +194,29 @@
             - `WOEEncoder`: WOEEncoder uses the Weight of Evidence technique for categorical features. It supports only one kind of target: binary. For polynomial target support, it uses a PolynomialWrapper. It cannot be used for Regression.
             - `JamesSteinEncoder`: JamesSteinEncoder uses the James-Stein estimator. It supports 2 kinds of targets: binary and continuous. For polynomial target support, it uses PolynomialWrapper.
             For feature value i, James-Stein estimator returns a weighted average of:
             The mean target value for the observed feature value i.
             The mean target value (regardless of the feature value).
             - `dask_xgboost_flag`: Default is False. Set to True to use dask_xgboost estimator. You can turn it off if it gives an error. Then it will use pandas and regular xgboost to do the job.
             - `nrows`: default `None`. You can set the number of rows to read from your datafile if it is too large to fit into either dask or pandas. But you won't have to if you use dask. 
+            - `skip_sulov`: default `False`. You can set the flag to skip the SULOV method if you wanted. 
+            - `skip_xgboost`: default `False`. You can set the flag to skip the Recursive XGBoost method if you wanted. 
         
         **Output values**
         -   `outputs`: Output is always a tuple. We can call our outputs in that tuple: out1 and out2.
             -   `out1` and `out2`: If you sent in just one dataframe or filename as input, you will get:
                 - 1. `features`: It will be a list (of selected features) and
                 - 2. `trainm`: It will be a dataframe (if you sent in a file or dataname as input)
             -   `out1` and `out2`: If you sent in two files or dataframes (train and test), you will get:
                 - 1. `trainm`: a modified train dataframe with engineered and selected features from dataname and
                 - 2. `testm`: a modified test dataframe with engineered and selected features from test_data.
         
         ## Additional
         
-        ![background](featurewiz_background.jpg)
+        ![background](images/featurewiz_background.jpg)
         
         To learn more about how featurewiz works under the hood, watch this [video](https://www.youtube.com/embed/ZiNutwPcAU0)<br>
         <p>featurewiz was designed for selecting High Performance variables with the fewest steps.
         In most cases, featurewiz builds models with 20%-99% fewer features than your original data set with nearly the same or slightly lower performance (this is based on my trials. Your experience may vary).<br>
         <p>
         featurewiz is every Data Scientist's feature wizard that will:<ol>
         <li><b>Automatically pre-process data</b>: you can send in your entire dataframe "as is" and featurewiz will classify and change/label encode categorical variables changes to help XGBoost processing. It classifies variables as numeric or categorical or NLP or date-time variables automatically so it can use them correctly to model.<br>
```

#### html2text {}

```diff
@@ -1,46 +1,45 @@
-Metadata-Version: 2.1 Name: featurewiz Version: 0.3.1 Summary: Select Best
+Metadata-Version: 2.1 Name: featurewiz Version: 0.3.2 Summary: Select Best
 Features from your data set - any size - now with XGBoost! Home-page: https://
 github.com/AutoViML/featurewiz Author: Ram Seshadri Author-email:
 rsesha2001@yahoo.com License: Apache License 2.0 Description: # featurewiz
-`featurewiz` is a powerful feature selection library that has a number of
-features that make it stand out from the competition, including:
-   1. It provides one of the best automatic feature selection algorithms
-      (Minimum Redundancy Maximum Relevance (MRMR)) described by wikipedia as:
-      "The_MRMR_selection_has_been_found_to_be_more_powerful_than_the_maximum
-      relevance_feature_selection" such as Boruta.
-   2. It selects the best number of un-correlated features that have maximum
-      mutual information about the target without having to specify the number
-      of features
-   3. It is fast and easy to use, and comes with a number of helpful features,
-      such as a built-in categorical-to-numeric encoder and a powerful feature
-      engineering module
-   4. It is well-documented, and it comes with a number of examples.
-   5. It is actively maintained, and it is regularly updated with new features
-      and bug fixes.
-## Latest Updates If you are looking for the latest and greatest updates about
-the library, we would definitely recommend checking out our updates_page often.
-It is a powerful tool that can help you improve the performance of your machine
-learning models with constant new capabilities from featurewiz. # Table of
-Contents
+`featurewiz` is the best feature selection library for boosting your machine
+learning performance with minimal effort and maximum relevance using the famous
+MRMR algorithm. ![banner](images/featurewiz_logos.png) # Table of Contents
+    * Latest_updates
     * What_is_featurewiz
     * How_it_works
     * Tips_for_using_featurewiz
     * How_to_install_featurewiz
     * Usage
     * API
     * Additional_Tips
     * Maintainers
     * Contributing
     * License
     * Disclaimer
-![banner](featurewiz_logos.png) ## Introduction `featurewiz` a new python
-library for creating and selecting the best features in your data set fast!
-`featurewiz` can be used in one or two ways. Both are explained below. ### 1.
-Feature Engineering
+## Latest If you are looking for the latest and greatest updates about our
+library, we would definitely recommend checking out our updates_page often. ##
+Introduction `featurewiz` a new python library for creating and selecting the
+best features in your data set fast! `featurewiz` can be used in one or two
+ways. Both are explained below.
+   1. It provides one of the best automatic feature selection algorithms
+      (Minimum Redundancy Maximum Relevance (MRMR)) described by wikipedia as:
+      "The_MRMR_selection_has_been_found_to_be_more_powerful_than_the_maximum
+      relevance_feature_selection" such as Boruta.
+   2. It selects the best number of un-correlated features that have maximum
+      mutual information about the target without having to specify the number
+      of features
+   3. It is fast and easy to use, and comes with a number of helpful features,
+      such as a built-in categorical-to-numeric encoder and a powerful feature
+      engineering module
+   4. It is well-documented, and it comes with a number of examples.
+   5. It is actively maintained, and it is regularly updated with new_features
+      and_bug_fixes.
+### 1. Feature Engineering
 The first step is not absolutely necessary but it can be used to create new
 features that may or may not be helpful (be careful with automated feature
 engineering tools!).
 1. Performing Feature Engineering: One of the gaps in open source AutoML tools
 and especially Auto_ViML has been the lack of feature engineering capabilities
 that high powered competitions such as Kaggle required. The ability to create
 "interaction" variables or adding "group-by" features or "target-encoding"
@@ -50,15 +49,15 @@
 featurewiz now enables you to add hundreds of such features with a single line
 of code. Set the "feature_engg" flag to "interactions", "groupby" or "target"
 and featurewiz will select the best encoders for each of those options and
 create hundreds (perhaps thousands) of features in one go. Not only that, using
 the next step, featurewiz will sift through numerous such variables and find
 only the least correlated and most relevant features to your model. All in one
 step!.
-![feature_engg](feature_engg.jpg) ### 2. Feature Selection
+![feature_engg](images/feature_engg.jpg) ### 2. Feature Selection
 The second step is Feature Selection. `featurewiz` uses the MRMR (Minimum
 Redundancy Maximum Relevance) algorithm as the basis for its feature selection.
 
 Why do Feature Selection? Once you have created 100's of new features, you
 still have three questions left to answer: 1. How do we interpret those newly
 created features? 2. Which of these features is important and which are
 useless? How many of them are highly correlated to each other causing
@@ -68,40 +67,39 @@
 method and Recursive XGBoost to reduce features in your dataset to the best
 "minimum optimal" features for the model.
 SULOV: SULOV stands for `Searching for Uncorrelated List of Variables`. The
 SULOV algorithm is based on the Minimum-Redundancy-Maximum-Relevance (MRMR)
 algorithm_explained_in_this_article as one of the best feature selection
 methods. To understand how MRMR works and how it is different from `Boruta` and
 other feature selection methods, see the chart below. Here "Minimal Optimal"
-refers to the MRMR and featurewiz kind of algorithms while "all-relevant"
-refers to Boruta kind of algorithms.
-![MRMR_chart](MRMR.png) ## Working `featurewiz` performs feature selection in 2
-steps. Each step is explained below. The working of the `SULOV` algorithm is as
-follows:
+refers to MRMR (featurewiz) while "all-relevant" refers to Boruta.
+![MRMR_chart](images/MRMR.png) ## Working `featurewiz` performs feature
+selection in 2 steps. Each step is explained below. The working of the `SULOV`
+algorithm is as follows:
    1. Find all the pairs of highly correlated variables exceeding a correlation
       threshold (say absolute(0.7)).
    2. Then find their MIS score (Mutual Information Score) to the target
       variable. MIS is a non-parametric scoring method. So its suitable for all
       kinds of variables and target.
    3. Now take each pair of correlated variables, then knock off the one with
       the lower MIS score.
    4. Whatâs left is the ones with the highest Information scores and least
       correlation with each other.
-![sulov](SULOV.jpg) The working of the Recursive XGBoost is as follows: Once
-SULOV has selected variables that have high mutual information scores with
+![sulov](images/SULOV.jpg) The working of the Recursive XGBoost is as follows:
+Once SULOV has selected variables that have high mutual information scores with
 least less correlation amongst them, featurewiz uses XGBoost to repeatedly find
 the best features among the remaining variables after SULOV.
    1. Select all variables in data set and the full data split into train and
       valid sets.
    2. Find top X features (could be 10) on train using valid for early stopping
       (to prevent over-fitting)
    3. Then take next set of vars and find top X
    4. Do this 5 times. Combine all selected features and de-duplicate them.
-![xgboost](xgboost.jpg) ## Tips Here are some additional tips for ML engineers
-and data scientists when using featurewiz:
+![xgboost](images/xgboost.jpg) ## Tips Here are some additional tips for ML
+engineers and data scientists when using featurewiz:
    1. Always cross-validate your results: When you use a feature selection
       tool, it is important to cross-validate your results. This means that you
       should split your data into a training set and a test set. Use the
       training set to select features, and then evaluate your model on the test
       set. This will help you to ensure that your model is not overfitting to
       the training data.
    2. Use multiple feature selection tools: It is a good idea to use multiple
@@ -136,36 +134,34 @@
 archive/master.zip conda create -n  python=3.7 anaconda conda activate  # ON
 WINDOWS: `source activate ` cd featurewiz pip install -r requirements.txt ```
 ## Good News: You can install featurewiz on Colab and Kaggle easily in 2 steps!
 Check_out_more_latest_updates_from_this_page
 As of June 2022, thanks to [arturdaraujo](https://github.com/arturdaraujo),
 featurewiz is now available on conda-forge. You can try:
 ``` conda install -c conda-forge featurewiz ``` ### If the above conda install
-fails, you can try installing featurewiz this way: ##Step 1: Install featurewiz
-first
-``` !pip install featurewiz --ignore-installed --no-deps !pip install xlrd --
-ignore-installed --no-deps ``` ##Step 2: Next, install Pillow since Kaggle has
-an incompatible version.
-``` !pip install Pillow==9.0.0 ``` ## Usage For feature selection, you must use
-the newer syntax which is similar to the scikit-learn fit and predict
-transformer syntax below. ``` from featurewiz import FeatureWiz fwiz =
-FeatureWiz(corr_limit=0.70, feature_engg='', category_encoders='',
-dask_xgboost_flag=False, nrows=None, verbose=2) X_train_selected =
-fwiz.fit_transform(X_train, y_train) X_test_selected = fwiz.transform(X_test)
-### get list of selected features ### fwiz.features ``` Alternatively, you can
-use featurewiz for feature engineering using this older syntax. Otherwise, it
-will give an error. If you want to combine feature engg and then feature
-selection, you must use this older syntax: ``` import featurewiz as fwiz
-outputs = fwiz.featurewiz(dataname=train, target=target, corr_limit=0.70,
-verbose=2, sep=',', header=0, test_data='',feature_engg='',
-category_encoders='', dask_xgboost_flag=False, nrows=None) ``` `outputs`: There
-will always be multiple objects in output. The objects in that tuple can vary:
-1. "features" and "trainm": It be a list (of selected features) and one
-dataframe (if you sent in train only) 2. "trainm" and "testm": It can be two
-dataframes when you send in both test and train but with selected features.
+fails, you can try installing featurewiz this way: ##### Install featurewiz
+using git+
+``` !pip install git+https://github.com/AutoViML/featurewiz.git ``` ## Usage
+For feature selection, you must use the newer syntax which is similar to the
+scikit-learn fit and predict transformer syntax below. ``` from featurewiz
+import FeatureWiz fwiz = FeatureWiz(corr_limit=0.70, feature_engg='',
+category_encoders='', dask_xgboost_flag=False, nrows=None, verbose=2)
+X_train_selected = fwiz.fit_transform(X_train, y_train) X_test_selected =
+fwiz.transform(X_test) ### get list of selected features ### fwiz.features ```
+Alternatively, you can use featurewiz for feature engineering using this older
+syntax. Otherwise, it will give an error. If you want to combine feature engg
+and then feature selection, you must use this older syntax: ``` import
+featurewiz as fwiz outputs = fwiz.featurewiz(dataname=train, target=target,
+corr_limit=0.70, verbose=2, sep=',', header=0, test_data='',feature_engg='',
+category_encoders='', dask_xgboost_flag=False, nrows=None, skip_sulov=False,
+skip_xgboost=False) ``` `outputs`: There will always be multiple objects in
+output. The objects in that tuple can vary: 1. "features" and "trainm": It be a
+list (of selected features) and one dataframe (if you sent in train only) 2.
+"trainm" and "testm": It can be two dataframes when you send in both test and
+train but with selected features.
    1. Both the selected features and dataframes are ready for you to now to do
       further modeling.
    2. Featurewiz works on any multi-class, multi-label data Set. So you can
       have as many target labels as you want.
    3. You don't have to tell Featurewiz whether it is a Regression or
       Classification problem. It will decide that automatically.
 ## API **Arguments** - `dataname`: could be a datapath+filename or a dataframe.
@@ -235,26 +231,28 @@
 support, it uses PolynomialWrapper. For feature value i, James-Stein estimator
 returns a weighted average of: The mean target value for the observed feature
 value i. The mean target value (regardless of the feature value). -
 `dask_xgboost_flag`: Default is False. Set to True to use dask_xgboost
 estimator. You can turn it off if it gives an error. Then it will use pandas
 and regular xgboost to do the job. - `nrows`: default `None`. You can set the
 number of rows to read from your datafile if it is too large to fit into either
-dask or pandas. But you won't have to if you use dask. **Output values** -
-`outputs`: Output is always a tuple. We can call our outputs in that tuple:
-out1 and out2. - `out1` and `out2`: If you sent in just one dataframe or
-filename as input, you will get: - 1. `features`: It will be a list (of
-selected features) and - 2. `trainm`: It will be a dataframe (if you sent in a
-file or dataname as input) - `out1` and `out2`: If you sent in two files or
-dataframes (train and test), you will get: - 1. `trainm`: a modified train
-dataframe with engineered and selected features from dataname and - 2. `testm`:
-a modified test dataframe with engineered and selected features from test_data.
-## Additional ![background](featurewiz_background.jpg) To learn more about how
-featurewiz works under the hood, watch this [video](https://www.youtube.com/
-embed/ZiNutwPcAU0)
+dask or pandas. But you won't have to if you use dask. - `skip_sulov`: default
+`False`. You can set the flag to skip the SULOV method if you wanted. -
+`skip_xgboost`: default `False`. You can set the flag to skip the Recursive
+XGBoost method if you wanted. **Output values** - `outputs`: Output is always a
+tuple. We can call our outputs in that tuple: out1 and out2. - `out1` and
+`out2`: If you sent in just one dataframe or filename as input, you will get: -
+1. `features`: It will be a list (of selected features) and - 2. `trainm`: It
+will be a dataframe (if you sent in a file or dataname as input) - `out1` and
+`out2`: If you sent in two files or dataframes (train and test), you will get:
+- 1. `trainm`: a modified train dataframe with engineered and selected features
+from dataname and - 2. `testm`: a modified test dataframe with engineered and
+selected features from test_data. ## Additional ![background](images/
+featurewiz_background.jpg) To learn more about how featurewiz works under the
+hood, watch this [video](https://www.youtube.com/embed/ZiNutwPcAU0)
 featurewiz was designed for selecting High Performance variables with the
 fewest steps. In most cases, featurewiz builds models with 20%-99% fewer
 features than your original data set with nearly the same or slightly lower
 performance (this is based on my trials. Your experience may vary).
 featurewiz is every Data Scientist's feature wizard that will:
    1. Automatically pre-process data: you can send in your entire dataframe "as
       is" and featurewiz will classify and change/label encode categorical
```

### Comparing `featurewiz-0.3.1/README.md` & `featurewiz-0.3.2/README.md`

 * *Files 3% similar despite different names*

```diff
@@ -1,83 +1,83 @@
 # featurewiz
-`featurewiz` is a powerful feature selection library that has a number of features that make it stand out from the competition, including:
-<ol>
-<li>It provides one of the best automatic feature selection algorithms (Minimum Redundancy Maximum Relevance (MRMR)) described by wikipedia as: <a href="https://en.wikipedia.org/wiki/Minimum_redundancy_feature_selection">"The MRMR selection has been found to be more powerful than the maximum relevance feature selection"</a> such as Boruta.</li>
-<li>It selects the best number of un-correlated features that have maximum mutual information about the target without having to specify the number of features</li>
-<li>It is fast and easy to use, and comes with a number of helpful features, such as a built-in categorical-to-numeric encoder and a powerful feature engineering module</li>
-<li>It is well-documented, and it comes with a number of <a href="https://github.com/AutoViML/featurewiz/tree/main/examples">examples</a>.</li>
-<li>It is actively maintained, and it is regularly updated with new features and bug fixes.</li>
-</ol>
+`featurewiz` is the best feature selection library for boosting your machine learning performance with minimal effort and maximum relevance using the famous MRMR algorithm.
 
-## Latest Updates
-If you are looking for the latest and greatest updates about the library, we would definitely recommend checking out our <a href="https://github.com/AutoViML/featurewiz/blob/main/updates.md">updates page</a> often. It is a powerful tool that can help you improve the performance of your machine learning models with constant new capabilities from featurewiz.
+![banner](images/featurewiz_logos.png)
 
 # Table of Contents
 <ul>
+<li><a href="#Latest">Latest updates</a></li>
 <li><a href="#introduction">What is featurewiz</a></li>
 <li><a href="#working">How it works</a></li>
 <li><a href="#tips">Tips for using featurewiz</a></li>
 <li><a href="#install">How to install featurewiz</a></li>
 <li><a href="#usage">Usage</a></li>
 <li><a href="#api">API</a></li>
 <li><a href="#additional">Additional Tips</a></li>
 <li><a href="#maintainers">Maintainers</a></li>
 <li><a href="#contributing">Contributing</a></li>
 <li><a href="#license">License</a></li>
 <li><a href="#disclaimer">Disclaimer</a></li>
 </ul>
-<p>
 
-![banner](featurewiz_logos.png)
+## Latest
+If you are looking for the latest and greatest updates about our library, we would definitely recommend checking out our <a href="https://github.com/AutoViML/featurewiz/blob/main/updates.md">updates page</a> often. 
 
 ## Introduction
 `featurewiz` a new python library for creating and selecting the best features in your data set fast!
 `featurewiz` can be used in one or two ways. Both are explained below.
+<ol>
+<li>It provides one of the best automatic feature selection algorithms (Minimum Redundancy Maximum Relevance (MRMR)) described by wikipedia as: <a href="https://en.wikipedia.org/wiki/Minimum_redundancy_feature_selection">"The MRMR selection has been found to be more powerful than the maximum relevance feature selection"</a> such as Boruta.</li>
+<li>It selects the best number of un-correlated features that have maximum mutual information about the target without having to specify the number of features</li>
+<li>It is fast and easy to use, and comes with a number of helpful features, such as a built-in categorical-to-numeric encoder and a powerful feature engineering module</li>
+<li>It is well-documented, and it comes with a number of <a href="https://github.com/AutoViML/featurewiz/tree/main/examples">examples</a>.</li>
+<li>It is actively maintained, and it is regularly updated with <a href="https://github.com/AutoViML/featurewiz/blob/main/updates.md">new features and bug fixes</a>.</li>
+</ol>
 
 ### 1.  Feature Engineering
 <p>The first step is not absolutely necessary but it can be used to create new features that may or may not be helpful (be careful with automated feature engineering tools!).<p>
 1. <b>Performing Feature Engineering</b>: One of the gaps in open source AutoML tools and especially Auto_ViML has been the lack of feature engineering capabilities that high powered competitions such as Kaggle required. The ability to create "interaction" variables or adding "group-by" features or "target-encoding" categorical variables was difficult and sifting through those hundreds of new features to find best features was difficult and left only to "experts" or "professionals". featurewiz was created to help you in this endeavor.<br>
 <p>featurewiz now enables you to add hundreds of such features with a single line of code. Set the "feature_engg" flag to "interactions", "groupby" or "target" and featurewiz will select the best encoders for each of those options and create hundreds (perhaps thousands) of features in one go. Not only that, using the next step, featurewiz will sift through numerous such variables and find only the least correlated and most relevant features to your model. All in one step!.<br>
 
-![feature_engg](feature_engg.jpg)
+![feature_engg](images/feature_engg.jpg)
 
 ### 2.  Feature Selection
 <p>The second step is Feature Selection. `featurewiz` uses the MRMR (Minimum Redundancy Maximum Relevance) algorithm as the basis for its feature selection. <br>
 <b> Why do Feature Selection</b>? Once you have created 100's of new features, you still have three questions left to answer:
 1. How do we interpret those newly created features?
 2. Which of these features is important and which are useless? How many of them are highly correlated to each other causing redundancy?
 3. Does the model overfit now on these new features and perform better or worse than before?
 <br>
 All are very important questions and featurewiz answers them by using the SULOV method and Recursive XGBoost to reduce features in your dataset to the best "minimum optimal" features for the model.<br>
-<p><b>SULOV</b>: SULOV stands for `Searching for Uncorrelated List of Variables`. The SULOV algorithm is based on the Minimum-Redundancy-Maximum-Relevance (MRMR) <a href="https://towardsdatascience.com/mrmr-explained-exactly-how-you-wished-someone-explained-to-you-9cf4ed27458b">algorithm explained in this article</a> as one of the best feature selection methods. To understand how MRMR works and how it is different from `Boruta` and other feature selection methods, see the chart below. Here "Minimal Optimal" refers to the MRMR and featurewiz kind of algorithms while "all-relevant" refers to Boruta kind of algorithms.<br>
+<p><b>SULOV</b>: SULOV stands for `Searching for Uncorrelated List of Variables`. The SULOV algorithm is based on the Minimum-Redundancy-Maximum-Relevance (MRMR) <a href="https://towardsdatascience.com/mrmr-explained-exactly-how-you-wished-someone-explained-to-you-9cf4ed27458b">algorithm explained in this article</a> as one of the best feature selection methods. To understand how MRMR works and how it is different from `Boruta` and other feature selection methods, see the chart below. Here "Minimal Optimal" refers to MRMR  (featurewiz) while "all-relevant" refers to Boruta.<br>
 
-![MRMR_chart](MRMR.png)
+![MRMR_chart](images/MRMR.png)
 
 ## Working
 `featurewiz` performs feature selection in 2 steps. Each step is explained below.
 <b>The working of the `SULOV` algorithm</b> is as follows:
 <ol>
 <li>Find all the pairs of highly correlated variables exceeding a correlation threshold (say absolute(0.7)).</li>
 <li>Then find their MIS score (Mutual Information Score) to the target variable. MIS is a non-parametric scoring method. So its suitable for all kinds of variables and target.</li>
 <li>Now take each pair of correlated variables, then knock off the one with the lower MIS score.</li>
 <li>What’s left is the ones with the highest Information scores and least correlation with each other.</li>
 </ol>
 
-![sulov](SULOV.jpg)
+![sulov](images/SULOV.jpg)
 
 <b>The working of the Recursive XGBoost</b> is as follows: 
 Once SULOV has selected variables that have high mutual information scores with least less correlation amongst them, featurewiz uses XGBoost to repeatedly find the best features among the remaining variables after SULOV. 
 <ol>
 <li>Select all variables in data set and the full data split into train and valid sets.</li>
 <li>Find top X features (could be 10) on train using valid for early stopping (to prevent over-fitting)</li>
 <li>Then take next set of vars and find top X</li>
 <li>Do this 5 times. Combine all selected features and de-duplicate them.</li>
 </ol>
 
-![xgboost](xgboost.jpg)
+![xgboost](images/xgboost.jpg)
 
 ## Tips
 Here are some additional tips for ML engineers and data scientists when using featurewiz:
 <ol>
 <li><b>Always cross-validate your results</b>: When you use a feature selection tool, it is important to cross-validate your results. This means that you should split your data into a training set and a test set. Use the training set to select features, and then evaluate your model on the test set. This will help you to ensure that your model is not overfitting to the training data.</li>
 <li><b>Use multiple feature selection tools</b>: It is a good idea to use multiple feature selection tools and compare the results. This will help you to get a better understanding of which features are most important for your data.</li>
 <li><b>Don't forget to engineer new features</b>: Feature selection is only one part of the process of building a good machine learning model. You should also spend time engineering your features to make them as informative as possible. This can involve things like creating new features, transforming existing features, and removing irrelevant features.</li>
@@ -109,25 +109,18 @@
 As of June 2022, thanks to [arturdaraujo](https://github.com/arturdaraujo), featurewiz is now available on conda-forge. You can try:<br>
 
 ```
  conda install -c conda-forge featurewiz
 ```
 
 ### If the above conda install fails, you can try installing featurewiz this way:
-##Step 1: Install featurewiz first<br>
-
-```
- !pip install featurewiz --ignore-installed --no-deps
- !pip install xlrd --ignore-installed --no-deps 
-```
-
-##Step 2: Next, install Pillow since Kaggle has an incompatible version. <br>
+##### Install featurewiz using git+<br>
 
 ```
- !pip install Pillow==9.0.0
+!pip install git+https://github.com/AutoViML/featurewiz.git
 ```
 
 ## Usage
 
 For feature selection, you must use the newer syntax which is similar to the scikit-learn fit and predict transformer syntax below.
 
 ```
@@ -141,15 +134,15 @@
 
 Alternatively, you can use featurewiz for feature engineering using this older syntax. Otherwise, it will give an error. If you want to combine feature engg and then feature selection, you must use this older syntax:
 
 ```
 import featurewiz as fwiz
 outputs = fwiz.featurewiz(dataname=train, target=target, corr_limit=0.70, verbose=2, sep=',', 
 		header=0, test_data='',feature_engg='', category_encoders='',
-		dask_xgboost_flag=False, nrows=None)
+		dask_xgboost_flag=False, nrows=None, skip_sulov=False, skip_xgboost=False)
 ```
 
 `outputs`: There will always be multiple objects in output. The objects in that tuple can vary:
 1. "features" and "trainm": It be a list (of selected features) and one dataframe (if you sent in train only)
 2. "trainm" and "testm": It can be two dataframes when you send in both test and train but with selected features.
 <ol>
 <li>Both the selected features and dataframes are ready for you to now to do further modeling.
@@ -193,27 +186,29 @@
     - `WOEEncoder`: WOEEncoder uses the Weight of Evidence technique for categorical features. It supports only one kind of target: binary. For polynomial target support, it uses a PolynomialWrapper. It cannot be used for Regression.
     - `JamesSteinEncoder`: JamesSteinEncoder uses the James-Stein estimator. It supports 2 kinds of targets: binary and continuous. For polynomial target support, it uses PolynomialWrapper.
     For feature value i, James-Stein estimator returns a weighted average of:
     The mean target value for the observed feature value i.
     The mean target value (regardless of the feature value).
     - `dask_xgboost_flag`: Default is False. Set to True to use dask_xgboost estimator. You can turn it off if it gives an error. Then it will use pandas and regular xgboost to do the job.
     - `nrows`: default `None`. You can set the number of rows to read from your datafile if it is too large to fit into either dask or pandas. But you won't have to if you use dask. 
+    - `skip_sulov`: default `False`. You can set the flag to skip the SULOV method if you wanted. 
+    - `skip_xgboost`: default `False`. You can set the flag to skip the Recursive XGBoost method if you wanted. 
 
 **Output values**
 -   `outputs`: Output is always a tuple. We can call our outputs in that tuple: out1 and out2.
     -   `out1` and `out2`: If you sent in just one dataframe or filename as input, you will get:
         - 1. `features`: It will be a list (of selected features) and
         - 2. `trainm`: It will be a dataframe (if you sent in a file or dataname as input)
     -   `out1` and `out2`: If you sent in two files or dataframes (train and test), you will get:
         - 1. `trainm`: a modified train dataframe with engineered and selected features from dataname and
         - 2. `testm`: a modified test dataframe with engineered and selected features from test_data.
 
 ## Additional
 
-![background](featurewiz_background.jpg)
+![background](images/featurewiz_background.jpg)
 
 To learn more about how featurewiz works under the hood, watch this [video](https://www.youtube.com/embed/ZiNutwPcAU0)<br>
 <p>featurewiz was designed for selecting High Performance variables with the fewest steps.
 In most cases, featurewiz builds models with 20%-99% fewer features than your original data set with nearly the same or slightly lower performance (this is based on my trials. Your experience may vary).<br>
 <p>
 featurewiz is every Data Scientist's feature wizard that will:<ol>
 <li><b>Automatically pre-process data</b>: you can send in your entire dataframe "as is" and featurewiz will classify and change/label encode categorical variables changes to help XGBoost processing. It classifies variables as numeric or categorical or NLP or date-time variables automatically so it can use them correctly to model.<br>
```

#### html2text {}

```diff
@@ -1,42 +1,42 @@
-# featurewiz `featurewiz` is a powerful feature selection library that has a
-number of features that make it stand out from the competition, including:
-   1. It provides one of the best automatic feature selection algorithms
-      (Minimum Redundancy Maximum Relevance (MRMR)) described by wikipedia as:
-      "The_MRMR_selection_has_been_found_to_be_more_powerful_than_the_maximum
-      relevance_feature_selection" such as Boruta.
-   2. It selects the best number of un-correlated features that have maximum
-      mutual information about the target without having to specify the number
-      of features
-   3. It is fast and easy to use, and comes with a number of helpful features,
-      such as a built-in categorical-to-numeric encoder and a powerful feature
-      engineering module
-   4. It is well-documented, and it comes with a number of examples.
-   5. It is actively maintained, and it is regularly updated with new features
-      and bug fixes.
-## Latest Updates If you are looking for the latest and greatest updates about
-the library, we would definitely recommend checking out our updates_page often.
-It is a powerful tool that can help you improve the performance of your machine
-learning models with constant new capabilities from featurewiz. # Table of
-Contents
+# featurewiz `featurewiz` is the best feature selection library for boosting
+your machine learning performance with minimal effort and maximum relevance
+using the famous MRMR algorithm. ![banner](images/featurewiz_logos.png) # Table
+of Contents
+    * Latest_updates
     * What_is_featurewiz
     * How_it_works
     * Tips_for_using_featurewiz
     * How_to_install_featurewiz
     * Usage
     * API
     * Additional_Tips
     * Maintainers
     * Contributing
     * License
     * Disclaimer
-![banner](featurewiz_logos.png) ## Introduction `featurewiz` a new python
-library for creating and selecting the best features in your data set fast!
-`featurewiz` can be used in one or two ways. Both are explained below. ### 1.
-Feature Engineering
+## Latest If you are looking for the latest and greatest updates about our
+library, we would definitely recommend checking out our updates_page often. ##
+Introduction `featurewiz` a new python library for creating and selecting the
+best features in your data set fast! `featurewiz` can be used in one or two
+ways. Both are explained below.
+   1. It provides one of the best automatic feature selection algorithms
+      (Minimum Redundancy Maximum Relevance (MRMR)) described by wikipedia as:
+      "The_MRMR_selection_has_been_found_to_be_more_powerful_than_the_maximum
+      relevance_feature_selection" such as Boruta.
+   2. It selects the best number of un-correlated features that have maximum
+      mutual information about the target without having to specify the number
+      of features
+   3. It is fast and easy to use, and comes with a number of helpful features,
+      such as a built-in categorical-to-numeric encoder and a powerful feature
+      engineering module
+   4. It is well-documented, and it comes with a number of examples.
+   5. It is actively maintained, and it is regularly updated with new_features
+      and_bug_fixes.
+### 1. Feature Engineering
 The first step is not absolutely necessary but it can be used to create new
 features that may or may not be helpful (be careful with automated feature
 engineering tools!).
 1. Performing Feature Engineering: One of the gaps in open source AutoML tools
 and especially Auto_ViML has been the lack of feature engineering capabilities
 that high powered competitions such as Kaggle required. The ability to create
 "interaction" variables or adding "group-by" features or "target-encoding"
@@ -46,15 +46,15 @@
 featurewiz now enables you to add hundreds of such features with a single line
 of code. Set the "feature_engg" flag to "interactions", "groupby" or "target"
 and featurewiz will select the best encoders for each of those options and
 create hundreds (perhaps thousands) of features in one go. Not only that, using
 the next step, featurewiz will sift through numerous such variables and find
 only the least correlated and most relevant features to your model. All in one
 step!.
-![feature_engg](feature_engg.jpg) ### 2. Feature Selection
+![feature_engg](images/feature_engg.jpg) ### 2. Feature Selection
 The second step is Feature Selection. `featurewiz` uses the MRMR (Minimum
 Redundancy Maximum Relevance) algorithm as the basis for its feature selection.
 
 Why do Feature Selection? Once you have created 100's of new features, you
 still have three questions left to answer: 1. How do we interpret those newly
 created features? 2. Which of these features is important and which are
 useless? How many of them are highly correlated to each other causing
@@ -64,40 +64,39 @@
 method and Recursive XGBoost to reduce features in your dataset to the best
 "minimum optimal" features for the model.
 SULOV: SULOV stands for `Searching for Uncorrelated List of Variables`. The
 SULOV algorithm is based on the Minimum-Redundancy-Maximum-Relevance (MRMR)
 algorithm_explained_in_this_article as one of the best feature selection
 methods. To understand how MRMR works and how it is different from `Boruta` and
 other feature selection methods, see the chart below. Here "Minimal Optimal"
-refers to the MRMR and featurewiz kind of algorithms while "all-relevant"
-refers to Boruta kind of algorithms.
-![MRMR_chart](MRMR.png) ## Working `featurewiz` performs feature selection in 2
-steps. Each step is explained below. The working of the `SULOV` algorithm is as
-follows:
+refers to MRMR (featurewiz) while "all-relevant" refers to Boruta.
+![MRMR_chart](images/MRMR.png) ## Working `featurewiz` performs feature
+selection in 2 steps. Each step is explained below. The working of the `SULOV`
+algorithm is as follows:
    1. Find all the pairs of highly correlated variables exceeding a correlation
       threshold (say absolute(0.7)).
    2. Then find their MIS score (Mutual Information Score) to the target
       variable. MIS is a non-parametric scoring method. So its suitable for all
       kinds of variables and target.
    3. Now take each pair of correlated variables, then knock off the one with
       the lower MIS score.
    4. Whatâs left is the ones with the highest Information scores and least
       correlation with each other.
-![sulov](SULOV.jpg) The working of the Recursive XGBoost is as follows: Once
-SULOV has selected variables that have high mutual information scores with
+![sulov](images/SULOV.jpg) The working of the Recursive XGBoost is as follows:
+Once SULOV has selected variables that have high mutual information scores with
 least less correlation amongst them, featurewiz uses XGBoost to repeatedly find
 the best features among the remaining variables after SULOV.
    1. Select all variables in data set and the full data split into train and
       valid sets.
    2. Find top X features (could be 10) on train using valid for early stopping
       (to prevent over-fitting)
    3. Then take next set of vars and find top X
    4. Do this 5 times. Combine all selected features and de-duplicate them.
-![xgboost](xgboost.jpg) ## Tips Here are some additional tips for ML engineers
-and data scientists when using featurewiz:
+![xgboost](images/xgboost.jpg) ## Tips Here are some additional tips for ML
+engineers and data scientists when using featurewiz:
    1. Always cross-validate your results: When you use a feature selection
       tool, it is important to cross-validate your results. This means that you
       should split your data into a training set and a test set. Use the
       training set to select features, and then evaluate your model on the test
       set. This will help you to ensure that your model is not overfitting to
       the training data.
    2. Use multiple feature selection tools: It is a good idea to use multiple
@@ -132,36 +131,34 @@
 archive/master.zip conda create -n  python=3.7 anaconda conda activate  # ON
 WINDOWS: `source activate ` cd featurewiz pip install -r requirements.txt ```
 ## Good News: You can install featurewiz on Colab and Kaggle easily in 2 steps!
 Check_out_more_latest_updates_from_this_page
 As of June 2022, thanks to [arturdaraujo](https://github.com/arturdaraujo),
 featurewiz is now available on conda-forge. You can try:
 ``` conda install -c conda-forge featurewiz ``` ### If the above conda install
-fails, you can try installing featurewiz this way: ##Step 1: Install featurewiz
-first
-``` !pip install featurewiz --ignore-installed --no-deps !pip install xlrd --
-ignore-installed --no-deps ``` ##Step 2: Next, install Pillow since Kaggle has
-an incompatible version.
-``` !pip install Pillow==9.0.0 ``` ## Usage For feature selection, you must use
-the newer syntax which is similar to the scikit-learn fit and predict
-transformer syntax below. ``` from featurewiz import FeatureWiz fwiz =
-FeatureWiz(corr_limit=0.70, feature_engg='', category_encoders='',
-dask_xgboost_flag=False, nrows=None, verbose=2) X_train_selected =
-fwiz.fit_transform(X_train, y_train) X_test_selected = fwiz.transform(X_test)
-### get list of selected features ### fwiz.features ``` Alternatively, you can
-use featurewiz for feature engineering using this older syntax. Otherwise, it
-will give an error. If you want to combine feature engg and then feature
-selection, you must use this older syntax: ``` import featurewiz as fwiz
-outputs = fwiz.featurewiz(dataname=train, target=target, corr_limit=0.70,
-verbose=2, sep=',', header=0, test_data='',feature_engg='',
-category_encoders='', dask_xgboost_flag=False, nrows=None) ``` `outputs`: There
-will always be multiple objects in output. The objects in that tuple can vary:
-1. "features" and "trainm": It be a list (of selected features) and one
-dataframe (if you sent in train only) 2. "trainm" and "testm": It can be two
-dataframes when you send in both test and train but with selected features.
+fails, you can try installing featurewiz this way: ##### Install featurewiz
+using git+
+``` !pip install git+https://github.com/AutoViML/featurewiz.git ``` ## Usage
+For feature selection, you must use the newer syntax which is similar to the
+scikit-learn fit and predict transformer syntax below. ``` from featurewiz
+import FeatureWiz fwiz = FeatureWiz(corr_limit=0.70, feature_engg='',
+category_encoders='', dask_xgboost_flag=False, nrows=None, verbose=2)
+X_train_selected = fwiz.fit_transform(X_train, y_train) X_test_selected =
+fwiz.transform(X_test) ### get list of selected features ### fwiz.features ```
+Alternatively, you can use featurewiz for feature engineering using this older
+syntax. Otherwise, it will give an error. If you want to combine feature engg
+and then feature selection, you must use this older syntax: ``` import
+featurewiz as fwiz outputs = fwiz.featurewiz(dataname=train, target=target,
+corr_limit=0.70, verbose=2, sep=',', header=0, test_data='',feature_engg='',
+category_encoders='', dask_xgboost_flag=False, nrows=None, skip_sulov=False,
+skip_xgboost=False) ``` `outputs`: There will always be multiple objects in
+output. The objects in that tuple can vary: 1. "features" and "trainm": It be a
+list (of selected features) and one dataframe (if you sent in train only) 2.
+"trainm" and "testm": It can be two dataframes when you send in both test and
+train but with selected features.
    1. Both the selected features and dataframes are ready for you to now to do
       further modeling.
    2. Featurewiz works on any multi-class, multi-label data Set. So you can
       have as many target labels as you want.
    3. You don't have to tell Featurewiz whether it is a Regression or
       Classification problem. It will decide that automatically.
 ## API **Arguments** - `dataname`: could be a datapath+filename or a dataframe.
@@ -231,26 +228,28 @@
 support, it uses PolynomialWrapper. For feature value i, James-Stein estimator
 returns a weighted average of: The mean target value for the observed feature
 value i. The mean target value (regardless of the feature value). -
 `dask_xgboost_flag`: Default is False. Set to True to use dask_xgboost
 estimator. You can turn it off if it gives an error. Then it will use pandas
 and regular xgboost to do the job. - `nrows`: default `None`. You can set the
 number of rows to read from your datafile if it is too large to fit into either
-dask or pandas. But you won't have to if you use dask. **Output values** -
-`outputs`: Output is always a tuple. We can call our outputs in that tuple:
-out1 and out2. - `out1` and `out2`: If you sent in just one dataframe or
-filename as input, you will get: - 1. `features`: It will be a list (of
-selected features) and - 2. `trainm`: It will be a dataframe (if you sent in a
-file or dataname as input) - `out1` and `out2`: If you sent in two files or
-dataframes (train and test), you will get: - 1. `trainm`: a modified train
-dataframe with engineered and selected features from dataname and - 2. `testm`:
-a modified test dataframe with engineered and selected features from test_data.
-## Additional ![background](featurewiz_background.jpg) To learn more about how
-featurewiz works under the hood, watch this [video](https://www.youtube.com/
-embed/ZiNutwPcAU0)
+dask or pandas. But you won't have to if you use dask. - `skip_sulov`: default
+`False`. You can set the flag to skip the SULOV method if you wanted. -
+`skip_xgboost`: default `False`. You can set the flag to skip the Recursive
+XGBoost method if you wanted. **Output values** - `outputs`: Output is always a
+tuple. We can call our outputs in that tuple: out1 and out2. - `out1` and
+`out2`: If you sent in just one dataframe or filename as input, you will get: -
+1. `features`: It will be a list (of selected features) and - 2. `trainm`: It
+will be a dataframe (if you sent in a file or dataname as input) - `out1` and
+`out2`: If you sent in two files or dataframes (train and test), you will get:
+- 1. `trainm`: a modified train dataframe with engineered and selected features
+from dataname and - 2. `testm`: a modified test dataframe with engineered and
+selected features from test_data. ## Additional ![background](images/
+featurewiz_background.jpg) To learn more about how featurewiz works under the
+hood, watch this [video](https://www.youtube.com/embed/ZiNutwPcAU0)
 featurewiz was designed for selecting High Performance variables with the
 fewest steps. In most cases, featurewiz builds models with 20%-99% fewer
 features than your original data set with nearly the same or slightly lower
 performance (this is based on my trials. Your experience may vary).
 featurewiz is every Data Scientist's feature wizard that will:
    1. Automatically pre-process data: you can send in your entire dataframe "as
       is" and featurewiz will classify and change/label encode categorical
```

### Comparing `featurewiz-0.3.1/featurewiz/__init__.py` & `featurewiz-0.3.2/featurewiz/__init__.py`

 * *Files 1% similar despite different names*

```diff
@@ -42,11 +42,11 @@
     module_type = 'Running'
 else:
     module_type = 'Imported'
 version_number = __version__
 print("""%s %s version. Select nrows to a small number when running on huge datasets.
 output = featurewiz(dataname, target, corr_limit=0.90, verbose=2, sep=',', 
 		header=0, test_data='',feature_engg='', category_encoders='',
-		dask_xgboost_flag=False, nrows=None, skip_sulov=False)
+		dask_xgboost_flag=False, nrows=None, skip_sulov=False, skip_xgboost=False)
 Create new features via 'feature_engg' flag : ['interactions','groupby','target']
 """ %(module_type, version_number))
 ################################################################################
```

### Comparing `featurewiz-0.3.1/featurewiz/classify_method.py` & `featurewiz-0.3.2/featurewiz/classify_method.py`

 * *Files identical despite different names*

### Comparing `featurewiz-0.3.1/featurewiz/databunch.py` & `featurewiz-0.3.2/featurewiz/databunch.py`

 * *Files identical despite different names*

### Comparing `featurewiz-0.3.1/featurewiz/encoders.py` & `featurewiz-0.3.2/featurewiz/encoders.py`

 * *Files identical despite different names*

### Comparing `featurewiz-0.3.1/featurewiz/featurewiz.py` & `featurewiz-0.3.2/featurewiz/featurewiz.py`

 * *Files 0% similar despite different names*

```diff
@@ -1242,9310 +1242,9400 @@
 00004d90: 2020 7465 7374 5f64 6174 613d 2727 2c20    test_data='', 
 00004da0: 6665 6174 7572 655f 656e 6767 3d27 272c  feature_engg='',
 00004db0: 2063 6174 6567 6f72 795f 656e 636f 6465   category_encode
 00004dc0: 7273 3d27 272c 2064 6173 6b5f 7867 626f  rs='', dask_xgbo
 00004dd0: 6f73 745f 666c 6167 3d46 616c 7365 2c0a  ost_flag=False,.
 00004de0: 2020 2020 2020 2020 2020 2020 6e72 6f77              nrow
 00004df0: 733d 4e6f 6e65 2c20 736b 6970 5f73 756c  s=None, skip_sul
-00004e00: 6f76 3d46 616c 7365 2c20 202a 2a6b 7761  ov=False,  **kwa
-00004e10: 7267 7329 3a0a 2020 2020 2222 220a 2020  rgs):.    """.  
-00004e20: 2020 2323 2323 2323 2323 2323 2323 2323    ##############
-00004e30: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00004e00: 6f76 3d46 616c 7365 2c20 736b 6970 5f78  ov=False, skip_x
+00004e10: 6762 6f6f 7374 3d46 616c 7365 2c20 202a  gboost=False,  *
+00004e20: 2a6b 7761 7267 7329 3a0a 2020 2020 2222  *kwargs):.    ""
+00004e30: 220a 2020 2020 2323 2323 2323 2323 2323  ".    ##########
 00004e40: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 00004e50: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 00004e60: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00004e70: 2323 230a 2020 2020 2323 2323 2323 2323  ###.    ########
-00004e80: 2323 2323 2323 2320 2020 2020 2020 2020  #######         
-00004e90: 2020 4620 4520 4120 5420 5520 5220 4520    F E A T U R E 
-00004ea0: 2020 5720 4920 5a20 4120 5220 4420 2020    W I Z A R D   
-00004eb0: 2020 2020 2020 2023 2323 2323 2323 2323         #########
-00004ec0: 2323 2323 2323 2323 230a 2020 2020 2323  #########.    ##
-00004ed0: 2323 2323 2323 2323 2323 2323 2323 2020  ##############  
-00004ee0: 6665 6174 7572 6577 697a 206c 6962 7261  featurewiz libra
-00004ef0: 7279 2064 6576 656c 6f70 6564 2062 7920  ry developed by 
-00004f00: 5261 6d20 5365 7368 6164 7269 2020 2323  Ram Seshadri  ##
-00004f10: 2323 2323 2323 2323 2323 2323 2323 230a  ###############.
-00004f20: 2020 2020 2320 6665 6174 7572 6577 697a      # featurewiz
-00004f30: 2075 7469 6c69 7a65 7320 5355 4c4f 5620   utilizes SULOV 
-00004f40: 4d45 5448 4f44 2077 6869 6368 2069 7320  METHOD which is 
-00004f50: 6120 6661 7374 206d 6574 686f 6420 666f  a fast method fo
-00004f60: 7220 6665 6174 7572 6520 7365 6c65 6374  r feature select
-00004f70: 696f 6e20 230a 2020 2020 2323 2323 2320  ion #.    ##### 
-00004f80: 2053 554c 4f56 2061 6c73 6f20 6d65 616e   SULOV also mean
-00004f90: 7320 5365 6172 6368 696e 6720 666f 7220  s Searching for 
-00004fa0: 556e 636f 7272 656c 6174 6564 204c 6973  Uncorrelated Lis
-00004fb0: 7420 4f66 2056 6172 6961 626c 6573 2028  t Of Variables (
-00004fc0: 3a2d 2920 2023 2323 2323 230a 2020 2020  :-)  ######.    
-00004fd0: 2323 2323 2323 2323 2323 2323 2323 2320  ############### 
-00004fe0: 2020 2020 4120 4c20 4c20 2020 5220 4920      A L L   R I 
-00004ff0: 4720 4820 5420 5320 2052 2045 2053 2045  G H T S  R E S E
-00005000: 2052 2056 2045 2044 2020 2020 2020 2020   R V E D        
-00005010: 2023 2323 2323 2323 2323 2323 2323 2323   ###############
-00005020: 230a 2020 2020 2323 2323 2323 2323 2323  #.    ##########
-00005030: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00004e70: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00004e80: 2323 2323 2323 230a 2020 2020 2323 2323  #######.    ####
+00004e90: 2323 2323 2323 2323 2323 2320 2020 2020  ###########     
+00004ea0: 2020 2020 2020 4620 4520 4120 5420 5520        F E A T U 
+00004eb0: 5220 4520 2020 5720 4920 5a20 4120 5220  R E   W I Z A R 
+00004ec0: 4420 2020 2020 2020 2020 2023 2323 2323  D          #####
+00004ed0: 2323 2323 2323 2323 2323 2323 230a 2020  #############.  
+00004ee0: 2020 2323 2323 2323 2323 2323 2323 2323    ##############
+00004ef0: 2323 2020 6665 6174 7572 6577 697a 206c  ##  featurewiz l
+00004f00: 6962 7261 7279 2064 6576 656c 6f70 6564  ibrary developed
+00004f10: 2062 7920 5261 6d20 5365 7368 6164 7269   by Ram Seshadri
+00004f20: 2020 2323 2323 2323 2323 2323 2323 2323    ##############
+00004f30: 2323 230a 2020 2020 2320 6665 6174 7572  ###.    # featur
+00004f40: 6577 697a 2075 7469 6c69 7a65 7320 5355  ewiz utilizes SU
+00004f50: 4c4f 5620 4d45 5448 4f44 2077 6869 6368  LOV METHOD which
+00004f60: 2069 7320 6120 6661 7374 206d 6574 686f   is a fast metho
+00004f70: 6420 666f 7220 6665 6174 7572 6520 7365  d for feature se
+00004f80: 6c65 6374 696f 6e20 230a 2020 2020 2323  lection #.    ##
+00004f90: 2323 2320 2053 554c 4f56 2061 6c73 6f20  ###  SULOV also 
+00004fa0: 6d65 616e 7320 5365 6172 6368 696e 6720  means Searching 
+00004fb0: 666f 7220 556e 636f 7272 656c 6174 6564  for Uncorrelated
+00004fc0: 204c 6973 7420 4f66 2056 6172 6961 626c   List Of Variabl
+00004fd0: 6573 2028 3a2d 2920 2023 2323 2323 230a  es (:-)  ######.
+00004fe0: 2020 2020 2323 2323 2323 2323 2323 2323      ############
+00004ff0: 2323 2320 2020 2020 4120 4c20 4c20 2020  ###     A L L   
+00005000: 5220 4920 4720 4820 5420 5320 2052 2045  R I G H T S  R E
+00005010: 2053 2045 2052 2056 2045 2044 2020 2020   S E R V E D    
+00005020: 2020 2020 2023 2323 2323 2323 2323 2323       ###########
+00005030: 2323 2323 230a 2020 2020 2323 2323 2323  #####.    ######
 00005040: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 00005050: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 00005060: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00005070: 2323 2323 2323 230a 2020 2020 4665 6174  #######.    Feat
-00005080: 7572 6577 697a 2069 7320 7468 6520 6d61  urewiz is the ma
-00005090: 696e 206d 6f64 756c 6520 6f66 2074 6869  in module of thi
-000050a0: 7320 6c69 6272 6172 792e 2059 6f75 2077  s library. You w
-000050b0: 696c 6c20 6372 6561 7465 2066 6561 7475  ill create featu
-000050c0: 7265 7320 616e 6420 7365 6c65 6374 0a20  res and select. 
-000050d0: 2020 2074 6865 2062 6573 7420 6665 6174     the best feat
-000050e0: 7572 6573 2075 7369 6e67 2074 6865 2053  ures using the S
-000050f0: 554c 4f56 206d 6574 686f 6420 616e 6420  ULOV method and 
-00005100: 7065 726d 7574 6174 696f 6e20 6261 7365  permutation base
-00005110: 6420 5847 4220 6665 6174 7572 6520 696d  d XGB feature im
-00005120: 706f 7274 616e 6365 2e0a 2020 2020 4974  portance..    It
-00005130: 2072 6574 7572 6e73 2061 206c 6973 7420   returns a list 
-00005140: 6f66 2069 6d70 6f72 7461 6e74 2066 6561  of important fea
-00005150: 7475 7265 7320 6672 6f6d 2079 6f75 7220  tures from your 
-00005160: 6461 7461 6672 616d 6520 6166 7465 7220  dataframe after 
-00005170: 6665 6174 7572 6520 656e 6769 6e65 6572  feature engineer
-00005180: 696e 672e 0a20 2020 2053 696e 6365 2077  ing..    Since w
-00005190: 6520 646f 206c 6162 656c 2065 6e63 6f64  e do label encod
-000051a0: 696e 672c 2079 6f75 2063 616e 2073 656e  ing, you can sen
-000051b0: 6420 626f 7468 2063 6174 6567 6f72 6963  d both categoric
-000051c0: 616c 2061 6e64 206e 756d 6572 6963 2076  al and numeric v
-000051d0: 6172 732e 0a20 2020 2059 6f75 2063 616e  ars..    You can
-000051e0: 2061 6c73 6f20 7365 6e64 2069 6e20 6665   also send in fe
-000051f0: 6174 7572 6573 2077 6974 6820 4e61 4e27  atures with NaN'
-00005200: 7320 696e 2074 6865 6d2e 0a20 2020 2023  s in them..    #
-00005210: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00005220: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00005070: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00005080: 2323 2323 2323 2323 2323 230a 2020 2020  ###########.    
+00005090: 4665 6174 7572 6577 697a 2069 7320 7468  Featurewiz is th
+000050a0: 6520 6d61 696e 206d 6f64 756c 6520 6f66  e main module of
+000050b0: 2074 6869 7320 6c69 6272 6172 792e 2059   this library. Y
+000050c0: 6f75 2077 696c 6c20 6372 6561 7465 2066  ou will create f
+000050d0: 6561 7475 7265 7320 616e 6420 7365 6c65  eatures and sele
+000050e0: 6374 0a20 2020 2074 6865 2062 6573 7420  ct.    the best 
+000050f0: 6665 6174 7572 6573 2075 7369 6e67 2074  features using t
+00005100: 6865 2053 554c 4f56 206d 6574 686f 6420  he SULOV method 
+00005110: 616e 6420 7065 726d 7574 6174 696f 6e20  and permutation 
+00005120: 6261 7365 6420 5847 4220 6665 6174 7572  based XGB featur
+00005130: 6520 696d 706f 7274 616e 6365 2e0a 2020  e importance..  
+00005140: 2020 4974 2072 6574 7572 6e73 2061 206c    It returns a l
+00005150: 6973 7420 6f66 2069 6d70 6f72 7461 6e74  ist of important
+00005160: 2066 6561 7475 7265 7320 6672 6f6d 2079   features from y
+00005170: 6f75 7220 6461 7461 6672 616d 6520 6166  our dataframe af
+00005180: 7465 7220 6665 6174 7572 6520 656e 6769  ter feature engi
+00005190: 6e65 6572 696e 672e 0a20 2020 2053 696e  neering..    Sin
+000051a0: 6365 2077 6520 646f 206c 6162 656c 2065  ce we do label e
+000051b0: 6e63 6f64 696e 672c 2079 6f75 2063 616e  ncoding, you can
+000051c0: 2073 656e 6420 626f 7468 2063 6174 6567   send both categ
+000051d0: 6f72 6963 616c 2061 6e64 206e 756d 6572  orical and numer
+000051e0: 6963 2076 6172 732e 0a20 2020 2059 6f75  ic vars..    You
+000051f0: 2063 616e 2061 6c73 6f20 7365 6e64 2069   can also send i
+00005200: 6e20 6665 6174 7572 6573 2077 6974 6820  n features with 
+00005210: 4e61 4e27 7320 696e 2074 6865 6d2e 0a20  NaN's in them.. 
+00005220: 2020 2023 2323 2323 2323 2323 2323 2323     #############
 00005230: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 00005240: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 00005250: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00005260: 0a20 2020 2049 6e70 7574 733a 0a20 2020  .    Inputs:.   
-00005270: 2020 2020 2064 6174 616e 616d 653a 2074       dataname: t
-00005280: 7261 696e 696e 6720 6461 7461 2073 6574  raining data set
-00005290: 2079 6f75 2077 616e 7420 746f 2069 6e70   you want to inp
-000052a0: 7574 2e20 6461 7461 6e61 6d65 2063 6f75  ut. dataname cou
-000052b0: 6c64 2062 6520 6120 6461 7461 7061 7468  ld be a datapath
-000052c0: 2b66 696c 656e 616d 6520 6f72 2061 2064  +filename or a d
-000052d0: 6174 6166 7261 6d65 2e20 0a20 2020 2020  ataframe. .     
-000052e0: 2020 2020 2020 2066 6561 7475 7265 7769         featurewi
-000052f0: 7a20 7769 6c6c 2064 6574 6563 7420 7768  z will detect wh
-00005300: 6574 6865 7220 796f 7572 2069 6e70 7574  ether your input
-00005310: 2069 7320 6120 6669 6c65 6e61 6d65 206f   is a filename o
-00005320: 7220 6120 6461 7461 6672 616d 6520 616e  r a dataframe an
-00005330: 6420 6c6f 6164 2069 7420 6175 746f 6d61  d load it automa
-00005340: 7469 6361 6c6c 792e 0a20 2020 2020 2020  tically..       
-00005350: 2074 6172 6765 743a 206e 616d 6520 6f66   target: name of
-00005360: 2074 6865 2074 6172 6765 7420 7661 7269   the target vari
-00005370: 6162 6c65 2069 6e20 7468 6520 6461 7461  able in the data
-00005380: 2073 6574 2e20 416c 736f 206b 6e6f 776e   set. Also known
-00005390: 2061 7320 6465 7065 6e64 656e 7420 7661   as dependent va
-000053a0: 7269 6162 6c65 2e0a 2020 2020 2020 2020  riable..        
-000053b0: 636f 7272 5f6c 696d 6974 3a20 6966 2079  corr_limit: if y
-000053c0: 6f75 2077 616e 7420 746f 2073 6574 2079  ou want to set y
-000053d0: 6f75 7220 6f77 6e20 7468 7265 7368 6f6c  our own threshol
-000053e0: 6420 666f 7220 7265 6d6f 7669 6e67 2076  d for removing v
-000053f0: 6172 6961 626c 6573 2061 730a 2020 2020  ariables as.    
-00005400: 2020 2020 2020 2020 6869 6768 6c79 2063          highly c
-00005410: 6f72 7265 6c61 7465 642c 2074 6865 6e20  orrelated, then 
-00005420: 6769 7665 2069 7420 6865 7265 2e20 5468  give it here. Th
-00005430: 6520 6465 6661 756c 7420 6973 2030 2e37  e default is 0.7
-00005440: 2077 6869 6368 206d 6561 6e73 2076 6172   which means var
-00005450: 6961 626c 6573 206c 6573 730a 2020 2020  iables less.    
-00005460: 2020 2020 2020 2020 7468 616e 202d 302e          than -0.
-00005470: 3720 616e 6420 6772 6561 7465 7220 7468  7 and greater th
-00005480: 616e 2030 2e37 2069 6e20 7065 6172 736f  an 0.7 in pearso
-00005490: 6e27 7320 636f 7272 656c 6174 696f 6e20  n's correlation 
-000054a0: 7769 6c6c 2062 6520 6361 6e64 6964 6174  will be candidat
-000054b0: 6573 2066 6f72 2072 656d 6f76 616c 2e0a  es for removal..
-000054c0: 2020 2020 2020 2020 7665 7262 6f73 653a          verbose:
-000054d0: 2054 6869 7320 6861 7320 3320 706f 7373   This has 3 poss
-000054e0: 6962 6c65 2073 7461 7465 733a 0a20 2020  ible states:.   
-000054f0: 2020 2020 2020 2020 2030 206c 696d 6974           0 limit
-00005500: 6564 206f 7574 7075 742e 2047 7265 6174  ed output. Great
-00005510: 2066 6f72 2072 756e 6e69 6e67 2074 6869   for running thi
-00005520: 7320 7369 6c65 6e74 6c79 2061 6e64 2067  s silently and g
-00005530: 6574 7469 6e67 2066 6173 7420 7265 7375  etting fast resu
-00005540: 6c74 732e 0a20 2020 2020 2020 2020 2020  lts..           
-00005550: 2031 206d 6f72 6520 7665 7262 6961 6765   1 more verbiage
-00005560: 2e20 4772 6561 7420 666f 7220 6b6e 6f77  . Great for know
-00005570: 696e 6720 686f 7720 7265 7375 6c74 7320  ing how results 
-00005580: 7765 7265 2061 6e64 206d 616b 696e 6720  were and making 
-00005590: 6368 616e 6765 7320 746f 2066 6c61 6773  changes to flags
-000055a0: 2069 6e20 696e 7075 742e 0a20 2020 2020   in input..     
-000055b0: 2020 2020 2020 2032 2053 554c 4f56 2063         2 SULOV c
-000055c0: 6861 7274 7320 616e 6420 6f75 7470 7574  harts and output
-000055d0: 2e20 4772 6561 7420 666f 7220 6669 6e64  . Great for find
-000055e0: 696e 6720 6f75 7420 7768 6174 2068 6170  ing out what hap
-000055f0: 7065 6e73 2075 6e64 6572 2074 6865 2068  pens under the h
-00005600: 6f6f 6420 666f 7220 5355 4c4f 5620 6d65  ood for SULOV me
-00005610: 7468 6f64 2e0a 2020 2020 2020 2020 7465  thod..        te
-00005620: 7374 5f64 6174 613a 2049 6620 796f 7520  st_data: If you 
-00005630: 7761 6e74 2074 6f20 7472 616e 7366 6f72  want to transfor
-00005640: 6d20 7465 7374 2064 6174 6120 696e 2074  m test data in t
-00005650: 6865 2073 616d 6520 7761 7920 796f 7520  he same way you 
-00005660: 6172 6520 7472 616e 7366 6f72 6d69 6e67  are transforming
-00005670: 2064 6174 616e 616d 652c 2079 6f75 2063   dataname, you c
-00005680: 616e 2e0a 2020 2020 2020 2020 2020 2020  an..            
-00005690: 7465 7374 5f64 6174 6120 636f 756c 6420  test_data could 
-000056a0: 6265 2074 6865 206e 616d 6520 6f66 2061  be the name of a
-000056b0: 2064 6174 6170 6174 682b 6669 6c65 6e61   datapath+filena
-000056c0: 6d65 206f 7220 6120 6461 7461 6672 616d  me or a datafram
-000056d0: 652e 2066 6561 7475 7265 7769 7a20 7769  e. featurewiz wi
-000056e0: 6c6c 2064 6574 6563 7420 7768 6574 6865  ll detect whethe
-000056f0: 720a 2020 2020 2020 2020 2020 2020 2020  r.              
-00005700: 2020 796f 7572 2069 6e70 7574 2069 7320    your input is 
-00005710: 6120 6669 6c65 6e61 6d65 206f 7220 6120  a filename or a 
-00005720: 6461 7461 6672 616d 6520 616e 6420 6c6f  dataframe and lo
-00005730: 6164 2069 7420 6175 746f 6d61 7469 6361  ad it automatica
-00005740: 6c6c 792e 2044 6566 6175 6c74 2069 7320  lly. Default is 
-00005750: 656d 7074 7920 7374 7269 6e67 2e0a 2020  empty string..  
-00005760: 2020 2020 2020 6665 6174 7572 655f 656e        feature_en
-00005770: 6767 3a20 596f 7520 6361 6e20 6c65 7420  gg: You can let 
-00005780: 6665 6174 7572 6577 697a 2073 656c 6563  featurewiz selec
-00005790: 7420 6974 7320 6265 7374 2065 6e63 6f64  t its best encod
-000057a0: 6572 7320 666f 7220 796f 7572 2064 6174  ers for your dat
-000057b0: 6120 7365 7420 6279 2073 6574 7469 6e67  a set by setting
-000057c0: 2074 6869 7320 666c 6167 0a20 2020 2020   this flag.     
-000057d0: 2020 2020 2020 2066 6f72 2061 6464 696e         for addin
-000057e0: 6720 6665 6174 7572 6520 656e 6769 6e65  g feature engine
-000057f0: 6572 696e 672e 2054 6865 7265 2061 7265  ering. There are
-00005800: 2074 6872 6565 2063 686f 6963 6573 2e20   three choices. 
-00005810: 596f 7520 6361 6e20 6368 6f6f 7365 206f  You can choose o
-00005820: 6e65 2c20 7477 6f20 6f72 2061 6c6c 2074  ne, two or all t
-00005830: 6872 6565 2069 6e20 6120 6c69 7374 2e0a  hree in a list..
-00005840: 2020 2020 2020 2020 2020 2020 2769 6e74              'int
-00005850: 6572 6163 7469 6f6e 7327 3a20 5468 6973  eractions': This
-00005860: 2077 696c 6c20 6164 6420 696e 7465 7261   will add intera
-00005870: 6374 696f 6e20 6665 6174 7572 6573 2074  ction features t
-00005880: 6f20 796f 7572 2064 6174 6120 7375 6368  o your data such
-00005890: 2061 7320 7831 2a78 322c 2078 322a 7833   as x1*x2, x2*x3
-000058a0: 2c20 7831 2a2a 322c 2078 322a 2a32 2c20  , x1**2, x2**2, 
-000058b0: 6574 632e 0a20 2020 2020 2020 2020 2020  etc..           
-000058c0: 2027 6772 6f75 7062 7927 3a20 5468 6973   'groupby': This
-000058d0: 2077 696c 6c20 6765 6e65 7261 7465 2047   will generate G
-000058e0: 726f 7570 2042 7920 6665 6174 7572 6573  roup By features
-000058f0: 2074 6f20 796f 7572 206e 756d 6572 6963   to your numeric
-00005900: 2076 6172 7320 6279 2067 726f 7570 696e   vars by groupin
-00005910: 6720 616c 6c20 6361 7465 676f 7269 6361  g all categorica
-00005920: 6c20 7661 7273 2e0a 2020 2020 2020 2020  l vars..        
-00005930: 2020 2020 2774 6172 6765 7427 3a20 2054      'target':  T
-00005940: 6869 7320 7769 6c6c 2065 6e63 6f64 6520  his will encode 
-00005950: 2620 7472 616e 7366 6f72 6d20 616c 6c20  & transform all 
-00005960: 796f 7572 2063 6174 6567 6f72 6963 616c  your categorical
-00005970: 2066 6561 7475 7265 7320 7573 696e 6720   features using 
-00005980: 6365 7274 6169 6e20 7461 7267 6574 2065  certain target e
-00005990: 6e63 6f64 6572 732e 0a20 2020 2020 2020  ncoders..       
-000059a0: 2020 2020 2044 6566 6175 6c74 2069 7320       Default is 
-000059b0: 656d 7074 7920 7374 7269 6e67 2028 7768  empty string (wh
-000059c0: 6963 6820 6d65 616e 7320 6e6f 2061 6464  ich means no add
-000059d0: 6974 696f 6e61 6c20 6665 6174 7572 6520  itional feature 
-000059e0: 656e 6769 6e65 6572 696e 6720 746f 2062  engineering to b
-000059f0: 6520 7065 7266 6f72 6d65 6429 0a20 2020  e performed).   
-00005a00: 2020 2020 2063 6174 6567 6f72 795f 656e       category_en
-00005a10: 636f 6465 7273 3a20 496e 7374 6561 6420  coders: Instead 
-00005a20: 6f66 2061 626f 7665 206d 6574 686f 642c  of above method,
-00005a30: 2079 6f75 2063 616e 2063 686f 6f73 6520   you can choose 
-00005a40: 796f 7572 206f 776e 206b 696e 6420 6f66  your own kind of
-00005a50: 2063 6174 6567 6f72 7920 656e 636f 6465   category encode
-00005a60: 7273 2066 726f 6d20 6265 6c6f 772e 0a20  rs from below.. 
-00005a70: 2020 2020 2020 2020 2020 2052 6563 6f6d             Recom
-00005a80: 6d65 6e64 2079 6f75 2064 6f20 6e6f 7420  mend you do not 
-00005a90: 7573 6520 6d6f 7265 2074 6861 6e20 7477  use more than tw
-00005aa0: 6f20 6f66 2074 6865 7365 2e0a 2020 2020  o of these..    
-00005ab0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005ac0: 2020 2020 2020 2020 4665 6174 7572 6577          Featurew
-00005ad0: 697a 2077 696c 6c20 6175 746f 6d61 7469  iz will automati
-00005ae0: 6361 6c6c 7920 7365 6c65 6374 206f 6e6c  cally select onl
-00005af0: 7920 7477 6f20 6672 6f6d 2079 6f75 7220  y two from your 
-00005b00: 6c69 7374 2e0a 2020 2020 2020 2020 2020  list..          
-00005b10: 2020 4465 6661 756c 7420 6973 2065 6d70    Default is emp
-00005b20: 7479 2073 7472 696e 6720 2877 6869 6368  ty string (which
-00005b30: 206d 6561 6e73 206e 6f20 656e 636f 6469   means no encodi
-00005b40: 6e67 206f 6620 796f 7572 2063 6174 6567  ng of your categ
-00005b50: 6f72 6963 616c 2066 6561 7475 7265 7329  orical features)
-00005b60: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00005b70: 205b 2748 6173 6869 6e67 456e 636f 6465   ['HashingEncode
-00005b80: 7227 2c20 2753 756d 456e 636f 6465 7227  r', 'SumEncoder'
-00005b90: 2c20 2750 6f6c 796e 6f6d 6961 6c45 6e63  , 'PolynomialEnc
-00005ba0: 6f64 6572 272c 2027 4261 636b 7761 7264  oder', 'Backward
-00005bb0: 4469 6666 6572 656e 6365 456e 636f 6465  DifferenceEncode
-00005bc0: 7227 2c0a 2020 2020 2020 2020 2020 2020  r',.            
-00005bd0: 2020 2020 274f 6e65 486f 7445 6e63 6f64      'OneHotEncod
-00005be0: 6572 272c 2027 4865 6c6d 6572 7445 6e63  er', 'HelmertEnc
-00005bf0: 6f64 6572 272c 2027 4f72 6469 6e61 6c45  oder', 'OrdinalE
-00005c00: 6e63 6f64 6572 272c 2027 4672 6571 7565  ncoder', 'Freque
-00005c10: 6e63 7945 6e63 6f64 6572 272c 2027 4261  ncyEncoder', 'Ba
-00005c20: 7365 4e45 6e63 6f64 6572 272c 0a20 2020  seNEncoder',.   
-00005c30: 2020 2020 2020 2020 2020 2020 2027 5461               'Ta
-00005c40: 7267 6574 456e 636f 6465 7227 2c20 2743  rgetEncoder', 'C
-00005c50: 6174 426f 6f73 7445 6e63 6f64 6572 272c  atBoostEncoder',
-00005c60: 2027 574f 4545 6e63 6f64 6572 272c 2027   'WOEEncoder', '
-00005c70: 4a61 6d65 7353 7465 696e 456e 636f 6465  JamesSteinEncode
-00005c80: 7227 5d0a 2020 2020 2020 2020 6461 736b  r'].        dask
-00005c90: 5f78 6762 6f6f 7374 5f66 6c61 673a 2064  _xgboost_flag: d
-00005ca0: 6566 6175 6c74 203d 2046 616c 7365 2e20  efault = False. 
-00005cb0: 5468 6973 2066 6c61 6720 656e 6162 6c65  This flag enable
-00005cc0: 7320 4441 534b 2062 7920 6465 6661 756c  s DASK by defaul
-00005cd0: 7420 736f 2074 6861 7420 796f 7520 6361  t so that you ca
-00005ce0: 6e20 7072 6f63 6573 7320 6c61 7267 650a  n process large.
-00005cf0: 2020 2020 2020 2020 2020 2020 6461 7461              data
-00005d00: 2073 6574 7320 6661 7374 6572 2075 7369   sets faster usi
-00005d10: 6e67 2070 6172 616c 6c65 6c20 7072 6f63  ng parallel proc
-00005d20: 6573 7369 6e67 2e20 4974 2064 6574 6563  essing. It detec
-00005d30: 7473 2074 6865 206e 756d 6265 7220 6f66  ts the number of
-00005d40: 2043 5055 7320 616e 6420 4750 5527 7320   CPUs and GPU's 
-00005d50: 696e 2079 6f75 7220 6d61 6368 696e 650a  in your machine.
-00005d60: 2020 2020 2020 2020 2020 2020 6175 746f              auto
-00005d70: 6d61 7469 6361 6c6c 7920 616e 6420 7365  matically and se
-00005d80: 7473 2074 6865 206e 756d 206f 6620 776f  ts the num of wo
-00005d90: 726b 6572 7320 666f 7220 4441 534b 2e20  rkers for DASK. 
-00005da0: 4974 2061 6c73 6f20 7573 6573 2044 4153  It also uses DAS
-00005db0: 4b20 5847 426f 6f73 7420 746f 2072 756e  K XGBoost to run
-00005dc0: 2069 742e 0a20 2020 2020 2020 206e 726f   it..        nro
-00005dd0: 7773 3a20 6465 6661 756c 7420 3d20 4e6f  ws: default = No
-00005de0: 6e65 3a20 4e6f 6e65 206d 6561 6e73 2061  ne: None means a
-00005df0: 6c6c 2072 6f77 7320 7769 6c6c 2062 6520  ll rows will be 
-00005e00: 7574 696c 697a 6564 2e20 4966 2079 6f75  utilized. If you
-00005e10: 2077 616e 7420 746f 2073 616d 706c 6520   want to sample 
-00005e20: 224e 2220 726f 7773 2c20 7365 7420 6e72  "N" rows, set nr
-00005e30: 6f77 733d 4e2e 0a20 2020 2020 2020 2073  ows=N..        s
-00005e40: 6b69 705f 7375 6c6f 763a 2061 206e 6577  kip_sulov: a new
-00005e50: 2066 6c61 6720 746f 2073 6b69 7020 5355   flag to skip SU
-00005e60: 4c4f 5620 6d65 7468 6f64 2e20 4974 2077  LOV method. It w
-00005e70: 696c 6c20 6175 746f 6d61 7469 6361 6c6c  ill automaticall
-00005e80: 7920 676f 2073 7472 6169 6768 7420 746f  y go straight to
-00005e90: 2072 6563 7572 7369 7665 2078 6762 6f6f   recursive xgboo
-00005ea0: 7374 2e0a 2020 2020 2323 2323 2323 2323  st..    ########
-00005eb0: 2020 2020 2020 2020 2020 2046 6561 7475             Featu
-00005ec0: 7265 7769 7a20 4f75 7470 7574 2020 2020  rewiz Output    
-00005ed0: 2020 2020 2020 2023 2323 2323 2323 2323         #########
-00005ee0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00005ef0: 2323 2323 0a20 2020 204f 7574 7075 743a  ####.    Output:
-00005f00: 2054 7570 6c65 0a20 2020 2046 6561 7475   Tuple.    Featu
-00005f10: 7265 7769 7a20 6361 6e20 6f75 7470 7574  rewiz can output
-00005f20: 2065 6974 6865 7220 6120 6c69 7374 206f   either a list o
-00005f30: 6620 6665 6174 7572 6573 206f 7220 6f6e  f features or on
-00005f40: 6520 6461 7461 6672 616d 6520 6f72 2074  e dataframe or t
-00005f50: 776f 2064 6570 656e 6469 6e67 206f 6e20  wo depending on 
-00005f60: 7768 6174 2079 6f75 2073 656e 6420 696e  what you send in
-00005f70: 2e0a 2020 2020 2020 2020 312e 2066 6561  ..        1. fea
-00005f80: 7475 7265 733a 2066 6561 7475 7265 7769  tures: featurewi
-00005f90: 7a20 7769 6c6c 2072 6574 7572 6e20 6a75  z will return ju
-00005fa0: 7374 2061 206c 6973 7420 6f66 2069 6d70  st a list of imp
-00005fb0: 6f72 7461 6e74 2066 6561 7475 7265 730a  ortant features.
-00005fc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00005fd0: 2020 2020 2069 6e20 796f 7572 2064 6174       in your dat
-00005fe0: 6120 6966 2079 6f75 2073 656e 6420 696e  a if you send in
-00005ff0: 206a 7573 7420 6120 6461 7461 7365 742e   just a dataset.
-00006000: 0a20 2020 2020 2020 2032 2e20 7472 6169  .        2. trai
-00006010: 6e6d 3a20 6d6f 6469 6669 6564 2074 7261  nm: modified tra
-00006020: 696e 2064 6174 6166 7261 6d65 2069 7320  in dataframe is 
-00006030: 7468 6520 6461 7461 6672 616d 6520 7468  the dataframe th
-00006040: 6174 2069 7320 6d6f 6469 6669 6564 0a20  at is modified. 
-00006050: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006060: 2020 2020 2020 2077 6974 6820 656e 6769         with engi
-00006070: 6e65 6572 6564 2061 6e64 2073 656c 6563  neered and selec
-00006080: 7465 6420 6665 6174 7572 6573 2066 726f  ted features fro
-00006090: 6d20 6461 7461 6e61 6d65 2e0a 2020 2020  m dataname..    
-000060a0: 2020 2020 332e 2074 6573 746d 3a20 6d6f      3. testm: mo
-000060b0: 6469 6669 6564 2074 6573 7420 6461 7461  dified test data
-000060c0: 6672 616d 6520 6973 2074 6865 2064 6174  frame is the dat
-000060d0: 6166 7261 6d65 2074 6861 7420 6973 206d  aframe that is m
-000060e0: 6f64 6966 6965 6420 7769 7468 0a20 2020  odified with.   
-000060f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006100: 2065 6e67 696e 6565 7265 6420 616e 6420   engineered and 
-00006110: 7365 6c65 6374 6564 2066 6561 7475 7265  selected feature
-00006120: 7320 6672 6f6d 2074 6573 745f 6461 7461  s from test_data
-00006130: 0a20 2020 2022 2222 0a20 2020 2069 6620  .    """.    if 
-00006140: 7665 7262 6f73 653a 0a20 2020 2020 2020  verbose:.       
-00006150: 2070 7269 6e74 2827 2323 2323 2323 2323   print('########
-00006160: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00006170: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00006180: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00006190: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000061a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000061b0: 2323 2323 2729 0a20 2020 2020 2020 2070  ####').        p
-000061c0: 7269 6e74 2827 2323 2323 2323 2323 2323  rint('##########
-000061d0: 2323 2020 2020 2020 2046 2041 2053 2054  ##       F A S T
-000061e0: 2020 2046 2045 2041 2054 2055 2052 2045     F E A T U R E
-000061f0: 2020 4520 4e20 4720 4720 2020 2041 204e    E N G G    A N
-00006200: 2044 2020 2020 5320 4520 4c20 4520 4320   D    S E L E C 
-00006210: 5420 4920 4f20 4e20 2120 2323 2323 2323  T I O N ! ######
-00006220: 2323 2729 0a20 2020 2020 2020 2070 7269  ##').        pri
-00006230: 6e74 2822 2320 4265 206a 7564 6963 696f  nt("# Be judicio
-00006240: 7573 2077 6974 6820 6665 6174 7572 6577  us with featurew
-00006250: 697a 2e20 446f 6e27 7420 7573 6520 6974  iz. Don't use it
-00006260: 2074 6f20 6372 6561 7465 2074 6f6f 206d   to create too m
-00006270: 616e 7920 756e 2d69 6e74 6572 7072 6574  any un-interpret
-00006280: 6162 6c65 2066 6561 7475 7265 7321 2023  able features! #
-00006290: 2229 0a20 2020 2020 2020 2070 7269 6e74  ").        print
-000062a0: 2827 2323 2323 2323 2323 2323 2323 2323  ('##############
-000062b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000062c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000062d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000062e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000062f0: 2323 2323 2323 2323 2323 2323 2323 2729  ##############')
-00006300: 0a20 2020 2070 7269 6e74 2827 6665 6174  .    print('feat
-00006310: 7572 6577 697a 2068 6173 2073 656c 6563  urewiz has selec
-00006320: 7465 6420 2573 2061 7320 7468 6520 636f  ted %s as the co
-00006330: 7272 656c 6174 696f 6e20 6c69 6d69 742e  rrelation limit.
-00006340: 2043 6861 6e67 6520 7468 6973 206c 696d   Change this lim
-00006350: 6974 2074 6f20 6669 7420 796f 7572 206e  it to fit your n
-00006360: 6565 6473 2e2e 2e27 2025 636f 7272 5f6c  eeds...' %corr_l
-00006370: 696d 6974 290a 2020 2020 6966 206e 6f74  imit).    if not
-00006380: 206e 726f 7773 2069 7320 4e6f 6e65 3a0a   nrows is None:.
-00006390: 2020 2020 2020 2020 7072 696e 7428 2741          print('A
-000063a0: 4c45 5254 3a20 6e72 6f77 733d 2573 2e20  LERT: nrows=%s. 
-000063b0: 4865 6e63 6520 6665 6174 7572 6577 697a  Hence featurewiz
-000063c0: 2077 696c 6c20 7261 6e64 6f6d 6c79 2073   will randomly s
-000063d0: 616d 706c 6520 7468 6174 206d 616e 7920  ample that many 
-000063e0: 726f 7773 2e27 2025 6e72 6f77 7329 0a20  rows.' %nrows). 
-000063f0: 2020 2020 2020 2070 7269 6e74 2827 2020         print('  
-00006400: 2020 4368 616e 6765 206e 726f 7773 3d4e    Change nrows=N
-00006410: 6f6e 6520 6966 2079 6f75 2077 616e 7420  one if you want 
-00006420: 616c 6c20 726f 7773 2e2e 2e27 290a 2020  all rows...').  
-00006430: 2020 2323 2320 7365 7420 616c 6c20 7468    ### set all th
-00006440: 6520 6465 6661 756c 7473 2068 6572 6520  e defaults here 
-00006450: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00006460: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00006470: 2323 2323 2323 2323 2323 2323 2323 0a20  ##############. 
-00006480: 2020 2064 6174 616e 616d 6520 3d20 636f     dataname = co
-00006490: 7079 2e64 6565 7063 6f70 7928 6461 7461  py.deepcopy(data
-000064a0: 6e61 6d65 290a 2020 2020 6d61 785f 6e75  name).    max_nu
-000064b0: 6d73 203d 2033 300a 2020 2020 6d61 785f  ms = 30.    max_
-000064c0: 6361 7473 203d 2031 350a 2020 2020 6d61  cats = 15.    ma
-000064d0: 7872 6f77 7320 3d20 3130 3030 300a 2020  xrows = 10000.  
-000064e0: 2020 5241 4e44 4f4d 5f53 4545 4420 3d20    RANDOM_SEED = 
-000064f0: 3432 0a20 2020 206d 656d 5f6c 696d 6974  42.    mem_limit
-00006500: 203d 2035 3030 2023 2323 2061 6d6f 756e   = 500 ### amoun
-00006510: 7420 6f66 206d 656d 6f72 7920 636f 6e73  t of memory cons
-00006520: 756d 6564 2062 7920 7061 6e64 6173 2064  umed by pandas d
-00006530: 6620 6265 666f 7265 2072 6564 7563 696e  f before reducin
-00006540: 675f 6d65 6d20 6675 6e63 7469 6f6e 2063  g_mem function c
-00006550: 616c 6c65 640a 2020 2020 2323 2323 2323  alled.    ######
-00006560: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00006570: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00006580: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00006590: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000065a0: 2323 2323 2323 0a20 2020 2063 6174 5f65  ######.    cat_e
-000065b0: 6e63 6f64 6572 735f 6c69 7374 203d 206c  ncoders_list = l
-000065c0: 6973 7428 7365 7474 696e 6773 2e63 6174  ist(settings.cat
-000065d0: 5f65 6e63 6f64 6572 735f 6e61 6d65 732e  _encoders_names.
-000065e0: 6b65 7973 2829 290a 2020 2020 2323 2320  keys()).    ### 
-000065f0: 4a75 7374 2073 6574 2064 6566 6175 6c74  Just set default
-00006600: 7320 6865 7265 2077 6869 6368 2063 616e  s here which can
-00006610: 2062 6520 6f76 6572 7269 6464 656e 2062   be overridden b
-00006620: 7920 7573 6572 2069 6e70 7574 2023 2323  y user input ###
-00006630: 230a 2020 2020 6361 745f 7661 7273 203d  #.    cat_vars =
-00006640: 205b 5d0a 2020 2020 6966 206b 7761 7267   [].    if kwarg
-00006650: 733a 0a20 2020 2020 2020 2066 6f72 206b  s:.        for k
-00006660: 6579 2c20 7661 6c75 6520 696e 207a 6970  ey, value in zip
-00006670: 286b 7761 7267 732e 6b65 7973 2829 2c20  (kwargs.keys(), 
-00006680: 6b77 6172 6773 2e76 616c 7565 7328 2929  kwargs.values())
-00006690: 3a0a 2020 2020 2020 2020 2020 2020 7072  :.            pr
-000066a0: 696e 7428 2759 6f75 2073 7570 706c 6965  int('You supplie
-000066b0: 6420 2573 203d 2025 7327 2025 286b 6579  d %s = %s' %(key
-000066c0: 2c20 7661 6c75 6529 290a 2020 2020 2020  , value)).      
-000066d0: 2020 2020 2020 2323 2323 2323 204e 6f77        ###### Now
-000066e0: 2074 6573 7420 7468 6520 6e65 7874 2073   test the next s
-000066f0: 6574 206f 6620 6b77 6172 6773 2023 2323  et of kwargs ###
-00006700: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-00006710: 6b65 7920 3d3d 2027 6361 745f 7661 7273  key == 'cat_vars
-00006720: 273a 0a20 2020 2020 2020 2020 2020 2020  ':.             
-00006730: 2020 2069 6620 6973 696e 7374 616e 6365     if isinstance
-00006740: 2876 616c 7565 2c20 6c69 7374 293a 0a20  (value, list):. 
-00006750: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006760: 2020 2063 6174 5f76 6172 7320 3d20 7661     cat_vars = va
-00006770: 6c75 650a 2020 2020 2020 2020 2020 2020  lue.            
-00006780: 2020 2020 656c 6966 2069 7369 6e73 7461      elif isinsta
-00006790: 6e63 6528 7661 6c75 652c 2073 7472 293a  nce(value, str):
-000067a0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000067b0: 2020 2020 2063 6174 5f76 6172 7320 3d20       cat_vars = 
-000067c0: 7661 6c75 650a 2020 2020 2020 2020 2020  value.          
-000067d0: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
-000067e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000067f0: 7072 696e 7428 2763 6174 2076 6172 7320  print('cat vars 
-00006800: 6d75 7374 2062 6520 6120 6c69 7374 206f  must be a list o
-00006810: 7220 6120 7374 7269 6e67 2729 0a20 2020  r a string').   
-00006820: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00006830: 2072 6574 7572 6e0a 2020 2020 2323 2323   return.    ####
-00006840: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00006850: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00006860: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00006870: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00006880: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00006890: 2323 0a20 2020 2023 2323 2323 2020 2020  ##.    #####    
-000068a0: 2020 4d41 4b49 4e47 2046 4541 5455 5245    MAKING FEATURE
-000068b0: 5f54 5950 4520 414e 4420 4645 4154 5552  _TYPE AND FEATUR
-000068c0: 455f 4745 4e20 5345 4c45 4354 494f 4e53  E_GEN SELECTIONS
-000068d0: 2048 4552 4520 2020 2020 2020 2020 2020   HERE           
-000068e0: 2323 2323 2323 2323 2323 2323 230a 2020  #############.  
-000068f0: 2020 2323 2323 2323 2323 2323 2323 2323    ##############
-00006900: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00006910: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00006920: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00006930: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00006940: 2323 2323 2323 2323 0a20 2020 2066 6561  ########.    fea
-00006950: 7475 7265 5f67 656e 6572 6174 6f72 7320  ture_generators 
-00006960: 3d20 5b27 696e 7465 7261 6374 696f 6e73  = ['interactions
-00006970: 272c 2027 6772 6f75 7062 7927 2c20 2774  ', 'groupby', 't
-00006980: 6172 6765 7427 5d0a 2020 2020 6665 6174  arget'].    feat
-00006990: 7572 655f 6765 6e20 3d20 2727 0a20 2020  ure_gen = ''.   
-000069a0: 2069 6620 6665 6174 7572 655f 656e 6767   if feature_engg
-000069b0: 3a0a 2020 2020 2020 2020 6966 2069 7369  :.        if isi
-000069c0: 6e73 7461 6e63 6528 6665 6174 7572 655f  nstance(feature_
-000069d0: 656e 6767 2c20 7374 7229 3a0a 2020 2020  engg, str):.    
-000069e0: 2020 2020 2020 2020 6966 2066 6561 7475          if featu
-000069f0: 7265 5f65 6e67 6720 696e 2066 6561 7475  re_engg in featu
-00006a00: 7265 5f67 656e 6572 6174 6f72 733a 0a20  re_generators:. 
-00006a10: 2020 2020 2020 2020 2020 2020 2020 2066                 f
-00006a20: 6561 7475 7265 5f67 656e 203d 205b 6665  eature_gen = [fe
-00006a30: 6174 7572 655f 656e 6767 5d0a 2020 2020  ature_engg].    
-00006a40: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
-00006a50: 2020 2020 2020 2020 2020 2020 2020 7072                pr
-00006a60: 696e 7428 2766 6561 7475 7265 2065 6e67  int('feature eng
-00006a70: 6720 7479 7065 7320 6d75 7374 2062 6520  g types must be 
-00006a80: 6f6e 6520 6f66 2074 6872 6565 2073 7472  one of three str
-00006a90: 696e 6773 3a20 2573 2720 2566 6561 7475  ings: %s' %featu
-00006aa0: 7265 5f67 656e 6572 6174 6f72 7329 0a20  re_generators). 
-00006ab0: 2020 2020 2020 2020 2020 2020 2020 2072                 r
-00006ac0: 6574 7572 6e0a 2020 2020 2020 2020 656c  eturn.        el
-00006ad0: 6966 2069 7369 6e73 7461 6e63 6528 6665  if isinstance(fe
-00006ae0: 6174 7572 655f 656e 6767 2c20 6c69 7374  ature_engg, list
-00006af0: 293a 0a20 2020 2020 2020 2020 2020 2066  ):.            f
-00006b00: 6561 7475 7265 5f67 656e 203d 2063 6f70  eature_gen = cop
-00006b10: 792e 6465 6570 636f 7079 2866 6561 7475  y.deepcopy(featu
-00006b20: 7265 5f65 6e67 6729 0a20 2020 2065 6c73  re_engg).    els
-00006b30: 653a 0a20 2020 2020 2020 2070 7269 6e74  e:.        print
-00006b40: 2827 536b 6970 7069 6e67 2066 6561 7475  ('Skipping featu
-00006b50: 7265 2065 6e67 696e 6565 7269 6e67 2073  re engineering s
-00006b60: 696e 6365 206e 6f20 6665 6174 7572 655f  ince no feature_
-00006b70: 656e 6767 2069 6e70 7574 2e2e 2e27 290a  engg input...').
-00006b80: 2020 2020 6665 6174 7572 655f 7479 7065      feature_type
-00006b90: 203d 2027 270a 2020 2020 6966 2063 6174   = ''.    if cat
-00006ba0: 6567 6f72 795f 656e 636f 6465 7273 3a0a  egory_encoders:.
-00006bb0: 2020 2020 2020 2020 6966 2069 7369 6e73          if isins
-00006bc0: 7461 6e63 6528 6361 7465 676f 7279 5f65  tance(category_e
-00006bd0: 6e63 6f64 6572 732c 2073 7472 293a 0a20  ncoders, str):. 
-00006be0: 2020 2020 2020 2020 2020 2066 6561 7475             featu
-00006bf0: 7265 5f74 7970 6520 3d20 5b63 6174 6567  re_type = [categ
-00006c00: 6f72 795f 656e 636f 6465 7273 5d0a 2020  ory_encoders].  
-00006c10: 2020 2020 2020 656c 6966 2069 7369 6e73        elif isins
-00006c20: 7461 6e63 6528 6361 7465 676f 7279 5f65  tance(category_e
-00006c30: 6e63 6f64 6572 732c 206c 6973 7429 3a0a  ncoders, list):.
-00006c40: 2020 2020 2020 2020 2020 2020 6665 6174              feat
-00006c50: 7572 655f 7479 7065 203d 2063 6174 6567  ure_type = categ
-00006c60: 6f72 795f 656e 636f 6465 7273 5b3a 325d  ory_encoders[:2]
-00006c70: 2023 2323 204f 6e6c 7920 7477 6f20 7769   ### Only two wi
-00006c80: 6c6c 2062 6520 616c 6c6f 7765 6420 6174  ll be allowed at
-00006c90: 2061 2074 696d 650a 2020 2020 656c 7365   a time.    else
-00006ca0: 3a0a 2020 2020 2020 2020 7072 696e 7428  :.        print(
-00006cb0: 2753 6b69 7070 696e 6720 6361 7465 676f  'Skipping catego
-00006cc0: 7279 2065 6e63 6f64 696e 6720 7369 6e63  ry encoding sinc
-00006cd0: 6520 6e6f 2063 6174 6567 6f72 7920 656e  e no category en
-00006ce0: 636f 6465 7273 2073 7065 6369 6669 6564  coders specified
-00006cf0: 2069 6e20 696e 7075 742e 2e2e 2729 0a20   in input...'). 
-00006d00: 2020 2023 2323 2323 2323 2323 2323 2323     #############
-00006d10: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00006d20: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00006d30: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00006d40: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00006d50: 2323 2323 2323 2323 230a 2020 2020 2323  #########.    ##
+00005260: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00005270: 2323 2323 0a20 2020 2049 6e70 7574 733a  ####.    Inputs:
+00005280: 0a20 2020 2020 2020 2064 6174 616e 616d  .        datanam
+00005290: 653a 2074 7261 696e 696e 6720 6461 7461  e: training data
+000052a0: 2073 6574 2079 6f75 2077 616e 7420 746f   set you want to
+000052b0: 2069 6e70 7574 2e20 6461 7461 6e61 6d65   input. dataname
+000052c0: 2063 6f75 6c64 2062 6520 6120 6461 7461   could be a data
+000052d0: 7061 7468 2b66 696c 656e 616d 6520 6f72  path+filename or
+000052e0: 2061 2064 6174 6166 7261 6d65 2e20 0a20   a dataframe. . 
+000052f0: 2020 2020 2020 2020 2020 2066 6561 7475             featu
+00005300: 7265 7769 7a20 7769 6c6c 2064 6574 6563  rewiz will detec
+00005310: 7420 7768 6574 6865 7220 796f 7572 2069  t whether your i
+00005320: 6e70 7574 2069 7320 6120 6669 6c65 6e61  nput is a filena
+00005330: 6d65 206f 7220 6120 6461 7461 6672 616d  me or a datafram
+00005340: 6520 616e 6420 6c6f 6164 2069 7420 6175  e and load it au
+00005350: 746f 6d61 7469 6361 6c6c 792e 0a20 2020  tomatically..   
+00005360: 2020 2020 2074 6172 6765 743a 206e 616d       target: nam
+00005370: 6520 6f66 2074 6865 2074 6172 6765 7420  e of the target 
+00005380: 7661 7269 6162 6c65 2069 6e20 7468 6520  variable in the 
+00005390: 6461 7461 2073 6574 2e20 416c 736f 206b  data set. Also k
+000053a0: 6e6f 776e 2061 7320 6465 7065 6e64 656e  nown as dependen
+000053b0: 7420 7661 7269 6162 6c65 2e0a 2020 2020  t variable..    
+000053c0: 2020 2020 636f 7272 5f6c 696d 6974 3a20      corr_limit: 
+000053d0: 6966 2079 6f75 2077 616e 7420 746f 2073  if you want to s
+000053e0: 6574 2079 6f75 7220 6f77 6e20 7468 7265  et your own thre
+000053f0: 7368 6f6c 6420 666f 7220 7265 6d6f 7669  shold for removi
+00005400: 6e67 2076 6172 6961 626c 6573 2061 730a  ng variables as.
+00005410: 2020 2020 2020 2020 2020 2020 6869 6768              high
+00005420: 6c79 2063 6f72 7265 6c61 7465 642c 2074  ly correlated, t
+00005430: 6865 6e20 6769 7665 2069 7420 6865 7265  hen give it here
+00005440: 2e20 5468 6520 6465 6661 756c 7420 6973  . The default is
+00005450: 2030 2e37 2077 6869 6368 206d 6561 6e73   0.7 which means
+00005460: 2076 6172 6961 626c 6573 206c 6573 730a   variables less.
+00005470: 2020 2020 2020 2020 2020 2020 7468 616e              than
+00005480: 202d 302e 3720 616e 6420 6772 6561 7465   -0.7 and greate
+00005490: 7220 7468 616e 2030 2e37 2069 6e20 7065  r than 0.7 in pe
+000054a0: 6172 736f 6e27 7320 636f 7272 656c 6174  arson's correlat
+000054b0: 696f 6e20 7769 6c6c 2062 6520 6361 6e64  ion will be cand
+000054c0: 6964 6174 6573 2066 6f72 2072 656d 6f76  idates for remov
+000054d0: 616c 2e0a 2020 2020 2020 2020 7665 7262  al..        verb
+000054e0: 6f73 653a 2054 6869 7320 6861 7320 3320  ose: This has 3 
+000054f0: 706f 7373 6962 6c65 2073 7461 7465 733a  possible states:
+00005500: 0a20 2020 2020 2020 2020 2020 2030 206c  .            0 l
+00005510: 696d 6974 6564 206f 7574 7075 742e 2047  imited output. G
+00005520: 7265 6174 2066 6f72 2072 756e 6e69 6e67  reat for running
+00005530: 2074 6869 7320 7369 6c65 6e74 6c79 2061   this silently a
+00005540: 6e64 2067 6574 7469 6e67 2066 6173 7420  nd getting fast 
+00005550: 7265 7375 6c74 732e 0a20 2020 2020 2020  results..       
+00005560: 2020 2020 2031 206d 6f72 6520 7665 7262       1 more verb
+00005570: 6961 6765 2e20 4772 6561 7420 666f 7220  iage. Great for 
+00005580: 6b6e 6f77 696e 6720 686f 7720 7265 7375  knowing how resu
+00005590: 6c74 7320 7765 7265 2061 6e64 206d 616b  lts were and mak
+000055a0: 696e 6720 6368 616e 6765 7320 746f 2066  ing changes to f
+000055b0: 6c61 6773 2069 6e20 696e 7075 742e 0a20  lags in input.. 
+000055c0: 2020 2020 2020 2020 2020 2032 2053 554c             2 SUL
+000055d0: 4f56 2063 6861 7274 7320 616e 6420 6f75  OV charts and ou
+000055e0: 7470 7574 2e20 4772 6561 7420 666f 7220  tput. Great for 
+000055f0: 6669 6e64 696e 6720 6f75 7420 7768 6174  finding out what
+00005600: 2068 6170 7065 6e73 2075 6e64 6572 2074   happens under t
+00005610: 6865 2068 6f6f 6420 666f 7220 5355 4c4f  he hood for SULO
+00005620: 5620 6d65 7468 6f64 2e0a 2020 2020 2020  V method..      
+00005630: 2020 7465 7374 5f64 6174 613a 2049 6620    test_data: If 
+00005640: 796f 7520 7761 6e74 2074 6f20 7472 616e  you want to tran
+00005650: 7366 6f72 6d20 7465 7374 2064 6174 6120  sform test data 
+00005660: 696e 2074 6865 2073 616d 6520 7761 7920  in the same way 
+00005670: 796f 7520 6172 6520 7472 616e 7366 6f72  you are transfor
+00005680: 6d69 6e67 2064 6174 616e 616d 652c 2079  ming dataname, y
+00005690: 6f75 2063 616e 2e0a 2020 2020 2020 2020  ou can..        
+000056a0: 2020 2020 7465 7374 5f64 6174 6120 636f      test_data co
+000056b0: 756c 6420 6265 2074 6865 206e 616d 6520  uld be the name 
+000056c0: 6f66 2061 2064 6174 6170 6174 682b 6669  of a datapath+fi
+000056d0: 6c65 6e61 6d65 206f 7220 6120 6461 7461  lename or a data
+000056e0: 6672 616d 652e 2066 6561 7475 7265 7769  frame. featurewi
+000056f0: 7a20 7769 6c6c 2064 6574 6563 7420 7768  z will detect wh
+00005700: 6574 6865 720a 2020 2020 2020 2020 2020  ether.          
+00005710: 2020 2020 2020 796f 7572 2069 6e70 7574        your input
+00005720: 2069 7320 6120 6669 6c65 6e61 6d65 206f   is a filename o
+00005730: 7220 6120 6461 7461 6672 616d 6520 616e  r a dataframe an
+00005740: 6420 6c6f 6164 2069 7420 6175 746f 6d61  d load it automa
+00005750: 7469 6361 6c6c 792e 2044 6566 6175 6c74  tically. Default
+00005760: 2069 7320 656d 7074 7920 7374 7269 6e67   is empty string
+00005770: 2e0a 2020 2020 2020 2020 6665 6174 7572  ..        featur
+00005780: 655f 656e 6767 3a20 596f 7520 6361 6e20  e_engg: You can 
+00005790: 6c65 7420 6665 6174 7572 6577 697a 2073  let featurewiz s
+000057a0: 656c 6563 7420 6974 7320 6265 7374 2065  elect its best e
+000057b0: 6e63 6f64 6572 7320 666f 7220 796f 7572  ncoders for your
+000057c0: 2064 6174 6120 7365 7420 6279 2073 6574   data set by set
+000057d0: 7469 6e67 2074 6869 7320 666c 6167 0a20  ting this flag. 
+000057e0: 2020 2020 2020 2020 2020 2066 6f72 2061             for a
+000057f0: 6464 696e 6720 6665 6174 7572 6520 656e  dding feature en
+00005800: 6769 6e65 6572 696e 672e 2054 6865 7265  gineering. There
+00005810: 2061 7265 2074 6872 6565 2063 686f 6963   are three choic
+00005820: 6573 2e20 596f 7520 6361 6e20 6368 6f6f  es. You can choo
+00005830: 7365 206f 6e65 2c20 7477 6f20 6f72 2061  se one, two or a
+00005840: 6c6c 2074 6872 6565 2069 6e20 6120 6c69  ll three in a li
+00005850: 7374 2e0a 2020 2020 2020 2020 2020 2020  st..            
+00005860: 2769 6e74 6572 6163 7469 6f6e 7327 3a20  'interactions': 
+00005870: 5468 6973 2077 696c 6c20 6164 6420 696e  This will add in
+00005880: 7465 7261 6374 696f 6e20 6665 6174 7572  teraction featur
+00005890: 6573 2074 6f20 796f 7572 2064 6174 6120  es to your data 
+000058a0: 7375 6368 2061 7320 7831 2a78 322c 2078  such as x1*x2, x
+000058b0: 322a 7833 2c20 7831 2a2a 322c 2078 322a  2*x3, x1**2, x2*
+000058c0: 2a32 2c20 6574 632e 0a20 2020 2020 2020  *2, etc..       
+000058d0: 2020 2020 2027 6772 6f75 7062 7927 3a20       'groupby': 
+000058e0: 5468 6973 2077 696c 6c20 6765 6e65 7261  This will genera
+000058f0: 7465 2047 726f 7570 2042 7920 6665 6174  te Group By feat
+00005900: 7572 6573 2074 6f20 796f 7572 206e 756d  ures to your num
+00005910: 6572 6963 2076 6172 7320 6279 2067 726f  eric vars by gro
+00005920: 7570 696e 6720 616c 6c20 6361 7465 676f  uping all catego
+00005930: 7269 6361 6c20 7661 7273 2e0a 2020 2020  rical vars..    
+00005940: 2020 2020 2020 2020 2774 6172 6765 7427          'target'
+00005950: 3a20 2054 6869 7320 7769 6c6c 2065 6e63  :  This will enc
+00005960: 6f64 6520 2620 7472 616e 7366 6f72 6d20  ode & transform 
+00005970: 616c 6c20 796f 7572 2063 6174 6567 6f72  all your categor
+00005980: 6963 616c 2066 6561 7475 7265 7320 7573  ical features us
+00005990: 696e 6720 6365 7274 6169 6e20 7461 7267  ing certain targ
+000059a0: 6574 2065 6e63 6f64 6572 732e 0a20 2020  et encoders..   
+000059b0: 2020 2020 2020 2020 2044 6566 6175 6c74           Default
+000059c0: 2069 7320 656d 7074 7920 7374 7269 6e67   is empty string
+000059d0: 2028 7768 6963 6820 6d65 616e 7320 6e6f   (which means no
+000059e0: 2061 6464 6974 696f 6e61 6c20 6665 6174   additional feat
+000059f0: 7572 6520 656e 6769 6e65 6572 696e 6720  ure engineering 
+00005a00: 746f 2062 6520 7065 7266 6f72 6d65 6429  to be performed)
+00005a10: 0a20 2020 2020 2020 2063 6174 6567 6f72  .        categor
+00005a20: 795f 656e 636f 6465 7273 3a20 496e 7374  y_encoders: Inst
+00005a30: 6561 6420 6f66 2061 626f 7665 206d 6574  ead of above met
+00005a40: 686f 642c 2079 6f75 2063 616e 2063 686f  hod, you can cho
+00005a50: 6f73 6520 796f 7572 206f 776e 206b 696e  ose your own kin
+00005a60: 6420 6f66 2063 6174 6567 6f72 7920 656e  d of category en
+00005a70: 636f 6465 7273 2066 726f 6d20 6265 6c6f  coders from belo
+00005a80: 772e 0a20 2020 2020 2020 2020 2020 2052  w..            R
+00005a90: 6563 6f6d 6d65 6e64 2079 6f75 2064 6f20  ecommend you do 
+00005aa0: 6e6f 7420 7573 6520 6d6f 7265 2074 6861  not use more tha
+00005ab0: 6e20 7477 6f20 6f66 2074 6865 7365 2e0a  n two of these..
+00005ac0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00005ad0: 2020 2020 2020 2020 2020 2020 4665 6174              Feat
+00005ae0: 7572 6577 697a 2077 696c 6c20 6175 746f  urewiz will auto
+00005af0: 6d61 7469 6361 6c6c 7920 7365 6c65 6374  matically select
+00005b00: 206f 6e6c 7920 7477 6f20 6672 6f6d 2079   only two from y
+00005b10: 6f75 7220 6c69 7374 2e0a 2020 2020 2020  our list..      
+00005b20: 2020 2020 2020 4465 6661 756c 7420 6973        Default is
+00005b30: 2065 6d70 7479 2073 7472 696e 6720 2877   empty string (w
+00005b40: 6869 6368 206d 6561 6e73 206e 6f20 656e  hich means no en
+00005b50: 636f 6469 6e67 206f 6620 796f 7572 2063  coding of your c
+00005b60: 6174 6567 6f72 6963 616c 2066 6561 7475  ategorical featu
+00005b70: 7265 7329 0a20 2020 2020 2020 2020 2020  res).           
+00005b80: 2020 2020 205b 2748 6173 6869 6e67 456e       ['HashingEn
+00005b90: 636f 6465 7227 2c20 2753 756d 456e 636f  coder', 'SumEnco
+00005ba0: 6465 7227 2c20 2750 6f6c 796e 6f6d 6961  der', 'Polynomia
+00005bb0: 6c45 6e63 6f64 6572 272c 2027 4261 636b  lEncoder', 'Back
+00005bc0: 7761 7264 4469 6666 6572 656e 6365 456e  wardDifferenceEn
+00005bd0: 636f 6465 7227 2c0a 2020 2020 2020 2020  coder',.        
+00005be0: 2020 2020 2020 2020 274f 6e65 486f 7445          'OneHotE
+00005bf0: 6e63 6f64 6572 272c 2027 4865 6c6d 6572  ncoder', 'Helmer
+00005c00: 7445 6e63 6f64 6572 272c 2027 4f72 6469  tEncoder', 'Ordi
+00005c10: 6e61 6c45 6e63 6f64 6572 272c 2027 4672  nalEncoder', 'Fr
+00005c20: 6571 7565 6e63 7945 6e63 6f64 6572 272c  equencyEncoder',
+00005c30: 2027 4261 7365 4e45 6e63 6f64 6572 272c   'BaseNEncoder',
+00005c40: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00005c50: 2027 5461 7267 6574 456e 636f 6465 7227   'TargetEncoder'
+00005c60: 2c20 2743 6174 426f 6f73 7445 6e63 6f64  , 'CatBoostEncod
+00005c70: 6572 272c 2027 574f 4545 6e63 6f64 6572  er', 'WOEEncoder
+00005c80: 272c 2027 4a61 6d65 7353 7465 696e 456e  ', 'JamesSteinEn
+00005c90: 636f 6465 7227 5d0a 2020 2020 2020 2020  coder'].        
+00005ca0: 6461 736b 5f78 6762 6f6f 7374 5f66 6c61  dask_xgboost_fla
+00005cb0: 673a 2064 6566 6175 6c74 203d 2046 616c  g: default = Fal
+00005cc0: 7365 2e20 5468 6973 2066 6c61 6720 656e  se. This flag en
+00005cd0: 6162 6c65 7320 4441 534b 2062 7920 6465  ables DASK by de
+00005ce0: 6661 756c 7420 736f 2074 6861 7420 796f  fault so that yo
+00005cf0: 7520 6361 6e20 7072 6f63 6573 7320 6c61  u can process la
+00005d00: 7267 650a 2020 2020 2020 2020 2020 2020  rge.            
+00005d10: 6461 7461 2073 6574 7320 6661 7374 6572  data sets faster
+00005d20: 2075 7369 6e67 2070 6172 616c 6c65 6c20   using parallel 
+00005d30: 7072 6f63 6573 7369 6e67 2e20 4974 2064  processing. It d
+00005d40: 6574 6563 7473 2074 6865 206e 756d 6265  etects the numbe
+00005d50: 7220 6f66 2043 5055 7320 616e 6420 4750  r of CPUs and GP
+00005d60: 5527 7320 696e 2079 6f75 7220 6d61 6368  U's in your mach
+00005d70: 696e 650a 2020 2020 2020 2020 2020 2020  ine.            
+00005d80: 6175 746f 6d61 7469 6361 6c6c 7920 616e  automatically an
+00005d90: 6420 7365 7473 2074 6865 206e 756d 206f  d sets the num o
+00005da0: 6620 776f 726b 6572 7320 666f 7220 4441  f workers for DA
+00005db0: 534b 2e20 4974 2061 6c73 6f20 7573 6573  SK. It also uses
+00005dc0: 2044 4153 4b20 5847 426f 6f73 7420 746f   DASK XGBoost to
+00005dd0: 2072 756e 2069 742e 0a20 2020 2020 2020   run it..       
+00005de0: 206e 726f 7773 3a20 6465 6661 756c 7420   nrows: default 
+00005df0: 3d20 4e6f 6e65 3a20 4e6f 6e65 206d 6561  = None: None mea
+00005e00: 6e73 2061 6c6c 2072 6f77 7320 7769 6c6c  ns all rows will
+00005e10: 2062 6520 7574 696c 697a 6564 2e20 4966   be utilized. If
+00005e20: 2079 6f75 2077 616e 7420 746f 2073 616d   you want to sam
+00005e30: 706c 6520 224e 2220 726f 7773 2c20 7365  ple "N" rows, se
+00005e40: 7420 6e72 6f77 733d 4e2e 0a20 2020 2020  t nrows=N..     
+00005e50: 2020 2073 6b69 705f 7375 6c6f 763a 2061     skip_sulov: a
+00005e60: 206e 6577 2066 6c61 6720 746f 2073 6b69   new flag to ski
+00005e70: 7020 5355 4c4f 5620 6d65 7468 6f64 2e20  p SULOV method. 
+00005e80: 4974 2077 696c 6c20 6175 746f 6d61 7469  It will automati
+00005e90: 6361 6c6c 7920 676f 2073 7472 6169 6768  cally go straigh
+00005ea0: 7420 746f 2072 6563 7572 7369 7665 2078  t to recursive x
+00005eb0: 6762 6f6f 7374 2e0a 2020 2020 2020 2020  gboost..        
+00005ec0: 736b 6970 5f78 6762 6f6f 7374 3a20 6120  skip_xgboost: a 
+00005ed0: 6e65 7720 666c 6167 2074 6f20 736b 6970  new flag to skip
+00005ee0: 2072 6563 7572 7369 7665 2078 6762 6f6f   recursive xgboo
+00005ef0: 7374 2e0a 2020 2020 2323 2323 2323 2323  st..    ########
+00005f00: 2020 2020 2020 2020 2020 2046 6561 7475             Featu
+00005f10: 7265 7769 7a20 4f75 7470 7574 2020 2020  rewiz Output    
+00005f20: 2020 2020 2020 2023 2323 2323 2323 2323         #########
+00005f30: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00005f40: 2323 2323 0a20 2020 204f 7574 7075 743a  ####.    Output:
+00005f50: 2054 7570 6c65 0a20 2020 2046 6561 7475   Tuple.    Featu
+00005f60: 7265 7769 7a20 6361 6e20 6f75 7470 7574  rewiz can output
+00005f70: 2065 6974 6865 7220 6120 6c69 7374 206f   either a list o
+00005f80: 6620 6665 6174 7572 6573 206f 7220 6f6e  f features or on
+00005f90: 6520 6461 7461 6672 616d 6520 6f72 2074  e dataframe or t
+00005fa0: 776f 2064 6570 656e 6469 6e67 206f 6e20  wo depending on 
+00005fb0: 7768 6174 2079 6f75 2073 656e 6420 696e  what you send in
+00005fc0: 2e0a 2020 2020 2020 2020 312e 2066 6561  ..        1. fea
+00005fd0: 7475 7265 733a 2066 6561 7475 7265 7769  tures: featurewi
+00005fe0: 7a20 7769 6c6c 2072 6574 7572 6e20 6a75  z will return ju
+00005ff0: 7374 2061 206c 6973 7420 6f66 2069 6d70  st a list of imp
+00006000: 6f72 7461 6e74 2066 6561 7475 7265 730a  ortant features.
+00006010: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006020: 2020 2020 2069 6e20 796f 7572 2064 6174       in your dat
+00006030: 6120 6966 2079 6f75 2073 656e 6420 696e  a if you send in
+00006040: 206a 7573 7420 6120 6461 7461 7365 742e   just a dataset.
+00006050: 0a20 2020 2020 2020 2032 2e20 7472 6169  .        2. trai
+00006060: 6e6d 3a20 6d6f 6469 6669 6564 2074 7261  nm: modified tra
+00006070: 696e 2064 6174 6166 7261 6d65 2069 7320  in dataframe is 
+00006080: 7468 6520 6461 7461 6672 616d 6520 7468  the dataframe th
+00006090: 6174 2069 7320 6d6f 6469 6669 6564 0a20  at is modified. 
+000060a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000060b0: 2020 2020 2020 2077 6974 6820 656e 6769         with engi
+000060c0: 6e65 6572 6564 2061 6e64 2073 656c 6563  neered and selec
+000060d0: 7465 6420 6665 6174 7572 6573 2066 726f  ted features fro
+000060e0: 6d20 6461 7461 6e61 6d65 2e0a 2020 2020  m dataname..    
+000060f0: 2020 2020 332e 2074 6573 746d 3a20 6d6f      3. testm: mo
+00006100: 6469 6669 6564 2074 6573 7420 6461 7461  dified test data
+00006110: 6672 616d 6520 6973 2074 6865 2064 6174  frame is the dat
+00006120: 6166 7261 6d65 2074 6861 7420 6973 206d  aframe that is m
+00006130: 6f64 6966 6965 6420 7769 7468 0a20 2020  odified with.   
+00006140: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006150: 2065 6e67 696e 6565 7265 6420 616e 6420   engineered and 
+00006160: 7365 6c65 6374 6564 2066 6561 7475 7265  selected feature
+00006170: 7320 6672 6f6d 2074 6573 745f 6461 7461  s from test_data
+00006180: 0a20 2020 2022 2222 0a20 2020 2069 6620  .    """.    if 
+00006190: 7665 7262 6f73 653a 0a20 2020 2020 2020  verbose:.       
+000061a0: 2070 7269 6e74 2827 2323 2323 2323 2323   print('########
+000061b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000061c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000061d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000061e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000061f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00006200: 2323 2323 2729 0a20 2020 2020 2020 2070  ####').        p
+00006210: 7269 6e74 2827 2323 2323 2323 2323 2323  rint('##########
+00006220: 2323 2020 2020 2020 2046 2041 2053 2054  ##       F A S T
+00006230: 2020 2046 2045 2041 2054 2055 2052 2045     F E A T U R E
+00006240: 2020 4520 4e20 4720 4720 2020 2041 204e    E N G G    A N
+00006250: 2044 2020 2020 5320 4520 4c20 4520 4320   D    S E L E C 
+00006260: 5420 4920 4f20 4e20 2120 2323 2323 2323  T I O N ! ######
+00006270: 2323 2729 0a20 2020 2020 2020 2070 7269  ##').        pri
+00006280: 6e74 2822 2320 4265 206a 7564 6963 696f  nt("# Be judicio
+00006290: 7573 2077 6974 6820 6665 6174 7572 6577  us with featurew
+000062a0: 697a 2e20 446f 6e27 7420 7573 6520 6974  iz. Don't use it
+000062b0: 2074 6f20 6372 6561 7465 2074 6f6f 206d   to create too m
+000062c0: 616e 7920 756e 2d69 6e74 6572 7072 6574  any un-interpret
+000062d0: 6162 6c65 2066 6561 7475 7265 7321 2023  able features! #
+000062e0: 2229 0a20 2020 2020 2020 2070 7269 6e74  ").        print
+000062f0: 2827 2323 2323 2323 2323 2323 2323 2323  ('##############
+00006300: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00006310: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00006320: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00006330: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00006340: 2323 2323 2323 2323 2323 2323 2323 2729  ##############')
+00006350: 0a20 2020 2070 7269 6e74 2827 6665 6174  .    print('feat
+00006360: 7572 6577 697a 2068 6173 2073 656c 6563  urewiz has selec
+00006370: 7465 6420 2573 2061 7320 7468 6520 636f  ted %s as the co
+00006380: 7272 656c 6174 696f 6e20 6c69 6d69 742e  rrelation limit.
+00006390: 2043 6861 6e67 6520 7468 6973 206c 696d   Change this lim
+000063a0: 6974 2074 6f20 6669 7420 796f 7572 206e  it to fit your n
+000063b0: 6565 6473 2e2e 2e27 2025 636f 7272 5f6c  eeds...' %corr_l
+000063c0: 696d 6974 290a 2020 2020 6966 206e 6f74  imit).    if not
+000063d0: 206e 726f 7773 2069 7320 4e6f 6e65 3a0a   nrows is None:.
+000063e0: 2020 2020 2020 2020 7072 696e 7428 2741          print('A
+000063f0: 4c45 5254 3a20 6e72 6f77 733d 2573 2e20  LERT: nrows=%s. 
+00006400: 4865 6e63 6520 6665 6174 7572 6577 697a  Hence featurewiz
+00006410: 2077 696c 6c20 7261 6e64 6f6d 6c79 2073   will randomly s
+00006420: 616d 706c 6520 7468 6174 206d 616e 7920  ample that many 
+00006430: 726f 7773 2e27 2025 6e72 6f77 7329 0a20  rows.' %nrows). 
+00006440: 2020 2020 2020 2070 7269 6e74 2827 2020         print('  
+00006450: 2020 4368 616e 6765 206e 726f 7773 3d4e    Change nrows=N
+00006460: 6f6e 6520 6966 2079 6f75 2077 616e 7420  one if you want 
+00006470: 616c 6c20 726f 7773 2e2e 2e27 290a 2020  all rows...').  
+00006480: 2020 2323 2320 7365 7420 616c 6c20 7468    ### set all th
+00006490: 6520 6465 6661 756c 7473 2068 6572 6520  e defaults here 
+000064a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000064b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000064c0: 2323 2323 2323 2323 2323 2323 2323 0a20  ##############. 
+000064d0: 2020 2064 6174 616e 616d 6520 3d20 636f     dataname = co
+000064e0: 7079 2e64 6565 7063 6f70 7928 6461 7461  py.deepcopy(data
+000064f0: 6e61 6d65 290a 2020 2020 6d61 785f 6e75  name).    max_nu
+00006500: 6d73 203d 2033 300a 2020 2020 6d61 785f  ms = 30.    max_
+00006510: 6361 7473 203d 2031 350a 2020 2020 6d61  cats = 15.    ma
+00006520: 7872 6f77 7320 3d20 3130 3030 300a 2020  xrows = 10000.  
+00006530: 2020 5241 4e44 4f4d 5f53 4545 4420 3d20    RANDOM_SEED = 
+00006540: 3432 0a20 2020 206d 656d 5f6c 696d 6974  42.    mem_limit
+00006550: 203d 2035 3030 2023 2323 2061 6d6f 756e   = 500 ### amoun
+00006560: 7420 6f66 206d 656d 6f72 7920 636f 6e73  t of memory cons
+00006570: 756d 6564 2062 7920 7061 6e64 6173 2064  umed by pandas d
+00006580: 6620 6265 666f 7265 2072 6564 7563 696e  f before reducin
+00006590: 675f 6d65 6d20 6675 6e63 7469 6f6e 2063  g_mem function c
+000065a0: 616c 6c65 640a 2020 2020 2323 2323 2323  alled.    ######
+000065b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000065c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000065d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000065e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000065f0: 2323 2323 2323 0a20 2020 2063 6174 5f65  ######.    cat_e
+00006600: 6e63 6f64 6572 735f 6c69 7374 203d 206c  ncoders_list = l
+00006610: 6973 7428 7365 7474 696e 6773 2e63 6174  ist(settings.cat
+00006620: 5f65 6e63 6f64 6572 735f 6e61 6d65 732e  _encoders_names.
+00006630: 6b65 7973 2829 290a 2020 2020 2323 2320  keys()).    ### 
+00006640: 4a75 7374 2073 6574 2064 6566 6175 6c74  Just set default
+00006650: 7320 6865 7265 2077 6869 6368 2063 616e  s here which can
+00006660: 2062 6520 6f76 6572 7269 6464 656e 2062   be overridden b
+00006670: 7920 7573 6572 2069 6e70 7574 2023 2323  y user input ###
+00006680: 230a 2020 2020 6361 745f 7661 7273 203d  #.    cat_vars =
+00006690: 205b 5d0a 2020 2020 6966 206b 7761 7267   [].    if kwarg
+000066a0: 733a 0a20 2020 2020 2020 2066 6f72 206b  s:.        for k
+000066b0: 6579 2c20 7661 6c75 6520 696e 207a 6970  ey, value in zip
+000066c0: 286b 7761 7267 732e 6b65 7973 2829 2c20  (kwargs.keys(), 
+000066d0: 6b77 6172 6773 2e76 616c 7565 7328 2929  kwargs.values())
+000066e0: 3a0a 2020 2020 2020 2020 2020 2020 7072  :.            pr
+000066f0: 696e 7428 2759 6f75 2073 7570 706c 6965  int('You supplie
+00006700: 6420 2573 203d 2025 7327 2025 286b 6579  d %s = %s' %(key
+00006710: 2c20 7661 6c75 6529 290a 2020 2020 2020  , value)).      
+00006720: 2020 2020 2020 2323 2323 2323 204e 6f77        ###### Now
+00006730: 2074 6573 7420 7468 6520 6e65 7874 2073   test the next s
+00006740: 6574 206f 6620 6b77 6172 6773 2023 2323  et of kwargs ###
+00006750: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+00006760: 6b65 7920 3d3d 2027 6361 745f 7661 7273  key == 'cat_vars
+00006770: 273a 0a20 2020 2020 2020 2020 2020 2020  ':.             
+00006780: 2020 2069 6620 6973 696e 7374 616e 6365     if isinstance
+00006790: 2876 616c 7565 2c20 6c69 7374 293a 0a20  (value, list):. 
+000067a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000067b0: 2020 2063 6174 5f76 6172 7320 3d20 7661     cat_vars = va
+000067c0: 6c75 650a 2020 2020 2020 2020 2020 2020  lue.            
+000067d0: 2020 2020 656c 6966 2069 7369 6e73 7461      elif isinsta
+000067e0: 6e63 6528 7661 6c75 652c 2073 7472 293a  nce(value, str):
+000067f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00006800: 2020 2020 2063 6174 5f76 6172 7320 3d20       cat_vars = 
+00006810: 7661 6c75 650a 2020 2020 2020 2020 2020  value.          
+00006820: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
+00006830: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006840: 7072 696e 7428 2763 6174 2076 6172 7320  print('cat vars 
+00006850: 6d75 7374 2062 6520 6120 6c69 7374 206f  must be a list o
+00006860: 7220 6120 7374 7269 6e67 2729 0a20 2020  r a string').   
+00006870: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00006880: 2072 6574 7572 6e0a 2020 2020 2323 2323   return.    ####
+00006890: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000068a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000068b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000068c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000068d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000068e0: 2323 0a20 2020 2023 2323 2323 2020 2020  ##.    #####    
+000068f0: 2020 4d41 4b49 4e47 2046 4541 5455 5245    MAKING FEATURE
+00006900: 5f54 5950 4520 414e 4420 4645 4154 5552  _TYPE AND FEATUR
+00006910: 455f 4745 4e20 5345 4c45 4354 494f 4e53  E_GEN SELECTIONS
+00006920: 2048 4552 4520 2020 2020 2020 2020 2020   HERE           
+00006930: 2323 2323 2323 2323 2323 2323 230a 2020  #############.  
+00006940: 2020 2323 2323 2323 2323 2323 2323 2323    ##############
+00006950: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00006960: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00006970: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00006980: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00006990: 2323 2323 2323 2323 0a20 2020 2066 6561  ########.    fea
+000069a0: 7475 7265 5f67 656e 6572 6174 6f72 7320  ture_generators 
+000069b0: 3d20 5b27 696e 7465 7261 6374 696f 6e73  = ['interactions
+000069c0: 272c 2027 6772 6f75 7062 7927 2c20 2774  ', 'groupby', 't
+000069d0: 6172 6765 7427 5d0a 2020 2020 6665 6174  arget'].    feat
+000069e0: 7572 655f 6765 6e20 3d20 2727 0a20 2020  ure_gen = ''.   
+000069f0: 2069 6620 6665 6174 7572 655f 656e 6767   if feature_engg
+00006a00: 3a0a 2020 2020 2020 2020 6966 2069 7369  :.        if isi
+00006a10: 6e73 7461 6e63 6528 6665 6174 7572 655f  nstance(feature_
+00006a20: 656e 6767 2c20 7374 7229 3a0a 2020 2020  engg, str):.    
+00006a30: 2020 2020 2020 2020 6966 2066 6561 7475          if featu
+00006a40: 7265 5f65 6e67 6720 696e 2066 6561 7475  re_engg in featu
+00006a50: 7265 5f67 656e 6572 6174 6f72 733a 0a20  re_generators:. 
+00006a60: 2020 2020 2020 2020 2020 2020 2020 2066                 f
+00006a70: 6561 7475 7265 5f67 656e 203d 205b 6665  eature_gen = [fe
+00006a80: 6174 7572 655f 656e 6767 5d0a 2020 2020  ature_engg].    
+00006a90: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
+00006aa0: 2020 2020 2020 2020 2020 2020 2020 7072                pr
+00006ab0: 696e 7428 2766 6561 7475 7265 2065 6e67  int('feature eng
+00006ac0: 6720 7479 7065 7320 6d75 7374 2062 6520  g types must be 
+00006ad0: 6f6e 6520 6f66 2074 6872 6565 2073 7472  one of three str
+00006ae0: 696e 6773 3a20 2573 2720 2566 6561 7475  ings: %s' %featu
+00006af0: 7265 5f67 656e 6572 6174 6f72 7329 0a20  re_generators). 
+00006b00: 2020 2020 2020 2020 2020 2020 2020 2072                 r
+00006b10: 6574 7572 6e0a 2020 2020 2020 2020 656c  eturn.        el
+00006b20: 6966 2069 7369 6e73 7461 6e63 6528 6665  if isinstance(fe
+00006b30: 6174 7572 655f 656e 6767 2c20 6c69 7374  ature_engg, list
+00006b40: 293a 0a20 2020 2020 2020 2020 2020 2066  ):.            f
+00006b50: 6561 7475 7265 5f67 656e 203d 2063 6f70  eature_gen = cop
+00006b60: 792e 6465 6570 636f 7079 2866 6561 7475  y.deepcopy(featu
+00006b70: 7265 5f65 6e67 6729 0a20 2020 2065 6c73  re_engg).    els
+00006b80: 653a 0a20 2020 2020 2020 2070 7269 6e74  e:.        print
+00006b90: 2827 536b 6970 7069 6e67 2066 6561 7475  ('Skipping featu
+00006ba0: 7265 2065 6e67 696e 6565 7269 6e67 2073  re engineering s
+00006bb0: 696e 6365 206e 6f20 6665 6174 7572 655f  ince no feature_
+00006bc0: 656e 6767 2069 6e70 7574 2e2e 2e27 290a  engg input...').
+00006bd0: 2020 2020 6665 6174 7572 655f 7479 7065      feature_type
+00006be0: 203d 2027 270a 2020 2020 6966 2063 6174   = ''.    if cat
+00006bf0: 6567 6f72 795f 656e 636f 6465 7273 3a0a  egory_encoders:.
+00006c00: 2020 2020 2020 2020 6966 2069 7369 6e73          if isins
+00006c10: 7461 6e63 6528 6361 7465 676f 7279 5f65  tance(category_e
+00006c20: 6e63 6f64 6572 732c 2073 7472 293a 0a20  ncoders, str):. 
+00006c30: 2020 2020 2020 2020 2020 2066 6561 7475             featu
+00006c40: 7265 5f74 7970 6520 3d20 5b63 6174 6567  re_type = [categ
+00006c50: 6f72 795f 656e 636f 6465 7273 5d0a 2020  ory_encoders].  
+00006c60: 2020 2020 2020 656c 6966 2069 7369 6e73        elif isins
+00006c70: 7461 6e63 6528 6361 7465 676f 7279 5f65  tance(category_e
+00006c80: 6e63 6f64 6572 732c 206c 6973 7429 3a0a  ncoders, list):.
+00006c90: 2020 2020 2020 2020 2020 2020 6665 6174              feat
+00006ca0: 7572 655f 7479 7065 203d 2063 6174 6567  ure_type = categ
+00006cb0: 6f72 795f 656e 636f 6465 7273 5b3a 325d  ory_encoders[:2]
+00006cc0: 2023 2323 204f 6e6c 7920 7477 6f20 7769   ### Only two wi
+00006cd0: 6c6c 2062 6520 616c 6c6f 7765 6420 6174  ll be allowed at
+00006ce0: 2061 2074 696d 650a 2020 2020 656c 7365   a time.    else
+00006cf0: 3a0a 2020 2020 2020 2020 7072 696e 7428  :.        print(
+00006d00: 2753 6b69 7070 696e 6720 6361 7465 676f  'Skipping catego
+00006d10: 7279 2065 6e63 6f64 696e 6720 7369 6e63  ry encoding sinc
+00006d20: 6520 6e6f 2063 6174 6567 6f72 7920 656e  e no category en
+00006d30: 636f 6465 7273 2073 7065 6369 6669 6564  coders specified
+00006d40: 2069 6e20 696e 7075 742e 2e2e 2729 0a20   in input...'). 
+00006d50: 2020 2023 2323 2323 2323 2323 2323 2323     #############
 00006d60: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00006d70: 2020 2020 4c20 4f20 4120 4420 2020 2020      L O A D     
-00006d80: 5420 5220 4120 4920 4e20 2020 4420 4120  T R A I N   D A 
-00006d90: 5420 4120 2020 2323 2323 2323 2323 2323  T A   ##########
-00006da0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00006db0: 2323 2323 0a20 2020 2023 2323 2323 2323  ####.    #######
-00006dc0: 2323 2320 2020 6461 7461 6e61 6d65 2077  ###   dataname w
-00006dd0: 696c 6c20 6265 2074 6865 206e 616d 6520  ill be the name 
-00006de0: 6f66 2074 6865 2070 616e 6461 7320 7665  of the pandas ve
-00006df0: 7273 696f 6e20 6f66 2074 7261 696e 2064  rsion of train d
-00006e00: 6174 6120 2020 2020 2023 2323 2323 230a  ata      ######.
-00006e10: 2020 2020 2323 2323 2323 2323 2323 2020      ##########  
-00006e20: 2020 2020 2020 2020 2074 7261 696e 2077           train w
-00006e30: 696c 6c20 6265 2074 6865 2044 6173 6b20  ill be the Dask 
-00006e40: 7665 7273 696f 6e20 6f66 2074 7261 696e  version of train
-00006e50: 2064 6174 6120 2020 2020 2020 2020 2020   data           
-00006e60: 2020 2020 2323 2323 2323 0a20 2020 2023      ######.    #
-00006e70: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00006e80: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00006e90: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00006ea0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00006eb0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00006ec0: 2323 2323 230a 2020 2020 6966 2069 7369  #####.    if isi
-00006ed0: 6e73 7461 6e63 6528 6461 7461 6e61 6d65  nstance(dataname
-00006ee0: 2c20 7374 7229 3a0a 2020 2020 2020 2020  , str):.        
-00006ef0: 2323 2323 2054 6869 7320 6973 2077 6865  #### This is whe
-00006f00: 7265 2077 6520 6765 7420 6120 6669 6c65  re we get a file
-00006f10: 6e61 6d65 2061 7320 6120 7374 7269 6e67  name as a string
-00006f20: 2061 7320 616e 2069 6e70 7574 2023 2323   as an input ###
-00006f30: 2323 2323 2323 2323 2323 2323 2323 0a20  ##############. 
-00006f40: 2020 2020 2020 2069 6620 7265 2e73 6561         if re.sea
-00006f50: 7263 6828 7227 282e 6674 7229 272c 2064  rch(r'(.ftr)', d
-00006f60: 6174 616e 616d 6529 206f 7220 7265 2e73  ataname) or re.s
-00006f70: 6561 7263 6828 7227 282e 6665 6174 6865  earch(r'(.feathe
-00006f80: 7229 272c 2064 6174 616e 616d 6529 3a0a  r)', dataname):.
-00006f90: 2020 2020 2020 2020 2020 2020 7072 696e              prin
-00006fa0: 7428 2222 222a 2a49 4e46 4f3a 2046 6561  t("""**INFO: Fea
-00006fb0: 7468 6572 2066 6f72 6d61 7420 616c 6c6f  ther format allo
-00006fc0: 7765 642e 204c 6f61 6469 6e67 2066 6561  wed. Loading fea
-00006fd0: 7468 6572 2066 6f72 6d61 7474 6564 2066  ther formatted f
-00006fe0: 696c 652e 2e2e 2a2a 2222 2229 0a20 2020  ile...**""").   
-00006ff0: 2020 2020 2020 2020 2069 6d70 6f72 7420           import 
-00007000: 6665 6174 6865 720a 2020 2020 2020 2020  feather.        
-00007010: 2020 2020 6461 7461 6e61 6d65 203d 2070      dataname = p
-00007020: 642e 7265 6164 5f66 6561 7468 6572 2864  d.read_feather(d
-00007030: 6174 616e 616d 652c 2075 7365 5f74 6872  ataname, use_thr
-00007040: 6561 6473 3d54 7275 6529 0a20 2020 2020  eads=True).     
-00007050: 2020 2020 2020 2074 7261 696e 203d 206c         train = l
-00007060: 6f61 645f 6461 736b 5f64 6174 6128 6461  oad_dask_data(da
-00007070: 7461 6e61 6d65 2c20 7365 7029 0a20 2020  taname, sep).   
-00007080: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
-00007090: 2020 2020 2020 2069 6620 7665 7262 6f73         if verbos
-000070a0: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
-000070b0: 2020 2070 7269 6e74 2822 2222 2a2a 494e     print("""**IN
-000070c0: 464f 3a20 746f 2069 6e63 7265 6173 6520  FO: to increase 
-000070d0: 6669 6c65 206c 6f61 6469 6e67 2070 6572  file loading per
-000070e0: 666f 726d 616e 6365 2c20 636f 6e76 6572  formance, conver
-000070f0: 7420 6875 6765 2060 6373 7660 2066 696c  t huge `csv` fil
-00007100: 6573 2074 6f20 6066 6561 7468 6572 6020  es to `feather` 
-00007110: 666f 726d 6174 2222 2229 0a20 2020 2020  format""").     
-00007120: 2020 2020 2020 2020 2020 2070 7269 6e74             print
-00007130: 2822 2222 2a2a 494e 464f 3a20 5573 6520  ("""**INFO: Use 
-00007140: 6064 662e 7265 7365 745f 696e 6465 7828  `df.reset_index(
-00007150: 6472 6f70 3d54 7275 6529 2e74 6f5f 6665  drop=True).to_fe
-00007160: 6174 6865 7228 2270 6174 682f 746f 2f73  ather("path/to/s
-00007170: 6176 652f 6669 6c65 2e66 7472 2229 6020  ave/file.ftr")` 
-00007180: 746f 2073 6176 6520 6669 6c65 2069 6e20  to save file in 
-00007190: 6665 6174 6865 7220 666f 726d 6174 2a2a  feather format**
-000071a0: 2222 2229 0a20 2020 2020 2020 2020 2020  """).           
-000071b0: 2069 6620 6461 736b 5f78 6762 6f6f 7374   if dask_xgboost
-000071c0: 5f66 6c61 673a 0a20 2020 2020 2020 2020  _flag:.         
-000071d0: 2020 2020 2020 2074 7279 3a0a 2020 2020         try:.    
-000071e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000071f0: 7072 696e 7428 2720 2020 2053 696e 6365  print('    Since
-00007200: 2064 6173 6b5f 7867 626f 6f73 745f 666c   dask_xgboost_fl
-00007210: 6167 2069 7320 5472 7565 2c20 7265 6475  ag is True, redu
-00007220: 6369 6e67 206d 656d 6f72 7920 7369 7a65  cing memory size
-00007230: 2061 6e64 206c 6f61 6469 6e67 2069 6e74   and loading int
-00007240: 6f20 6461 736b 2729 0a20 2020 2020 2020  o dask').       
-00007250: 2020 2020 2020 2020 2020 2020 2064 6174               dat
-00007260: 616e 616d 6520 3d20 7064 2e72 6561 645f  aname = pd.read_
-00007270: 6373 7628 6461 7461 6e61 6d65 2c20 7365  csv(dataname, se
-00007280: 703d 7365 702c 2068 6561 6465 723d 6865  p=sep, header=he
-00007290: 6164 6572 2c20 6e72 6f77 733d 6e72 6f77  ader, nrows=nrow
-000072a0: 7329 0a20 2020 2020 2020 2020 2020 2020  s).             
-000072b0: 2020 2020 2020 2069 6620 2864 6174 616e         if (datan
-000072c0: 616d 652e 6d65 6d6f 7279 5f75 7361 6765  ame.memory_usage
-000072d0: 2829 2e73 756d 2829 2f31 3030 3030 3030  ().sum()/1000000
-000072e0: 2920 3e20 6d65 6d5f 6c69 6d69 743a 0a20  ) > mem_limit:. 
-000072f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007300: 2020 2020 2020 2064 6174 616e 616d 6520         dataname 
-00007310: 3d20 7265 6475 6365 5f6d 656d 5f75 7361  = reduce_mem_usa
-00007320: 6765 2864 6174 616e 616d 6529 0a20 2020  ge(dataname).   
-00007330: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007340: 2074 7261 696e 203d 206c 6f61 645f 6461   train = load_da
-00007350: 736b 5f64 6174 6128 6461 7461 6e61 6d65  sk_data(dataname
-00007360: 2c20 7365 7029 0a20 2020 2020 2020 2020  , sep).         
-00007370: 2020 2020 2020 2065 7863 6570 743a 0a20         except:. 
+00006d70: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00006d80: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00006d90: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00006da0: 2323 2323 2323 2323 230a 2020 2020 2323  #########.    ##
+00006db0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00006dc0: 2020 2020 4c20 4f20 4120 4420 2020 2020      L O A D     
+00006dd0: 5420 5220 4120 4920 4e20 2020 4420 4120  T R A I N   D A 
+00006de0: 5420 4120 2020 2323 2323 2323 2323 2323  T A   ##########
+00006df0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00006e00: 2323 2323 0a20 2020 2023 2323 2323 2323  ####.    #######
+00006e10: 2323 2320 2020 6461 7461 6e61 6d65 2077  ###   dataname w
+00006e20: 696c 6c20 6265 2074 6865 206e 616d 6520  ill be the name 
+00006e30: 6f66 2074 6865 2070 616e 6461 7320 7665  of the pandas ve
+00006e40: 7273 696f 6e20 6f66 2074 7261 696e 2064  rsion of train d
+00006e50: 6174 6120 2020 2020 2023 2323 2323 230a  ata      ######.
+00006e60: 2020 2020 2323 2323 2323 2323 2323 2020      ##########  
+00006e70: 2020 2020 2020 2020 2074 7261 696e 2077           train w
+00006e80: 696c 6c20 6265 2074 6865 2044 6173 6b20  ill be the Dask 
+00006e90: 7665 7273 696f 6e20 6f66 2074 7261 696e  version of train
+00006ea0: 2064 6174 6120 2020 2020 2020 2020 2020   data           
+00006eb0: 2020 2020 2323 2323 2323 0a20 2020 2023      ######.    #
+00006ec0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00006ed0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00006ee0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00006ef0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00006f00: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00006f10: 2323 2323 230a 2020 2020 6966 2069 7369  #####.    if isi
+00006f20: 6e73 7461 6e63 6528 6461 7461 6e61 6d65  nstance(dataname
+00006f30: 2c20 7374 7229 3a0a 2020 2020 2020 2020  , str):.        
+00006f40: 2323 2323 2054 6869 7320 6973 2077 6865  #### This is whe
+00006f50: 7265 2077 6520 6765 7420 6120 6669 6c65  re we get a file
+00006f60: 6e61 6d65 2061 7320 6120 7374 7269 6e67  name as a string
+00006f70: 2061 7320 616e 2069 6e70 7574 2023 2323   as an input ###
+00006f80: 2323 2323 2323 2323 2323 2323 2323 0a20  ##############. 
+00006f90: 2020 2020 2020 2069 6620 7265 2e73 6561         if re.sea
+00006fa0: 7263 6828 7227 282e 6674 7229 272c 2064  rch(r'(.ftr)', d
+00006fb0: 6174 616e 616d 6529 206f 7220 7265 2e73  ataname) or re.s
+00006fc0: 6561 7263 6828 7227 282e 6665 6174 6865  earch(r'(.feathe
+00006fd0: 7229 272c 2064 6174 616e 616d 6529 3a0a  r)', dataname):.
+00006fe0: 2020 2020 2020 2020 2020 2020 7072 696e              prin
+00006ff0: 7428 2222 222a 2a49 4e46 4f3a 2046 6561  t("""**INFO: Fea
+00007000: 7468 6572 2066 6f72 6d61 7420 616c 6c6f  ther format allo
+00007010: 7765 642e 204c 6f61 6469 6e67 2066 6561  wed. Loading fea
+00007020: 7468 6572 2066 6f72 6d61 7474 6564 2066  ther formatted f
+00007030: 696c 652e 2e2e 2a2a 2222 2229 0a20 2020  ile...**""").   
+00007040: 2020 2020 2020 2020 2069 6d70 6f72 7420           import 
+00007050: 6665 6174 6865 720a 2020 2020 2020 2020  feather.        
+00007060: 2020 2020 6461 7461 6e61 6d65 203d 2070      dataname = p
+00007070: 642e 7265 6164 5f66 6561 7468 6572 2864  d.read_feather(d
+00007080: 6174 616e 616d 652c 2075 7365 5f74 6872  ataname, use_thr
+00007090: 6561 6473 3d54 7275 6529 0a20 2020 2020  eads=True).     
+000070a0: 2020 2020 2020 2074 7261 696e 203d 206c         train = l
+000070b0: 6f61 645f 6461 736b 5f64 6174 6128 6461  oad_dask_data(da
+000070c0: 7461 6e61 6d65 2c20 7365 7029 0a20 2020  taname, sep).   
+000070d0: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+000070e0: 2020 2020 2020 2069 6620 7665 7262 6f73         if verbos
+000070f0: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+00007100: 2020 2070 7269 6e74 2822 2222 2a2a 494e     print("""**IN
+00007110: 464f 3a20 746f 2069 6e63 7265 6173 6520  FO: to increase 
+00007120: 6669 6c65 206c 6f61 6469 6e67 2070 6572  file loading per
+00007130: 666f 726d 616e 6365 2c20 636f 6e76 6572  formance, conver
+00007140: 7420 6875 6765 2060 6373 7660 2066 696c  t huge `csv` fil
+00007150: 6573 2074 6f20 6066 6561 7468 6572 6020  es to `feather` 
+00007160: 666f 726d 6174 2222 2229 0a20 2020 2020  format""").     
+00007170: 2020 2020 2020 2020 2020 2070 7269 6e74             print
+00007180: 2822 2222 2a2a 494e 464f 3a20 5573 6520  ("""**INFO: Use 
+00007190: 6064 662e 7265 7365 745f 696e 6465 7828  `df.reset_index(
+000071a0: 6472 6f70 3d54 7275 6529 2e74 6f5f 6665  drop=True).to_fe
+000071b0: 6174 6865 7228 2270 6174 682f 746f 2f73  ather("path/to/s
+000071c0: 6176 652f 6669 6c65 2e66 7472 2229 6020  ave/file.ftr")` 
+000071d0: 746f 2073 6176 6520 6669 6c65 2069 6e20  to save file in 
+000071e0: 6665 6174 6865 7220 666f 726d 6174 2a2a  feather format**
+000071f0: 2222 2229 0a20 2020 2020 2020 2020 2020  """).           
+00007200: 2069 6620 6461 736b 5f78 6762 6f6f 7374   if dask_xgboost
+00007210: 5f66 6c61 673a 0a20 2020 2020 2020 2020  _flag:.         
+00007220: 2020 2020 2020 2074 7279 3a0a 2020 2020         try:.    
+00007230: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007240: 7072 696e 7428 2720 2020 2053 696e 6365  print('    Since
+00007250: 2064 6173 6b5f 7867 626f 6f73 745f 666c   dask_xgboost_fl
+00007260: 6167 2069 7320 5472 7565 2c20 7265 6475  ag is True, redu
+00007270: 6369 6e67 206d 656d 6f72 7920 7369 7a65  cing memory size
+00007280: 2061 6e64 206c 6f61 6469 6e67 2069 6e74   and loading int
+00007290: 6f20 6461 736b 2729 0a20 2020 2020 2020  o dask').       
+000072a0: 2020 2020 2020 2020 2020 2020 2064 6174               dat
+000072b0: 616e 616d 6520 3d20 7064 2e72 6561 645f  aname = pd.read_
+000072c0: 6373 7628 6461 7461 6e61 6d65 2c20 7365  csv(dataname, se
+000072d0: 703d 7365 702c 2068 6561 6465 723d 6865  p=sep, header=he
+000072e0: 6164 6572 2c20 6e72 6f77 733d 6e72 6f77  ader, nrows=nrow
+000072f0: 7329 0a20 2020 2020 2020 2020 2020 2020  s).             
+00007300: 2020 2020 2020 2069 6620 2864 6174 616e         if (datan
+00007310: 616d 652e 6d65 6d6f 7279 5f75 7361 6765  ame.memory_usage
+00007320: 2829 2e73 756d 2829 2f31 3030 3030 3030  ().sum()/1000000
+00007330: 2920 3e20 6d65 6d5f 6c69 6d69 743a 0a20  ) > mem_limit:. 
+00007340: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007350: 2020 2020 2020 2064 6174 616e 616d 6520         dataname 
+00007360: 3d20 7265 6475 6365 5f6d 656d 5f75 7361  = reduce_mem_usa
+00007370: 6765 2864 6174 616e 616d 6529 0a20 2020  ge(dataname).   
 00007380: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00007390: 2020 2070 7269 6e74 2827 4669 6c65 2063     print('File c
-000073a0: 6f75 6c64 206e 6f74 2062 6520 6c6f 6164  ould not be load
-000073b0: 6564 2069 6e74 6f20 6461 736b 2e20 4368  ed into dask. Ch
-000073c0: 6563 6b20 7468 6520 7061 7468 206f 7220  eck the path or 
-000073d0: 6669 6c65 6e61 6d65 2061 6e64 2074 7279  filename and try
-000073e0: 2061 6761 696e 2729 0a20 2020 2020 2020   again').       
-000073f0: 2020 2020 2020 2020 2020 2020 2072 6574               ret
-00007400: 7572 6e20 4e6f 6e65 0a20 2020 2020 2020  urn None.       
-00007410: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
-00007420: 2020 2020 2020 2020 2020 2023 2323 2320             #### 
-00007430: 5468 6572 6520 6973 206e 6f20 6461 736b  There is no dask
-00007440: 2066 6c61 6720 736f 206c 6f61 6420 6974   flag so load it
-00007450: 2069 6e74 6f20 6120 7265 6775 6c61 7220   into a regular 
-00007460: 7061 6e64 6173 2064 6174 6166 7261 6d65  pandas dataframe
-00007470: 2023 2323 230a 2020 2020 2020 2020 2020   ####.          
-00007480: 2020 2020 2020 7472 6169 6e20 3d20 6c6f        train = lo
-00007490: 6164 5f66 696c 655f 6461 7461 6672 616d  ad_file_datafram
-000074a0: 6528 6461 7461 6e61 6d65 2c20 7365 703d  e(dataname, sep=
-000074b0: 7365 702c 2068 6561 6465 723d 6865 6164  sep, header=head
-000074c0: 6572 2c20 7665 7262 6f73 653d 7665 7262  er, verbose=verb
-000074d0: 6f73 652c 200a 2020 2020 2020 2020 2020  ose, .          
-000074e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000074f0: 2020 2020 2020 2020 2020 6e72 6f77 733d            nrows=
-00007500: 6e72 6f77 732c 2074 6172 6765 743d 7461  nrows, target=ta
-00007510: 7267 6574 290a 2020 2020 2020 2020 2020  rget).          
-00007520: 2020 2020 2020 6966 2028 7472 6169 6e2e        if (train.
-00007530: 6d65 6d6f 7279 5f75 7361 6765 2829 2e73  memory_usage().s
-00007540: 756d 2829 2f31 3030 3030 3030 2920 3e20  um()/1000000) > 
-00007550: 6d65 6d5f 6c69 6d69 743a 0a20 2020 2020  mem_limit:.     
-00007560: 2020 2020 2020 2020 2020 2020 2020 2064                 d
-00007570: 6174 616e 616d 6520 3d20 7265 6475 6365  ataname = reduce
-00007580: 5f6d 656d 5f75 7361 6765 2874 7261 696e  _mem_usage(train
-00007590: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-000075a0: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
-000075b0: 2020 2020 2020 2020 2020 2020 6461 7461              data
-000075c0: 6e61 6d65 203d 2063 6f70 792e 6465 6570  name = copy.deep
-000075d0: 636f 7079 2874 7261 696e 290a 2020 2020  copy(train).    
-000075e0: 656c 7365 3a0a 2020 2020 2020 2020 2323  else:.        ##
-000075f0: 2323 2054 6869 7320 6973 2077 6865 7265  ## This is where
-00007600: 2077 6520 6765 7420 6120 6461 7461 6672   we get a datafr
-00007610: 616d 6520 6173 2061 6e20 696e 7075 7420  ame as an input 
-00007620: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00007630: 230a 2020 2020 2020 2020 6966 2064 6173  #.        if das
-00007640: 6b5f 7867 626f 6f73 745f 666c 6167 3a0a  k_xgboost_flag:.
-00007650: 2020 2020 2020 2020 2020 2020 6966 206e              if n
-00007660: 6f74 206e 726f 7773 2069 7320 4e6f 6e65  ot nrows is None
-00007670: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00007680: 2020 6461 7461 6e61 6d65 203d 2064 6174    dataname = dat
-00007690: 616e 616d 652e 7361 6d70 6c65 286e 3d6e  aname.sample(n=n
-000076a0: 726f 7773 2c20 7265 706c 6163 653d 5472  rows, replace=Tr
-000076b0: 7565 2c20 7261 6e64 6f6d 5f73 7461 7465  ue, random_state
-000076c0: 3d39 3939 3929 0a20 2020 2020 2020 2020  =9999).         
-000076d0: 2020 2020 2020 2070 7269 6e74 2827 5361         print('Sa
-000076e0: 6d70 6c69 6e67 2025 7320 726f 7773 2066  mpling %s rows f
-000076f0: 726f 6d20 6461 7461 6672 616d 6520 6769  rom dataframe gi
-00007700: 7665 6e27 2025 6e72 6f77 7329 0a20 2020  ven' %nrows).   
-00007710: 2020 2020 2020 2020 2070 7269 6e74 2827           print('
-00007720: 2020 2020 5369 6e63 6520 6461 736b 5f78      Since dask_x
-00007730: 6762 6f6f 7374 5f66 6c61 6720 6973 2054  gboost_flag is T
-00007740: 7275 652c 2072 6564 7563 696e 6720 6d65  rue, reducing me
-00007750: 6d6f 7279 2073 697a 6520 616e 6420 6c6f  mory size and lo
-00007760: 6164 696e 6720 696e 746f 2064 6173 6b27  ading into dask'
-00007770: 290a 2020 2020 2020 2020 2020 2020 6966  ).            if
-00007780: 2028 6461 7461 6e61 6d65 2e6d 656d 6f72   (dataname.memor
-00007790: 795f 7573 6167 6528 292e 7375 6d28 292f  y_usage().sum()/
-000077a0: 3130 3030 3030 3029 203e 206d 656d 5f6c  1000000) > mem_l
-000077b0: 696d 6974 3a0a 2020 2020 2020 2020 2020  imit:.          
-000077c0: 2020 2020 2020 6461 7461 6e61 6d65 203d        dataname =
-000077d0: 2072 6564 7563 655f 6d65 6d5f 7573 6167   reduce_mem_usag
-000077e0: 6528 6461 7461 6e61 6d65 290a 2020 2020  e(dataname).    
-000077f0: 2020 2020 2020 2020 7472 6169 6e20 3d20          train = 
-00007800: 6c6f 6164 5f64 6173 6b5f 6461 7461 2864  load_dask_data(d
-00007810: 6174 616e 616d 652c 2073 6570 290a 2020  ataname, sep).  
-00007820: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
-00007830: 2020 2020 2020 2020 7472 6169 6e20 3d20          train = 
-00007840: 6c6f 6164 5f66 696c 655f 6461 7461 6672  load_file_datafr
-00007850: 616d 6528 6461 7461 6e61 6d65 2c20 7365  ame(dataname, se
-00007860: 703d 7365 702c 2068 6561 6465 723d 6865  p=sep, header=he
-00007870: 6164 6572 2c20 7665 7262 6f73 653d 7665  ader, verbose=ve
-00007880: 7262 6f73 652c 200a 2020 2020 2020 2020  rbose, .        
-00007890: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000078a0: 2020 2020 6e72 6f77 733d 6e72 6f77 732c      nrows=nrows,
-000078b0: 2074 6172 6765 743d 7461 7267 6574 290a   target=target).
-000078c0: 2020 2020 2020 2020 2020 2020 6966 2028              if (
-000078d0: 7472 6169 6e2e 6d65 6d6f 7279 5f75 7361  train.memory_usa
-000078e0: 6765 2829 2e73 756d 2829 2f31 3030 3030  ge().sum()/10000
-000078f0: 3030 2920 3e20 6d65 6d5f 6c69 6d69 743a  00) > mem_limit:
-00007900: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00007910: 2064 6174 616e 616d 6520 3d20 7265 6475   dataname = redu
-00007920: 6365 5f6d 656d 5f75 7361 6765 2874 7261  ce_mem_usage(tra
-00007930: 696e 290a 2020 2020 2020 2020 2020 2020  in).            
-00007940: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
-00007950: 2020 2020 2020 6461 7461 6e61 6d65 203d        dataname =
-00007960: 2063 6f70 792e 6465 6570 636f 7079 2874   copy.deepcopy(t
-00007970: 7261 696e 290a 2020 2020 7072 696e 7428  rain).    print(
-00007980: 2720 2020 204c 6f61 6465 6420 7472 6169  '    Loaded trai
-00007990: 6e20 6461 7461 2e20 5368 6170 6520 3d20  n data. Shape = 
-000079a0: 2573 2720 2528 6461 7461 6e61 6d65 2e73  %s' %(dataname.s
-000079b0: 6861 7065 2c29 290a 2020 2020 2323 2323  hape,)).    ####
-000079c0: 2323 2323 2323 2323 2323 2323 2323 2020  ##############  
-000079d0: 2020 4c20 4f20 4120 4420 2020 2054 2045    L O A D    T E
-000079e0: 2053 2054 2020 2044 2041 2054 2041 2020   S T   D A T A  
-000079f0: 2020 2020 2323 2323 2323 2323 2323 2323      ############
-00007a00: 2323 2323 2323 2323 2323 0a20 2020 2064  ##########.    d
-00007a10: 6174 616e 616d 6520 3d20 7265 6d6f 7665  ataname = remove
-00007a20: 5f64 7570 6c69 6361 7465 5f63 6f6c 735f  _duplicate_cols_
-00007a30: 696e 5f64 6174 6173 6574 2864 6174 616e  in_dataset(datan
-00007a40: 616d 6529 0a20 0a20 2020 2023 2323 2320  ame). .    #### 
-00007a50: 436f 6e76 6572 7420 6d69 7865 6420 6461  Convert mixed da
-00007a60: 7461 2074 7970 6573 2074 6f20 7374 7269  ta types to stri
-00007a70: 6e67 2064 6174 6120 7479 7065 2020 2323  ng data type  ##
-00007a80: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00007a90: 2323 2323 2323 2323 2323 0a20 2020 2023  ##########.    #
-00007aa0: 6461 7461 6e61 6d65 203d 2046 455f 636f  dataname = FE_co
-00007ab0: 6e76 6572 745f 6d69 7865 645f 6461 7461  nvert_mixed_data
-00007ac0: 7479 7065 735f 746f 5f73 7472 696e 6728  types_to_string(
-00007ad0: 6461 7461 6e61 6d65 290a 2020 2020 0a20  dataname).    . 
-00007ae0: 2020 2023 2323 2323 2320 2020 5847 426f     ######   XGBo
-00007af0: 6f73 7420 6361 6e6e 6f74 2068 616e 646c  ost cannot handl
-00007b00: 6520 7370 6563 6961 6c20 6368 6172 7320  e special chars 
-00007b10: 696e 2063 6f6c 756d 6e20 6e61 6d65 7320  in column names 
-00007b20: 2323 2323 2323 2323 2323 230a 2020 2020  ###########.    
-00007b30: 756e 6971 203d 2043 6f6c 756d 6e5f 4e61  uniq = Column_Na
-00007b40: 6d65 735f 5472 616e 7366 6f72 6d65 7228  mes_Transformer(
-00007b50: 290a 2020 2020 6461 7461 6e61 6d65 203d  ).    dataname =
-00007b60: 2075 6e69 712e 6669 745f 7472 616e 7366   uniq.fit_transf
-00007b70: 6f72 6d28 6461 7461 6e61 6d65 290a 2020  orm(dataname).  
-00007b80: 2020 6e65 775f 636f 6c5f 6e61 6d65 7320    new_col_names 
-00007b90: 3d20 756e 6971 2e6e 6577 5f63 6f6c 756d  = uniq.new_colum
-00007ba0: 6e5f 6e61 6d65 730a 2020 2020 6f6c 645f  n_names.    old_
-00007bb0: 636f 6c5f 6e61 6d65 7320 3d20 756e 6971  col_names = uniq
-00007bc0: 2e6f 6c64 5f63 6f6c 756d 6e5f 6e61 6d65  .old_column_name
-00007bd0: 730a 2020 2020 7370 6563 6961 6c5f 6368  s.    special_ch
-00007be0: 6172 5f66 6c61 6720 3d20 756e 6971 2e74  ar_flag = uniq.t
-00007bf0: 7261 6e73 666f 726d 6564 5f66 6c61 670a  ransformed_flag.
-00007c00: 0a20 2020 2023 2323 2053 7570 706f 7365  .    ### Suppose
-00007c10: 2079 6f75 2068 6176 6520 6368 616e 6765   you have change
-00007c20: 6420 7468 6520 6e61 6d65 732c 2074 6865  d the names, the
-00007c30: 6e6e 2079 6f75 206d 7573 7420 6c6f 6164  nn you must load
-00007c40: 2069 7420 696e 2064 6173 6b20 6167 6169   it in dask agai
-00007c50: 6e20 2323 2020 2020 0a20 2020 2069 6620  n ##    .    if 
-00007c60: 7370 6563 6961 6c5f 6368 6172 5f66 6c61  special_char_fla
-00007c70: 673a 0a20 2020 2020 2020 2069 6620 6461  g:.        if da
-00007c80: 736b 5f78 6762 6f6f 7374 5f66 6c61 673a  sk_xgboost_flag:
-00007c90: 0a20 2020 2020 2020 2020 2020 2074 7261  .            tra
-00007ca0: 696e 203d 206c 6f61 645f 6461 736b 5f64  in = load_dask_d
-00007cb0: 6174 6128 6461 7461 6e61 6d65 2c20 7365  ata(dataname, se
-00007cc0: 7029 0a0a 2020 2020 2323 2323 2323 204e  p)..    ###### N
-00007cd0: 6f77 2073 6176 6520 7468 6520 6f6c 6420  ow save the old 
-00007ce0: 616e 6420 6e65 7720 636f 6c75 6d6e 7320  and new columns 
-00007cf0: 696e 2061 2064 6963 7469 6f6e 6172 7920  in a dictionary 
-00007d00: 746f 2075 7365 2074 6865 6d20 6c61 7465  to use them late
-00007d10: 7220 2323 230a 2020 2020 636f 6c5f 6e61  r ###.    col_na
-00007d20: 6d65 5f6d 6170 7065 7220 3d20 6469 6374  me_mapper = dict
-00007d30: 287a 6970 286e 6577 5f63 6f6c 5f6e 616d  (zip(new_col_nam
-00007d40: 6573 2c20 6f6c 645f 636f 6c5f 6e61 6d65  es, old_col_name
-00007d50: 7329 290a 2020 2020 636f 6c5f 6e61 6d65  s)).    col_name
-00007d60: 5f72 6570 6c61 6365 7220 3d20 7b79 3a20  _replacer = {y: 
-00007d70: 7820 666f 7220 2878 2c20 7929 2069 6e20  x for (x, y) in 
-00007d80: 636f 6c5f 6e61 6d65 5f6d 6170 7065 722e  col_name_mapper.
-00007d90: 6974 656d 7328 297d 0a20 2020 2069 7465  items()}.    ite
-00007da0: 6d5f 7265 706c 6163 6572 203d 2063 6f6c  m_replacer = col
-00007db0: 5f6e 616d 655f 7265 706c 6163 6572 2e67  _name_replacer.g
-00007dc0: 6574 2020 2320 466f 7220 6661 7374 6572  et  # For faster
-00007dd0: 2067 6574 732e 0a0a 2020 2020 2323 2323   gets...    ####
-00007de0: 2059 6f75 206e 6565 6420 746f 2063 6861   You need to cha
-00007df0: 6e67 6520 7468 6520 7461 7267 6574 206e  nge the target n
-00007e00: 616d 6520 6966 2079 6f75 2068 6176 6520  ame if you have 
-00007e10: 6368 616e 6765 6420 7468 6520 636f 6c75  changed the colu
-00007e20: 6d6e 206e 616d 6573 2023 2323 200a 2020  mn names ### .  
-00007e30: 2020 6966 2073 7065 6369 616c 5f63 6861    if special_cha
-00007e40: 725f 666c 6167 3a0a 2020 2020 2020 2020  r_flag:.        
-00007e50: 6966 2069 7369 6e73 7461 6e63 6528 7461  if isinstance(ta
-00007e60: 7267 6574 2c20 7374 7229 3a0a 2020 2020  rget, str):.    
-00007e70: 2020 2020 2020 2020 7461 7267 6574 7320          targets 
-00007e80: 3d20 5b74 6172 6765 745d 0a20 2020 2020  = [target].     
-00007e90: 2020 2020 2020 2074 6172 6765 7473 203d         targets =
-00007ea0: 205b 6974 656d 5f72 6570 6c61 6365 7228   [item_replacer(
-00007eb0: 6e2c 206e 2920 666f 7220 6e20 696e 2074  n, n) for n in t
-00007ec0: 6172 6765 7473 5d0a 2020 2020 2020 2020  argets].        
-00007ed0: 2020 2020 7461 7267 6574 203d 2074 6172      target = tar
-00007ee0: 6765 7473 5b30 5d0a 2020 2020 2020 2020  gets[0].        
-00007ef0: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
-00007f00: 2020 7461 7267 6574 7320 3d20 636f 7079    targets = copy
-00007f10: 2e64 6565 7063 6f70 7928 7461 7267 6574  .deepcopy(target
-00007f20: 290a 2020 2020 2020 2020 2020 2020 7461  ).            ta
-00007f30: 7267 6574 203d 205b 6974 656d 5f72 6570  rget = [item_rep
-00007f40: 6c61 6365 7228 6e2c 206e 2920 666f 7220  lacer(n, n) for 
-00007f50: 6e20 696e 2074 6172 6765 7473 5d0a 0a20  n in targets].. 
-00007f60: 2020 2074 7261 696e 5f69 6e64 6578 203d     train_index =
-00007f70: 2064 6174 616e 616d 652e 696e 6465 780a   dataname.index.
-00007f80: 2020 2020 0a20 2020 2069 6620 6973 696e      .    if isin
-00007f90: 7374 616e 6365 2874 6172 6765 742c 2073  stance(target, s
-00007fa0: 7472 293a 0a20 2020 2020 2020 2069 6620  tr):.        if 
-00007fb0: 6c65 6e28 7461 7267 6574 2920 3d3d 2030  len(target) == 0
-00007fc0: 3a0a 2020 2020 2020 2020 2020 2020 636f  :.            co
-00007fd0: 6c73 5f6c 6973 7420 3d20 6c69 7374 2864  ls_list = list(d
-00007fe0: 6174 616e 616d 6529 0a20 2020 2020 2020  ataname).       
-00007ff0: 2020 2020 2073 6574 7469 6e67 732e 6d6f       settings.mo
-00008000: 6465 6c74 7970 6520 3d20 2743 6c75 7374  deltype = 'Clust
-00008010: 6572 696e 6727 0a20 2020 2020 2020 2020  ering'.         
-00008020: 2020 2070 7269 6e74 2827 6665 6174 7572     print('featur
-00008030: 6577 697a 2064 6f65 7320 6e6f 7420 776f  ewiz does not wo
-00008040: 726b 206f 6e20 636c 7573 7465 7269 6e67  rk on clustering
-00008050: 206f 7220 756e 7375 7065 7276 6973 6564   or unsupervised
-00008060: 2070 726f 626c 656d 732e 2052 6574 7572   problems. Retur
-00008070: 6e69 6e67 2e2e 2e27 290a 2020 2020 2020  ning...').      
-00008080: 2020 2020 2020 7265 7475 726e 206f 6c64        return old
-00008090: 5f63 6f6c 5f6e 616d 6573 2c20 6461 7461  _col_names, data
-000080a0: 6e61 6d65 0a20 2020 2020 2020 2065 6c73  name.        els
-000080b0: 653a 0a20 2020 2020 2020 2020 2020 2073  e:.            s
-000080c0: 6574 7469 6e67 732e 6d6f 6465 6c74 7970  ettings.modeltyp
-000080d0: 652c 205f 203d 2061 6e61 6c79 7a65 5f70  e, _ = analyze_p
-000080e0: 726f 626c 656d 5f74 7970 6528 6461 7461  roblem_type(data
-000080f0: 6e61 6d65 5b74 6172 6765 745d 2c20 7461  name[target], ta
-00008100: 7267 6574 290a 2020 2020 2020 2020 2020  rget).          
-00008110: 2020 636f 6c73 5f6c 6973 7420 3d20 6c65    cols_list = le
-00008120: 6674 5f73 7562 7472 6163 7428 6c69 7374  ft_subtract(list
-00008130: 2864 6174 616e 616d 6529 2c74 6172 6765  (dataname),targe
-00008140: 7429 0a20 2020 2065 6c73 653a 0a20 2020  t).    else:.   
-00008150: 2020 2020 2023 2323 2054 6172 6765 7420       ### Target 
-00008160: 6973 2061 206c 6973 7420 6f72 204e 6f6e  is a list or Non
-00008170: 6520 2323 2323 2323 2323 2323 2323 0a20  e ############. 
-00008180: 2020 2020 2020 2069 6620 7461 7267 6574         if target
-00008190: 2069 7320 4e6f 6e65 206f 7220 6c65 6e28   is None or len(
-000081a0: 7461 7267 6574 2920 3d3d 2030 3a0a 2020  target) == 0:.  
-000081b0: 2020 2020 2020 2020 2020 636f 6c73 5f6c            cols_l
-000081c0: 6973 7420 3d20 6c69 7374 2864 6174 616e  ist = list(datan
-000081d0: 616d 6529 0a20 2020 2020 2020 2020 2020  ame).           
-000081e0: 2073 6574 7469 6e67 732e 6d6f 6465 6c74   settings.modelt
-000081f0: 7970 6520 3d20 2743 6c75 7374 6572 696e  ype = 'Clusterin
-00008200: 6727 0a20 2020 2020 2020 2020 2020 2070  g'.            p
-00008210: 7269 6e74 2827 6665 6174 7572 6577 697a  rint('featurewiz
-00008220: 2064 6f65 7320 6e6f 7420 776f 726b 206f   does not work o
-00008230: 6e20 636c 7573 7465 7269 6e67 206f 7220  n clustering or 
-00008240: 756e 7375 7065 7276 6973 6564 2070 726f  unsupervised pro
-00008250: 626c 656d 732e 2052 6574 7572 6e69 6e67  blems. Returning
-00008260: 2e2e 2e27 290a 2020 2020 2020 2020 2020  ...').          
-00008270: 2020 7265 7475 726e 206f 6c64 5f63 6f6c    return old_col
-00008280: 5f6e 616d 6573 2c20 6461 7461 6e61 6d65  _names, dataname
-00008290: 0a20 2020 2020 2020 2065 6c73 653a 0a20  .        else:. 
-000082a0: 2020 2020 2020 2020 2020 2073 6574 7469             setti
-000082b0: 6e67 732e 6d6f 6465 6c74 7970 652c 205f  ngs.modeltype, _
-000082c0: 203d 2061 6e61 6c79 7a65 5f70 726f 626c   = analyze_probl
-000082d0: 656d 5f74 7970 6528 6461 7461 6e61 6d65  em_type(dataname
-000082e0: 5b74 6172 6765 745d 2c20 7461 7267 6574  [target], target
-000082f0: 290a 2020 2020 2020 2020 2020 2020 636f  ).            co
-00008300: 6c73 5f6c 6973 7420 3d20 6c65 6674 5f73  ls_list = left_s
-00008310: 7562 7472 6163 7428 6c69 7374 2864 6174  ubtract(list(dat
-00008320: 616e 616d 6529 2c74 6172 6765 7429 0a0a  aname),target)..
-00008330: 2020 2020 2323 2323 2323 2323 2323 2323      ############
-00008340: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00008350: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00008360: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00008370: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00008380: 2323 2323 2323 2323 2323 0a20 2020 2023  ##########.    #
+00007390: 2074 7261 696e 203d 206c 6f61 645f 6461   train = load_da
+000073a0: 736b 5f64 6174 6128 6461 7461 6e61 6d65  sk_data(dataname
+000073b0: 2c20 7365 7029 0a20 2020 2020 2020 2020  , sep).         
+000073c0: 2020 2020 2020 2065 7863 6570 743a 0a20         except:. 
+000073d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000073e0: 2020 2070 7269 6e74 2827 4669 6c65 2063     print('File c
+000073f0: 6f75 6c64 206e 6f74 2062 6520 6c6f 6164  ould not be load
+00007400: 6564 2069 6e74 6f20 6461 736b 2e20 4368  ed into dask. Ch
+00007410: 6563 6b20 7468 6520 7061 7468 206f 7220  eck the path or 
+00007420: 6669 6c65 6e61 6d65 2061 6e64 2074 7279  filename and try
+00007430: 2061 6761 696e 2729 0a20 2020 2020 2020   again').       
+00007440: 2020 2020 2020 2020 2020 2020 2072 6574               ret
+00007450: 7572 6e20 4e6f 6e65 0a20 2020 2020 2020  urn None.       
+00007460: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+00007470: 2020 2020 2020 2020 2020 2023 2323 2320             #### 
+00007480: 5468 6572 6520 6973 206e 6f20 6461 736b  There is no dask
+00007490: 2066 6c61 6720 736f 206c 6f61 6420 6974   flag so load it
+000074a0: 2069 6e74 6f20 6120 7265 6775 6c61 7220   into a regular 
+000074b0: 7061 6e64 6173 2064 6174 6166 7261 6d65  pandas dataframe
+000074c0: 2023 2323 230a 2020 2020 2020 2020 2020   ####.          
+000074d0: 2020 2020 2020 7472 6169 6e20 3d20 6c6f        train = lo
+000074e0: 6164 5f66 696c 655f 6461 7461 6672 616d  ad_file_datafram
+000074f0: 6528 6461 7461 6e61 6d65 2c20 7365 703d  e(dataname, sep=
+00007500: 7365 702c 2068 6561 6465 723d 6865 6164  sep, header=head
+00007510: 6572 2c20 7665 7262 6f73 653d 7665 7262  er, verbose=verb
+00007520: 6f73 652c 200a 2020 2020 2020 2020 2020  ose, .          
+00007530: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00007540: 2020 2020 2020 2020 2020 6e72 6f77 733d            nrows=
+00007550: 6e72 6f77 732c 2074 6172 6765 743d 7461  nrows, target=ta
+00007560: 7267 6574 290a 2020 2020 2020 2020 2020  rget).          
+00007570: 2020 2020 2020 6966 2028 7472 6169 6e2e        if (train.
+00007580: 6d65 6d6f 7279 5f75 7361 6765 2829 2e73  memory_usage().s
+00007590: 756d 2829 2f31 3030 3030 3030 2920 3e20  um()/1000000) > 
+000075a0: 6d65 6d5f 6c69 6d69 743a 0a20 2020 2020  mem_limit:.     
+000075b0: 2020 2020 2020 2020 2020 2020 2020 2064                 d
+000075c0: 6174 616e 616d 6520 3d20 7265 6475 6365  ataname = reduce
+000075d0: 5f6d 656d 5f75 7361 6765 2874 7261 696e  _mem_usage(train
+000075e0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+000075f0: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+00007600: 2020 2020 2020 2020 2020 2020 6461 7461              data
+00007610: 6e61 6d65 203d 2063 6f70 792e 6465 6570  name = copy.deep
+00007620: 636f 7079 2874 7261 696e 290a 2020 2020  copy(train).    
+00007630: 656c 7365 3a0a 2020 2020 2020 2020 2323  else:.        ##
+00007640: 2323 2054 6869 7320 6973 2077 6865 7265  ## This is where
+00007650: 2077 6520 6765 7420 6120 6461 7461 6672   we get a datafr
+00007660: 616d 6520 6173 2061 6e20 696e 7075 7420  ame as an input 
+00007670: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00007680: 230a 2020 2020 2020 2020 6966 2064 6173  #.        if das
+00007690: 6b5f 7867 626f 6f73 745f 666c 6167 3a0a  k_xgboost_flag:.
+000076a0: 2020 2020 2020 2020 2020 2020 6966 206e              if n
+000076b0: 6f74 206e 726f 7773 2069 7320 4e6f 6e65  ot nrows is None
+000076c0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+000076d0: 2020 6461 7461 6e61 6d65 203d 2064 6174    dataname = dat
+000076e0: 616e 616d 652e 7361 6d70 6c65 286e 3d6e  aname.sample(n=n
+000076f0: 726f 7773 2c20 7265 706c 6163 653d 5472  rows, replace=Tr
+00007700: 7565 2c20 7261 6e64 6f6d 5f73 7461 7465  ue, random_state
+00007710: 3d39 3939 3929 0a20 2020 2020 2020 2020  =9999).         
+00007720: 2020 2020 2020 2070 7269 6e74 2827 5361         print('Sa
+00007730: 6d70 6c69 6e67 2025 7320 726f 7773 2066  mpling %s rows f
+00007740: 726f 6d20 6461 7461 6672 616d 6520 6769  rom dataframe gi
+00007750: 7665 6e27 2025 6e72 6f77 7329 0a20 2020  ven' %nrows).   
+00007760: 2020 2020 2020 2020 2070 7269 6e74 2827           print('
+00007770: 2020 2020 5369 6e63 6520 6461 736b 5f78      Since dask_x
+00007780: 6762 6f6f 7374 5f66 6c61 6720 6973 2054  gboost_flag is T
+00007790: 7275 652c 2072 6564 7563 696e 6720 6d65  rue, reducing me
+000077a0: 6d6f 7279 2073 697a 6520 616e 6420 6c6f  mory size and lo
+000077b0: 6164 696e 6720 696e 746f 2064 6173 6b27  ading into dask'
+000077c0: 290a 2020 2020 2020 2020 2020 2020 6966  ).            if
+000077d0: 2028 6461 7461 6e61 6d65 2e6d 656d 6f72   (dataname.memor
+000077e0: 795f 7573 6167 6528 292e 7375 6d28 292f  y_usage().sum()/
+000077f0: 3130 3030 3030 3029 203e 206d 656d 5f6c  1000000) > mem_l
+00007800: 696d 6974 3a0a 2020 2020 2020 2020 2020  imit:.          
+00007810: 2020 2020 2020 6461 7461 6e61 6d65 203d        dataname =
+00007820: 2072 6564 7563 655f 6d65 6d5f 7573 6167   reduce_mem_usag
+00007830: 6528 6461 7461 6e61 6d65 290a 2020 2020  e(dataname).    
+00007840: 2020 2020 2020 2020 7472 6169 6e20 3d20          train = 
+00007850: 6c6f 6164 5f64 6173 6b5f 6461 7461 2864  load_dask_data(d
+00007860: 6174 616e 616d 652c 2073 6570 290a 2020  ataname, sep).  
+00007870: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
+00007880: 2020 2020 2020 2020 7472 6169 6e20 3d20          train = 
+00007890: 6c6f 6164 5f66 696c 655f 6461 7461 6672  load_file_datafr
+000078a0: 616d 6528 6461 7461 6e61 6d65 2c20 7365  ame(dataname, se
+000078b0: 703d 7365 702c 2068 6561 6465 723d 6865  p=sep, header=he
+000078c0: 6164 6572 2c20 7665 7262 6f73 653d 7665  ader, verbose=ve
+000078d0: 7262 6f73 652c 200a 2020 2020 2020 2020  rbose, .        
+000078e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000078f0: 2020 2020 6e72 6f77 733d 6e72 6f77 732c      nrows=nrows,
+00007900: 2074 6172 6765 743d 7461 7267 6574 290a   target=target).
+00007910: 2020 2020 2020 2020 2020 2020 6966 2028              if (
+00007920: 7472 6169 6e2e 6d65 6d6f 7279 5f75 7361  train.memory_usa
+00007930: 6765 2829 2e73 756d 2829 2f31 3030 3030  ge().sum()/10000
+00007940: 3030 2920 3e20 6d65 6d5f 6c69 6d69 743a  00) > mem_limit:
+00007950: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00007960: 2064 6174 616e 616d 6520 3d20 7265 6475   dataname = redu
+00007970: 6365 5f6d 656d 5f75 7361 6765 2874 7261  ce_mem_usage(tra
+00007980: 696e 290a 2020 2020 2020 2020 2020 2020  in).            
+00007990: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
+000079a0: 2020 2020 2020 6461 7461 6e61 6d65 203d        dataname =
+000079b0: 2063 6f70 792e 6465 6570 636f 7079 2874   copy.deepcopy(t
+000079c0: 7261 696e 290a 2020 2020 7072 696e 7428  rain).    print(
+000079d0: 2720 2020 204c 6f61 6465 6420 7472 6169  '    Loaded trai
+000079e0: 6e20 6461 7461 2e20 5368 6170 6520 3d20  n data. Shape = 
+000079f0: 2573 2720 2528 6461 7461 6e61 6d65 2e73  %s' %(dataname.s
+00007a00: 6861 7065 2c29 290a 2020 2020 2323 2323  hape,)).    ####
+00007a10: 2323 2323 2323 2323 2323 2323 2323 2020  ##############  
+00007a20: 2020 4c20 4f20 4120 4420 2020 2054 2045    L O A D    T E
+00007a30: 2053 2054 2020 2044 2041 2054 2041 2020   S T   D A T A  
+00007a40: 2020 2020 2323 2323 2323 2323 2323 2323      ############
+00007a50: 2323 2323 2323 2323 2323 0a20 2020 2064  ##########.    d
+00007a60: 6174 616e 616d 6520 3d20 7265 6d6f 7665  ataname = remove
+00007a70: 5f64 7570 6c69 6361 7465 5f63 6f6c 735f  _duplicate_cols_
+00007a80: 696e 5f64 6174 6173 6574 2864 6174 616e  in_dataset(datan
+00007a90: 616d 6529 0a20 0a20 2020 2023 2323 2320  ame). .    #### 
+00007aa0: 436f 6e76 6572 7420 6d69 7865 6420 6461  Convert mixed da
+00007ab0: 7461 2074 7970 6573 2074 6f20 7374 7269  ta types to stri
+00007ac0: 6e67 2064 6174 6120 7479 7065 2020 2323  ng data type  ##
+00007ad0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00007ae0: 2323 2323 2323 2323 2323 0a20 2020 2023  ##########.    #
+00007af0: 6461 7461 6e61 6d65 203d 2046 455f 636f  dataname = FE_co
+00007b00: 6e76 6572 745f 6d69 7865 645f 6461 7461  nvert_mixed_data
+00007b10: 7479 7065 735f 746f 5f73 7472 696e 6728  types_to_string(
+00007b20: 6461 7461 6e61 6d65 290a 2020 2020 0a20  dataname).    . 
+00007b30: 2020 2023 2323 2323 2320 2020 5847 426f     ######   XGBo
+00007b40: 6f73 7420 6361 6e6e 6f74 2068 616e 646c  ost cannot handl
+00007b50: 6520 7370 6563 6961 6c20 6368 6172 7320  e special chars 
+00007b60: 696e 2063 6f6c 756d 6e20 6e61 6d65 7320  in column names 
+00007b70: 2323 2323 2323 2323 2323 230a 2020 2020  ###########.    
+00007b80: 756e 6971 203d 2043 6f6c 756d 6e5f 4e61  uniq = Column_Na
+00007b90: 6d65 735f 5472 616e 7366 6f72 6d65 7228  mes_Transformer(
+00007ba0: 290a 2020 2020 6461 7461 6e61 6d65 203d  ).    dataname =
+00007bb0: 2075 6e69 712e 6669 745f 7472 616e 7366   uniq.fit_transf
+00007bc0: 6f72 6d28 6461 7461 6e61 6d65 290a 2020  orm(dataname).  
+00007bd0: 2020 6e65 775f 636f 6c5f 6e61 6d65 7320    new_col_names 
+00007be0: 3d20 756e 6971 2e6e 6577 5f63 6f6c 756d  = uniq.new_colum
+00007bf0: 6e5f 6e61 6d65 730a 2020 2020 6f6c 645f  n_names.    old_
+00007c00: 636f 6c5f 6e61 6d65 7320 3d20 756e 6971  col_names = uniq
+00007c10: 2e6f 6c64 5f63 6f6c 756d 6e5f 6e61 6d65  .old_column_name
+00007c20: 730a 2020 2020 7370 6563 6961 6c5f 6368  s.    special_ch
+00007c30: 6172 5f66 6c61 6720 3d20 756e 6971 2e74  ar_flag = uniq.t
+00007c40: 7261 6e73 666f 726d 6564 5f66 6c61 670a  ransformed_flag.
+00007c50: 0a20 2020 2023 2323 2053 7570 706f 7365  .    ### Suppose
+00007c60: 2079 6f75 2068 6176 6520 6368 616e 6765   you have change
+00007c70: 6420 7468 6520 6e61 6d65 732c 2074 6865  d the names, the
+00007c80: 6e6e 2079 6f75 206d 7573 7420 6c6f 6164  nn you must load
+00007c90: 2069 7420 696e 2064 6173 6b20 6167 6169   it in dask agai
+00007ca0: 6e20 2323 2020 2020 0a20 2020 2069 6620  n ##    .    if 
+00007cb0: 7370 6563 6961 6c5f 6368 6172 5f66 6c61  special_char_fla
+00007cc0: 673a 0a20 2020 2020 2020 2069 6620 6461  g:.        if da
+00007cd0: 736b 5f78 6762 6f6f 7374 5f66 6c61 673a  sk_xgboost_flag:
+00007ce0: 0a20 2020 2020 2020 2020 2020 2074 7261  .            tra
+00007cf0: 696e 203d 206c 6f61 645f 6461 736b 5f64  in = load_dask_d
+00007d00: 6174 6128 6461 7461 6e61 6d65 2c20 7365  ata(dataname, se
+00007d10: 7029 0a0a 2020 2020 2323 2323 2323 204e  p)..    ###### N
+00007d20: 6f77 2073 6176 6520 7468 6520 6f6c 6420  ow save the old 
+00007d30: 616e 6420 6e65 7720 636f 6c75 6d6e 7320  and new columns 
+00007d40: 696e 2061 2064 6963 7469 6f6e 6172 7920  in a dictionary 
+00007d50: 746f 2075 7365 2074 6865 6d20 6c61 7465  to use them late
+00007d60: 7220 2323 230a 2020 2020 636f 6c5f 6e61  r ###.    col_na
+00007d70: 6d65 5f6d 6170 7065 7220 3d20 6469 6374  me_mapper = dict
+00007d80: 287a 6970 286e 6577 5f63 6f6c 5f6e 616d  (zip(new_col_nam
+00007d90: 6573 2c20 6f6c 645f 636f 6c5f 6e61 6d65  es, old_col_name
+00007da0: 7329 290a 2020 2020 636f 6c5f 6e61 6d65  s)).    col_name
+00007db0: 5f72 6570 6c61 6365 7220 3d20 7b79 3a20  _replacer = {y: 
+00007dc0: 7820 666f 7220 2878 2c20 7929 2069 6e20  x for (x, y) in 
+00007dd0: 636f 6c5f 6e61 6d65 5f6d 6170 7065 722e  col_name_mapper.
+00007de0: 6974 656d 7328 297d 0a20 2020 2069 7465  items()}.    ite
+00007df0: 6d5f 7265 706c 6163 6572 203d 2063 6f6c  m_replacer = col
+00007e00: 5f6e 616d 655f 7265 706c 6163 6572 2e67  _name_replacer.g
+00007e10: 6574 2020 2320 466f 7220 6661 7374 6572  et  # For faster
+00007e20: 2067 6574 732e 0a0a 2020 2020 2323 2323   gets...    ####
+00007e30: 2059 6f75 206e 6565 6420 746f 2063 6861   You need to cha
+00007e40: 6e67 6520 7468 6520 7461 7267 6574 206e  nge the target n
+00007e50: 616d 6520 6966 2079 6f75 2068 6176 6520  ame if you have 
+00007e60: 6368 616e 6765 6420 7468 6520 636f 6c75  changed the colu
+00007e70: 6d6e 206e 616d 6573 2023 2323 200a 2020  mn names ### .  
+00007e80: 2020 6966 2073 7065 6369 616c 5f63 6861    if special_cha
+00007e90: 725f 666c 6167 3a0a 2020 2020 2020 2020  r_flag:.        
+00007ea0: 6966 2069 7369 6e73 7461 6e63 6528 7461  if isinstance(ta
+00007eb0: 7267 6574 2c20 7374 7229 3a0a 2020 2020  rget, str):.    
+00007ec0: 2020 2020 2020 2020 7461 7267 6574 7320          targets 
+00007ed0: 3d20 5b74 6172 6765 745d 0a20 2020 2020  = [target].     
+00007ee0: 2020 2020 2020 2074 6172 6765 7473 203d         targets =
+00007ef0: 205b 6974 656d 5f72 6570 6c61 6365 7228   [item_replacer(
+00007f00: 6e2c 206e 2920 666f 7220 6e20 696e 2074  n, n) for n in t
+00007f10: 6172 6765 7473 5d0a 2020 2020 2020 2020  argets].        
+00007f20: 2020 2020 7461 7267 6574 203d 2074 6172      target = tar
+00007f30: 6765 7473 5b30 5d0a 2020 2020 2020 2020  gets[0].        
+00007f40: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
+00007f50: 2020 7461 7267 6574 7320 3d20 636f 7079    targets = copy
+00007f60: 2e64 6565 7063 6f70 7928 7461 7267 6574  .deepcopy(target
+00007f70: 290a 2020 2020 2020 2020 2020 2020 7461  ).            ta
+00007f80: 7267 6574 203d 205b 6974 656d 5f72 6570  rget = [item_rep
+00007f90: 6c61 6365 7228 6e2c 206e 2920 666f 7220  lacer(n, n) for 
+00007fa0: 6e20 696e 2074 6172 6765 7473 5d0a 0a20  n in targets].. 
+00007fb0: 2020 2074 7261 696e 5f69 6e64 6578 203d     train_index =
+00007fc0: 2064 6174 616e 616d 652e 696e 6465 780a   dataname.index.
+00007fd0: 2020 2020 0a20 2020 2069 6620 6973 696e      .    if isin
+00007fe0: 7374 616e 6365 2874 6172 6765 742c 2073  stance(target, s
+00007ff0: 7472 293a 0a20 2020 2020 2020 2069 6620  tr):.        if 
+00008000: 6c65 6e28 7461 7267 6574 2920 3d3d 2030  len(target) == 0
+00008010: 3a0a 2020 2020 2020 2020 2020 2020 636f  :.            co
+00008020: 6c73 5f6c 6973 7420 3d20 6c69 7374 2864  ls_list = list(d
+00008030: 6174 616e 616d 6529 0a20 2020 2020 2020  ataname).       
+00008040: 2020 2020 2073 6574 7469 6e67 732e 6d6f       settings.mo
+00008050: 6465 6c74 7970 6520 3d20 2743 6c75 7374  deltype = 'Clust
+00008060: 6572 696e 6727 0a20 2020 2020 2020 2020  ering'.         
+00008070: 2020 2070 7269 6e74 2827 6665 6174 7572     print('featur
+00008080: 6577 697a 2064 6f65 7320 6e6f 7420 776f  ewiz does not wo
+00008090: 726b 206f 6e20 636c 7573 7465 7269 6e67  rk on clustering
+000080a0: 206f 7220 756e 7375 7065 7276 6973 6564   or unsupervised
+000080b0: 2070 726f 626c 656d 732e 2052 6574 7572   problems. Retur
+000080c0: 6e69 6e67 2e2e 2e27 290a 2020 2020 2020  ning...').      
+000080d0: 2020 2020 2020 7265 7475 726e 206f 6c64        return old
+000080e0: 5f63 6f6c 5f6e 616d 6573 2c20 6461 7461  _col_names, data
+000080f0: 6e61 6d65 0a20 2020 2020 2020 2065 6c73  name.        els
+00008100: 653a 0a20 2020 2020 2020 2020 2020 2073  e:.            s
+00008110: 6574 7469 6e67 732e 6d6f 6465 6c74 7970  ettings.modeltyp
+00008120: 652c 205f 203d 2061 6e61 6c79 7a65 5f70  e, _ = analyze_p
+00008130: 726f 626c 656d 5f74 7970 6528 6461 7461  roblem_type(data
+00008140: 6e61 6d65 5b74 6172 6765 745d 2c20 7461  name[target], ta
+00008150: 7267 6574 290a 2020 2020 2020 2020 2020  rget).          
+00008160: 2020 636f 6c73 5f6c 6973 7420 3d20 6c65    cols_list = le
+00008170: 6674 5f73 7562 7472 6163 7428 6c69 7374  ft_subtract(list
+00008180: 2864 6174 616e 616d 6529 2c74 6172 6765  (dataname),targe
+00008190: 7429 0a20 2020 2065 6c73 653a 0a20 2020  t).    else:.   
+000081a0: 2020 2020 2023 2323 2054 6172 6765 7420       ### Target 
+000081b0: 6973 2061 206c 6973 7420 6f72 204e 6f6e  is a list or Non
+000081c0: 6520 2323 2323 2323 2323 2323 2323 0a20  e ############. 
+000081d0: 2020 2020 2020 2069 6620 7461 7267 6574         if target
+000081e0: 2069 7320 4e6f 6e65 206f 7220 6c65 6e28   is None or len(
+000081f0: 7461 7267 6574 2920 3d3d 2030 3a0a 2020  target) == 0:.  
+00008200: 2020 2020 2020 2020 2020 636f 6c73 5f6c            cols_l
+00008210: 6973 7420 3d20 6c69 7374 2864 6174 616e  ist = list(datan
+00008220: 616d 6529 0a20 2020 2020 2020 2020 2020  ame).           
+00008230: 2073 6574 7469 6e67 732e 6d6f 6465 6c74   settings.modelt
+00008240: 7970 6520 3d20 2743 6c75 7374 6572 696e  ype = 'Clusterin
+00008250: 6727 0a20 2020 2020 2020 2020 2020 2070  g'.            p
+00008260: 7269 6e74 2827 6665 6174 7572 6577 697a  rint('featurewiz
+00008270: 2064 6f65 7320 6e6f 7420 776f 726b 206f   does not work o
+00008280: 6e20 636c 7573 7465 7269 6e67 206f 7220  n clustering or 
+00008290: 756e 7375 7065 7276 6973 6564 2070 726f  unsupervised pro
+000082a0: 626c 656d 732e 2052 6574 7572 6e69 6e67  blems. Returning
+000082b0: 2e2e 2e27 290a 2020 2020 2020 2020 2020  ...').          
+000082c0: 2020 7265 7475 726e 206f 6c64 5f63 6f6c    return old_col
+000082d0: 5f6e 616d 6573 2c20 6461 7461 6e61 6d65  _names, dataname
+000082e0: 0a20 2020 2020 2020 2065 6c73 653a 0a20  .        else:. 
+000082f0: 2020 2020 2020 2020 2020 2073 6574 7469             setti
+00008300: 6e67 732e 6d6f 6465 6c74 7970 652c 205f  ngs.modeltype, _
+00008310: 203d 2061 6e61 6c79 7a65 5f70 726f 626c   = analyze_probl
+00008320: 656d 5f74 7970 6528 6461 7461 6e61 6d65  em_type(dataname
+00008330: 5b74 6172 6765 745d 2c20 7461 7267 6574  [target], target
+00008340: 290a 2020 2020 2020 2020 2020 2020 636f  ).            co
+00008350: 6c73 5f6c 6973 7420 3d20 6c65 6674 5f73  ls_list = left_s
+00008360: 7562 7472 6163 7428 6c69 7374 2864 6174  ubtract(list(dat
+00008370: 616e 616d 6529 2c74 6172 6765 7429 0a0a  aname),target)..
+00008380: 2020 2020 2323 2323 2323 2323 2323 2323      ############
 00008390: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000083a0: 2320 2020 204c 204f 2041 2044 2020 2020  #    L O A D    
-000083b0: 2020 5420 4520 5320 5420 2020 2020 4420    T E S T     D 
-000083c0: 4120 5420 4120 2020 2323 2323 2323 2323  A T A   ########
-000083d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000083e0: 2323 2323 230a 2020 2020 2323 2323 2323  #####.    ######
-000083f0: 2323 2323 2020 2074 6573 745f 6461 7461  ####   test_data
-00008400: 2077 696c 6c20 6265 2074 6865 206e 616d   will be the nam
-00008410: 6520 6f66 2074 6865 2070 616e 6461 7320  e of the pandas 
-00008420: 7665 7273 696f 6e20 6f66 2074 6573 7420  version of test 
-00008430: 6461 7461 2020 2020 2020 2323 2323 230a  data      #####.
-00008440: 2020 2020 2323 2323 2323 2323 2323 2020      ##########  
-00008450: 2074 6573 7420 7769 6c6c 2062 6520 7468   test will be th
-00008460: 6520 6e61 6d65 206f 6620 7468 6520 6461  e name of the da
-00008470: 736b 2064 6174 6166 7261 6d65 2076 6572  sk dataframe ver
-00008480: 7369 6f6e 206f 6620 7465 7374 2064 6174  sion of test dat
-00008490: 6120 2020 2323 2323 230a 2020 2020 2323  a   #####.    ##
-000084a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000084b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000084c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000084d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000084e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000084f0: 2323 2323 0a20 2020 2069 6620 6973 696e  ####.    if isin
-00008500: 7374 616e 6365 2874 6573 745f 6461 7461  stance(test_data
-00008510: 2c20 7374 7229 3a0a 2020 2020 2020 2020  , str):.        
-00008520: 6966 2074 6573 745f 6461 7461 2021 3d20  if test_data != 
-00008530: 2727 3a0a 2020 2020 2020 2020 2020 2020  '':.            
-00008540: 6966 2072 652e 7365 6172 6368 2872 2728  if re.search(r'(
-00008550: 2e66 7472 2927 2c20 7465 7374 5f64 6174  .ftr)', test_dat
-00008560: 6129 3a0a 2020 2020 2020 2020 2020 2020  a):.            
-00008570: 2020 2020 7072 696e 7428 2222 222a 2a49      print("""**I
-00008580: 4e46 4f3a 2046 6561 7468 6572 2066 6f72  NFO: Feather for
-00008590: 6d61 7420 616c 6c6f 7765 642e 204c 6f61  mat allowed. Loa
-000085a0: 6469 6e67 2066 6561 7468 6572 2066 696c  ding feather fil
-000085b0: 652e 2e2e 2a2a 2222 2229 0a20 2020 2020  e...**""").     
-000085c0: 2020 2020 2020 2020 2020 2069 6d70 6f72             impor
-000085d0: 7420 6665 6174 6865 720a 2020 2020 2020  t feather.      
-000085e0: 2020 2020 2020 2020 2020 7465 7374 5f64            test_d
-000085f0: 6174 6120 3d20 7064 2e72 6561 645f 6665  ata = pd.read_fe
-00008600: 6174 6865 7228 7465 7374 5f64 6174 612c  ather(test_data,
-00008610: 2075 7365 5f74 6872 6561 6473 3d54 7275   use_threads=Tru
-00008620: 6529 0a20 2020 2020 2020 2020 2020 2020  e).             
-00008630: 2020 2074 6573 7420 3d20 6c6f 6164 5f64     test = load_d
-00008640: 6173 6b5f 6461 7461 2874 6573 745f 6461  ask_data(test_da
-00008650: 7461 2c20 7365 7029 0a20 2020 2020 2020  ta, sep).       
-00008660: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
-00008670: 2020 2020 2020 2020 2020 2069 6620 7665             if ve
-00008680: 7262 6f73 653a 0a20 2020 2020 2020 2020  rbose:.         
-00008690: 2020 2020 2020 2020 2020 2070 7269 6e74             print
-000086a0: 2822 2222 2a2a 494e 464f 3a20 746f 2069  ("""**INFO: to i
-000086b0: 6e63 7265 6173 6520 6669 6c65 206c 6f61  ncrease file loa
-000086c0: 6469 6e67 2070 6572 666f 726d 616e 6365  ding performance
-000086d0: 2c20 636f 6e76 6572 7420 6875 6765 2060  , convert huge `
-000086e0: 6373 7660 2066 696c 6573 2074 6f20 6066  csv` files to `f
-000086f0: 6561 7468 6572 6020 666f 726d 6174 2075  eather` format u
-00008700: 7369 6e67 2060 6466 2e74 6f5f 6665 6174  sing `df.to_feat
-00008710: 6865 7228 2270 6174 682f 746f 2f73 6176  her("path/to/sav
-00008720: 652f 6669 6c65 2e66 6561 7468 6572 2229  e/file.feather")
-00008730: 602a 2a22 2222 290a 2020 2020 2020 2020  `**""").        
-00008740: 2020 2020 2020 2020 2020 2020 7072 696e              prin
-00008750: 7428 272a 2a49 4e46 4f3a 2066 6561 7475  t('**INFO: featu
-00008760: 7265 7769 7a20 6361 6e20 6e6f 7720 7265  rewiz can now re
-00008770: 6164 2066 6561 7468 6572 2066 6f72 6d61  ad feather forma
-00008780: 7474 6564 2066 696c 6573 2e2e 2e2a 2a2a  tted files...***
-00008790: 2729 0a20 2020 2020 2020 2020 2020 2020  ').             
-000087a0: 2020 2023 2323 206f 6e6c 7920 6966 2074     ### only if t
-000087b0: 6573 745f 6461 7461 2069 7320 6120 6669  est_data is a fi
-000087c0: 6c65 6e61 6d65 206c 6f61 6420 7468 6973  lename load this
-000087d0: 2023 2323 2323 0a20 2020 2020 2020 2020   #####.         
-000087e0: 2020 2020 2020 2070 7269 6e74 2827 4c6f         print('Lo
-000087f0: 6164 696e 6720 7465 7374 2064 6174 6120  ading test data 
-00008800: 6669 6c65 6e61 6d65 203d 2025 732e 2e2e  filename = %s...
-00008810: 2720 2574 6573 745f 6461 7461 290a 2020  ' %test_data).  
-00008820: 2020 2020 2020 2020 2020 2020 2020 6966                if
-00008830: 2064 6173 6b5f 7867 626f 6f73 745f 666c   dask_xgboost_fl
-00008840: 6167 3a0a 2020 2020 2020 2020 2020 2020  ag:.            
-00008850: 2020 2020 2020 2020 7072 696e 7428 2720          print(' 
-00008860: 2020 2053 696e 6365 2064 6173 6b5f 7867     Since dask_xg
-00008870: 626f 6f73 745f 666c 6167 2069 7320 5472  boost_flag is Tr
-00008880: 7565 2c20 7265 6475 6369 6e67 206d 656d  ue, reducing mem
-00008890: 6f72 7920 7369 7a65 2061 6e64 206c 6f61  ory size and loa
-000088a0: 6469 6e67 2069 6e74 6f20 6461 736b 2729  ding into dask')
-000088b0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000088c0: 2020 2020 2023 2323 206e 726f 7773 2064       ### nrows d
-000088d0: 6f65 7320 6e6f 7420 6170 706c 7920 746f  oes not apply to
-000088e0: 2074 6573 7420 6461 7461 2069 6e20 7468   test data in th
-000088f0: 6520 6361 7365 206f 6620 6665 6174 7572  e case of featur
-00008900: 6577 697a 2023 2323 2323 2323 2323 2323  ewiz ###########
-00008910: 2323 2323 0a20 2020 2020 2020 2020 2020  ####.           
-00008920: 2020 2020 2020 2020 2074 6573 745f 6461           test_da
-00008930: 7461 203d 206c 6f61 645f 6669 6c65 5f64  ta = load_file_d
-00008940: 6174 6166 7261 6d65 2874 6573 745f 6461  ataframe(test_da
-00008950: 7461 2c20 7365 703d 7365 702c 2068 6561  ta, sep=sep, hea
-00008960: 6465 723d 6865 6164 6572 2c20 7665 7262  der=header, verb
-00008970: 6f73 653d 7665 7262 6f73 652c 0a20 2020  ose=verbose,.   
-00008980: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008990: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000089a0: 2020 6e72 6f77 733d 4e6f 6e65 2c20 7461    nrows=None, ta
-000089b0: 7267 6574 3d73 6574 7469 6e67 732e 6d6f  rget=settings.mo
-000089c0: 6465 6c74 7970 652c 2069 735f 7465 7374  deltype, is_test
-000089d0: 5f66 6c61 673d 5472 7565 290a 2020 2020  _flag=True).    
+000083a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000083b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000083c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000083d0: 2323 2323 2323 2323 2323 0a20 2020 2023  ##########.    #
+000083e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000083f0: 2320 2020 204c 204f 2041 2044 2020 2020  #    L O A D    
+00008400: 2020 5420 4520 5320 5420 2020 2020 4420    T E S T     D 
+00008410: 4120 5420 4120 2020 2323 2323 2323 2323  A T A   ########
+00008420: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00008430: 2323 2323 230a 2020 2020 2323 2323 2323  #####.    ######
+00008440: 2323 2323 2020 2074 6573 745f 6461 7461  ####   test_data
+00008450: 2077 696c 6c20 6265 2074 6865 206e 616d   will be the nam
+00008460: 6520 6f66 2074 6865 2070 616e 6461 7320  e of the pandas 
+00008470: 7665 7273 696f 6e20 6f66 2074 6573 7420  version of test 
+00008480: 6461 7461 2020 2020 2020 2323 2323 230a  data      #####.
+00008490: 2020 2020 2323 2323 2323 2323 2323 2020      ##########  
+000084a0: 2074 6573 7420 7769 6c6c 2062 6520 7468   test will be th
+000084b0: 6520 6e61 6d65 206f 6620 7468 6520 6461  e name of the da
+000084c0: 736b 2064 6174 6166 7261 6d65 2076 6572  sk dataframe ver
+000084d0: 7369 6f6e 206f 6620 7465 7374 2064 6174  sion of test dat
+000084e0: 6120 2020 2323 2323 230a 2020 2020 2323  a   #####.    ##
+000084f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00008500: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00008510: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00008520: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00008530: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00008540: 2323 2323 0a20 2020 2069 6620 6973 696e  ####.    if isin
+00008550: 7374 616e 6365 2874 6573 745f 6461 7461  stance(test_data
+00008560: 2c20 7374 7229 3a0a 2020 2020 2020 2020  , str):.        
+00008570: 6966 2074 6573 745f 6461 7461 2021 3d20  if test_data != 
+00008580: 2727 3a0a 2020 2020 2020 2020 2020 2020  '':.            
+00008590: 6966 2072 652e 7365 6172 6368 2872 2728  if re.search(r'(
+000085a0: 2e66 7472 2927 2c20 7465 7374 5f64 6174  .ftr)', test_dat
+000085b0: 6129 3a0a 2020 2020 2020 2020 2020 2020  a):.            
+000085c0: 2020 2020 7072 696e 7428 2222 222a 2a49      print("""**I
+000085d0: 4e46 4f3a 2046 6561 7468 6572 2066 6f72  NFO: Feather for
+000085e0: 6d61 7420 616c 6c6f 7765 642e 204c 6f61  mat allowed. Loa
+000085f0: 6469 6e67 2066 6561 7468 6572 2066 696c  ding feather fil
+00008600: 652e 2e2e 2a2a 2222 2229 0a20 2020 2020  e...**""").     
+00008610: 2020 2020 2020 2020 2020 2069 6d70 6f72             impor
+00008620: 7420 6665 6174 6865 720a 2020 2020 2020  t feather.      
+00008630: 2020 2020 2020 2020 2020 7465 7374 5f64            test_d
+00008640: 6174 6120 3d20 7064 2e72 6561 645f 6665  ata = pd.read_fe
+00008650: 6174 6865 7228 7465 7374 5f64 6174 612c  ather(test_data,
+00008660: 2075 7365 5f74 6872 6561 6473 3d54 7275   use_threads=Tru
+00008670: 6529 0a20 2020 2020 2020 2020 2020 2020  e).             
+00008680: 2020 2074 6573 7420 3d20 6c6f 6164 5f64     test = load_d
+00008690: 6173 6b5f 6461 7461 2874 6573 745f 6461  ask_data(test_da
+000086a0: 7461 2c20 7365 7029 0a20 2020 2020 2020  ta, sep).       
+000086b0: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+000086c0: 2020 2020 2020 2020 2020 2069 6620 7665             if ve
+000086d0: 7262 6f73 653a 0a20 2020 2020 2020 2020  rbose:.         
+000086e0: 2020 2020 2020 2020 2020 2070 7269 6e74             print
+000086f0: 2822 2222 2a2a 494e 464f 3a20 746f 2069  ("""**INFO: to i
+00008700: 6e63 7265 6173 6520 6669 6c65 206c 6f61  ncrease file loa
+00008710: 6469 6e67 2070 6572 666f 726d 616e 6365  ding performance
+00008720: 2c20 636f 6e76 6572 7420 6875 6765 2060  , convert huge `
+00008730: 6373 7660 2066 696c 6573 2074 6f20 6066  csv` files to `f
+00008740: 6561 7468 6572 6020 666f 726d 6174 2075  eather` format u
+00008750: 7369 6e67 2060 6466 2e74 6f5f 6665 6174  sing `df.to_feat
+00008760: 6865 7228 2270 6174 682f 746f 2f73 6176  her("path/to/sav
+00008770: 652f 6669 6c65 2e66 6561 7468 6572 2229  e/file.feather")
+00008780: 602a 2a22 2222 290a 2020 2020 2020 2020  `**""").        
+00008790: 2020 2020 2020 2020 2020 2020 7072 696e              prin
+000087a0: 7428 272a 2a49 4e46 4f3a 2066 6561 7475  t('**INFO: featu
+000087b0: 7265 7769 7a20 6361 6e20 6e6f 7720 7265  rewiz can now re
+000087c0: 6164 2066 6561 7468 6572 2066 6f72 6d61  ad feather forma
+000087d0: 7474 6564 2066 696c 6573 2e2e 2e2a 2a2a  tted files...***
+000087e0: 2729 0a20 2020 2020 2020 2020 2020 2020  ').             
+000087f0: 2020 2023 2323 206f 6e6c 7920 6966 2074     ### only if t
+00008800: 6573 745f 6461 7461 2069 7320 6120 6669  est_data is a fi
+00008810: 6c65 6e61 6d65 206c 6f61 6420 7468 6973  lename load this
+00008820: 2023 2323 2323 0a20 2020 2020 2020 2020   #####.         
+00008830: 2020 2020 2020 2070 7269 6e74 2827 4c6f         print('Lo
+00008840: 6164 696e 6720 7465 7374 2064 6174 6120  ading test data 
+00008850: 6669 6c65 6e61 6d65 203d 2025 732e 2e2e  filename = %s...
+00008860: 2720 2574 6573 745f 6461 7461 290a 2020  ' %test_data).  
+00008870: 2020 2020 2020 2020 2020 2020 2020 6966                if
+00008880: 2064 6173 6b5f 7867 626f 6f73 745f 666c   dask_xgboost_fl
+00008890: 6167 3a0a 2020 2020 2020 2020 2020 2020  ag:.            
+000088a0: 2020 2020 2020 2020 7072 696e 7428 2720          print(' 
+000088b0: 2020 2053 696e 6365 2064 6173 6b5f 7867     Since dask_xg
+000088c0: 626f 6f73 745f 666c 6167 2069 7320 5472  boost_flag is Tr
+000088d0: 7565 2c20 7265 6475 6369 6e67 206d 656d  ue, reducing mem
+000088e0: 6f72 7920 7369 7a65 2061 6e64 206c 6f61  ory size and loa
+000088f0: 6469 6e67 2069 6e74 6f20 6461 736b 2729  ding into dask')
+00008900: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00008910: 2020 2020 2023 2323 206e 726f 7773 2064       ### nrows d
+00008920: 6f65 7320 6e6f 7420 6170 706c 7920 746f  oes not apply to
+00008930: 2074 6573 7420 6461 7461 2069 6e20 7468   test data in th
+00008940: 6520 6361 7365 206f 6620 6665 6174 7572  e case of featur
+00008950: 6577 697a 2023 2323 2323 2323 2323 2323  ewiz ###########
+00008960: 2323 2323 0a20 2020 2020 2020 2020 2020  ####.           
+00008970: 2020 2020 2020 2020 2074 6573 745f 6461           test_da
+00008980: 7461 203d 206c 6f61 645f 6669 6c65 5f64  ta = load_file_d
+00008990: 6174 6166 7261 6d65 2874 6573 745f 6461  ataframe(test_da
+000089a0: 7461 2c20 7365 703d 7365 702c 2068 6561  ta, sep=sep, hea
+000089b0: 6465 723d 6865 6164 6572 2c20 7665 7262  der=header, verb
+000089c0: 6f73 653d 7665 7262 6f73 652c 0a20 2020  ose=verbose,.   
+000089d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 000089e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000089f0: 2323 2320 736f 6d65 7469 6d65 732c 2074  ### sometimes, t
-00008a00: 6573 745f 6461 7461 2072 6574 7572 6e73  est_data returns
-00008a10: 204e 6f6e 6520 6966 2074 6865 7265 2069   None if there i
-00008a20: 7320 616e 2065 7272 6f72 2e20 2323 2323  s an error. ####
-00008a30: 2323 2323 2323 0a20 2020 2020 2020 2020  ######.         
-00008a40: 2020 2020 2020 2020 2020 2069 6620 7465             if te
-00008a50: 7374 5f64 6174 6120 6973 206e 6f74 204e  st_data is not N
-00008a60: 6f6e 653a 0a20 2020 2020 2020 2020 2020  one:.           
-00008a70: 2020 2020 2020 2020 2020 2020 2074 6573               tes
-00008a80: 745f 6461 7461 203d 2072 6564 7563 655f  t_data = reduce_
-00008a90: 6d65 6d5f 7573 6167 6528 7465 7374 5f64  mem_usage(test_d
-00008aa0: 6174 6129 0a20 2020 2020 2020 2020 2020  ata).           
-00008ab0: 2020 2020 2020 2020 2020 2020 2023 2323               ###
-00008ac0: 2074 6573 745f 6461 7461 2069 7320 7468   test_data is th
-00008ad0: 6520 7061 6e64 6173 2064 6174 6166 7261  e pandas datafra
-00008ae0: 6d65 206f 626a 6563 7420 616e 6420 7465  me object and te
-00008af0: 7374 2069 7320 6461 736b 2064 6174 6166  st is dask dataf
-00008b00: 7261 6d65 206f 626a 6563 7420 2323 0a20  rame object ##. 
-00008b10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008b20: 2020 2020 2020 2074 6573 7420 3d20 6c6f         test = lo
-00008b30: 6164 5f64 6173 6b5f 6461 7461 2874 6573  ad_dask_data(tes
-00008b40: 745f 6461 7461 2c20 7365 7029 0a20 2020  t_data, sep).   
-00008b50: 2020 2020 2020 2020 2020 2020 2065 6c73               els
-00008b60: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
-00008b70: 2020 2020 2020 2023 2323 2320 6c6f 6164         #### load
-00008b80: 2074 6865 2065 6e74 6972 6520 7465 7374   the entire test
-00008b90: 2064 6174 6166 7261 6d65 202d 2074 6865   dataframe - the
-00008ba0: 7265 2069 7320 6e6f 206c 696d 6974 2061  re is no limit a
-00008bb0: 7070 6c69 6361 626c 6520 7468 6572 6520  pplicable there 
-00008bc0: 2323 2323 2323 2323 230a 2020 2020 2020  #########.      
-00008bd0: 2020 2020 2020 2020 2020 2020 2020 7465                te
-00008be0: 7374 5f64 6174 6120 3d20 6c6f 6164 5f66  st_data = load_f
-00008bf0: 696c 655f 6461 7461 6672 616d 6528 7465  ile_dataframe(te
-00008c00: 7374 5f64 6174 612c 2073 6570 3d73 6570  st_data, sep=sep
-00008c10: 2c20 6865 6164 6572 3d68 6561 6465 722c  , header=header,
-00008c20: 200a 2020 2020 2020 2020 2020 2020 2020   .              
-00008c30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00008c40: 2020 2020 2020 7665 7262 6f73 653d 7665        verbose=ve
-00008c50: 7262 6f73 652c 206e 726f 7773 3d4e 6f6e  rbose, nrows=Non
-00008c60: 652c 2074 6172 6765 743d 7365 7474 696e  e, target=settin
-00008c70: 6773 2e6d 6f64 656c 7479 7065 2c20 6973  gs.modeltype, is
-00008c80: 5f74 6573 745f 666c 6167 3d54 7275 6529  _test_flag=True)
-00008c90: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00008ca0: 2020 2020 2074 6573 7420 3d20 636f 7079       test = copy
-00008cb0: 2e64 6565 7063 6f70 7928 7465 7374 5f64  .deepcopy(test_d
-00008cc0: 6174 6129 0a20 2020 2020 2020 2065 6c73  ata).        els
-00008cd0: 653a 0a20 2020 2020 2020 2020 2020 2070  e:.            p
-00008ce0: 7269 6e74 2827 4e6f 2074 6573 7420 6461  rint('No test da
-00008cf0: 7461 2066 696c 656e 616d 6520 6769 7665  ta filename give
-00008d00: 6e2e 2e2e 2729 0a20 2020 2020 2020 2020  n...').         
-00008d10: 2020 2074 6573 745f 6461 7461 203d 204e     test_data = N
-00008d20: 6f6e 650a 2020 2020 2020 2020 2020 2020  one.            
-00008d30: 7465 7374 203d 204e 6f6e 650a 2020 2020  test = None.    
-00008d40: 656c 7365 3a0a 2020 2020 2020 2020 7072  else:.        pr
-00008d50: 696e 7428 276c 6f61 6469 6e67 2074 6865  int('loading the
-00008d60: 2065 6e74 6972 6520 7465 7374 2064 6174   entire test dat
-00008d70: 6166 7261 6d65 202d 2074 6865 7265 2069  aframe - there i
-00008d80: 7320 6e6f 206e 726f 7773 206c 696d 6974  s no nrows limit
-00008d90: 2061 7070 6c69 6361 626c 6520 2323 2323   applicable ####
-00008da0: 2323 2323 2327 290a 2020 2020 2020 2020  #####').        
-00008db0: 7465 7374 5f64 6174 6120 3d20 6c6f 6164  test_data = load
-00008dc0: 5f66 696c 655f 6461 7461 6672 616d 6528  _file_dataframe(
-00008dd0: 7465 7374 5f64 6174 612c 2073 6570 3d73  test_data, sep=s
-00008de0: 6570 2c20 6865 6164 6572 3d68 6561 6465  ep, header=heade
-00008df0: 722c 200a 2020 2020 2020 2020 2020 2020  r, .            
-00008e00: 2020 2020 2020 2020 2020 2020 7665 7262              verb
-00008e10: 6f73 653d 7665 7262 6f73 652c 206e 726f  ose=verbose, nro
-00008e20: 7773 3d4e 6f6e 652c 2074 6172 6765 743d  ws=None, target=
-00008e30: 7365 7474 696e 6773 2e6d 6f64 656c 7479  settings.modelty
-00008e40: 7065 2c20 6973 5f74 6573 745f 666c 6167  pe, is_test_flag
-00008e50: 3d54 7275 6529 0a20 2020 2020 2020 2074  =True).        t
-00008e60: 6573 7420 3d20 636f 7079 2e64 6565 7063  est = copy.deepc
-00008e70: 6f70 7928 7465 7374 5f64 6174 6129 0a20  opy(test_data). 
-00008e80: 2020 2023 2323 2073 6f6d 6574 696d 6573     ### sometimes
-00008e90: 2c20 7465 7374 5f64 6174 6120 7265 7475  , test_data retu
-00008ea0: 726e 7320 4e6f 6e65 2069 6620 7468 6572  rns None if ther
-00008eb0: 6520 6973 2061 6e20 6572 726f 722e 2023  e is an error. #
-00008ec0: 2323 2323 2323 2323 230a 2020 2020 6966  #########.    if
-00008ed0: 2074 6573 745f 6461 7461 2069 7320 6e6f   test_data is no
-00008ee0: 7420 4e6f 6e65 3a0a 2020 2020 2020 2020  t None:.        
-00008ef0: 7465 7374 5f64 6174 6120 3d20 7265 6d6f  test_data = remo
-00008f00: 7665 5f64 7570 6c69 6361 7465 5f63 6f6c  ve_duplicate_col
-00008f10: 735f 696e 5f64 6174 6173 6574 2874 6573  s_in_dataset(tes
-00008f20: 745f 6461 7461 290a 2020 2020 2020 2020  t_data).        
-00008f30: 7465 7374 5f69 6e64 6578 203d 2074 6573  test_index = tes
-00008f40: 745f 6461 7461 2e69 6e64 6578 0a20 2020  t_data.index.   
-00008f50: 2020 2020 2070 7269 6e74 2827 2020 2020       print('    
-00008f60: 4c6f 6164 6564 2074 6573 7420 6461 7461  Loaded test data
-00008f70: 2e20 5368 6170 6520 3d20 2573 2720 2528  . Shape = %s' %(
-00008f80: 7465 7374 5f64 6174 612e 7368 6170 652c  test_data.shape,
-00008f90: 2929 0a20 2020 2020 2020 2023 2323 2323  )).        #####
-00008fa0: 2323 2020 4f6e 6365 2061 6761 696e 2072  ##  Once again r
-00008fb0: 656d 6f76 6520 7370 6563 6961 6c20 6368  emove special ch
-00008fc0: 6172 7320 696e 2074 6573 7420 6461 7461  ars in test data
-00008fd0: 2061 7320 7765 6c6c 2023 2323 0a20 2020   as well ###.   
-00008fe0: 2020 2020 2074 6573 745f 6461 7461 203d       test_data =
-00008ff0: 2075 6e69 712e 7472 616e 7366 6f72 6d28   uniq.transform(
-00009000: 7465 7374 5f64 6174 6129 0a0a 2020 2020  test_data)..    
-00009010: 2020 2020 2323 2320 5375 7070 6f73 6520      ### Suppose 
-00009020: 796f 7520 6861 7665 2063 6861 6e67 6564  you have changed
-00009030: 2074 6865 206e 616d 6573 2c20 7468 656e   the names, then
-00009040: 6e20 796f 7520 6d75 7374 206c 6f61 6420  n you must load 
-00009050: 6974 2069 6e20 6461 736b 2061 6761 696e  it in dask again
-00009060: 2023 2320 2020 200a 2020 2020 2020 2020   ##    .        
-00009070: 6966 2073 7065 6369 616c 5f63 6861 725f  if special_char_
-00009080: 666c 6167 3a0a 2020 2020 2020 2020 2020  flag:.          
-00009090: 2020 6966 2064 6173 6b5f 7867 626f 6f73    if dask_xgboos
-000090a0: 745f 666c 6167 3a0a 2020 2020 2020 2020  t_flag:.        
-000090b0: 2020 2020 2020 2020 2323 2320 5265 2d6c          ### Re-l
-000090c0: 6f61 6420 7465 7374 2069 6e74 6f20 6461  oad test into da
-000090d0: 736b 2069 6e20 6361 7365 206e 616d 6573  sk in case names
-000090e0: 2068 6176 6520 6265 656e 2063 6861 6e67   have been chang
-000090f0: 6564 2023 2323 0a20 2020 2020 2020 2020  ed ###.         
-00009100: 2020 2020 2020 2074 6573 7420 3d20 6c6f         test = lo
-00009110: 6164 5f64 6173 6b5f 6461 7461 2874 6573  ad_dask_data(tes
-00009120: 745f 6461 7461 2c20 7365 7029 0a20 2020  t_data, sep).   
-00009130: 2020 2020 2023 2323 2323 2063 6f6e 7665       ##### conve
-00009140: 7274 206d 6978 6564 2064 6174 6120 7479  rt mixed data ty
-00009150: 7065 7320 746f 2073 7472 696e 6720 2323  pes to string ##
-00009160: 2323 2323 2323 2323 2323 0a20 2020 2020  ##########.     
-00009170: 2020 2023 7465 7374 5f64 6174 6120 3d20     #test_data = 
-00009180: 4645 5f63 6f6e 7665 7274 5f6d 6978 6564  FE_convert_mixed
-00009190: 5f64 6174 6174 7970 6573 5f74 6f5f 7374  _datatypes_to_st
-000091a0: 7269 6e67 2874 6573 745f 6461 7461 290a  ring(test_data).
-000091b0: 2020 2020 2020 2020 2374 6573 7420 3d20          #test = 
-000091c0: 4645 5f63 6f6e 7665 7274 5f6d 6978 6564  FE_convert_mixed
-000091d0: 5f64 6174 6174 7970 6573 5f74 6f5f 7374  _datatypes_to_st
-000091e0: 7269 6e67 2874 6573 7429 0a20 2020 2023  ring(test).    #
-000091f0: 2323 2323 2323 2323 2323 2323 2020 2020  ############    
-00009200: 4320 4c20 4120 5320 5320 4920 4620 5920  C L A S S I F Y 
-00009210: 2020 2046 2045 2041 2054 2055 2052 2045     F E A T U R E
-00009220: 2053 2020 2020 2020 2323 2323 2323 2323   S      ########
-00009230: 2323 2323 2323 2323 2323 2323 0a20 2020  ############.   
-00009240: 2069 6620 6e72 6f77 7320 6973 204e 6f6e   if nrows is Non
-00009250: 653a 0a20 2020 2020 2020 206e 726f 7773  e:.        nrows
-00009260: 5f6c 696d 6974 203d 206d 6178 726f 7773  _limit = maxrows
-00009270: 0a20 2020 2065 6c73 653a 0a20 2020 2020  .    else:.     
-00009280: 2020 206e 726f 7773 5f6c 696d 6974 203d     nrows_limit =
-00009290: 2069 6e74 286d 696e 286e 726f 7773 2c20   int(min(nrows, 
-000092a0: 6d61 7872 6f77 7329 290a 2020 2020 2323  maxrows)).    ##
-000092b0: 2323 2079 6f75 2063 616e 2075 7365 2074  ## you can use t
-000092c0: 6172 6765 7473 2061 7320 6120 6c69 7374  argets as a list
-000092d0: 2077 6865 7265 7665 7220 796f 7520 6368   wherever you ch
-000092e0: 6f6f 7365 2023 2323 2323 0a20 2020 2069  oose #####.    i
-000092f0: 6620 6973 696e 7374 616e 6365 2874 6172  f isinstance(tar
-00009300: 6765 742c 2073 7472 293a 0a20 2020 2020  get, str):.     
-00009310: 2020 2074 6172 6765 7473 203d 205b 7461     targets = [ta
-00009320: 7267 6574 5d0a 2020 2020 656c 7365 3a0a  rget].    else:.
-00009330: 2020 2020 2020 2020 7461 7267 6574 7320          targets 
-00009340: 3d20 636f 7079 2e64 6565 7063 6f70 7928  = copy.deepcopy(
-00009350: 7461 7267 6574 290a 2020 2020 6966 2064  target).    if d
-00009360: 6174 616e 616d 652e 7368 6170 655b 305d  ataname.shape[0]
-00009370: 203e 3d20 6e72 6f77 735f 6c69 6d69 743a   >= nrows_limit:
-00009380: 0a20 2020 2020 2020 2070 7269 6e74 2827  .        print('
-00009390: 436c 6173 7369 6679 696e 6720 6665 6174  Classifying feat
-000093a0: 7572 6573 2075 7369 6e67 2061 2072 616e  ures using a ran
-000093b0: 646f 6d20 7361 6d70 6c65 206f 6620 2573  dom sample of %s
-000093c0: 2072 6f77 7320 6672 6f6d 2064 6174 6173   rows from datas
-000093d0: 6574 2e2e 2e27 2025 6e72 6f77 735f 6c69  et...' %nrows_li
-000093e0: 6d69 7429 0a20 2020 2020 2020 2023 2323  mit).        ###
-000093f0: 2323 2079 6f75 2063 616e 2075 7365 206e  ## you can use n
-00009400: 726f 7773 5f6c 696d 6974 2074 6f20 7365  rows_limit to se
-00009410: 6c65 6374 2061 2073 6d61 6c6c 2073 616d  lect a small sam
-00009420: 706c 6520 6672 6f6d 2064 6174 6120 7365  ple from data se
-00009430: 7420 2323 2323 2323 2323 2323 2323 2323  t ##############
-00009440: 2323 2323 2323 2323 2323 0a20 2020 2020  ##########.     
-00009450: 2020 2074 7261 696e 5f73 6d61 6c6c 203d     train_small =
-00009460: 2045 4441 5f72 616e 646f 6d6c 795f 7365   EDA_randomly_se
-00009470: 6c65 6374 5f72 6f77 735f 6672 6f6d 5f64  lect_rows_from_d
-00009480: 6174 6166 7261 6d65 2864 6174 616e 616d  ataframe(datanam
-00009490: 652c 2074 6172 6765 7473 2c20 6e72 6f77  e, targets, nrow
-000094a0: 735f 6c69 6d69 742c 2044 535f 4c45 4e3d  s_limit, DS_LEN=
-000094b0: 6461 7461 6e61 6d65 2e73 6861 7065 5b30  dataname.shape[0
-000094c0: 5d29 0a20 2020 2020 2020 2066 6561 7475  ]).        featu
-000094d0: 7265 735f 6469 6374 203d 2063 6c61 7373  res_dict = class
-000094e0: 6966 795f 6665 6174 7572 6573 2874 7261  ify_features(tra
-000094f0: 696e 5f73 6d61 6c6c 2c20 7461 7267 6574  in_small, target
-00009500: 290a 2020 2020 656c 7365 3a0a 2020 2020  ).    else:.    
-00009510: 2020 2020 6665 6174 7572 6573 5f64 6963      features_dic
-00009520: 7420 3d20 636c 6173 7369 6679 5f66 6561  t = classify_fea
-00009530: 7475 7265 7328 6461 7461 6e61 6d65 2c20  tures(dataname, 
-00009540: 7461 7267 6574 290a 2020 2020 2323 2323  target).    ####
-00009550: 204e 6f77 2077 6520 6861 7665 2074 6f20   Now we have to 
-00009560: 6472 6f70 2063 6572 7461 696e 2063 6f6c  drop certain col
-00009570: 7320 7468 6174 206d 7573 7420 6265 2064  s that must be d
-00009580: 656c 6574 6564 2023 2323 2323 2323 2323  eleted #########
-00009590: 2323 2323 2323 2323 2323 2323 0a20 2020  ############.   
-000095a0: 2072 656d 6f76 655f 636f 6c73 203d 2066   remove_cols = f
-000095b0: 6561 7475 7265 735f 6469 6374 5b27 6469  eatures_dict['di
-000095c0: 7363 7265 7465 5f73 7472 696e 675f 7661  screte_string_va
-000095d0: 7273 275d 202b 2066 6561 7475 7265 735f  rs'] + features_
-000095e0: 6469 6374 5b27 636f 6c73 5f64 656c 6574  dict['cols_delet
-000095f0: 6527 5d0a 2020 2020 6966 206c 656e 2872  e'].    if len(r
-00009600: 656d 6f76 655f 636f 6c73 2920 3e20 303a  emove_cols) > 0:
-00009610: 0a20 2020 2020 2020 2070 7269 6e74 2827  .        print('
-00009620: 7472 6169 6e20 6461 7461 2073 6861 7065  train data shape
-00009630: 2062 6566 6f72 6520 6472 6f70 7069 6e67   before dropping
-00009640: 2025 6420 636f 6c75 6d6e 7320 3d20 2573   %d columns = %s
-00009650: 2720 2528 6c65 6e28 7265 6d6f 7665 5f63  ' %(len(remove_c
-00009660: 6f6c 7329 2c20 6461 7461 6e61 6d65 2e73  ols), dataname.s
-00009670: 6861 7065 2c29 290a 2020 2020 2020 2020  hape,)).        
-00009680: 6461 7461 6e61 6d65 2e64 726f 7028 7265  dataname.drop(re
-00009690: 6d6f 7665 5f63 6f6c 732c 2061 7869 733d  move_cols, axis=
-000096a0: 312c 2069 6e70 6c61 6365 3d54 7275 6529  1, inplace=True)
-000096b0: 0a20 2020 2020 2020 2070 7269 6e74 2827  .        print('
-000096c0: 5c74 7472 6169 6e20 6461 7461 2073 6861  \ttrain data sha
-000096d0: 7065 2061 6674 6572 2064 726f 7070 696e  pe after droppin
-000096e0: 6720 636f 6c75 6d6e 7320 3d20 2573 2720  g columns = %s' 
-000096f0: 2528 6461 7461 6e61 6d65 2e73 6861 7065  %(dataname.shape
-00009700: 2c29 290a 2020 2020 2020 2020 7472 6169  ,)).        trai
-00009710: 6e20 3d20 6c6f 6164 5f64 6173 6b5f 6461  n = load_dask_da
-00009720: 7461 2864 6174 616e 616d 652c 2073 6570  ta(dataname, sep
-00009730: 290a 2020 2020 2020 2020 6966 206e 6f74  ).        if not
-00009740: 2074 6573 745f 6461 7461 2069 7320 4e6f   test_data is No
-00009750: 6e65 3a0a 2020 2020 2020 2020 2020 2020  ne:.            
-00009760: 7465 7374 5f64 6174 612e 6472 6f70 2872  test_data.drop(r
-00009770: 656d 6f76 655f 636f 6c73 2c20 6178 6973  emove_cols, axis
-00009780: 3d31 2c20 696e 706c 6163 653d 5472 7565  =1, inplace=True
-00009790: 290a 2020 2020 2020 2020 2020 2020 7465  ).            te
-000097a0: 7374 203d 206c 6f61 645f 6461 736b 5f64  st = load_dask_d
-000097b0: 6174 6128 7465 7374 5f64 6174 612c 2073  ata(test_data, s
-000097c0: 6570 290a 2020 2020 2323 2323 2323 2323  ep).    ########
-000097d0: 2323 2323 2323 2323 2020 2020 4c6f 6164  ########    Load
-000097e0: 2064 6174 6120 6672 616d 6520 7769 7468   data frame with
-000097f0: 2064 6174 6520 7661 7220 6665 6174 7572   date var featur
-00009800: 6573 2063 6f72 7265 6374 6c79 2074 6869  es correctly thi
-00009810: 7320 7469 6d65 2023 2323 2323 2323 2323  s time #########
-00009820: 2323 2323 2323 230a 2020 2020 6966 206c  #######.    if l
-00009830: 656e 2866 6561 7475 7265 735f 6469 6374  en(features_dict
-00009840: 5b27 6461 7465 5f76 6172 7327 5d29 203e  ['date_vars']) >
-00009850: 2030 3a0a 2020 2020 2020 2020 7072 696e   0:.        prin
-00009860: 7428 2743 6175 7469 6f6e 3a20 5369 6e63  t('Caution: Sinc
-00009870: 6520 7468 6572 6520 6172 6520 6461 7465  e there are date
-00009880: 2d74 696d 6520 7661 7269 6162 6c65 7320  -time variables 
-00009890: 696e 2064 6174 6173 6574 2c20 6974 2069  in dataset, it i
-000098a0: 7320 6265 7374 2074 6f20 6c6f 6164 2074  s best to load t
-000098b0: 6865 6d20 7573 696e 6720 7061 6e64 6173  hem using pandas
-000098c0: 2729 0a20 2020 2020 2020 2064 6173 6b5f  ').        dask_
-000098d0: 7867 626f 6f73 745f 666c 6167 203d 2046  xgboost_flag = F
-000098e0: 616c 7365 2023 2323 2053 6574 2074 6865  alse ### Set the
-000098f0: 2064 6173 6b20 666c 6167 2074 6f20 6265   dask flag to be
-00009900: 2046 616c 7365 2073 696e 6365 2069 7420   False since it 
-00009910: 6973 206e 6f77 2062 6563 6f6d 696e 6720  is now becoming 
-00009920: 5061 6e64 6173 2064 6174 6166 7261 6d65  Pandas dataframe
-00009930: 200a 2020 2020 2020 2020 6461 7465 5f74   .        date_t
-00009940: 696d 655f 7661 7273 203d 2066 6561 7475  ime_vars = featu
-00009950: 7265 735f 6469 6374 5b27 6461 7465 5f76  res_dict['date_v
-00009960: 6172 7327 5d0a 2020 2020 2020 2020 6461  ars'].        da
-00009970: 7461 6e61 6d65 203d 206c 6f61 645f 6669  taname = load_fi
-00009980: 6c65 5f64 6174 6166 7261 6d65 2864 6174  le_dataframe(dat
-00009990: 616e 616d 652c 2073 6570 3d73 6570 2c20  aname, sep=sep, 
-000099a0: 6865 6164 6572 3d68 6561 6465 722c 2076  header=header, v
-000099b0: 6572 626f 7365 3d76 6572 626f 7365 2c20  erbose=verbose, 
-000099c0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000099d0: 2020 2020 2020 2020 2020 2020 206e 726f               nro
-000099e0: 7773 3d6e 726f 7773 2c20 7061 7273 655f  ws=nrows, parse_
-000099f0: 6461 7465 733d 6461 7465 5f74 696d 655f  dates=date_time_
-00009a00: 7661 7273 2c20 7461 7267 6574 3d74 6172  vars, target=tar
-00009a10: 6765 7429 0a20 2020 2020 2020 2069 6620  get).        if 
-00009a20: 2864 6174 616e 616d 652e 6d65 6d6f 7279  (dataname.memory
-00009a30: 5f75 7361 6765 2829 2e73 756d 2829 2f31  _usage().sum()/1
-00009a40: 3030 3030 3030 2920 3e20 6d65 6d5f 6c69  000000) > mem_li
-00009a50: 6d69 743a 0a20 2020 2020 2020 2020 2020  mit:.           
-00009a60: 2064 6174 616e 616d 6520 3d20 7265 6475   dataname = redu
-00009a70: 6365 5f6d 656d 5f75 7361 6765 2864 6174  ce_mem_usage(dat
-00009a80: 616e 616d 6529 0a20 2020 2020 2020 2074  aname).        t
-00009a90: 7261 696e 203d 206c 6f61 645f 6461 736b  rain = load_dask
-00009aa0: 5f64 6174 6128 6461 7461 6e61 6d65 2c20  _data(dataname, 
-00009ab0: 7365 7029 0a20 2020 2020 2020 2069 6620  sep).        if 
-00009ac0: 6e6f 7420 7465 7374 5f64 6174 6120 6973  not test_data is
-00009ad0: 204e 6f6e 653a 0a20 2020 2020 2020 2020   None:.         
-00009ae0: 2020 2023 2323 2059 6f75 206d 7573 7420     ### You must 
-00009af0: 6c6f 6164 2074 6865 2065 6e74 6972 6520  load the entire 
-00009b00: 7465 7374 2064 6174 6120 2d20 7468 6572  test data - ther
-00009b10: 6520 6973 206e 6f20 6c69 6d69 7420 7468  e is no limit th
-00009b20: 6572 6520 2323 2323 2323 2323 2323 2323  ere ############
-00009b30: 2323 2323 2323 0a20 2020 2020 2020 2020  ######.         
-00009b40: 2020 2023 2323 2074 6573 745f 6461 7461     ### test_data
-00009b50: 2069 7320 7468 6520 7061 6e64 6173 2064   is the pandas d
-00009b60: 6174 6166 7261 6d65 206f 626a 6563 7420  ataframe object 
-00009b70: 616e 6420 7465 7374 2069 7320 6461 736b  and test is dask
-00009b80: 2064 6174 6166 7261 6d65 206f 626a 6563   dataframe objec
-00009b90: 7420 2323 0a20 2020 2020 2020 2020 2020  t ##.           
-00009ba0: 2074 6573 745f 6461 7461 203d 206c 6f61   test_data = loa
-00009bb0: 645f 6669 6c65 5f64 6174 6166 7261 6d65  d_file_dataframe
-00009bc0: 2874 6573 745f 6461 7461 2c20 7365 703d  (test_data, sep=
-00009bd0: 7365 702c 2068 6561 6465 723d 6865 6164  sep, header=head
-00009be0: 6572 2c20 7665 7262 6f73 653d 7665 7262  er, verbose=verb
-00009bf0: 6f73 652c 200a 2020 2020 2020 2020 2020  ose, .          
-00009c00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00009c10: 2020 2020 2020 206e 726f 7773 3d6e 726f         nrows=nro
-00009c20: 7773 2c20 7061 7273 655f 6461 7465 733d  ws, parse_dates=
-00009c30: 6461 7465 5f74 696d 655f 7661 7273 2c20  date_time_vars, 
-00009c40: 7461 7267 6574 3d73 6574 7469 6e67 732e  target=settings.
-00009c50: 6d6f 6465 6c74 7970 652c 2069 735f 7465  modeltype, is_te
-00009c60: 7374 5f66 6c61 673d 5472 7565 2029 0a20  st_flag=True ). 
-00009c70: 2020 2020 2020 2020 2020 2074 6573 7420             test 
-00009c80: 3d20 636f 7079 2e64 6565 7063 6f70 7928  = copy.deepcopy(
-00009c90: 7465 7374 5f64 6174 6129 0a20 2020 2020  test_data).     
-00009ca0: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
-00009cb0: 2020 2020 2074 6573 745f 6461 7461 203d       test_data =
-00009cc0: 204e 6f6e 650a 2020 2020 2020 2020 2020   None.          
-00009cd0: 2020 7465 7374 203d 204e 6f6e 650a 2020    test = None.  
-00009ce0: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
-00009cf0: 7472 6169 6e5f 696e 6465 7820 3d20 6461  train_index = da
-00009d00: 7461 6e61 6d65 2e69 6e64 6578 0a20 2020  taname.index.   
-00009d10: 2020 2020 2069 6620 7465 7374 5f64 6174       if test_dat
-00009d20: 6120 6973 206e 6f74 204e 6f6e 653a 0a20  a is not None:. 
-00009d30: 2020 2020 2020 2020 2020 2074 6573 745f             test_
-00009d40: 696e 6465 7820 3d20 7465 7374 5f64 6174  index = test_dat
-00009d50: 612e 696e 6465 780a 2020 2020 2323 2323  a.index.    ####
-00009d60: 2323 2323 2323 2323 2323 2323 2020 2058  ############   X
-00009d70: 2047 2042 204f 204f 2053 2054 2020 2020   G B O O S T    
-00009d80: 2020 4420 4520 4620 4120 5520 4c20 5420    D E F A U L T 
-00009d90: 5320 2020 2020 2023 2323 2323 2323 2323  S      #########
-00009da0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00009db0: 2323 2323 2323 2323 2323 2323 230a 2020  #############.  
-00009dc0: 2020 2323 2323 2049 6620 7468 6572 6520    #### If there 
-00009dd0: 6172 6520 6d6f 7265 2074 6861 6e20 3330  are more than 30
-00009de0: 2063 6174 6567 6f72 6963 616c 2076 6172   categorical var
-00009df0: 6961 626c 6573 2069 6e20 6120 6461 7461  iables in a data
-00009e00: 2073 6574 2c20 6974 2069 7320 776f 7274   set, it is wort
-00009e10: 6820 7265 6475 6369 6e67 2066 6561 7475  h reducing featu
-00009e20: 7265 732e 0a20 2020 2023 2323 2320 204f  res..    ####  O
-00009e30: 7468 6572 7769 7365 2e20 5847 426f 6f73  therwise. XGBoos
-00009e40: 7420 6973 2070 7265 7474 7920 676f 6f64  t is pretty good
-00009e50: 2061 7420 6669 6e64 696e 6720 7468 6520   at finding the 
-00009e60: 6265 7374 2066 6561 7475 7265 7320 7768  best features wh
-00009e70: 6574 6865 7220 6361 7420 6f72 206e 756d  ether cat or num
-00009e80: 6572 6963 2021 0a20 2020 2023 2323 2323  eric !.    #####
-00009e90: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00009ea0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00009eb0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00009ec0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00009ed0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00009ee0: 2323 2323 2323 2323 2323 2323 0a0a 2020  ############..  
-00009ef0: 2020 7374 6172 745f 7469 6d65 203d 2074    start_time = t
-00009f00: 696d 652e 7469 6d65 2829 0a20 2020 206e  ime.time().    n
-00009f10: 5f73 706c 6974 7320 3d20 350a 2020 2020  _splits = 5.    
-00009f20: 6d61 785f 6465 7074 6820 3d20 380a 2020  max_depth = 8.  
-00009f30: 2020 2323 2323 2323 2323 2323 2323 2323    ##############
-00009f40: 2323 2323 2323 2323 2020 2049 204d 2050  ########   I M P
-00009f50: 204f 2052 2054 2041 204e 2054 2020 2020   O R T A N T    
-00009f60: 4420 4520 4620 4120 5520 4c20 5420 5320  D E F A U L T S 
-00009f70: 2323 2323 2323 2323 2323 2323 2323 0a20  ##############. 
-00009f80: 2020 2073 7562 7361 6d70 6c65 203d 2020     subsample =  
-00009f90: 302e 370a 2020 2020 636f 6c5f 7375 625f  0.7.    col_sub_
-00009fa0: 7361 6d70 6c65 203d 2030 2e37 0a20 2020  sample = 0.7.   
-00009fb0: 2074 6573 745f 7369 7a65 203d 2030 2e32   test_size = 0.2
-00009fc0: 0a20 2020 2023 7072 696e 7428 2774 6573  .    #print('tes
-00009fd0: 745f 7369 7a65 203d 2025 7327 2025 7465  t_size = %s' %te
-00009fe0: 7374 5f73 697a 6529 0a20 2020 2073 6565  st_size).    see
-00009ff0: 6420 3d20 310a 2020 2020 6561 726c 795f  d = 1.    early_
-0000a000: 7374 6f70 7069 6e67 203d 2035 0a20 2020  stopping = 5.   
-0000a010: 2023 2323 2323 2323 2041 6c6c 2074 6865   ####### All the
-0000a020: 2064 6566 6175 6c74 2070 6172 616d 6574   default paramet
-0000a030: 6572 7320 6172 6520 7365 7420 7570 206e  ers are set up n
-0000a040: 6f77 2023 2323 2323 2323 2323 0a20 2020  ow #########.   
-0000a050: 206b 6620 3d20 4b46 6f6c 6428 6e5f 7370   kf = KFold(n_sp
-0000a060: 6c69 7473 3d6e 5f73 706c 6974 7329 0a20  lits=n_splits). 
-0000a070: 2020 2023 2323 2323 2323 2323 2020 2020     #########    
-0000a080: 2047 2050 2055 2020 2020 2050 2052 204f   G P U     P R O
-0000a090: 2043 2045 2053 2053 2049 204e 2047 2020   C E S S I N G  
-0000a0a0: 2020 2020 4220 4520 4720 4920 4e20 5320      B E G I N S 
-0000a0b0: 2020 2023 2323 2323 2323 2323 2323 230a     ############.
-0000a0c0: 2020 2020 2323 2323 2323 2054 6869 7320      ###### This 
-0000a0d0: 6973 2077 6865 7265 2077 6520 7365 7420  is where we set 
-0000a0e0: 7468 6520 4350 5520 616e 6420 4750 5520  the CPU and GPU 
-0000a0f0: 7061 7261 6d65 7465 7273 2066 6f72 2058  parameters for X
-0000a100: 4742 6f6f 7374 0a20 2020 2047 5055 5f65  GBoost.    GPU_e
-0000a110: 7869 7374 7320 3d20 6368 6563 6b5f 6966  xists = check_if
-0000a120: 5f47 5055 5f65 7869 7374 7328 7665 7262  _GPU_exists(verb
-0000a130: 6f73 6529 0a20 2020 206e 5f77 6f72 6b65  ose).    n_worke
-0000a140: 7273 203d 2067 6574 5f63 7075 5f77 6f72  rs = get_cpu_wor
-0000a150: 6b65 725f 636f 756e 7428 290a 2020 2020  ker_count().    
-0000a160: 2323 2323 2320 2020 5365 7420 7468 6520  #####   Set the 
-0000a170: 5363 6f72 696e 6720 5061 7261 6d65 7465  Scoring Paramete
-0000a180: 7273 2068 6572 6520 6261 7365 6420 6f6e  rs here based on
-0000a190: 2065 6163 6820 6d6f 6465 6c20 616e 6420   each model and 
-0000a1a0: 7072 6566 6572 656e 6365 7320 6f66 2075  preferences of u
-0000a1b0: 7365 7220 2323 230a 2020 2020 6370 755f  ser ###.    cpu_
-0000a1c0: 7061 7261 6d73 203d 207b 7d0a 2020 2020  params = {}.    
-0000a1d0: 7061 7261 6d20 3d20 7b7d 0a20 2020 2063  param = {}.    c
-0000a1e0: 7075 5f74 7265 655f 6d65 7468 6f64 203d  pu_tree_method =
-0000a1f0: 2027 6869 7374 270a 2020 2020 7472 6565   'hist'.    tree
-0000a200: 5f6d 6574 686f 6420 3d20 2768 6973 7427  _method = 'hist'
-0000a210: 0a20 2020 206e 5f65 7374 696d 6174 6f72  .    n_estimator
-0000a220: 7320 3d20 3130 300a 2020 2020 6370 755f  s = 100.    cpu_
-0000a230: 7061 7261 6d73 5b27 6e74 6872 6561 6427  params['nthread'
-0000a240: 5d20 3d20 2d31 0a20 2020 2063 7075 5f70  ] = -1.    cpu_p
-0000a250: 6172 616d 735b 2774 7265 655f 6d65 7468  arams['tree_meth
-0000a260: 6f64 275d 203d 2027 6869 7374 270a 2020  od'] = 'hist'.  
-0000a270: 2020 6370 755f 7061 7261 6d73 5b27 6574    cpu_params['et
-0000a280: 6127 5d20 3d20 302e 3031 0a20 2020 2063  a'] = 0.01.    c
-0000a290: 7075 5f70 6172 616d 735b 2773 7562 7361  pu_params['subsa
-0000a2a0: 6d70 6c65 275d 203d 2030 2e35 0a20 2020  mple'] = 0.5.   
-0000a2b0: 2063 7075 5f70 6172 616d 735b 2767 726f   cpu_params['gro
-0000a2c0: 775f 706f 6c69 6379 275d 203d 2027 6465  w_policy'] = 'de
-0000a2d0: 7074 6877 6973 6527 2023 276c 6f73 7367  pthwise' #'lossg
-0000a2e0: 7569 6465 270a 2020 2020 6370 755f 7061  uide'.    cpu_pa
-0000a2f0: 7261 6d73 5b27 6e5f 6573 7469 6d61 746f  rams['n_estimato
-0000a300: 7273 275d 203d 206e 5f65 7374 696d 6174  rs'] = n_estimat
-0000a310: 6f72 730a 2020 2020 6370 755f 7061 7261  ors.    cpu_para
-0000a320: 6d73 5b27 6d61 785f 6465 7074 6827 5d20  ms['max_depth'] 
-0000a330: 3d20 6d61 785f 6465 7074 680a 2020 2020  = max_depth.    
-0000a340: 6370 755f 7061 7261 6d73 5b27 6d61 785f  cpu_params['max_
-0000a350: 6c65 6176 6573 275d 203d 2030 0a20 2020  leaves'] = 0.   
-0000a360: 2063 7075 5f70 6172 616d 735b 2776 6572   cpu_params['ver
-0000a370: 626f 7369 7479 275d 203d 2030 0a20 2020  bosity'] = 0.   
-0000a380: 2063 7075 5f70 6172 616d 735b 2767 7075   cpu_params['gpu
-0000a390: 5f69 6427 5d20 3d20 300a 2020 2020 6370  _id'] = 0.    cp
-0000a3a0: 755f 7061 7261 6d73 5b27 7570 6461 7465  u_params['update
-0000a3b0: 7227 5d20 3d20 2767 726f 775f 636f 6c6d  r'] = 'grow_colm
-0000a3c0: 616b 6572 270a 2020 2020 6370 755f 7061  aker'.    cpu_pa
-0000a3d0: 7261 6d73 5b27 7072 6564 6963 746f 7227  rams['predictor'
-0000a3e0: 5d20 3d20 2763 7075 5f70 7265 6469 6374  ] = 'cpu_predict
-0000a3f0: 6f72 270a 2020 2020 6370 755f 7061 7261  or'.    cpu_para
-0000a400: 6d73 5b27 6e75 6d5f 7061 7261 6c6c 656c  ms['num_parallel
-0000a410: 5f74 7265 6527 5d20 3d20 310a 2020 2020  _tree'] = 1.    
-0000a420: 6966 2047 5055 5f65 7869 7374 733a 0a20  if GPU_exists:. 
-0000a430: 2020 2020 2020 2023 2323 2054 6869 7320         ### This 
-0000a440: 6861 7320 6265 656e 2066 6978 6564 2023  has been fixed #
-0000a450: 2323 0a20 2020 2020 2020 2074 7265 655f  ##.        tree_
-0000a460: 6d65 7468 6f64 203d 2027 6770 755f 6869  method = 'gpu_hi
-0000a470: 7374 270a 2020 2020 2020 2020 7061 7261  st'.        para
-0000a480: 6d5b 276e 7468 7265 6164 275d 203d 202d  m['nthread'] = -
-0000a490: 310a 2020 2020 2020 2020 7061 7261 6d5b  1.        param[
-0000a4a0: 2774 7265 655f 6d65 7468 6f64 275d 203d  'tree_method'] =
-0000a4b0: 2027 6770 755f 6869 7374 270a 2020 2020   'gpu_hist'.    
-0000a4c0: 2020 2020 7061 7261 6d5b 2765 7461 275d      param['eta']
-0000a4d0: 203d 2030 2e30 310a 2020 2020 2020 2020   = 0.01.        
-0000a4e0: 7061 7261 6d5b 2773 7562 7361 6d70 6c65  param['subsample
-0000a4f0: 275d 203d 2030 2e35 0a20 2020 2020 2020  '] = 0.5.       
-0000a500: 2070 6172 616d 5b27 6772 6f77 5f70 6f6c   param['grow_pol
-0000a510: 6963 7927 5d20 3d20 2764 6570 7468 7769  icy'] = 'depthwi
-0000a520: 7365 2720 2320 276c 6f73 7367 7569 6465  se' # 'lossguide
-0000a530: 2720 2320 0a20 2020 2020 2020 2070 6172  ' # .        par
-0000a540: 616d 5b27 6e5f 6573 7469 6d61 746f 7273  am['n_estimators
-0000a550: 275d 203d 206e 5f65 7374 696d 6174 6f72  '] = n_estimator
-0000a560: 730a 2020 2020 2020 2020 7061 7261 6d5b  s.        param[
-0000a570: 276d 6178 5f64 6570 7468 275d 203d 206d  'max_depth'] = m
-0000a580: 6178 5f64 6570 7468 0a20 2020 2020 2020  ax_depth.       
-0000a590: 2070 6172 616d 5b27 6d61 785f 6c65 6176   param['max_leav
-0000a5a0: 6573 275d 203d 2030 0a20 2020 2020 2020  es'] = 0.       
-0000a5b0: 2070 6172 616d 5b27 7665 7262 6f73 6974   param['verbosit
-0000a5c0: 7927 5d20 3d20 300a 2020 2020 2020 2020  y'] = 0.        
-0000a5d0: 7061 7261 6d5b 2767 7075 5f69 6427 5d20  param['gpu_id'] 
-0000a5e0: 3d20 300a 2020 2020 2020 2020 7061 7261  = 0.        para
-0000a5f0: 6d5b 2775 7064 6174 6572 275d 203d 2027  m['updater'] = '
-0000a600: 6772 6f77 5f67 7075 5f68 6973 7427 2023  grow_gpu_hist' #
-0000a610: 2770 7275 6e65 270a 2020 2020 2020 2020  'prune'.        
-0000a620: 7061 7261 6d5b 2770 7265 6469 6374 6f72  param['predictor
-0000a630: 275d 203d 2027 6770 755f 7072 6564 6963  '] = 'gpu_predic
-0000a640: 746f 7227 0a20 2020 2020 2020 2070 6172  tor'.        par
-0000a650: 616d 5b27 6e75 6d5f 7061 7261 6c6c 656c  am['num_parallel
-0000a660: 5f74 7265 6527 5d20 3d20 310a 2020 2020  _tree'] = 1.    
-0000a670: 2020 2020 6770 7569 6420 3d20 300a 2020      gpuid = 0.  
-0000a680: 2020 2020 2020 6966 2076 6572 626f 7365        if verbose
-0000a690: 3a0a 2020 2020 2020 2020 2020 2020 7072  :.            pr
-0000a6a0: 696e 7428 2720 2020 2054 756e 696e 6720  int('    Tuning 
-0000a6b0: 5847 426f 6f73 7420 7573 696e 6720 4750  XGBoost using GP
-0000a6c0: 5520 6879 7065 722d 7061 7261 6d65 7465  U hyper-paramete
-0000a6d0: 7273 2e20 5468 6973 2077 696c 6c20 7461  rs. This will ta
-0000a6e0: 6b65 2074 696d 652e 2e2e 2729 0a20 2020  ke time...').   
-0000a6f0: 2065 6c73 653a 0a20 2020 2020 2020 2070   else:.        p
-0000a700: 6172 616d 203d 2063 6f70 792e 6465 6570  aram = copy.deep
-0000a710: 636f 7079 2863 7075 5f70 6172 616d 7329  copy(cpu_params)
-0000a720: 0a20 2020 2020 2020 2067 7075 6964 203d  .        gpuid =
-0000a730: 204e 6f6e 650a 2020 2020 2020 2020 6966   None.        if
-0000a740: 2076 6572 626f 7365 3a0a 2020 2020 2020   verbose:.      
-0000a750: 2020 2020 2020 7072 696e 7428 2720 2020        print('   
-0000a760: 2054 756e 696e 6720 5847 426f 6f73 7420   Tuning XGBoost 
-0000a770: 7573 696e 6720 4350 5520 6879 7065 722d  using CPU hyper-
-0000a780: 7061 7261 6d65 7465 7273 2e20 5468 6973  parameters. This
-0000a790: 2077 696c 6c20 7461 6b65 2074 696d 652e   will take time.
-0000a7a0: 2e2e 2729 0a20 2020 2023 2323 2323 2323  ..').    #######
-0000a7b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000a7c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000a7d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000a7e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000a7f0: 2323 2323 2323 2323 2323 0a20 2020 2023  ##########.    #
-0000a800: 2323 2323 2323 2323 2323 2323 2020 2044  ############   D
-0000a810: 2045 2054 2045 2043 2054 2020 5349 4e47   E T E C T  SING
-0000a820: 4c45 204f 5220 4d55 4c54 492d 4c41 4245  LE OR MULTI-LABE
-0000a830: 4c20 5052 4f42 4c45 4d20 2020 2020 2023  L PROBLEM      #
-0000a840: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000a850: 0a20 2020 2023 2323 2323 2323 2323 2323  .    ###########
-0000a860: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000a870: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000a880: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000089f0: 2020 6e72 6f77 733d 4e6f 6e65 2c20 7461    nrows=None, ta
+00008a00: 7267 6574 3d73 6574 7469 6e67 732e 6d6f  rget=settings.mo
+00008a10: 6465 6c74 7970 652c 2069 735f 7465 7374  deltype, is_test
+00008a20: 5f66 6c61 673d 5472 7565 290a 2020 2020  _flag=True).    
+00008a30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008a40: 2323 2320 736f 6d65 7469 6d65 732c 2074  ### sometimes, t
+00008a50: 6573 745f 6461 7461 2072 6574 7572 6e73  est_data returns
+00008a60: 204e 6f6e 6520 6966 2074 6865 7265 2069   None if there i
+00008a70: 7320 616e 2065 7272 6f72 2e20 2323 2323  s an error. ####
+00008a80: 2323 2323 2323 0a20 2020 2020 2020 2020  ######.         
+00008a90: 2020 2020 2020 2020 2020 2069 6620 7465             if te
+00008aa0: 7374 5f64 6174 6120 6973 206e 6f74 204e  st_data is not N
+00008ab0: 6f6e 653a 0a20 2020 2020 2020 2020 2020  one:.           
+00008ac0: 2020 2020 2020 2020 2020 2020 2074 6573               tes
+00008ad0: 745f 6461 7461 203d 2072 6564 7563 655f  t_data = reduce_
+00008ae0: 6d65 6d5f 7573 6167 6528 7465 7374 5f64  mem_usage(test_d
+00008af0: 6174 6129 0a20 2020 2020 2020 2020 2020  ata).           
+00008b00: 2020 2020 2020 2020 2020 2020 2023 2323               ###
+00008b10: 2074 6573 745f 6461 7461 2069 7320 7468   test_data is th
+00008b20: 6520 7061 6e64 6173 2064 6174 6166 7261  e pandas datafra
+00008b30: 6d65 206f 626a 6563 7420 616e 6420 7465  me object and te
+00008b40: 7374 2069 7320 6461 736b 2064 6174 6166  st is dask dataf
+00008b50: 7261 6d65 206f 626a 6563 7420 2323 0a20  rame object ##. 
+00008b60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008b70: 2020 2020 2020 2074 6573 7420 3d20 6c6f         test = lo
+00008b80: 6164 5f64 6173 6b5f 6461 7461 2874 6573  ad_dask_data(tes
+00008b90: 745f 6461 7461 2c20 7365 7029 0a20 2020  t_data, sep).   
+00008ba0: 2020 2020 2020 2020 2020 2020 2065 6c73               els
+00008bb0: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+00008bc0: 2020 2020 2020 2023 2323 2320 6c6f 6164         #### load
+00008bd0: 2074 6865 2065 6e74 6972 6520 7465 7374   the entire test
+00008be0: 2064 6174 6166 7261 6d65 202d 2074 6865   dataframe - the
+00008bf0: 7265 2069 7320 6e6f 206c 696d 6974 2061  re is no limit a
+00008c00: 7070 6c69 6361 626c 6520 7468 6572 6520  pplicable there 
+00008c10: 2323 2323 2323 2323 230a 2020 2020 2020  #########.      
+00008c20: 2020 2020 2020 2020 2020 2020 2020 7465                te
+00008c30: 7374 5f64 6174 6120 3d20 6c6f 6164 5f66  st_data = load_f
+00008c40: 696c 655f 6461 7461 6672 616d 6528 7465  ile_dataframe(te
+00008c50: 7374 5f64 6174 612c 2073 6570 3d73 6570  st_data, sep=sep
+00008c60: 2c20 6865 6164 6572 3d68 6561 6465 722c  , header=header,
+00008c70: 200a 2020 2020 2020 2020 2020 2020 2020   .              
+00008c80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00008c90: 2020 2020 2020 7665 7262 6f73 653d 7665        verbose=ve
+00008ca0: 7262 6f73 652c 206e 726f 7773 3d4e 6f6e  rbose, nrows=Non
+00008cb0: 652c 2074 6172 6765 743d 7365 7474 696e  e, target=settin
+00008cc0: 6773 2e6d 6f64 656c 7479 7065 2c20 6973  gs.modeltype, is
+00008cd0: 5f74 6573 745f 666c 6167 3d54 7275 6529  _test_flag=True)
+00008ce0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00008cf0: 2020 2020 2074 6573 7420 3d20 636f 7079       test = copy
+00008d00: 2e64 6565 7063 6f70 7928 7465 7374 5f64  .deepcopy(test_d
+00008d10: 6174 6129 0a20 2020 2020 2020 2065 6c73  ata).        els
+00008d20: 653a 0a20 2020 2020 2020 2020 2020 2070  e:.            p
+00008d30: 7269 6e74 2827 4e6f 2074 6573 7420 6461  rint('No test da
+00008d40: 7461 2066 696c 656e 616d 6520 6769 7665  ta filename give
+00008d50: 6e2e 2e2e 2729 0a20 2020 2020 2020 2020  n...').         
+00008d60: 2020 2074 6573 745f 6461 7461 203d 204e     test_data = N
+00008d70: 6f6e 650a 2020 2020 2020 2020 2020 2020  one.            
+00008d80: 7465 7374 203d 204e 6f6e 650a 2020 2020  test = None.    
+00008d90: 656c 7365 3a0a 2020 2020 2020 2020 7072  else:.        pr
+00008da0: 696e 7428 276c 6f61 6469 6e67 2074 6865  int('loading the
+00008db0: 2065 6e74 6972 6520 7465 7374 2064 6174   entire test dat
+00008dc0: 6166 7261 6d65 202d 2074 6865 7265 2069  aframe - there i
+00008dd0: 7320 6e6f 206e 726f 7773 206c 696d 6974  s no nrows limit
+00008de0: 2061 7070 6c69 6361 626c 6520 2323 2323   applicable ####
+00008df0: 2323 2323 2327 290a 2020 2020 2020 2020  #####').        
+00008e00: 7465 7374 5f64 6174 6120 3d20 6c6f 6164  test_data = load
+00008e10: 5f66 696c 655f 6461 7461 6672 616d 6528  _file_dataframe(
+00008e20: 7465 7374 5f64 6174 612c 2073 6570 3d73  test_data, sep=s
+00008e30: 6570 2c20 6865 6164 6572 3d68 6561 6465  ep, header=heade
+00008e40: 722c 200a 2020 2020 2020 2020 2020 2020  r, .            
+00008e50: 2020 2020 2020 2020 2020 2020 7665 7262              verb
+00008e60: 6f73 653d 7665 7262 6f73 652c 206e 726f  ose=verbose, nro
+00008e70: 7773 3d4e 6f6e 652c 2074 6172 6765 743d  ws=None, target=
+00008e80: 7365 7474 696e 6773 2e6d 6f64 656c 7479  settings.modelty
+00008e90: 7065 2c20 6973 5f74 6573 745f 666c 6167  pe, is_test_flag
+00008ea0: 3d54 7275 6529 0a20 2020 2020 2020 2074  =True).        t
+00008eb0: 6573 7420 3d20 636f 7079 2e64 6565 7063  est = copy.deepc
+00008ec0: 6f70 7928 7465 7374 5f64 6174 6129 0a20  opy(test_data). 
+00008ed0: 2020 2023 2323 2073 6f6d 6574 696d 6573     ### sometimes
+00008ee0: 2c20 7465 7374 5f64 6174 6120 7265 7475  , test_data retu
+00008ef0: 726e 7320 4e6f 6e65 2069 6620 7468 6572  rns None if ther
+00008f00: 6520 6973 2061 6e20 6572 726f 722e 2023  e is an error. #
+00008f10: 2323 2323 2323 2323 230a 2020 2020 6966  #########.    if
+00008f20: 2074 6573 745f 6461 7461 2069 7320 6e6f   test_data is no
+00008f30: 7420 4e6f 6e65 3a0a 2020 2020 2020 2020  t None:.        
+00008f40: 7465 7374 5f64 6174 6120 3d20 7265 6d6f  test_data = remo
+00008f50: 7665 5f64 7570 6c69 6361 7465 5f63 6f6c  ve_duplicate_col
+00008f60: 735f 696e 5f64 6174 6173 6574 2874 6573  s_in_dataset(tes
+00008f70: 745f 6461 7461 290a 2020 2020 2020 2020  t_data).        
+00008f80: 7465 7374 5f69 6e64 6578 203d 2074 6573  test_index = tes
+00008f90: 745f 6461 7461 2e69 6e64 6578 0a20 2020  t_data.index.   
+00008fa0: 2020 2020 2070 7269 6e74 2827 2020 2020       print('    
+00008fb0: 4c6f 6164 6564 2074 6573 7420 6461 7461  Loaded test data
+00008fc0: 2e20 5368 6170 6520 3d20 2573 2720 2528  . Shape = %s' %(
+00008fd0: 7465 7374 5f64 6174 612e 7368 6170 652c  test_data.shape,
+00008fe0: 2929 0a20 2020 2020 2020 2023 2323 2323  )).        #####
+00008ff0: 2323 2020 4f6e 6365 2061 6761 696e 2072  ##  Once again r
+00009000: 656d 6f76 6520 7370 6563 6961 6c20 6368  emove special ch
+00009010: 6172 7320 696e 2074 6573 7420 6461 7461  ars in test data
+00009020: 2061 7320 7765 6c6c 2023 2323 0a20 2020   as well ###.   
+00009030: 2020 2020 2074 6573 745f 6461 7461 203d       test_data =
+00009040: 2075 6e69 712e 7472 616e 7366 6f72 6d28   uniq.transform(
+00009050: 7465 7374 5f64 6174 6129 0a0a 2020 2020  test_data)..    
+00009060: 2020 2020 2323 2320 5375 7070 6f73 6520      ### Suppose 
+00009070: 796f 7520 6861 7665 2063 6861 6e67 6564  you have changed
+00009080: 2074 6865 206e 616d 6573 2c20 7468 656e   the names, then
+00009090: 6e20 796f 7520 6d75 7374 206c 6f61 6420  n you must load 
+000090a0: 6974 2069 6e20 6461 736b 2061 6761 696e  it in dask again
+000090b0: 2023 2320 2020 200a 2020 2020 2020 2020   ##    .        
+000090c0: 6966 2073 7065 6369 616c 5f63 6861 725f  if special_char_
+000090d0: 666c 6167 3a0a 2020 2020 2020 2020 2020  flag:.          
+000090e0: 2020 6966 2064 6173 6b5f 7867 626f 6f73    if dask_xgboos
+000090f0: 745f 666c 6167 3a0a 2020 2020 2020 2020  t_flag:.        
+00009100: 2020 2020 2020 2020 2323 2320 5265 2d6c          ### Re-l
+00009110: 6f61 6420 7465 7374 2069 6e74 6f20 6461  oad test into da
+00009120: 736b 2069 6e20 6361 7365 206e 616d 6573  sk in case names
+00009130: 2068 6176 6520 6265 656e 2063 6861 6e67   have been chang
+00009140: 6564 2023 2323 0a20 2020 2020 2020 2020  ed ###.         
+00009150: 2020 2020 2020 2074 6573 7420 3d20 6c6f         test = lo
+00009160: 6164 5f64 6173 6b5f 6461 7461 2874 6573  ad_dask_data(tes
+00009170: 745f 6461 7461 2c20 7365 7029 0a20 2020  t_data, sep).   
+00009180: 2020 2020 2023 2323 2323 2063 6f6e 7665       ##### conve
+00009190: 7274 206d 6978 6564 2064 6174 6120 7479  rt mixed data ty
+000091a0: 7065 7320 746f 2073 7472 696e 6720 2323  pes to string ##
+000091b0: 2323 2323 2323 2323 2323 0a20 2020 2020  ##########.     
+000091c0: 2020 2023 7465 7374 5f64 6174 6120 3d20     #test_data = 
+000091d0: 4645 5f63 6f6e 7665 7274 5f6d 6978 6564  FE_convert_mixed
+000091e0: 5f64 6174 6174 7970 6573 5f74 6f5f 7374  _datatypes_to_st
+000091f0: 7269 6e67 2874 6573 745f 6461 7461 290a  ring(test_data).
+00009200: 2020 2020 2020 2020 2374 6573 7420 3d20          #test = 
+00009210: 4645 5f63 6f6e 7665 7274 5f6d 6978 6564  FE_convert_mixed
+00009220: 5f64 6174 6174 7970 6573 5f74 6f5f 7374  _datatypes_to_st
+00009230: 7269 6e67 2874 6573 7429 0a20 2020 2023  ring(test).    #
+00009240: 2323 2323 2323 2323 2323 2323 2020 2020  ############    
+00009250: 4320 4c20 4120 5320 5320 4920 4620 5920  C L A S S I F Y 
+00009260: 2020 2046 2045 2041 2054 2055 2052 2045     F E A T U R E
+00009270: 2053 2020 2020 2020 2323 2323 2323 2323   S      ########
+00009280: 2323 2323 2323 2323 2323 2323 0a20 2020  ############.   
+00009290: 2069 6620 6e72 6f77 7320 6973 204e 6f6e   if nrows is Non
+000092a0: 653a 0a20 2020 2020 2020 206e 726f 7773  e:.        nrows
+000092b0: 5f6c 696d 6974 203d 206d 6178 726f 7773  _limit = maxrows
+000092c0: 0a20 2020 2065 6c73 653a 0a20 2020 2020  .    else:.     
+000092d0: 2020 206e 726f 7773 5f6c 696d 6974 203d     nrows_limit =
+000092e0: 2069 6e74 286d 696e 286e 726f 7773 2c20   int(min(nrows, 
+000092f0: 6d61 7872 6f77 7329 290a 2020 2020 2323  maxrows)).    ##
+00009300: 2323 2079 6f75 2063 616e 2075 7365 2074  ## you can use t
+00009310: 6172 6765 7473 2061 7320 6120 6c69 7374  argets as a list
+00009320: 2077 6865 7265 7665 7220 796f 7520 6368   wherever you ch
+00009330: 6f6f 7365 2023 2323 2323 0a20 2020 2069  oose #####.    i
+00009340: 6620 6973 696e 7374 616e 6365 2874 6172  f isinstance(tar
+00009350: 6765 742c 2073 7472 293a 0a20 2020 2020  get, str):.     
+00009360: 2020 2074 6172 6765 7473 203d 205b 7461     targets = [ta
+00009370: 7267 6574 5d0a 2020 2020 656c 7365 3a0a  rget].    else:.
+00009380: 2020 2020 2020 2020 7461 7267 6574 7320          targets 
+00009390: 3d20 636f 7079 2e64 6565 7063 6f70 7928  = copy.deepcopy(
+000093a0: 7461 7267 6574 290a 2020 2020 6966 2064  target).    if d
+000093b0: 6174 616e 616d 652e 7368 6170 655b 305d  ataname.shape[0]
+000093c0: 203e 3d20 6e72 6f77 735f 6c69 6d69 743a   >= nrows_limit:
+000093d0: 0a20 2020 2020 2020 2070 7269 6e74 2827  .        print('
+000093e0: 436c 6173 7369 6679 696e 6720 6665 6174  Classifying feat
+000093f0: 7572 6573 2075 7369 6e67 2061 2072 616e  ures using a ran
+00009400: 646f 6d20 7361 6d70 6c65 206f 6620 2573  dom sample of %s
+00009410: 2072 6f77 7320 6672 6f6d 2064 6174 6173   rows from datas
+00009420: 6574 2e2e 2e27 2025 6e72 6f77 735f 6c69  et...' %nrows_li
+00009430: 6d69 7429 0a20 2020 2020 2020 2023 2323  mit).        ###
+00009440: 2323 2079 6f75 2063 616e 2075 7365 206e  ## you can use n
+00009450: 726f 7773 5f6c 696d 6974 2074 6f20 7365  rows_limit to se
+00009460: 6c65 6374 2061 2073 6d61 6c6c 2073 616d  lect a small sam
+00009470: 706c 6520 6672 6f6d 2064 6174 6120 7365  ple from data se
+00009480: 7420 2323 2323 2323 2323 2323 2323 2323  t ##############
+00009490: 2323 2323 2323 2323 2323 0a20 2020 2020  ##########.     
+000094a0: 2020 2074 7261 696e 5f73 6d61 6c6c 203d     train_small =
+000094b0: 2045 4441 5f72 616e 646f 6d6c 795f 7365   EDA_randomly_se
+000094c0: 6c65 6374 5f72 6f77 735f 6672 6f6d 5f64  lect_rows_from_d
+000094d0: 6174 6166 7261 6d65 2864 6174 616e 616d  ataframe(datanam
+000094e0: 652c 2074 6172 6765 7473 2c20 6e72 6f77  e, targets, nrow
+000094f0: 735f 6c69 6d69 742c 2044 535f 4c45 4e3d  s_limit, DS_LEN=
+00009500: 6461 7461 6e61 6d65 2e73 6861 7065 5b30  dataname.shape[0
+00009510: 5d29 0a20 2020 2020 2020 2066 6561 7475  ]).        featu
+00009520: 7265 735f 6469 6374 203d 2063 6c61 7373  res_dict = class
+00009530: 6966 795f 6665 6174 7572 6573 2874 7261  ify_features(tra
+00009540: 696e 5f73 6d61 6c6c 2c20 7461 7267 6574  in_small, target
+00009550: 290a 2020 2020 656c 7365 3a0a 2020 2020  ).    else:.    
+00009560: 2020 2020 6665 6174 7572 6573 5f64 6963      features_dic
+00009570: 7420 3d20 636c 6173 7369 6679 5f66 6561  t = classify_fea
+00009580: 7475 7265 7328 6461 7461 6e61 6d65 2c20  tures(dataname, 
+00009590: 7461 7267 6574 290a 2020 2020 2323 2323  target).    ####
+000095a0: 204e 6f77 2077 6520 6861 7665 2074 6f20   Now we have to 
+000095b0: 6472 6f70 2063 6572 7461 696e 2063 6f6c  drop certain col
+000095c0: 7320 7468 6174 206d 7573 7420 6265 2064  s that must be d
+000095d0: 656c 6574 6564 2023 2323 2323 2323 2323  eleted #########
+000095e0: 2323 2323 2323 2323 2323 2323 0a20 2020  ############.   
+000095f0: 2072 656d 6f76 655f 636f 6c73 203d 2066   remove_cols = f
+00009600: 6561 7475 7265 735f 6469 6374 5b27 6469  eatures_dict['di
+00009610: 7363 7265 7465 5f73 7472 696e 675f 7661  screte_string_va
+00009620: 7273 275d 202b 2066 6561 7475 7265 735f  rs'] + features_
+00009630: 6469 6374 5b27 636f 6c73 5f64 656c 6574  dict['cols_delet
+00009640: 6527 5d0a 2020 2020 6966 206c 656e 2872  e'].    if len(r
+00009650: 656d 6f76 655f 636f 6c73 2920 3e20 303a  emove_cols) > 0:
+00009660: 0a20 2020 2020 2020 2070 7269 6e74 2827  .        print('
+00009670: 7472 6169 6e20 6461 7461 2073 6861 7065  train data shape
+00009680: 2062 6566 6f72 6520 6472 6f70 7069 6e67   before dropping
+00009690: 2025 6420 636f 6c75 6d6e 7320 3d20 2573   %d columns = %s
+000096a0: 2720 2528 6c65 6e28 7265 6d6f 7665 5f63  ' %(len(remove_c
+000096b0: 6f6c 7329 2c20 6461 7461 6e61 6d65 2e73  ols), dataname.s
+000096c0: 6861 7065 2c29 290a 2020 2020 2020 2020  hape,)).        
+000096d0: 6461 7461 6e61 6d65 2e64 726f 7028 7265  dataname.drop(re
+000096e0: 6d6f 7665 5f63 6f6c 732c 2061 7869 733d  move_cols, axis=
+000096f0: 312c 2069 6e70 6c61 6365 3d54 7275 6529  1, inplace=True)
+00009700: 0a20 2020 2020 2020 2070 7269 6e74 2827  .        print('
+00009710: 5c74 7472 6169 6e20 6461 7461 2073 6861  \ttrain data sha
+00009720: 7065 2061 6674 6572 2064 726f 7070 696e  pe after droppin
+00009730: 6720 636f 6c75 6d6e 7320 3d20 2573 2720  g columns = %s' 
+00009740: 2528 6461 7461 6e61 6d65 2e73 6861 7065  %(dataname.shape
+00009750: 2c29 290a 2020 2020 2020 2020 7472 6169  ,)).        trai
+00009760: 6e20 3d20 6c6f 6164 5f64 6173 6b5f 6461  n = load_dask_da
+00009770: 7461 2864 6174 616e 616d 652c 2073 6570  ta(dataname, sep
+00009780: 290a 2020 2020 2020 2020 6966 206e 6f74  ).        if not
+00009790: 2074 6573 745f 6461 7461 2069 7320 4e6f   test_data is No
+000097a0: 6e65 3a0a 2020 2020 2020 2020 2020 2020  ne:.            
+000097b0: 7465 7374 5f64 6174 612e 6472 6f70 2872  test_data.drop(r
+000097c0: 656d 6f76 655f 636f 6c73 2c20 6178 6973  emove_cols, axis
+000097d0: 3d31 2c20 696e 706c 6163 653d 5472 7565  =1, inplace=True
+000097e0: 290a 2020 2020 2020 2020 2020 2020 7465  ).            te
+000097f0: 7374 203d 206c 6f61 645f 6461 736b 5f64  st = load_dask_d
+00009800: 6174 6128 7465 7374 5f64 6174 612c 2073  ata(test_data, s
+00009810: 6570 290a 2020 2020 2323 2323 2323 2323  ep).    ########
+00009820: 2323 2323 2323 2323 2020 2020 4c6f 6164  ########    Load
+00009830: 2064 6174 6120 6672 616d 6520 7769 7468   data frame with
+00009840: 2064 6174 6520 7661 7220 6665 6174 7572   date var featur
+00009850: 6573 2063 6f72 7265 6374 6c79 2074 6869  es correctly thi
+00009860: 7320 7469 6d65 2023 2323 2323 2323 2323  s time #########
+00009870: 2323 2323 2323 230a 2020 2020 6966 206c  #######.    if l
+00009880: 656e 2866 6561 7475 7265 735f 6469 6374  en(features_dict
+00009890: 5b27 6461 7465 5f76 6172 7327 5d29 203e  ['date_vars']) >
+000098a0: 2030 3a0a 2020 2020 2020 2020 7072 696e   0:.        prin
+000098b0: 7428 2743 6175 7469 6f6e 3a20 5369 6e63  t('Caution: Sinc
+000098c0: 6520 7468 6572 6520 6172 6520 6461 7465  e there are date
+000098d0: 2d74 696d 6520 7661 7269 6162 6c65 7320  -time variables 
+000098e0: 696e 2064 6174 6173 6574 2c20 6974 2069  in dataset, it i
+000098f0: 7320 6265 7374 2074 6f20 6c6f 6164 2074  s best to load t
+00009900: 6865 6d20 7573 696e 6720 7061 6e64 6173  hem using pandas
+00009910: 2729 0a20 2020 2020 2020 2064 6173 6b5f  ').        dask_
+00009920: 7867 626f 6f73 745f 666c 6167 203d 2046  xgboost_flag = F
+00009930: 616c 7365 2023 2323 2053 6574 2074 6865  alse ### Set the
+00009940: 2064 6173 6b20 666c 6167 2074 6f20 6265   dask flag to be
+00009950: 2046 616c 7365 2073 696e 6365 2069 7420   False since it 
+00009960: 6973 206e 6f77 2062 6563 6f6d 696e 6720  is now becoming 
+00009970: 5061 6e64 6173 2064 6174 6166 7261 6d65  Pandas dataframe
+00009980: 200a 2020 2020 2020 2020 6461 7465 5f74   .        date_t
+00009990: 696d 655f 7661 7273 203d 2066 6561 7475  ime_vars = featu
+000099a0: 7265 735f 6469 6374 5b27 6461 7465 5f76  res_dict['date_v
+000099b0: 6172 7327 5d0a 2020 2020 2020 2020 6461  ars'].        da
+000099c0: 7461 6e61 6d65 203d 206c 6f61 645f 6669  taname = load_fi
+000099d0: 6c65 5f64 6174 6166 7261 6d65 2864 6174  le_dataframe(dat
+000099e0: 616e 616d 652c 2073 6570 3d73 6570 2c20  aname, sep=sep, 
+000099f0: 6865 6164 6572 3d68 6561 6465 722c 2076  header=header, v
+00009a00: 6572 626f 7365 3d76 6572 626f 7365 2c20  erbose=verbose, 
+00009a10: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00009a20: 2020 2020 2020 2020 2020 2020 206e 726f               nro
+00009a30: 7773 3d6e 726f 7773 2c20 7061 7273 655f  ws=nrows, parse_
+00009a40: 6461 7465 733d 6461 7465 5f74 696d 655f  dates=date_time_
+00009a50: 7661 7273 2c20 7461 7267 6574 3d74 6172  vars, target=tar
+00009a60: 6765 7429 0a20 2020 2020 2020 2069 6620  get).        if 
+00009a70: 2864 6174 616e 616d 652e 6d65 6d6f 7279  (dataname.memory
+00009a80: 5f75 7361 6765 2829 2e73 756d 2829 2f31  _usage().sum()/1
+00009a90: 3030 3030 3030 2920 3e20 6d65 6d5f 6c69  000000) > mem_li
+00009aa0: 6d69 743a 0a20 2020 2020 2020 2020 2020  mit:.           
+00009ab0: 2064 6174 616e 616d 6520 3d20 7265 6475   dataname = redu
+00009ac0: 6365 5f6d 656d 5f75 7361 6765 2864 6174  ce_mem_usage(dat
+00009ad0: 616e 616d 6529 0a20 2020 2020 2020 2074  aname).        t
+00009ae0: 7261 696e 203d 206c 6f61 645f 6461 736b  rain = load_dask
+00009af0: 5f64 6174 6128 6461 7461 6e61 6d65 2c20  _data(dataname, 
+00009b00: 7365 7029 0a20 2020 2020 2020 2069 6620  sep).        if 
+00009b10: 6e6f 7420 7465 7374 5f64 6174 6120 6973  not test_data is
+00009b20: 204e 6f6e 653a 0a20 2020 2020 2020 2020   None:.         
+00009b30: 2020 2023 2323 2059 6f75 206d 7573 7420     ### You must 
+00009b40: 6c6f 6164 2074 6865 2065 6e74 6972 6520  load the entire 
+00009b50: 7465 7374 2064 6174 6120 2d20 7468 6572  test data - ther
+00009b60: 6520 6973 206e 6f20 6c69 6d69 7420 7468  e is no limit th
+00009b70: 6572 6520 2323 2323 2323 2323 2323 2323  ere ############
+00009b80: 2323 2323 2323 0a20 2020 2020 2020 2020  ######.         
+00009b90: 2020 2023 2323 2074 6573 745f 6461 7461     ### test_data
+00009ba0: 2069 7320 7468 6520 7061 6e64 6173 2064   is the pandas d
+00009bb0: 6174 6166 7261 6d65 206f 626a 6563 7420  ataframe object 
+00009bc0: 616e 6420 7465 7374 2069 7320 6461 736b  and test is dask
+00009bd0: 2064 6174 6166 7261 6d65 206f 626a 6563   dataframe objec
+00009be0: 7420 2323 0a20 2020 2020 2020 2020 2020  t ##.           
+00009bf0: 2074 6573 745f 6461 7461 203d 206c 6f61   test_data = loa
+00009c00: 645f 6669 6c65 5f64 6174 6166 7261 6d65  d_file_dataframe
+00009c10: 2874 6573 745f 6461 7461 2c20 7365 703d  (test_data, sep=
+00009c20: 7365 702c 2068 6561 6465 723d 6865 6164  sep, header=head
+00009c30: 6572 2c20 7665 7262 6f73 653d 7665 7262  er, verbose=verb
+00009c40: 6f73 652c 200a 2020 2020 2020 2020 2020  ose, .          
+00009c50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00009c60: 2020 2020 2020 206e 726f 7773 3d6e 726f         nrows=nro
+00009c70: 7773 2c20 7061 7273 655f 6461 7465 733d  ws, parse_dates=
+00009c80: 6461 7465 5f74 696d 655f 7661 7273 2c20  date_time_vars, 
+00009c90: 7461 7267 6574 3d73 6574 7469 6e67 732e  target=settings.
+00009ca0: 6d6f 6465 6c74 7970 652c 2069 735f 7465  modeltype, is_te
+00009cb0: 7374 5f66 6c61 673d 5472 7565 2029 0a20  st_flag=True ). 
+00009cc0: 2020 2020 2020 2020 2020 2074 6573 7420             test 
+00009cd0: 3d20 636f 7079 2e64 6565 7063 6f70 7928  = copy.deepcopy(
+00009ce0: 7465 7374 5f64 6174 6129 0a20 2020 2020  test_data).     
+00009cf0: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+00009d00: 2020 2020 2074 6573 745f 6461 7461 203d       test_data =
+00009d10: 204e 6f6e 650a 2020 2020 2020 2020 2020   None.          
+00009d20: 2020 7465 7374 203d 204e 6f6e 650a 2020    test = None.  
+00009d30: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+00009d40: 7472 6169 6e5f 696e 6465 7820 3d20 6461  train_index = da
+00009d50: 7461 6e61 6d65 2e69 6e64 6578 0a20 2020  taname.index.   
+00009d60: 2020 2020 2069 6620 7465 7374 5f64 6174       if test_dat
+00009d70: 6120 6973 206e 6f74 204e 6f6e 653a 0a20  a is not None:. 
+00009d80: 2020 2020 2020 2020 2020 2074 6573 745f             test_
+00009d90: 696e 6465 7820 3d20 7465 7374 5f64 6174  index = test_dat
+00009da0: 612e 696e 6465 780a 2020 2020 2323 2323  a.index.    ####
+00009db0: 2323 2323 2323 2323 2323 2323 2020 2058  ############   X
+00009dc0: 2047 2042 204f 204f 2053 2054 2020 2020   G B O O S T    
+00009dd0: 2020 4420 4520 4620 4120 5520 4c20 5420    D E F A U L T 
+00009de0: 5320 2020 2020 2023 2323 2323 2323 2323  S      #########
+00009df0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00009e00: 2323 2323 2323 2323 2323 2323 230a 2020  #############.  
+00009e10: 2020 2323 2323 2049 6620 7468 6572 6520    #### If there 
+00009e20: 6172 6520 6d6f 7265 2074 6861 6e20 3330  are more than 30
+00009e30: 2063 6174 6567 6f72 6963 616c 2076 6172   categorical var
+00009e40: 6961 626c 6573 2069 6e20 6120 6461 7461  iables in a data
+00009e50: 2073 6574 2c20 6974 2069 7320 776f 7274   set, it is wort
+00009e60: 6820 7265 6475 6369 6e67 2066 6561 7475  h reducing featu
+00009e70: 7265 732e 0a20 2020 2023 2323 2320 204f  res..    ####  O
+00009e80: 7468 6572 7769 7365 2e20 5847 426f 6f73  therwise. XGBoos
+00009e90: 7420 6973 2070 7265 7474 7920 676f 6f64  t is pretty good
+00009ea0: 2061 7420 6669 6e64 696e 6720 7468 6520   at finding the 
+00009eb0: 6265 7374 2066 6561 7475 7265 7320 7768  best features wh
+00009ec0: 6574 6865 7220 6361 7420 6f72 206e 756d  ether cat or num
+00009ed0: 6572 6963 2021 0a20 2020 2023 2323 2323  eric !.    #####
+00009ee0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00009ef0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00009f00: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00009f10: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00009f20: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00009f30: 2323 2323 2323 2323 2323 2323 0a0a 2020  ############..  
+00009f40: 2020 7374 6172 745f 7469 6d65 203d 2074    start_time = t
+00009f50: 696d 652e 7469 6d65 2829 0a20 2020 206e  ime.time().    n
+00009f60: 5f73 706c 6974 7320 3d20 350a 2020 2020  _splits = 5.    
+00009f70: 6d61 785f 6465 7074 6820 3d20 380a 2020  max_depth = 8.  
+00009f80: 2020 2323 2323 2323 2323 2323 2323 2323    ##############
+00009f90: 2323 2323 2323 2323 2020 2049 204d 2050  ########   I M P
+00009fa0: 204f 2052 2054 2041 204e 2054 2020 2020   O R T A N T    
+00009fb0: 4420 4520 4620 4120 5520 4c20 5420 5320  D E F A U L T S 
+00009fc0: 2323 2323 2323 2323 2323 2323 2323 0a20  ##############. 
+00009fd0: 2020 2073 7562 7361 6d70 6c65 203d 2020     subsample =  
+00009fe0: 302e 370a 2020 2020 636f 6c5f 7375 625f  0.7.    col_sub_
+00009ff0: 7361 6d70 6c65 203d 2030 2e37 0a20 2020  sample = 0.7.   
+0000a000: 2074 6573 745f 7369 7a65 203d 2030 2e32   test_size = 0.2
+0000a010: 0a20 2020 2023 7072 696e 7428 2774 6573  .    #print('tes
+0000a020: 745f 7369 7a65 203d 2025 7327 2025 7465  t_size = %s' %te
+0000a030: 7374 5f73 697a 6529 0a20 2020 2073 6565  st_size).    see
+0000a040: 6420 3d20 310a 2020 2020 6561 726c 795f  d = 1.    early_
+0000a050: 7374 6f70 7069 6e67 203d 2035 0a20 2020  stopping = 5.   
+0000a060: 2023 2323 2323 2323 2041 6c6c 2074 6865   ####### All the
+0000a070: 2064 6566 6175 6c74 2070 6172 616d 6574   default paramet
+0000a080: 6572 7320 6172 6520 7365 7420 7570 206e  ers are set up n
+0000a090: 6f77 2023 2323 2323 2323 2323 0a20 2020  ow #########.   
+0000a0a0: 206b 6620 3d20 4b46 6f6c 6428 6e5f 7370   kf = KFold(n_sp
+0000a0b0: 6c69 7473 3d6e 5f73 706c 6974 7329 0a20  lits=n_splits). 
+0000a0c0: 2020 2023 2323 2323 2323 2323 2020 2020     #########    
+0000a0d0: 2047 2050 2055 2020 2020 2050 2052 204f   G P U     P R O
+0000a0e0: 2043 2045 2053 2053 2049 204e 2047 2020   C E S S I N G  
+0000a0f0: 2020 2020 4220 4520 4720 4920 4e20 5320      B E G I N S 
+0000a100: 2020 2023 2323 2323 2323 2323 2323 230a     ############.
+0000a110: 2020 2020 2323 2323 2323 2054 6869 7320      ###### This 
+0000a120: 6973 2077 6865 7265 2077 6520 7365 7420  is where we set 
+0000a130: 7468 6520 4350 5520 616e 6420 4750 5520  the CPU and GPU 
+0000a140: 7061 7261 6d65 7465 7273 2066 6f72 2058  parameters for X
+0000a150: 4742 6f6f 7374 0a20 2020 2047 5055 5f65  GBoost.    GPU_e
+0000a160: 7869 7374 7320 3d20 6368 6563 6b5f 6966  xists = check_if
+0000a170: 5f47 5055 5f65 7869 7374 7328 7665 7262  _GPU_exists(verb
+0000a180: 6f73 6529 0a20 2020 206e 5f77 6f72 6b65  ose).    n_worke
+0000a190: 7273 203d 2067 6574 5f63 7075 5f77 6f72  rs = get_cpu_wor
+0000a1a0: 6b65 725f 636f 756e 7428 290a 2020 2020  ker_count().    
+0000a1b0: 2323 2323 2320 2020 5365 7420 7468 6520  #####   Set the 
+0000a1c0: 5363 6f72 696e 6720 5061 7261 6d65 7465  Scoring Paramete
+0000a1d0: 7273 2068 6572 6520 6261 7365 6420 6f6e  rs here based on
+0000a1e0: 2065 6163 6820 6d6f 6465 6c20 616e 6420   each model and 
+0000a1f0: 7072 6566 6572 656e 6365 7320 6f66 2075  preferences of u
+0000a200: 7365 7220 2323 230a 2020 2020 6370 755f  ser ###.    cpu_
+0000a210: 7061 7261 6d73 203d 207b 7d0a 2020 2020  params = {}.    
+0000a220: 7061 7261 6d20 3d20 7b7d 0a20 2020 2063  param = {}.    c
+0000a230: 7075 5f74 7265 655f 6d65 7468 6f64 203d  pu_tree_method =
+0000a240: 2027 6869 7374 270a 2020 2020 7472 6565   'hist'.    tree
+0000a250: 5f6d 6574 686f 6420 3d20 2768 6973 7427  _method = 'hist'
+0000a260: 0a20 2020 206e 5f65 7374 696d 6174 6f72  .    n_estimator
+0000a270: 7320 3d20 3130 300a 2020 2020 6370 755f  s = 100.    cpu_
+0000a280: 7061 7261 6d73 5b27 6e74 6872 6561 6427  params['nthread'
+0000a290: 5d20 3d20 2d31 0a20 2020 2063 7075 5f70  ] = -1.    cpu_p
+0000a2a0: 6172 616d 735b 2774 7265 655f 6d65 7468  arams['tree_meth
+0000a2b0: 6f64 275d 203d 2027 6869 7374 270a 2020  od'] = 'hist'.  
+0000a2c0: 2020 6370 755f 7061 7261 6d73 5b27 6574    cpu_params['et
+0000a2d0: 6127 5d20 3d20 302e 3031 0a20 2020 2063  a'] = 0.01.    c
+0000a2e0: 7075 5f70 6172 616d 735b 2773 7562 7361  pu_params['subsa
+0000a2f0: 6d70 6c65 275d 203d 2030 2e35 0a20 2020  mple'] = 0.5.   
+0000a300: 2063 7075 5f70 6172 616d 735b 2767 726f   cpu_params['gro
+0000a310: 775f 706f 6c69 6379 275d 203d 2027 6465  w_policy'] = 'de
+0000a320: 7074 6877 6973 6527 2023 276c 6f73 7367  pthwise' #'lossg
+0000a330: 7569 6465 270a 2020 2020 6370 755f 7061  uide'.    cpu_pa
+0000a340: 7261 6d73 5b27 6e5f 6573 7469 6d61 746f  rams['n_estimato
+0000a350: 7273 275d 203d 206e 5f65 7374 696d 6174  rs'] = n_estimat
+0000a360: 6f72 730a 2020 2020 6370 755f 7061 7261  ors.    cpu_para
+0000a370: 6d73 5b27 6d61 785f 6465 7074 6827 5d20  ms['max_depth'] 
+0000a380: 3d20 6d61 785f 6465 7074 680a 2020 2020  = max_depth.    
+0000a390: 6370 755f 7061 7261 6d73 5b27 6d61 785f  cpu_params['max_
+0000a3a0: 6c65 6176 6573 275d 203d 2030 0a20 2020  leaves'] = 0.   
+0000a3b0: 2063 7075 5f70 6172 616d 735b 2776 6572   cpu_params['ver
+0000a3c0: 626f 7369 7479 275d 203d 2030 0a20 2020  bosity'] = 0.   
+0000a3d0: 2063 7075 5f70 6172 616d 735b 2767 7075   cpu_params['gpu
+0000a3e0: 5f69 6427 5d20 3d20 300a 2020 2020 6370  _id'] = 0.    cp
+0000a3f0: 755f 7061 7261 6d73 5b27 7570 6461 7465  u_params['update
+0000a400: 7227 5d20 3d20 2767 726f 775f 636f 6c6d  r'] = 'grow_colm
+0000a410: 616b 6572 270a 2020 2020 6370 755f 7061  aker'.    cpu_pa
+0000a420: 7261 6d73 5b27 7072 6564 6963 746f 7227  rams['predictor'
+0000a430: 5d20 3d20 2763 7075 5f70 7265 6469 6374  ] = 'cpu_predict
+0000a440: 6f72 270a 2020 2020 6370 755f 7061 7261  or'.    cpu_para
+0000a450: 6d73 5b27 6e75 6d5f 7061 7261 6c6c 656c  ms['num_parallel
+0000a460: 5f74 7265 6527 5d20 3d20 310a 2020 2020  _tree'] = 1.    
+0000a470: 6966 2047 5055 5f65 7869 7374 733a 0a20  if GPU_exists:. 
+0000a480: 2020 2020 2020 2023 2323 2054 6869 7320         ### This 
+0000a490: 6861 7320 6265 656e 2066 6978 6564 2023  has been fixed #
+0000a4a0: 2323 0a20 2020 2020 2020 2074 7265 655f  ##.        tree_
+0000a4b0: 6d65 7468 6f64 203d 2027 6770 755f 6869  method = 'gpu_hi
+0000a4c0: 7374 270a 2020 2020 2020 2020 7061 7261  st'.        para
+0000a4d0: 6d5b 276e 7468 7265 6164 275d 203d 202d  m['nthread'] = -
+0000a4e0: 310a 2020 2020 2020 2020 7061 7261 6d5b  1.        param[
+0000a4f0: 2774 7265 655f 6d65 7468 6f64 275d 203d  'tree_method'] =
+0000a500: 2027 6770 755f 6869 7374 270a 2020 2020   'gpu_hist'.    
+0000a510: 2020 2020 7061 7261 6d5b 2765 7461 275d      param['eta']
+0000a520: 203d 2030 2e30 310a 2020 2020 2020 2020   = 0.01.        
+0000a530: 7061 7261 6d5b 2773 7562 7361 6d70 6c65  param['subsample
+0000a540: 275d 203d 2030 2e35 0a20 2020 2020 2020  '] = 0.5.       
+0000a550: 2070 6172 616d 5b27 6772 6f77 5f70 6f6c   param['grow_pol
+0000a560: 6963 7927 5d20 3d20 2764 6570 7468 7769  icy'] = 'depthwi
+0000a570: 7365 2720 2320 276c 6f73 7367 7569 6465  se' # 'lossguide
+0000a580: 2720 2320 0a20 2020 2020 2020 2070 6172  ' # .        par
+0000a590: 616d 5b27 6e5f 6573 7469 6d61 746f 7273  am['n_estimators
+0000a5a0: 275d 203d 206e 5f65 7374 696d 6174 6f72  '] = n_estimator
+0000a5b0: 730a 2020 2020 2020 2020 7061 7261 6d5b  s.        param[
+0000a5c0: 276d 6178 5f64 6570 7468 275d 203d 206d  'max_depth'] = m
+0000a5d0: 6178 5f64 6570 7468 0a20 2020 2020 2020  ax_depth.       
+0000a5e0: 2070 6172 616d 5b27 6d61 785f 6c65 6176   param['max_leav
+0000a5f0: 6573 275d 203d 2030 0a20 2020 2020 2020  es'] = 0.       
+0000a600: 2070 6172 616d 5b27 7665 7262 6f73 6974   param['verbosit
+0000a610: 7927 5d20 3d20 300a 2020 2020 2020 2020  y'] = 0.        
+0000a620: 7061 7261 6d5b 2767 7075 5f69 6427 5d20  param['gpu_id'] 
+0000a630: 3d20 300a 2020 2020 2020 2020 7061 7261  = 0.        para
+0000a640: 6d5b 2775 7064 6174 6572 275d 203d 2027  m['updater'] = '
+0000a650: 6772 6f77 5f67 7075 5f68 6973 7427 2023  grow_gpu_hist' #
+0000a660: 2770 7275 6e65 270a 2020 2020 2020 2020  'prune'.        
+0000a670: 7061 7261 6d5b 2770 7265 6469 6374 6f72  param['predictor
+0000a680: 275d 203d 2027 6770 755f 7072 6564 6963  '] = 'gpu_predic
+0000a690: 746f 7227 0a20 2020 2020 2020 2070 6172  tor'.        par
+0000a6a0: 616d 5b27 6e75 6d5f 7061 7261 6c6c 656c  am['num_parallel
+0000a6b0: 5f74 7265 6527 5d20 3d20 310a 2020 2020  _tree'] = 1.    
+0000a6c0: 2020 2020 6770 7569 6420 3d20 300a 2020      gpuid = 0.  
+0000a6d0: 2020 2020 2020 6966 2076 6572 626f 7365        if verbose
+0000a6e0: 3a0a 2020 2020 2020 2020 2020 2020 7072  :.            pr
+0000a6f0: 696e 7428 2720 2020 2054 756e 696e 6720  int('    Tuning 
+0000a700: 5847 426f 6f73 7420 7573 696e 6720 4750  XGBoost using GP
+0000a710: 5520 6879 7065 722d 7061 7261 6d65 7465  U hyper-paramete
+0000a720: 7273 2e20 5468 6973 2077 696c 6c20 7461  rs. This will ta
+0000a730: 6b65 2074 696d 652e 2e2e 2729 0a20 2020  ke time...').   
+0000a740: 2065 6c73 653a 0a20 2020 2020 2020 2070   else:.        p
+0000a750: 6172 616d 203d 2063 6f70 792e 6465 6570  aram = copy.deep
+0000a760: 636f 7079 2863 7075 5f70 6172 616d 7329  copy(cpu_params)
+0000a770: 0a20 2020 2020 2020 2067 7075 6964 203d  .        gpuid =
+0000a780: 204e 6f6e 650a 2020 2020 2020 2020 6966   None.        if
+0000a790: 2076 6572 626f 7365 3a0a 2020 2020 2020   verbose:.      
+0000a7a0: 2020 2020 2020 7072 696e 7428 2720 2020        print('   
+0000a7b0: 2054 756e 696e 6720 5847 426f 6f73 7420   Tuning XGBoost 
+0000a7c0: 7573 696e 6720 4350 5520 6879 7065 722d  using CPU hyper-
+0000a7d0: 7061 7261 6d65 7465 7273 2e20 5468 6973  parameters. This
+0000a7e0: 2077 696c 6c20 7461 6b65 2074 696d 652e   will take time.
+0000a7f0: 2e2e 2729 0a20 2020 2023 2323 2323 2323  ..').    #######
+0000a800: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000a810: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000a820: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000a830: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000a840: 2323 2323 2323 2323 2323 0a20 2020 2023  ##########.    #
+0000a850: 2323 2323 2323 2323 2323 2323 2020 2044  ############   D
+0000a860: 2045 2054 2045 2043 2054 2020 5349 4e47   E T E C T  SING
+0000a870: 4c45 204f 5220 4d55 4c54 492d 4c41 4245  LE OR MULTI-LABE
+0000a880: 4c20 5052 4f42 4c45 4d20 2020 2020 2023  L PROBLEM      #
 0000a890: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000a8a0: 2323 2323 2323 0a20 2020 2069 6620 6973  ######.    if is
-0000a8b0: 696e 7374 616e 6365 2874 6172 6765 742c  instance(target,
-0000a8c0: 2073 7472 293a 0a20 2020 2020 2020 2074   str):.        t
-0000a8d0: 6172 6765 7420 3d20 5b74 6172 6765 745d  arget = [target]
-0000a8e0: 0a20 2020 2020 2020 2073 6574 7469 6e67  .        setting
-0000a8f0: 732e 6d75 6c74 695f 6c61 6265 6c20 3d20  s.multi_label = 
-0000a900: 4661 6c73 650a 2020 2020 656c 7365 3a0a  False.    else:.
-0000a910: 2020 2020 2020 2020 6966 206c 656e 2874          if len(t
-0000a920: 6172 6765 7429 203c 3d20 313a 0a20 2020  arget) <= 1:.   
-0000a930: 2020 2020 2020 2020 2073 6574 7469 6e67           setting
+0000a8a0: 0a20 2020 2023 2323 2323 2323 2323 2323  .    ###########
+0000a8b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000a8c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000a8d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000a8e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000a8f0: 2323 2323 2323 0a20 2020 2069 6620 6973  ######.    if is
+0000a900: 696e 7374 616e 6365 2874 6172 6765 742c  instance(target,
+0000a910: 2073 7472 293a 0a20 2020 2020 2020 2074   str):.        t
+0000a920: 6172 6765 7420 3d20 5b74 6172 6765 745d  arget = [target]
+0000a930: 0a20 2020 2020 2020 2073 6574 7469 6e67  .        setting
 0000a940: 732e 6d75 6c74 695f 6c61 6265 6c20 3d20  s.multi_label = 
-0000a950: 4661 6c73 650a 2020 2020 2020 2020 656c  False.        el
-0000a960: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
-0000a970: 7365 7474 696e 6773 2e6d 756c 7469 5f6c  settings.multi_l
-0000a980: 6162 656c 203d 2054 7275 650a 2020 2020  abel = True.    
-0000a990: 2323 2323 2059 6f75 206e 6565 6420 746f  #### You need to
-0000a9a0: 206d 616b 6520 7375 7265 206f 6e6c 7920   make sure only 
-0000a9b0: 5369 6e67 6c65 204c 6162 656c 2070 726f  Single Label pro
-0000a9c0: 626c 656d 7320 6172 6520 6861 6e64 6c65  blems are handle
-0000a9d0: 6420 696e 2074 6172 6765 7420 656e 636f  d in target enco
-0000a9e0: 6469 6e67 210a 2020 2020 6966 2073 6574  ding!.    if set
-0000a9f0: 7469 6e67 732e 6d75 6c74 695f 6c61 6265  tings.multi_labe
-0000aa00: 6c3a 0a20 2020 2020 2020 2069 6620 7665  l:.        if ve
-0000aa10: 7262 6f73 653a 0a20 2020 2020 2020 2020  rbose:.         
-0000aa20: 2020 2070 7269 6e74 2827 5475 726e 696e     print('Turnin
-0000aa30: 6720 6f66 6620 5461 7267 6574 2065 6e63  g off Target enc
-0000aa40: 6f64 696e 6720 666f 7220 6d75 6c74 692d  oding for multi-
-0000aa50: 6c61 6265 6c20 7072 6f62 6c65 6d73 206c  label problems l
-0000aa60: 696b 6520 7468 6973 2064 6174 6120 7365  ike this data se
-0000aa70: 742e 2e2e 2729 0a20 2020 2020 2020 2020  t...').         
-0000aa80: 2020 2070 7269 6e74 2827 2020 2020 7369     print('    si
-0000aa90: 6e63 6520 4665 6174 7572 6520 456e 6769  nce Feature Engi
-0000aaa0: 6e65 6572 696e 6720 6d6f 6475 6c65 2063  neering module c
-0000aab0: 616e 6e6f 7420 6861 6e64 6c65 204d 756c  annot handle Mul
-0000aac0: 7469 204c 6162 656c 2054 6172 6765 7473  ti Label Targets
-0000aad0: 2c20 7475 726e 6f66 6620 7461 7267 6574  , turnoff target
-0000aae0: 5f65 6e63 5f63 6174 5f66 6561 7475 7265  _enc_cat_feature
-0000aaf0: 7320 746f 2046 616c 7365 2729 0a20 2020  s to False').   
-0000ab00: 2020 2020 2074 6172 6765 745f 656e 635f       target_enc_
-0000ab10: 6361 745f 6665 6174 7572 6573 203d 2046  cat_features = F
-0000ab20: 616c 7365 0a20 2020 2065 6c73 653a 0a20  alse.    else:. 
-0000ab30: 2020 2020 2020 2023 2320 4966 2074 6172         ## If tar
-0000ab40: 6765 7420 6973 2073 7065 6369 6669 6564  get is specified
-0000ab50: 2069 6e20 6665 6174 7572 655f 6765 6e20   in feature_gen 
-0000ab60: 7468 656e 2075 7365 2069 7420 746f 2047  then use it to G
-0000ab70: 656e 6572 6174 6520 7461 7267 6574 2065  enerate target e
-0000ab80: 6e63 6f64 6564 2066 6561 7475 7265 730a  ncoded features.
-0000ab90: 2020 2020 2020 2020 7461 7267 6574 5f65          target_e
-0000aba0: 6e63 5f63 6174 5f66 6561 7475 7265 7320  nc_cat_features 
-0000abb0: 3d20 2774 6172 6765 7427 2069 6e20 6665  = 'target' in fe
-0000abc0: 6174 7572 655f 6765 6e0a 2020 2020 2323  ature_gen.    ##
-0000abd0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000abe0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000abf0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000ac00: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000ac10: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000ac20: 2323 2323 0a20 2020 2023 2323 2323 2323  ####.    #######
-0000ac30: 2320 2020 2020 4320 4c20 4120 5320 5320  #     C L A S S 
-0000ac40: 4920 4620 5920 2020 2056 2041 2052 2049  I F Y    V A R I
-0000ac50: 2041 2042 204c 2045 2053 2020 2020 2020   A B L E S      
-0000ac60: 2020 2020 2023 2323 2323 2323 2323 2323       ###########
-0000ac70: 2323 2323 2323 2323 2323 2323 2323 230a  ###############.
-0000ac80: 2020 2020 2323 2323 2323 204e 6f77 2077      ###### Now w
-0000ac90: 6520 6465 7465 6374 2074 6865 2076 6172  e detect the var
-0000aca0: 696f 7573 2074 7970 6573 206f 6620 7661  ious types of va
-0000acb0: 7269 6162 6c65 7320 746f 2073 6565 2068  riables to see h
-0000acc0: 6f77 2074 6f20 636f 6e76 6572 7420 7468  ow to convert th
-0000acd0: 656d 2074 6f20 6e75 6d65 7269 630a 2020  em to numeric.  
-0000ace0: 2020 2323 2323 2323 2323 2323 2323 2323    ##############
-0000acf0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000ad00: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000ad10: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000ad20: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000ad30: 2323 2323 2323 2323 0a20 2020 2064 6174  ########.    dat
-0000ad40: 655f 636f 6c73 203d 2066 6561 7475 7265  e_cols = feature
-0000ad50: 735f 6469 6374 5b27 6461 7465 5f76 6172  s_dict['date_var
-0000ad60: 7327 5d0a 2020 2020 6966 206c 656e 2866  s'].    if len(f
-0000ad70: 6561 7475 7265 735f 6469 6374 5b27 6461  eatures_dict['da
-0000ad80: 7465 5f76 6172 7327 5d29 203e 2030 3a0a  te_vars']) > 0:.
-0000ad90: 2020 2020 2020 2020 6461 7465 5f74 696d          date_tim
-0000ada0: 655f 7661 7273 203d 2063 6f70 792e 6465  e_vars = copy.de
-0000adb0: 6570 636f 7079 2864 6174 655f 636f 6c73  epcopy(date_cols
-0000adc0: 290a 2020 2020 2020 2020 2323 2323 2044  ).        #### D
-0000add0: 6f20 7468 6973 206f 6e6c 7920 6966 2064  o this only if d
-0000ade0: 6174 6520 7469 6d65 2063 6f6c 756d 6e73  ate time columns
-0000adf0: 2065 7869 7374 2069 6e20 796f 7572 2064   exist in your d
-0000ae00: 6174 6120 7365 7421 0a20 2020 2020 2020  ata set!.       
-0000ae10: 2064 6174 655f 636f 6c5f 6d61 7070 6572   date_col_mapper
-0000ae20: 7320 3d20 7b7d 0a20 2020 2020 2020 2066  s = {}.        f
-0000ae30: 6f72 2064 6174 655f 636f 6c20 696e 2064  or date_col in d
-0000ae40: 6174 655f 636f 6c73 3a0a 2020 2020 2020  ate_cols:.      
-0000ae50: 2020 2020 2020 7072 696e 7428 2750 726f        print('Pro
-0000ae60: 6365 7373 696e 6720 2573 2063 6f6c 756d  cessing %s colum
-0000ae70: 6e20 666f 7220 6461 7465 2074 696d 6520  n for date time 
-0000ae80: 6665 6174 7572 6573 2e2e 2e2e 2720 2564  features....' %d
-0000ae90: 6174 655f 636f 6c29 0a20 2020 2020 2020  ate_col).       
-0000aea0: 2020 2020 2064 6174 616e 616d 652c 2074       dataname, t
-0000aeb0: 735f 6164 6473 203d 2046 455f 6372 6561  s_adds = FE_crea
-0000aec0: 7465 5f74 696d 655f 7365 7269 6573 5f66  te_time_series_f
-0000aed0: 6561 7475 7265 7328 6461 7461 6e61 6d65  eatures(dataname
-0000aee0: 2c20 6461 7465 5f63 6f6c 290a 2020 2020  , date_col).    
-0000aef0: 2020 2020 2020 2020 6461 7465 5f63 6f6c          date_col
-0000af00: 5f6d 6170 7065 7220 3d20 6469 6374 285b  _mapper = dict([
-0000af10: 2878 2c64 6174 655f 636f 6c29 2066 6f72  (x,date_col) for
-0000af20: 2078 2069 6e20 7473 5f61 6464 735d 290a   x in ts_adds]).
-0000af30: 2020 2020 2020 2020 2020 2020 6461 7465              date
-0000af40: 5f63 6f6c 5f6d 6170 7065 7273 2e75 7064  _col_mappers.upd
-0000af50: 6174 6528 6461 7465 5f63 6f6c 5f6d 6170  ate(date_col_map
-0000af60: 7065 7229 0a20 2020 2020 2020 2020 2020  per).           
-0000af70: 2023 7072 696e 7428 2720 2020 2041 6464   #print('    Add
-0000af80: 696e 6720 2564 2063 6f6c 756d 6e28 7329  ing %d column(s)
-0000af90: 2066 726f 6d20 6461 7465 2d74 696d 6520   from date-time 
-0000afa0: 636f 6c75 6d6e 2025 7320 696e 2074 7261  column %s in tra
-0000afb0: 696e 2720 2528 6c65 6e28 6461 7465 5f63  in' %(len(date_c
-0000afc0: 6f6c 5f61 6464 735f 7472 6169 6e29 2c64  ol_adds_train),d
-0000afd0: 6174 655f 636f 6c29 290a 2020 2020 2020  ate_col)).      
-0000afe0: 2020 2020 2020 2374 7261 696e 203d 2074        #train = t
-0000aff0: 7261 696e 2e6a 6f69 6e28 6461 7465 5f64  rain.join(date_d
-0000b000: 665f 7472 6169 6e2c 2072 7375 6666 6978  f_train, rsuffix
-0000b010: 3d27 3227 290a 2020 2020 2020 2020 2020  ='2').          
-0000b020: 2020 6966 2069 7369 6e73 7461 6e63 6528    if isinstance(
-0000b030: 7465 7374 5f64 6174 612c 7374 7229 206f  test_data,str) o
-0000b040: 7220 7465 7374 5f64 6174 6120 6973 204e  r test_data is N
-0000b050: 6f6e 653a 0a20 2020 2020 2020 2020 2020  one:.           
-0000b060: 2020 2020 2023 2323 2064 6f20 6e6f 7468       ### do noth
-0000b070: 696e 6720 2323 2323 0a20 2020 2020 2020  ing ####.       
-0000b080: 2020 2020 2020 2020 2070 6173 730a 2020           pass.  
-0000b090: 2020 2020 2020 2020 2020 656c 7365 3a0a            else:.
-0000b0a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000b0b0: 7072 696e 7428 2720 2020 2020 2020 2041  print('        A
-0000b0c0: 6464 696e 6720 7361 6d65 2074 696d 6520  dding same time 
-0000b0d0: 7365 7269 6573 2066 6561 7475 7265 7320  series features 
-0000b0e0: 746f 2074 6573 7420 6461 7461 2e2e 2e27  to test data...'
-0000b0f0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-0000b100: 2020 7465 7374 5f64 6174 612c 205f 203d    test_data, _ =
-0000b110: 2046 455f 6372 6561 7465 5f74 696d 655f   FE_create_time_
-0000b120: 7365 7269 6573 5f66 6561 7475 7265 7328  series_features(
-0000b130: 7465 7374 5f64 6174 612c 2064 6174 655f  test_data, date_
-0000b140: 636f 6c2c 2074 735f 6164 6473 290a 2020  col, ts_adds).  
-0000b150: 2020 2020 2020 2020 2020 2020 2020 2364                #d
-0000b160: 6174 655f 636f 6c5f 6164 6473 5f74 6573  ate_col_adds_tes
-0000b170: 745f 6461 7461 203d 206c 6566 745f 7375  t_data = left_su
-0000b180: 6274 7261 6374 2864 6174 655f 6466 5f74  btract(date_df_t
-0000b190: 6573 742e 636f 6c75 6d6e 732e 746f 6c69  est.columns.toli
-0000b1a0: 7374 2829 2c64 6174 655f 636f 6c29 0a20  st(),date_col). 
-0000b1b0: 2020 2020 2020 2020 2020 2020 2020 2023                 #
-0000b1c0: 2323 204e 6f77 2074 696d 6520 746f 2072  ## Now time to r
-0000b1d0: 656d 6f76 6520 7468 6520 6461 7465 2074  emove the date t
-0000b1e0: 696d 6520 636f 6c75 6d6e 2066 726f 6d20  ime column from 
-0000b1f0: 616c 6c20 6675 7274 6865 7220 7072 6f63  all further proc
-0000b200: 6573 7369 6e67 2023 230a 2020 2020 2020  essing ##.      
-0000b210: 2020 2020 2020 2020 2020 2374 6573 7420            #test 
-0000b220: 3d20 7465 7374 2e6a 6f69 6e28 6461 7465  = test.join(date
-0000b230: 5f64 665f 7465 7374 2c20 7273 7566 6669  _df_test, rsuffi
-0000b240: 783d 2732 2729 0a20 2020 2023 2323 204e  x='2').    ### N
-0000b250: 6f77 2074 696d 6520 746f 2063 6f6e 7469  ow time to conti
-0000b260: 6e75 6520 7769 7468 206f 7572 2066 7572  nue with our fur
-0000b270: 7468 6572 2070 726f 6365 7373 696e 6720  ther processing 
-0000b280: 2323 0a20 2020 2069 6463 6f6c 7320 3d20  ##.    idcols = 
-0000b290: 6665 6174 7572 6573 5f64 6963 745b 2749  features_dict['I
-0000b2a0: 4463 6f6c 7327 5d0a 2020 2020 6966 2069  Dcols'].    if i
-0000b2b0: 7369 6e73 7461 6e63 6528 7465 7374 5f64  sinstance(test_d
-0000b2c0: 6174 612c 7374 7229 206f 7220 7465 7374  ata,str) or test
-0000b2d0: 5f64 6174 6120 6973 204e 6f6e 653a 0a20  _data is None:. 
-0000b2e0: 2020 2020 2020 2070 6173 730a 2020 2020         pass.    
-0000b2f0: 656c 7365 3a0a 2020 2020 2020 2020 7465  else:.        te
-0000b300: 7374 5f69 6473 203d 2074 6573 745f 6461  st_ids = test_da
-0000b310: 7461 5b69 6463 6f6c 735d 0a20 2020 2074  ta[idcols].    t
-0000b320: 7261 696e 5f69 6473 203d 2064 6174 616e  rain_ids = datan
-0000b330: 616d 655b 6964 636f 6c73 5d20 2323 2320  ame[idcols] ### 
-0000b340: 7468 6973 2073 6176 6573 2074 6865 2049  this saves the I
-0000b350: 4420 636f 6c75 6d6e 7320 6f66 2064 6174  D columns of dat
-0000b360: 616e 616d 650a 2020 2020 6966 2063 6174  aname.    if cat
-0000b370: 5f76 6172 733a 0a20 2020 2020 2020 2063  _vars:.        c
-0000b380: 6f6c 735f 696e 5f62 6f74 6820 3d20 5b78  ols_in_both = [x
-0000b390: 2066 6f72 2078 2069 6e20 6361 745f 7661   for x in cat_va
-0000b3a0: 7273 2069 6620 7820 696e 2066 6561 7475  rs if x in featu
-0000b3b0: 7265 735f 6469 6374 5b27 636f 6c73 5f64  res_dict['cols_d
-0000b3c0: 656c 6574 6527 5d5d 0a20 2020 2020 2020  elete']].       
-0000b3d0: 2063 6174 5f76 6172 7320 3d20 6c65 6674   cat_vars = left
-0000b3e0: 5f73 7562 7472 6163 7428 6361 745f 7661  _subtract(cat_va
-0000b3f0: 7273 2c20 6665 6174 7572 6573 5f64 6963  rs, features_dic
-0000b400: 745b 2763 6f6c 735f 6465 6c65 7465 275d  t['cols_delete']
-0000b410: 290a 2020 2020 2020 2020 6966 206c 656e  ).        if len
-0000b420: 2863 6f6c 735f 696e 5f62 6f74 6829 203e  (cols_in_both) >
-0000b430: 2030 3a0a 2020 2020 2020 2020 2020 2020   0:.            
-0000b440: 7072 696e 7428 2752 656d 6f76 696e 6720  print('Removing 
-0000b450: 2573 2063 6f6c 756d 6e73 2873 2920 7768  %s columns(s) wh
-0000b460: 6963 6820 6172 6520 696e 2062 6f74 6820  ich are in both 
-0000b470: 636f 6c73 2074 6f20 6265 2064 656c 6574  cols to be delet
-0000b480: 6564 2061 6e64 2063 6174 2076 6172 7320  ed and cat vars 
-0000b490: 6769 7665 6e20 6173 2069 6e70 7574 2720  given as input' 
-0000b4a0: 2563 6f6c 735f 696e 5f62 6f74 6829 0a20  %cols_in_both). 
-0000b4b0: 2020 2063 6f6c 735f 746f 5f72 656d 6f76     cols_to_remov
-0000b4c0: 6520 3d20 6665 6174 7572 6573 5f64 6963  e = features_dic
-0000b4d0: 745b 2763 6f6c 735f 6465 6c65 7465 275d  t['cols_delete']
-0000b4e0: 202b 2069 6463 6f6c 7320 2b20 6665 6174   + idcols + feat
-0000b4f0: 7572 6573 5f64 6963 745b 2764 6973 6372  ures_dict['discr
-0000b500: 6574 655f 7374 7269 6e67 5f76 6172 7327  ete_string_vars'
-0000b510: 5d0a 2020 2020 7072 696e 7428 2752 656d  ].    print('Rem
-0000b520: 6f76 696e 6720 2564 2063 6f6c 756d 6e73  oving %d columns
-0000b530: 2066 726f 6d20 6675 7274 6865 7220 7072   from further pr
-0000b540: 6f63 6573 7369 6e67 2073 696e 6365 2049  ocessing since I
-0000b550: 4420 6f72 206c 6f77 2069 6e66 6f72 6d61  D or low informa
-0000b560: 7469 6f6e 2076 6172 6961 626c 6573 2720  tion variables' 
-0000b570: 256c 656e 2863 6f6c 735f 746f 5f72 656d  %len(cols_to_rem
-0000b580: 6f76 6529 290a 2020 2020 7072 6564 7320  ove)).    preds 
-0000b590: 3d20 5b78 2066 6f72 2078 2069 6e20 6c69  = [x for x in li
-0000b5a0: 7374 2864 6174 616e 616d 6529 2069 6620  st(dataname) if 
-0000b5b0: 7820 6e6f 7420 696e 2074 6172 6765 742b  x not in target+
-0000b5c0: 636f 6c73 5f74 6f5f 7265 6d6f 7665 5d0a  cols_to_remove].
-0000b5d0: 2020 2020 2323 2320 2020 5468 6973 2069      ###   This i
-0000b5e0: 7320 7768 6572 6520 7765 2073 6f72 7420  s where we sort 
-0000b5f0: 7468 6520 636f 6c75 6d6e 7320 746f 206d  the columns to m
-0000b600: 616b 6520 7375 7265 2074 6861 7420 7468  ake sure that th
-0000b610: 6520 6f72 6465 7220 6f66 2063 6f6c 756d  e order of colum
-0000b620: 6e73 2064 6f65 736e 2774 206d 6174 7465  ns doesn't matte
-0000b630: 7220 696e 2073 656c 6563 7469 6f6e 2023  r in selection #
-0000b640: 2323 2323 2323 2323 2323 0a20 2020 2023  ##########.    #
-0000b650: 7072 6564 7320 3d20 6e70 2e73 6f72 7428  preds = np.sort(
-0000b660: 7072 6564 7329 0a20 2020 2069 6620 7665  preds).    if ve
-0000b670: 7262 6f73 653a 0a20 2020 2020 2020 2070  rbose:.        p
-0000b680: 7269 6e74 2827 2020 2020 4166 7465 7220  rint('    After 
-0000b690: 7265 6d6f 7669 6e67 2072 6564 756e 6461  removing redunda
-0000b6a0: 6e74 2076 6172 6961 626c 6573 2066 726f  nt variables fro
-0000b6b0: 6d20 6675 7274 6865 7220 7072 6f63 6573  m further proces
-0000b6c0: 7369 6e67 2c20 6665 6174 7572 6573 206c  sing, features l
-0000b6d0: 6566 7420 3d20 2564 2720 256c 656e 2870  eft = %d' %len(p
-0000b6e0: 7265 6473 2929 0a20 2020 206e 756d 7661  reds)).    numva
-0000b6f0: 7273 203d 2064 6174 616e 616d 655b 7072  rs = dataname[pr
-0000b700: 6564 735d 2e73 656c 6563 745f 6474 7970  eds].select_dtyp
-0000b710: 6573 2869 6e63 6c75 6465 203d 2027 6e75  es(include = 'nu
-0000b720: 6d62 6572 2729 2e63 6f6c 756d 6e73 2e74  mber').columns.t
-0000b730: 6f6c 6973 7428 290a 2020 2020 6966 206c  olist().    if l
-0000b740: 656e 286e 756d 7661 7273 2920 3e20 6d61  en(numvars) > ma
-0000b750: 785f 6e75 6d73 3a0a 2020 2020 2020 2020  x_nums:.        
-0000b760: 6966 2066 6561 7475 7265 5f67 656e 3a0a  if feature_gen:.
-0000b770: 2020 2020 2020 2020 2020 2020 7072 696e              prin
-0000b780: 7428 275c 6e57 6172 6e69 6e67 3a20 546f  t('\nWarning: To
-0000b790: 6f20 6d61 6e79 2065 7874 7261 2066 6561  o many extra fea
-0000b7a0: 7475 7265 7320 7769 6c6c 2062 6520 6765  tures will be ge
-0000b7b0: 6e65 7261 7465 6420 6279 2066 6561 7475  nerated by featu
-0000b7c0: 7265 7769 7a2e 2054 6869 7320 6d61 7920  rewiz. This may 
-0000b7d0: 7461 6b65 2074 696d 652e 2e2e 2729 0a20  take time...'). 
-0000b7e0: 2020 2069 6620 6361 745f 7661 7273 3a0a     if cat_vars:.
-0000b7f0: 2020 2020 2020 2020 2323 2320 6966 2069          ### if i
-0000b800: 6e70 7574 2069 7320 6769 7665 6e20 666f  nput is given fo
-0000b810: 7220 6361 745f 7661 7273 2c20 7573 6520  r cat_vars, use 
-0000b820: 6974 210a 2020 2020 2020 2020 6361 7476  it!.        catv
-0000b830: 6172 7320 3d20 636f 7079 2e64 6565 7063  ars = copy.deepc
-0000b840: 6f70 7928 6361 745f 7661 7273 290a 2020  opy(cat_vars).  
-0000b850: 2020 2020 2020 6e75 6d76 6172 7320 3d20        numvars = 
-0000b860: 6c65 6674 5f73 7562 7472 6163 7428 7072  left_subtract(pr
-0000b870: 6564 732c 2063 6174 7661 7273 290a 2020  eds, catvars).  
-0000b880: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
-0000b890: 6361 7476 6172 7320 3d20 6c65 6674 5f73  catvars = left_s
-0000b8a0: 7562 7472 6163 7428 7072 6564 732c 206e  ubtract(preds, n
-0000b8b0: 756d 7661 7273 290a 2020 2020 6966 206c  umvars).    if l
-0000b8c0: 656e 2863 6174 7661 7273 2920 3e20 6d61  en(catvars) > ma
-0000b8d0: 785f 6361 7473 3a0a 2020 2020 2020 2020  x_cats:.        
-0000b8e0: 6966 2066 6561 7475 7265 5f74 7970 653a  if feature_type:
-0000b8f0: 0a20 2020 2020 2020 2020 2020 2070 7269  .            pri
-0000b900: 6e74 2827 5c6e 5761 726e 696e 673a 2054  nt('\nWarning: T
-0000b910: 6f6f 206d 616e 7920 6578 7472 6120 6665  oo many extra fe
-0000b920: 6174 7572 6573 2077 696c 6c20 6265 2067  atures will be g
-0000b930: 656e 6572 6174 6564 2062 7920 6361 7465  enerated by cate
-0000b940: 676f 7279 2065 6e63 6f64 696e 672e 2054  gory encoding. T
-0000b950: 6869 7320 6d61 7920 7461 6b65 2074 696d  his may take tim
-0000b960: 652e 2e2e 2729 0a20 2020 2023 2323 2323  e...').    #####
-0000b970: 2320 2020 4320 5220 4520 4120 5420 4920  #   C R E A T I 
-0000b980: 4e20 4720 2020 2049 204e 2054 2058 204e  N G    I N T X N
-0000b990: 2020 5620 4120 5220 5320 2020 4620 5220    V A R S   F R 
-0000b9a0: 4f20 4d20 2020 4320 4120 5420 2056 2041  O M   C A T  V A
-0000b9b0: 2052 2053 2023 2323 2323 2323 2323 2323   R S ###########
-0000b9c0: 2323 2323 2323 2323 2323 0a20 2020 2069  ##########.    i
-0000b9d0: 6620 6e70 2e77 6865 7265 2827 696e 7465  f np.where('inte
-0000b9e0: 7261 6374 696f 6e73 2720 696e 2066 6561  ractions' in fea
-0000b9f0: 7475 7265 5f67 656e 2c54 7275 652c 2046  ture_gen,True, F
-0000ba00: 616c 7365 292e 746f 6c69 7374 2829 3a0a  alse).tolist():.
-0000ba10: 2020 2020 2020 2020 6966 206c 656e 2863          if len(c
-0000ba20: 6174 7661 7273 2920 3e20 313a 0a20 2020  atvars) > 1:.   
-0000ba30: 2020 2020 2020 2020 200a 2020 2020 2020           .      
-0000ba40: 2020 2020 2020 6e75 6d5f 636f 6d62 6f73        num_combos
-0000ba50: 203d 206c 656e 286c 6973 7428 636f 6d62   = len(list(comb
-0000ba60: 696e 6174 696f 6e73 2863 6174 7661 7273  inations(catvars
-0000ba70: 2c32 2929 290a 2020 2020 2020 2020 2020  ,2))).          
-0000ba80: 2020 7072 696e 7428 2741 6464 696e 6720    print('Adding 
-0000ba90: 2573 2069 6e74 6572 6163 7469 6f6e 7320  %s interactions 
-0000baa0: 6265 7477 6565 6e20 6361 7465 676f 7269  between categori
-0000bab0: 6361 6c5f 7661 7273 2025 732e 2e2e 2720  cal_vars %s...' 
-0000bac0: 2528 0a20 2020 2020 2020 2020 2020 2020  %(.             
-0000bad0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000bae0: 2020 206e 756d 5f63 6f6d 626f 732c 2063     num_combos, c
-0000baf0: 6174 7661 7273 2929 0a20 2020 2020 2020  atvars)).       
-0000bb00: 2020 2020 2064 6174 616e 616d 6520 3d20       dataname = 
-0000bb10: 4645 5f63 7265 6174 655f 696e 7465 7261  FE_create_intera
-0000bb20: 6374 696f 6e5f 7661 7273 2864 6174 616e  ction_vars(datan
-0000bb30: 616d 652c 2063 6174 7661 7273 290a 2020  ame, catvars).  
-0000bb40: 2020 2020 2020 2020 2020 7472 6169 6e20            train 
-0000bb50: 3d20 4645 5f63 7265 6174 655f 696e 7465  = FE_create_inte
-0000bb60: 7261 6374 696f 6e5f 7661 7273 2874 7261  raction_vars(tra
-0000bb70: 696e 2c20 6361 7476 6172 7329 0a20 2020  in, catvars).   
-0000bb80: 2020 2020 2020 2020 2063 6174 7661 7273           catvars
-0000bb90: 203d 206c 6566 745f 7375 6274 7261 6374   = left_subtract
-0000bba0: 2864 6174 616e 616d 652e 636f 6c75 6d6e  (dataname.column
-0000bbb0: 732e 746f 6c69 7374 2829 2c20 6e75 6d76  s.tolist(), numv
-0000bbc0: 6172 7329 0a20 2020 2020 2020 2020 2020  ars).           
-0000bbd0: 2063 6174 7661 7273 203d 206c 6566 745f   catvars = left_
-0000bbe0: 7375 6274 7261 6374 2863 6174 7661 7273  subtract(catvars
-0000bbf0: 2c20 7461 7267 6574 290a 2020 2020 2020  , target).      
-0000bc00: 2020 2020 2020 7072 6564 7320 3d20 206c        preds =  l
-0000bc10: 6566 745f 7375 6274 7261 6374 2864 6174  eft_subtract(dat
-0000bc20: 616e 616d 652e 636f 6c75 6d6e 732e 746f  aname.columns.to
-0000bc30: 6c69 7374 2829 2c20 7461 7267 6574 290a  list(), target).
-0000bc40: 2020 2020 2020 2020 2020 2020 6966 206e              if n
-0000bc50: 6f74 2074 6573 745f 6461 7461 2069 7320  ot test_data is 
-0000bc60: 4e6f 6e65 3a0a 2020 2020 2020 2020 2020  None:.          
-0000bc70: 2020 2020 2020 7465 7374 5f64 6174 6120        test_data 
-0000bc80: 3d20 4645 5f63 7265 6174 655f 696e 7465  = FE_create_inte
-0000bc90: 7261 6374 696f 6e5f 7661 7273 2874 6573  raction_vars(tes
-0000bca0: 745f 6461 7461 2c20 6361 7476 6172 7329  t_data, catvars)
-0000bcb0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000bcc0: 2074 6573 7420 3d20 4645 5f63 7265 6174   test = FE_creat
-0000bcd0: 655f 696e 7465 7261 6374 696f 6e5f 7661  e_interaction_va
-0000bce0: 7273 2874 6573 742c 2063 6174 7661 7273  rs(test, catvars
-0000bcf0: 290a 2020 2020 2020 2020 656c 7365 3a0a  ).        else:.
-0000bd00: 2020 2020 2020 2020 2020 2020 6966 2076              if v
-0000bd10: 6572 626f 7365 3a0a 2020 2020 2020 2020  erbose:.        
-0000bd20: 2020 2020 2020 2020 7072 696e 7428 274e          print('N
-0000bd30: 6f20 696e 7465 7261 6374 696f 6e73 2063  o interactions c
-0000bd40: 7265 6174 6564 2066 6f72 2063 6174 6567  reated for categ
-0000bd50: 6f72 6963 616c 2076 6172 7320 7369 6e63  orical vars sinc
-0000bd60: 6520 6e75 6d62 6572 206c 6573 7320 7468  e number less th
-0000bd70: 616e 2032 2729 0a20 2020 2065 6c73 653a  an 2').    else:
-0000bd80: 0a20 2020 2020 2020 2069 6620 7665 7262  .        if verb
-0000bd90: 6f73 653a 0a20 2020 2020 2020 2020 2020  ose:.           
-0000bda0: 2070 7269 6e74 2827 4e6f 2069 6e74 6572   print('No inter
-0000bdb0: 6163 7469 6f6e 7320 6372 6561 7465 6420  actions created 
-0000bdc0: 666f 7220 6361 7465 676f 7269 6361 6c20  for categorical 
-0000bdd0: 7661 7273 2073 696e 6365 2066 6561 7475  vars since featu
-0000bde0: 7265 2065 6e67 6720 646f 6573 206e 6f74  re engg does not
-0000bdf0: 2073 7065 6369 6679 2069 7427 290a 2020   specify it').  
-0000be00: 2020 2323 2323 2320 4e6f 7720 7765 206e    ##### Now we n
-0000be10: 6565 6420 746f 2072 652d 7365 7420 7468  eed to re-set th
-0000be20: 6520 6361 7476 6172 7320 6167 6169 6e20  e catvars again 
-0000be30: 7369 6e63 6520 7765 2068 6176 6520 6372  since we have cr
-0000be40: 6561 7465 6420 6e65 7720 6665 6174 7572  eated new featur
-0000be50: 6573 2023 2323 2323 0a20 2020 2072 656d  es #####.    rem
-0000be60: 5f76 6172 7320 3d20 636f 7079 2e64 6565  _vars = copy.dee
-0000be70: 7063 6f70 7928 6361 7476 6172 7329 0a20  pcopy(catvars). 
-0000be80: 2020 2023 2323 2323 2323 2323 2320 4e6f     ########## No
-0000be90: 7720 7765 206e 6565 6420 746f 2073 656c  w we need to sel
-0000bea0: 6563 7420 7468 6520 7269 6768 7420 6d6f  ect the right mo
-0000beb0: 6465 6c20 746f 2072 756e 2072 6570 6561  del to run repea
-0000bec0: 7465 646c 7920 2323 2323 0a20 2020 2069  tedly ####.    i
-0000bed0: 6620 7365 7474 696e 6773 2e6d 6f64 656c  f settings.model
-0000bee0: 7479 7065 2021 3d20 2752 6567 7265 7373  type != 'Regress
-0000bef0: 696f 6e27 3a0a 2020 2020 2020 2020 2323  ion':.        ##
-0000bf00: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000bf10: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000bf20: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000bf30: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000bf40: 2323 2323 2323 2323 0a20 2020 2020 2020  ########.       
-0000bf50: 2023 2323 2323 2323 2323 2323 2020 204c   ###########   L
-0000bf60: 2041 2042 2045 204c 2020 2020 4520 4e20   A B E L    E N 
-0000bf70: 4320 4f20 4420 4920 4e20 4720 2020 4f20  C O D I N G   O 
-0000bf80: 4620 2020 5420 4120 5220 4720 4520 5420  F   T A R G E T 
-0000bf90: 2020 2323 2323 2323 2323 230a 2020 2020    #########.    
-0000bfa0: 2020 2020 2323 2323 2323 2323 2323 2323      ############
-0000bfb0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000bfc0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000bfd0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000bfe0: 2323 2323 2323 2323 2323 2323 2323 0a20  ##############. 
-0000bff0: 2020 2020 2020 2023 2323 2054 6869 7320         ### This 
-0000c000: 6973 2074 6f20 636f 6e76 6572 7420 7468  is to convert th
-0000c010: 6520 7461 7267 6574 206c 6162 656c 7320  e target labels 
-0000c020: 746f 2070 726f 7065 7220 6e75 6d65 7269  to proper numeri
-0000c030: 6320 636f 6c75 6d6e 7320 2323 2323 2323  c columns ######
-0000c040: 0a20 2020 2020 2020 2074 6172 6765 745f  .        target_
-0000c050: 636f 6e76 6572 7369 6f6e 5f66 6c61 6720  conversion_flag 
-0000c060: 3d20 4661 6c73 650a 2020 2020 2020 2020  = False.        
-0000c070: 6361 745f 7461 7267 6574 7320 3d20 6461  cat_targets = da
-0000c080: 7461 6e61 6d65 5b74 6172 6765 745d 2e73  taname[target].s
-0000c090: 656c 6563 745f 6474 7970 6573 2869 6e63  elect_dtypes(inc
-0000c0a0: 6c75 6465 3d27 6f62 6a65 6374 2729 2e63  lude='object').c
-0000c0b0: 6f6c 756d 6e73 2e74 6f6c 6973 7428 2920  olumns.tolist() 
-0000c0c0: 2b20 6461 7461 6e61 6d65 5b74 6172 6765  + dataname[targe
-0000c0d0: 745d 2e73 656c 6563 745f 6474 7970 6573  t].select_dtypes
-0000c0e0: 2869 6e63 6c75 6465 3d27 6361 7465 676f  (include='catego
-0000c0f0: 7279 2729 2e63 6f6c 756d 6e73 2e74 6f6c  ry').columns.tol
-0000c100: 6973 7428 290a 2020 2020 2020 2020 636f  ist().        co
-0000c110: 7079 5f74 6172 6765 7473 203d 2063 6f70  py_targets = cop
-0000c120: 792e 6465 6570 636f 7079 2874 6172 6765  y.deepcopy(targe
-0000c130: 7473 290a 2020 2020 2020 2020 666f 7220  ts).        for 
-0000c140: 6561 6368 5f74 6172 6765 7420 696e 2063  each_target in c
-0000c150: 6f70 795f 7461 7267 6574 733a 0a20 2020  opy_targets:.   
-0000c160: 2020 2020 2020 2020 2020 2020 2069 6620               if 
-0000c170: 6361 745f 7461 7267 6574 7320 6f72 2073  cat_targets or s
-0000c180: 6f72 7465 6428 6e70 2e75 6e69 7175 6528  orted(np.unique(
-0000c190: 6461 7461 6e61 6d65 5b65 6163 685f 7461  dataname[each_ta
-0000c1a0: 7267 6574 5d2e 7661 6c75 6573 2929 5b30  rget].values))[0
-0000c1b0: 5d20 213d 2030 3a0a 2020 2020 2020 2020  ] != 0:.        
-0000c1c0: 2020 2020 2020 2020 2020 2020 7072 696e              prin
-0000c1d0: 7428 2720 2020 2074 6172 6765 7420 6c61  t('    target la
-0000c1e0: 6265 6c73 206e 6565 6420 746f 2062 6520  bels need to be 
-0000c1f0: 636f 6e76 6572 7465 642e 2e2e 2729 0a20  converted...'). 
-0000c200: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c210: 2020 2074 6172 6765 745f 636f 6e76 6572     target_conver
-0000c220: 7369 6f6e 5f66 6c61 6720 3d20 5472 7565  sion_flag = True
-0000c230: 0a20 2020 2020 2020 2023 2323 2063 6865  .        ### che
-0000c240: 636b 2069 6620 7468 6579 2061 7265 206e  ck if they are n
-0000c250: 6f74 2073 7461 7274 696e 6720 6672 6f6d  ot starting from
-0000c260: 207a 6572 6f20 2323 2323 2323 2323 2323   zero ##########
-0000c270: 2323 2323 2323 2323 0a20 2020 2020 2020  ########.       
-0000c280: 2063 6f70 795f 7461 7267 6574 7320 3d20   copy_targets = 
-0000c290: 636f 7079 2e64 6565 7063 6f70 7928 7461  copy.deepcopy(ta
-0000c2a0: 7267 6574 290a 2020 2020 2020 2020 666f  rget).        fo
-0000c2b0: 7220 6561 6368 5f74 6172 6765 7420 696e  r each_target in
-0000c2c0: 2063 6f70 795f 7461 7267 6574 733a 0a20   copy_targets:. 
-0000c2d0: 2020 2020 2020 2020 2020 2069 6620 7461             if ta
-0000c2e0: 7267 6574 5f63 6f6e 7665 7273 696f 6e5f  rget_conversion_
-0000c2f0: 666c 6167 3a0a 2020 2020 2020 2020 2020  flag:.          
-0000c300: 2020 2020 2020 6d6c 6220 3d20 4d79 5f4c        mlb = My_L
-0000c310: 6162 656c 456e 636f 6465 7228 290a 2020  abelEncoder().  
-0000c320: 2020 2020 2020 2020 2020 2020 2020 6461                da
-0000c330: 7461 6e61 6d65 5b65 6163 685f 7461 7267  taname[each_targ
-0000c340: 6574 5d20 3d20 6d6c 622e 6669 745f 7472  et] = mlb.fit_tr
-0000c350: 616e 7366 6f72 6d28 6461 7461 6e61 6d65  ansform(dataname
-0000c360: 5b65 6163 685f 7461 7267 6574 5d29 0a20  [each_target]). 
-0000c370: 2020 2020 2020 2020 2020 2020 2020 2074                 t
-0000c380: 7279 3a0a 2020 2020 2020 2020 2020 2020  ry:.            
-0000c390: 2020 2020 2020 2020 2323 2041 6674 6572          ## After
-0000c3a0: 2063 6f6e 7665 7274 696e 6720 7472 6169   converting trai
-0000c3b0: 6e2c 206a 7573 7420 6c6f 6164 2069 7420  n, just load it 
-0000c3c0: 696e 746f 2064 6173 6b20 6167 6169 6e20  into dask again 
-0000c3d0: 2323 0a20 2020 2020 2020 2020 2020 2020  ##.             
-0000c3e0: 2020 2020 2020 2074 7261 696e 5b65 6163         train[eac
-0000c3f0: 685f 7461 7267 6574 5d20 3d20 6464 2e66  h_target] = dd.f
-0000c400: 726f 6d5f 7061 6e64 6173 2864 6174 616e  rom_pandas(datan
-0000c410: 616d 655b 6561 6368 5f74 6172 6765 745d  ame[each_target]
-0000c420: 2c20 6e70 6172 7469 7469 6f6e 733d 6e5f  , npartitions=n_
-0000c430: 776f 726b 6572 7329 0a20 2020 2020 2020  workers).       
-0000c440: 2020 2020 2020 2020 2065 7863 6570 743a           except:
-0000c450: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000c460: 2020 2020 2070 7269 6e74 2827 436f 756c       print('Coul
-0000c470: 6420 6e6f 7420 636f 6e76 6572 7420 6461  d not convert da
-0000c480: 736b 2064 6174 6166 7261 6d65 2074 6172  sk dataframe tar
-0000c490: 6765 7420 696e 746f 206e 756d 6572 6963  get into numeric
-0000c4a0: 2e20 4368 6563 6b20 796f 7572 2069 6e70  . Check your inp
-0000c4b0: 7574 2e20 436f 6e74 696e 7569 6e67 2e2e  ut. Continuing..
-0000c4c0: 2e27 290a 2020 2020 2020 2020 2020 2020  .').            
-0000c4d0: 2020 2020 6966 2074 6573 745f 6461 7461      if test_data
-0000c4e0: 2069 7320 6e6f 7420 4e6f 6e65 3a0a 2020   is not None:.  
-0000c4f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c500: 2020 6966 2065 6163 685f 7461 7267 6574    if each_target
-0000c510: 2069 6e20 7465 7374 5f64 6174 612e 636f   in test_data.co
-0000c520: 6c75 6d6e 733a 0a20 2020 2020 2020 2020  lumns:.         
-0000c530: 2020 2020 2020 2020 2020 2020 2020 2074                 t
-0000c540: 6573 745f 6461 7461 5b65 6163 685f 7461  est_data[each_ta
-0000c550: 7267 6574 5d20 3d20 6d6c 622e 7472 616e  rget] = mlb.tran
-0000c560: 7366 6f72 6d28 7465 7374 5f64 6174 615b  sform(test_data[
-0000c570: 6561 6368 5f74 6172 6765 745d 290a 2020  each_target]).  
-0000c580: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c590: 2020 2020 2020 7472 793a 0a20 2020 2020        try:.     
-0000c5a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c5b0: 2020 2020 2020 2023 2320 4166 7465 7220         ## After 
-0000c5c0: 636f 6e76 6572 7469 6e67 2074 6573 742c  converting test,
-0000c5d0: 206a 7573 7420 6c6f 6164 2069 7420 696e   just load it in
-0000c5e0: 746f 2064 6173 6b20 6167 6169 6e20 2323  to dask again ##
-0000c5f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000c600: 2020 2020 2020 2020 2020 2020 2074 6573               tes
-0000c610: 745b 6561 6368 5f74 6172 6765 745d 203d  t[each_target] =
-0000c620: 2064 642e 6672 6f6d 5f70 616e 6461 7328   dd.from_pandas(
-0000c630: 7465 7374 5f64 6174 615b 6561 6368 5f74  test_data[each_t
-0000c640: 6172 6765 745d 2c20 6e70 6172 7469 7469  arget], npartiti
-0000c650: 6f6e 733d 6e5f 776f 726b 6572 7329 0a20  ons=n_workers). 
-0000c660: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c670: 2020 2020 2020 2065 7863 6570 743a 0a20         except:. 
-0000c680: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000c690: 2020 2020 2020 2020 2020 2070 7269 6e74             print
-0000c6a0: 2827 436f 756c 6420 6e6f 7420 636f 6e76  ('Could not conv
-0000c6b0: 6572 7420 6461 736b 2064 6174 6166 7261  ert dask datafra
-0000c6c0: 6d65 2074 6172 6765 7420 696e 746f 206e  me target into n
-0000c6d0: 756d 6572 6963 2e20 4368 6563 6b20 796f  umeric. Check yo
-0000c6e0: 7572 2069 6e70 7574 2e20 436f 6e74 696e  ur input. Contin
-0000c6f0: 7569 6e67 2e2e 2e27 290a 2020 2020 2020  uing...').      
-0000c700: 2020 2020 2020 2020 2020 7072 696e 7428            print(
-0000c710: 2743 6f6d 706c 6574 6564 206c 6162 656c  'Completed label
-0000c720: 2065 6e63 6f64 696e 6720 6f66 2074 6172   encoding of tar
-0000c730: 6765 7420 7661 7269 6162 6c65 203d 2025  get variable = %
-0000c740: 7327 2025 6561 6368 5f74 6172 6765 7429  s' %each_target)
-0000c750: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000c760: 2070 7269 6e74 2827 486f 7720 6d6f 6465   print('How mode
-0000c770: 6c20 7072 6564 6963 7469 6f6e 7320 6e65  l predictions ne
-0000c780: 6564 2074 6f20 6265 2074 7261 6e73 666f  ed to be transfo
-0000c790: 726d 6564 2066 6f72 2025 733a 5c6e 5c74  rmed for %s:\n\t
-0000c7a0: 2573 2720 2528 6561 6368 5f74 6172 6765  %s' %(each_targe
-0000c7b0: 742c 206d 6c62 2e69 6e76 6572 7365 5f74  t, mlb.inverse_t
-0000c7c0: 7261 6e73 666f 726d 6572 2929 0a0a 2020  ransformer))..  
-0000c7d0: 2020 2323 2323 2323 2323 2323 2323 2323    ##############
-0000c7e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000c7f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000c800: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000c810: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000c820: 2323 2323 2323 2323 0a20 2020 2023 2323  ########.    ###
-0000c830: 2323 2320 2020 2042 2045 2046 204f 2052  ###    B E F O R
-0000c840: 2045 2020 2020 5520 5320 4920 4e20 4720   E    U S I N G 
-0000c850: 2020 2044 2041 2054 2041 2042 2055 204e     D A T A B U N
-0000c860: 2043 2048 2020 4320 4820 4520 4320 4b20   C H  C H E C K 
-0000c870: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000c880: 2323 230a 2020 2020 2323 2323 2323 2323  ###.    ########
-0000c890: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000c8a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000c8b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000a950: 4661 6c73 650a 2020 2020 656c 7365 3a0a  False.    else:.
+0000a960: 2020 2020 2020 2020 6966 206c 656e 2874          if len(t
+0000a970: 6172 6765 7429 203c 3d20 313a 0a20 2020  arget) <= 1:.   
+0000a980: 2020 2020 2020 2020 2073 6574 7469 6e67           setting
+0000a990: 732e 6d75 6c74 695f 6c61 6265 6c20 3d20  s.multi_label = 
+0000a9a0: 4661 6c73 650a 2020 2020 2020 2020 656c  False.        el
+0000a9b0: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+0000a9c0: 7365 7474 696e 6773 2e6d 756c 7469 5f6c  settings.multi_l
+0000a9d0: 6162 656c 203d 2054 7275 650a 2020 2020  abel = True.    
+0000a9e0: 2323 2323 2059 6f75 206e 6565 6420 746f  #### You need to
+0000a9f0: 206d 616b 6520 7375 7265 206f 6e6c 7920   make sure only 
+0000aa00: 5369 6e67 6c65 204c 6162 656c 2070 726f  Single Label pro
+0000aa10: 626c 656d 7320 6172 6520 6861 6e64 6c65  blems are handle
+0000aa20: 6420 696e 2074 6172 6765 7420 656e 636f  d in target enco
+0000aa30: 6469 6e67 210a 2020 2020 6966 2073 6574  ding!.    if set
+0000aa40: 7469 6e67 732e 6d75 6c74 695f 6c61 6265  tings.multi_labe
+0000aa50: 6c3a 0a20 2020 2020 2020 2069 6620 7665  l:.        if ve
+0000aa60: 7262 6f73 653a 0a20 2020 2020 2020 2020  rbose:.         
+0000aa70: 2020 2070 7269 6e74 2827 5475 726e 696e     print('Turnin
+0000aa80: 6720 6f66 6620 5461 7267 6574 2065 6e63  g off Target enc
+0000aa90: 6f64 696e 6720 666f 7220 6d75 6c74 692d  oding for multi-
+0000aaa0: 6c61 6265 6c20 7072 6f62 6c65 6d73 206c  label problems l
+0000aab0: 696b 6520 7468 6973 2064 6174 6120 7365  ike this data se
+0000aac0: 742e 2e2e 2729 0a20 2020 2020 2020 2020  t...').         
+0000aad0: 2020 2070 7269 6e74 2827 2020 2020 7369     print('    si
+0000aae0: 6e63 6520 4665 6174 7572 6520 456e 6769  nce Feature Engi
+0000aaf0: 6e65 6572 696e 6720 6d6f 6475 6c65 2063  neering module c
+0000ab00: 616e 6e6f 7420 6861 6e64 6c65 204d 756c  annot handle Mul
+0000ab10: 7469 204c 6162 656c 2054 6172 6765 7473  ti Label Targets
+0000ab20: 2c20 7475 726e 6f66 6620 7461 7267 6574  , turnoff target
+0000ab30: 5f65 6e63 5f63 6174 5f66 6561 7475 7265  _enc_cat_feature
+0000ab40: 7320 746f 2046 616c 7365 2729 0a20 2020  s to False').   
+0000ab50: 2020 2020 2074 6172 6765 745f 656e 635f       target_enc_
+0000ab60: 6361 745f 6665 6174 7572 6573 203d 2046  cat_features = F
+0000ab70: 616c 7365 0a20 2020 2065 6c73 653a 0a20  alse.    else:. 
+0000ab80: 2020 2020 2020 2023 2320 4966 2074 6172         ## If tar
+0000ab90: 6765 7420 6973 2073 7065 6369 6669 6564  get is specified
+0000aba0: 2069 6e20 6665 6174 7572 655f 6765 6e20   in feature_gen 
+0000abb0: 7468 656e 2075 7365 2069 7420 746f 2047  then use it to G
+0000abc0: 656e 6572 6174 6520 7461 7267 6574 2065  enerate target e
+0000abd0: 6e63 6f64 6564 2066 6561 7475 7265 730a  ncoded features.
+0000abe0: 2020 2020 2020 2020 7461 7267 6574 5f65          target_e
+0000abf0: 6e63 5f63 6174 5f66 6561 7475 7265 7320  nc_cat_features 
+0000ac00: 3d20 2774 6172 6765 7427 2069 6e20 6665  = 'target' in fe
+0000ac10: 6174 7572 655f 6765 6e0a 2020 2020 2323  ature_gen.    ##
+0000ac20: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000ac30: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000ac40: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000ac50: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000ac60: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000ac70: 2323 2323 0a20 2020 2023 2323 2323 2323  ####.    #######
+0000ac80: 2320 2020 2020 4320 4c20 4120 5320 5320  #     C L A S S 
+0000ac90: 4920 4620 5920 2020 2056 2041 2052 2049  I F Y    V A R I
+0000aca0: 2041 2042 204c 2045 2053 2020 2020 2020   A B L E S      
+0000acb0: 2020 2020 2023 2323 2323 2323 2323 2323       ###########
+0000acc0: 2323 2323 2323 2323 2323 2323 2323 230a  ###############.
+0000acd0: 2020 2020 2323 2323 2323 204e 6f77 2077      ###### Now w
+0000ace0: 6520 6465 7465 6374 2074 6865 2076 6172  e detect the var
+0000acf0: 696f 7573 2074 7970 6573 206f 6620 7661  ious types of va
+0000ad00: 7269 6162 6c65 7320 746f 2073 6565 2068  riables to see h
+0000ad10: 6f77 2074 6f20 636f 6e76 6572 7420 7468  ow to convert th
+0000ad20: 656d 2074 6f20 6e75 6d65 7269 630a 2020  em to numeric.  
+0000ad30: 2020 2323 2323 2323 2323 2323 2323 2323    ##############
+0000ad40: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000ad50: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000ad60: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000ad70: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000ad80: 2323 2323 2323 2323 0a20 2020 2064 6174  ########.    dat
+0000ad90: 655f 636f 6c73 203d 2066 6561 7475 7265  e_cols = feature
+0000ada0: 735f 6469 6374 5b27 6461 7465 5f76 6172  s_dict['date_var
+0000adb0: 7327 5d0a 2020 2020 6966 206c 656e 2866  s'].    if len(f
+0000adc0: 6561 7475 7265 735f 6469 6374 5b27 6461  eatures_dict['da
+0000add0: 7465 5f76 6172 7327 5d29 203e 2030 3a0a  te_vars']) > 0:.
+0000ade0: 2020 2020 2020 2020 6461 7465 5f74 696d          date_tim
+0000adf0: 655f 7661 7273 203d 2063 6f70 792e 6465  e_vars = copy.de
+0000ae00: 6570 636f 7079 2864 6174 655f 636f 6c73  epcopy(date_cols
+0000ae10: 290a 2020 2020 2020 2020 2323 2323 2044  ).        #### D
+0000ae20: 6f20 7468 6973 206f 6e6c 7920 6966 2064  o this only if d
+0000ae30: 6174 6520 7469 6d65 2063 6f6c 756d 6e73  ate time columns
+0000ae40: 2065 7869 7374 2069 6e20 796f 7572 2064   exist in your d
+0000ae50: 6174 6120 7365 7421 0a20 2020 2020 2020  ata set!.       
+0000ae60: 2064 6174 655f 636f 6c5f 6d61 7070 6572   date_col_mapper
+0000ae70: 7320 3d20 7b7d 0a20 2020 2020 2020 2066  s = {}.        f
+0000ae80: 6f72 2064 6174 655f 636f 6c20 696e 2064  or date_col in d
+0000ae90: 6174 655f 636f 6c73 3a0a 2020 2020 2020  ate_cols:.      
+0000aea0: 2020 2020 2020 7072 696e 7428 2750 726f        print('Pro
+0000aeb0: 6365 7373 696e 6720 2573 2063 6f6c 756d  cessing %s colum
+0000aec0: 6e20 666f 7220 6461 7465 2074 696d 6520  n for date time 
+0000aed0: 6665 6174 7572 6573 2e2e 2e2e 2720 2564  features....' %d
+0000aee0: 6174 655f 636f 6c29 0a20 2020 2020 2020  ate_col).       
+0000aef0: 2020 2020 2064 6174 616e 616d 652c 2074       dataname, t
+0000af00: 735f 6164 6473 203d 2046 455f 6372 6561  s_adds = FE_crea
+0000af10: 7465 5f74 696d 655f 7365 7269 6573 5f66  te_time_series_f
+0000af20: 6561 7475 7265 7328 6461 7461 6e61 6d65  eatures(dataname
+0000af30: 2c20 6461 7465 5f63 6f6c 290a 2020 2020  , date_col).    
+0000af40: 2020 2020 2020 2020 6461 7465 5f63 6f6c          date_col
+0000af50: 5f6d 6170 7065 7220 3d20 6469 6374 285b  _mapper = dict([
+0000af60: 2878 2c64 6174 655f 636f 6c29 2066 6f72  (x,date_col) for
+0000af70: 2078 2069 6e20 7473 5f61 6464 735d 290a   x in ts_adds]).
+0000af80: 2020 2020 2020 2020 2020 2020 6461 7465              date
+0000af90: 5f63 6f6c 5f6d 6170 7065 7273 2e75 7064  _col_mappers.upd
+0000afa0: 6174 6528 6461 7465 5f63 6f6c 5f6d 6170  ate(date_col_map
+0000afb0: 7065 7229 0a20 2020 2020 2020 2020 2020  per).           
+0000afc0: 2023 7072 696e 7428 2720 2020 2041 6464   #print('    Add
+0000afd0: 696e 6720 2564 2063 6f6c 756d 6e28 7329  ing %d column(s)
+0000afe0: 2066 726f 6d20 6461 7465 2d74 696d 6520   from date-time 
+0000aff0: 636f 6c75 6d6e 2025 7320 696e 2074 7261  column %s in tra
+0000b000: 696e 2720 2528 6c65 6e28 6461 7465 5f63  in' %(len(date_c
+0000b010: 6f6c 5f61 6464 735f 7472 6169 6e29 2c64  ol_adds_train),d
+0000b020: 6174 655f 636f 6c29 290a 2020 2020 2020  ate_col)).      
+0000b030: 2020 2020 2020 2374 7261 696e 203d 2074        #train = t
+0000b040: 7261 696e 2e6a 6f69 6e28 6461 7465 5f64  rain.join(date_d
+0000b050: 665f 7472 6169 6e2c 2072 7375 6666 6978  f_train, rsuffix
+0000b060: 3d27 3227 290a 2020 2020 2020 2020 2020  ='2').          
+0000b070: 2020 6966 2069 7369 6e73 7461 6e63 6528    if isinstance(
+0000b080: 7465 7374 5f64 6174 612c 7374 7229 206f  test_data,str) o
+0000b090: 7220 7465 7374 5f64 6174 6120 6973 204e  r test_data is N
+0000b0a0: 6f6e 653a 0a20 2020 2020 2020 2020 2020  one:.           
+0000b0b0: 2020 2020 2023 2323 2064 6f20 6e6f 7468       ### do noth
+0000b0c0: 696e 6720 2323 2323 0a20 2020 2020 2020  ing ####.       
+0000b0d0: 2020 2020 2020 2020 2070 6173 730a 2020           pass.  
+0000b0e0: 2020 2020 2020 2020 2020 656c 7365 3a0a            else:.
+0000b0f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000b100: 7072 696e 7428 2720 2020 2020 2020 2041  print('        A
+0000b110: 6464 696e 6720 7361 6d65 2074 696d 6520  dding same time 
+0000b120: 7365 7269 6573 2066 6561 7475 7265 7320  series features 
+0000b130: 746f 2074 6573 7420 6461 7461 2e2e 2e27  to test data...'
+0000b140: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+0000b150: 2020 7465 7374 5f64 6174 612c 205f 203d    test_data, _ =
+0000b160: 2046 455f 6372 6561 7465 5f74 696d 655f   FE_create_time_
+0000b170: 7365 7269 6573 5f66 6561 7475 7265 7328  series_features(
+0000b180: 7465 7374 5f64 6174 612c 2064 6174 655f  test_data, date_
+0000b190: 636f 6c2c 2074 735f 6164 6473 290a 2020  col, ts_adds).  
+0000b1a0: 2020 2020 2020 2020 2020 2020 2020 2364                #d
+0000b1b0: 6174 655f 636f 6c5f 6164 6473 5f74 6573  ate_col_adds_tes
+0000b1c0: 745f 6461 7461 203d 206c 6566 745f 7375  t_data = left_su
+0000b1d0: 6274 7261 6374 2864 6174 655f 6466 5f74  btract(date_df_t
+0000b1e0: 6573 742e 636f 6c75 6d6e 732e 746f 6c69  est.columns.toli
+0000b1f0: 7374 2829 2c64 6174 655f 636f 6c29 0a20  st(),date_col). 
+0000b200: 2020 2020 2020 2020 2020 2020 2020 2023                 #
+0000b210: 2323 204e 6f77 2074 696d 6520 746f 2072  ## Now time to r
+0000b220: 656d 6f76 6520 7468 6520 6461 7465 2074  emove the date t
+0000b230: 696d 6520 636f 6c75 6d6e 2066 726f 6d20  ime column from 
+0000b240: 616c 6c20 6675 7274 6865 7220 7072 6f63  all further proc
+0000b250: 6573 7369 6e67 2023 230a 2020 2020 2020  essing ##.      
+0000b260: 2020 2020 2020 2020 2020 2374 6573 7420            #test 
+0000b270: 3d20 7465 7374 2e6a 6f69 6e28 6461 7465  = test.join(date
+0000b280: 5f64 665f 7465 7374 2c20 7273 7566 6669  _df_test, rsuffi
+0000b290: 783d 2732 2729 0a20 2020 2023 2323 204e  x='2').    ### N
+0000b2a0: 6f77 2074 696d 6520 746f 2063 6f6e 7469  ow time to conti
+0000b2b0: 6e75 6520 7769 7468 206f 7572 2066 7572  nue with our fur
+0000b2c0: 7468 6572 2070 726f 6365 7373 696e 6720  ther processing 
+0000b2d0: 2323 0a20 2020 2069 6463 6f6c 7320 3d20  ##.    idcols = 
+0000b2e0: 6665 6174 7572 6573 5f64 6963 745b 2749  features_dict['I
+0000b2f0: 4463 6f6c 7327 5d0a 2020 2020 6966 2069  Dcols'].    if i
+0000b300: 7369 6e73 7461 6e63 6528 7465 7374 5f64  sinstance(test_d
+0000b310: 6174 612c 7374 7229 206f 7220 7465 7374  ata,str) or test
+0000b320: 5f64 6174 6120 6973 204e 6f6e 653a 0a20  _data is None:. 
+0000b330: 2020 2020 2020 2070 6173 730a 2020 2020         pass.    
+0000b340: 656c 7365 3a0a 2020 2020 2020 2020 7465  else:.        te
+0000b350: 7374 5f69 6473 203d 2074 6573 745f 6461  st_ids = test_da
+0000b360: 7461 5b69 6463 6f6c 735d 0a20 2020 2074  ta[idcols].    t
+0000b370: 7261 696e 5f69 6473 203d 2064 6174 616e  rain_ids = datan
+0000b380: 616d 655b 6964 636f 6c73 5d20 2323 2320  ame[idcols] ### 
+0000b390: 7468 6973 2073 6176 6573 2074 6865 2049  this saves the I
+0000b3a0: 4420 636f 6c75 6d6e 7320 6f66 2064 6174  D columns of dat
+0000b3b0: 616e 616d 650a 2020 2020 6966 2063 6174  aname.    if cat
+0000b3c0: 5f76 6172 733a 0a20 2020 2020 2020 2063  _vars:.        c
+0000b3d0: 6f6c 735f 696e 5f62 6f74 6820 3d20 5b78  ols_in_both = [x
+0000b3e0: 2066 6f72 2078 2069 6e20 6361 745f 7661   for x in cat_va
+0000b3f0: 7273 2069 6620 7820 696e 2066 6561 7475  rs if x in featu
+0000b400: 7265 735f 6469 6374 5b27 636f 6c73 5f64  res_dict['cols_d
+0000b410: 656c 6574 6527 5d5d 0a20 2020 2020 2020  elete']].       
+0000b420: 2063 6174 5f76 6172 7320 3d20 6c65 6674   cat_vars = left
+0000b430: 5f73 7562 7472 6163 7428 6361 745f 7661  _subtract(cat_va
+0000b440: 7273 2c20 6665 6174 7572 6573 5f64 6963  rs, features_dic
+0000b450: 745b 2763 6f6c 735f 6465 6c65 7465 275d  t['cols_delete']
+0000b460: 290a 2020 2020 2020 2020 6966 206c 656e  ).        if len
+0000b470: 2863 6f6c 735f 696e 5f62 6f74 6829 203e  (cols_in_both) >
+0000b480: 2030 3a0a 2020 2020 2020 2020 2020 2020   0:.            
+0000b490: 7072 696e 7428 2752 656d 6f76 696e 6720  print('Removing 
+0000b4a0: 2573 2063 6f6c 756d 6e73 2873 2920 7768  %s columns(s) wh
+0000b4b0: 6963 6820 6172 6520 696e 2062 6f74 6820  ich are in both 
+0000b4c0: 636f 6c73 2074 6f20 6265 2064 656c 6574  cols to be delet
+0000b4d0: 6564 2061 6e64 2063 6174 2076 6172 7320  ed and cat vars 
+0000b4e0: 6769 7665 6e20 6173 2069 6e70 7574 2720  given as input' 
+0000b4f0: 2563 6f6c 735f 696e 5f62 6f74 6829 0a20  %cols_in_both). 
+0000b500: 2020 2063 6f6c 735f 746f 5f72 656d 6f76     cols_to_remov
+0000b510: 6520 3d20 6665 6174 7572 6573 5f64 6963  e = features_dic
+0000b520: 745b 2763 6f6c 735f 6465 6c65 7465 275d  t['cols_delete']
+0000b530: 202b 2069 6463 6f6c 7320 2b20 6665 6174   + idcols + feat
+0000b540: 7572 6573 5f64 6963 745b 2764 6973 6372  ures_dict['discr
+0000b550: 6574 655f 7374 7269 6e67 5f76 6172 7327  ete_string_vars'
+0000b560: 5d0a 2020 2020 7072 696e 7428 2752 656d  ].    print('Rem
+0000b570: 6f76 696e 6720 2564 2063 6f6c 756d 6e73  oving %d columns
+0000b580: 2066 726f 6d20 6675 7274 6865 7220 7072   from further pr
+0000b590: 6f63 6573 7369 6e67 2073 696e 6365 2049  ocessing since I
+0000b5a0: 4420 6f72 206c 6f77 2069 6e66 6f72 6d61  D or low informa
+0000b5b0: 7469 6f6e 2076 6172 6961 626c 6573 2720  tion variables' 
+0000b5c0: 256c 656e 2863 6f6c 735f 746f 5f72 656d  %len(cols_to_rem
+0000b5d0: 6f76 6529 290a 2020 2020 7072 6564 7320  ove)).    preds 
+0000b5e0: 3d20 5b78 2066 6f72 2078 2069 6e20 6c69  = [x for x in li
+0000b5f0: 7374 2864 6174 616e 616d 6529 2069 6620  st(dataname) if 
+0000b600: 7820 6e6f 7420 696e 2074 6172 6765 742b  x not in target+
+0000b610: 636f 6c73 5f74 6f5f 7265 6d6f 7665 5d0a  cols_to_remove].
+0000b620: 2020 2020 2323 2320 2020 5468 6973 2069      ###   This i
+0000b630: 7320 7768 6572 6520 7765 2073 6f72 7420  s where we sort 
+0000b640: 7468 6520 636f 6c75 6d6e 7320 746f 206d  the columns to m
+0000b650: 616b 6520 7375 7265 2074 6861 7420 7468  ake sure that th
+0000b660: 6520 6f72 6465 7220 6f66 2063 6f6c 756d  e order of colum
+0000b670: 6e73 2064 6f65 736e 2774 206d 6174 7465  ns doesn't matte
+0000b680: 7220 696e 2073 656c 6563 7469 6f6e 2023  r in selection #
+0000b690: 2323 2323 2323 2323 2323 0a20 2020 2023  ##########.    #
+0000b6a0: 7072 6564 7320 3d20 6e70 2e73 6f72 7428  preds = np.sort(
+0000b6b0: 7072 6564 7329 0a20 2020 2069 6620 7665  preds).    if ve
+0000b6c0: 7262 6f73 653a 0a20 2020 2020 2020 2070  rbose:.        p
+0000b6d0: 7269 6e74 2827 2020 2020 4166 7465 7220  rint('    After 
+0000b6e0: 7265 6d6f 7669 6e67 2072 6564 756e 6461  removing redunda
+0000b6f0: 6e74 2076 6172 6961 626c 6573 2066 726f  nt variables fro
+0000b700: 6d20 6675 7274 6865 7220 7072 6f63 6573  m further proces
+0000b710: 7369 6e67 2c20 6665 6174 7572 6573 206c  sing, features l
+0000b720: 6566 7420 3d20 2564 2720 256c 656e 2870  eft = %d' %len(p
+0000b730: 7265 6473 2929 0a20 2020 206e 756d 7661  reds)).    numva
+0000b740: 7273 203d 2064 6174 616e 616d 655b 7072  rs = dataname[pr
+0000b750: 6564 735d 2e73 656c 6563 745f 6474 7970  eds].select_dtyp
+0000b760: 6573 2869 6e63 6c75 6465 203d 2027 6e75  es(include = 'nu
+0000b770: 6d62 6572 2729 2e63 6f6c 756d 6e73 2e74  mber').columns.t
+0000b780: 6f6c 6973 7428 290a 2020 2020 6966 206c  olist().    if l
+0000b790: 656e 286e 756d 7661 7273 2920 3e20 6d61  en(numvars) > ma
+0000b7a0: 785f 6e75 6d73 3a0a 2020 2020 2020 2020  x_nums:.        
+0000b7b0: 6966 2066 6561 7475 7265 5f67 656e 3a0a  if feature_gen:.
+0000b7c0: 2020 2020 2020 2020 2020 2020 7072 696e              prin
+0000b7d0: 7428 275c 6e57 6172 6e69 6e67 3a20 546f  t('\nWarning: To
+0000b7e0: 6f20 6d61 6e79 2065 7874 7261 2066 6561  o many extra fea
+0000b7f0: 7475 7265 7320 7769 6c6c 2062 6520 6765  tures will be ge
+0000b800: 6e65 7261 7465 6420 6279 2066 6561 7475  nerated by featu
+0000b810: 7265 7769 7a2e 2054 6869 7320 6d61 7920  rewiz. This may 
+0000b820: 7461 6b65 2074 696d 652e 2e2e 2729 0a20  take time...'). 
+0000b830: 2020 2069 6620 6361 745f 7661 7273 3a0a     if cat_vars:.
+0000b840: 2020 2020 2020 2020 2323 2320 6966 2069          ### if i
+0000b850: 6e70 7574 2069 7320 6769 7665 6e20 666f  nput is given fo
+0000b860: 7220 6361 745f 7661 7273 2c20 7573 6520  r cat_vars, use 
+0000b870: 6974 210a 2020 2020 2020 2020 6361 7476  it!.        catv
+0000b880: 6172 7320 3d20 636f 7079 2e64 6565 7063  ars = copy.deepc
+0000b890: 6f70 7928 6361 745f 7661 7273 290a 2020  opy(cat_vars).  
+0000b8a0: 2020 2020 2020 6e75 6d76 6172 7320 3d20        numvars = 
+0000b8b0: 6c65 6674 5f73 7562 7472 6163 7428 7072  left_subtract(pr
+0000b8c0: 6564 732c 2063 6174 7661 7273 290a 2020  eds, catvars).  
+0000b8d0: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+0000b8e0: 6361 7476 6172 7320 3d20 6c65 6674 5f73  catvars = left_s
+0000b8f0: 7562 7472 6163 7428 7072 6564 732c 206e  ubtract(preds, n
+0000b900: 756d 7661 7273 290a 2020 2020 6966 206c  umvars).    if l
+0000b910: 656e 2863 6174 7661 7273 2920 3e20 6d61  en(catvars) > ma
+0000b920: 785f 6361 7473 3a0a 2020 2020 2020 2020  x_cats:.        
+0000b930: 6966 2066 6561 7475 7265 5f74 7970 653a  if feature_type:
+0000b940: 0a20 2020 2020 2020 2020 2020 2070 7269  .            pri
+0000b950: 6e74 2827 5c6e 5761 726e 696e 673a 2054  nt('\nWarning: T
+0000b960: 6f6f 206d 616e 7920 6578 7472 6120 6665  oo many extra fe
+0000b970: 6174 7572 6573 2077 696c 6c20 6265 2067  atures will be g
+0000b980: 656e 6572 6174 6564 2062 7920 6361 7465  enerated by cate
+0000b990: 676f 7279 2065 6e63 6f64 696e 672e 2054  gory encoding. T
+0000b9a0: 6869 7320 6d61 7920 7461 6b65 2074 696d  his may take tim
+0000b9b0: 652e 2e2e 2729 0a20 2020 2023 2323 2323  e...').    #####
+0000b9c0: 2320 2020 4320 5220 4520 4120 5420 4920  #   C R E A T I 
+0000b9d0: 4e20 4720 2020 2049 204e 2054 2058 204e  N G    I N T X N
+0000b9e0: 2020 5620 4120 5220 5320 2020 4620 5220    V A R S   F R 
+0000b9f0: 4f20 4d20 2020 4320 4120 5420 2056 2041  O M   C A T  V A
+0000ba00: 2052 2053 2023 2323 2323 2323 2323 2323   R S ###########
+0000ba10: 2323 2323 2323 2323 2323 0a20 2020 2069  ##########.    i
+0000ba20: 6620 6e70 2e77 6865 7265 2827 696e 7465  f np.where('inte
+0000ba30: 7261 6374 696f 6e73 2720 696e 2066 6561  ractions' in fea
+0000ba40: 7475 7265 5f67 656e 2c54 7275 652c 2046  ture_gen,True, F
+0000ba50: 616c 7365 292e 746f 6c69 7374 2829 3a0a  alse).tolist():.
+0000ba60: 2020 2020 2020 2020 6966 206c 656e 2863          if len(c
+0000ba70: 6174 7661 7273 2920 3e20 313a 0a20 2020  atvars) > 1:.   
+0000ba80: 2020 2020 2020 2020 200a 2020 2020 2020           .      
+0000ba90: 2020 2020 2020 6e75 6d5f 636f 6d62 6f73        num_combos
+0000baa0: 203d 206c 656e 286c 6973 7428 636f 6d62   = len(list(comb
+0000bab0: 696e 6174 696f 6e73 2863 6174 7661 7273  inations(catvars
+0000bac0: 2c32 2929 290a 2020 2020 2020 2020 2020  ,2))).          
+0000bad0: 2020 7072 696e 7428 2741 6464 696e 6720    print('Adding 
+0000bae0: 2573 2069 6e74 6572 6163 7469 6f6e 7320  %s interactions 
+0000baf0: 6265 7477 6565 6e20 6361 7465 676f 7269  between categori
+0000bb00: 6361 6c5f 7661 7273 2025 732e 2e2e 2720  cal_vars %s...' 
+0000bb10: 2528 0a20 2020 2020 2020 2020 2020 2020  %(.             
+0000bb20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000bb30: 2020 206e 756d 5f63 6f6d 626f 732c 2063     num_combos, c
+0000bb40: 6174 7661 7273 2929 0a20 2020 2020 2020  atvars)).       
+0000bb50: 2020 2020 2064 6174 616e 616d 6520 3d20       dataname = 
+0000bb60: 4645 5f63 7265 6174 655f 696e 7465 7261  FE_create_intera
+0000bb70: 6374 696f 6e5f 7661 7273 2864 6174 616e  ction_vars(datan
+0000bb80: 616d 652c 2063 6174 7661 7273 290a 2020  ame, catvars).  
+0000bb90: 2020 2020 2020 2020 2020 7472 6169 6e20            train 
+0000bba0: 3d20 4645 5f63 7265 6174 655f 696e 7465  = FE_create_inte
+0000bbb0: 7261 6374 696f 6e5f 7661 7273 2874 7261  raction_vars(tra
+0000bbc0: 696e 2c20 6361 7476 6172 7329 0a20 2020  in, catvars).   
+0000bbd0: 2020 2020 2020 2020 2063 6174 7661 7273           catvars
+0000bbe0: 203d 206c 6566 745f 7375 6274 7261 6374   = left_subtract
+0000bbf0: 2864 6174 616e 616d 652e 636f 6c75 6d6e  (dataname.column
+0000bc00: 732e 746f 6c69 7374 2829 2c20 6e75 6d76  s.tolist(), numv
+0000bc10: 6172 7329 0a20 2020 2020 2020 2020 2020  ars).           
+0000bc20: 2063 6174 7661 7273 203d 206c 6566 745f   catvars = left_
+0000bc30: 7375 6274 7261 6374 2863 6174 7661 7273  subtract(catvars
+0000bc40: 2c20 7461 7267 6574 290a 2020 2020 2020  , target).      
+0000bc50: 2020 2020 2020 7072 6564 7320 3d20 206c        preds =  l
+0000bc60: 6566 745f 7375 6274 7261 6374 2864 6174  eft_subtract(dat
+0000bc70: 616e 616d 652e 636f 6c75 6d6e 732e 746f  aname.columns.to
+0000bc80: 6c69 7374 2829 2c20 7461 7267 6574 290a  list(), target).
+0000bc90: 2020 2020 2020 2020 2020 2020 6966 206e              if n
+0000bca0: 6f74 2074 6573 745f 6461 7461 2069 7320  ot test_data is 
+0000bcb0: 4e6f 6e65 3a0a 2020 2020 2020 2020 2020  None:.          
+0000bcc0: 2020 2020 2020 7465 7374 5f64 6174 6120        test_data 
+0000bcd0: 3d20 4645 5f63 7265 6174 655f 696e 7465  = FE_create_inte
+0000bce0: 7261 6374 696f 6e5f 7661 7273 2874 6573  raction_vars(tes
+0000bcf0: 745f 6461 7461 2c20 6361 7476 6172 7329  t_data, catvars)
+0000bd00: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000bd10: 2074 6573 7420 3d20 4645 5f63 7265 6174   test = FE_creat
+0000bd20: 655f 696e 7465 7261 6374 696f 6e5f 7661  e_interaction_va
+0000bd30: 7273 2874 6573 742c 2063 6174 7661 7273  rs(test, catvars
+0000bd40: 290a 2020 2020 2020 2020 656c 7365 3a0a  ).        else:.
+0000bd50: 2020 2020 2020 2020 2020 2020 6966 2076              if v
+0000bd60: 6572 626f 7365 3a0a 2020 2020 2020 2020  erbose:.        
+0000bd70: 2020 2020 2020 2020 7072 696e 7428 274e          print('N
+0000bd80: 6f20 696e 7465 7261 6374 696f 6e73 2063  o interactions c
+0000bd90: 7265 6174 6564 2066 6f72 2063 6174 6567  reated for categ
+0000bda0: 6f72 6963 616c 2076 6172 7320 7369 6e63  orical vars sinc
+0000bdb0: 6520 6e75 6d62 6572 206c 6573 7320 7468  e number less th
+0000bdc0: 616e 2032 2729 0a20 2020 2065 6c73 653a  an 2').    else:
+0000bdd0: 0a20 2020 2020 2020 2069 6620 7665 7262  .        if verb
+0000bde0: 6f73 653a 0a20 2020 2020 2020 2020 2020  ose:.           
+0000bdf0: 2070 7269 6e74 2827 4e6f 2069 6e74 6572   print('No inter
+0000be00: 6163 7469 6f6e 7320 6372 6561 7465 6420  actions created 
+0000be10: 666f 7220 6361 7465 676f 7269 6361 6c20  for categorical 
+0000be20: 7661 7273 2073 696e 6365 2066 6561 7475  vars since featu
+0000be30: 7265 2065 6e67 6720 646f 6573 206e 6f74  re engg does not
+0000be40: 2073 7065 6369 6679 2069 7427 290a 2020   specify it').  
+0000be50: 2020 2323 2323 2320 4e6f 7720 7765 206e    ##### Now we n
+0000be60: 6565 6420 746f 2072 652d 7365 7420 7468  eed to re-set th
+0000be70: 6520 6361 7476 6172 7320 6167 6169 6e20  e catvars again 
+0000be80: 7369 6e63 6520 7765 2068 6176 6520 6372  since we have cr
+0000be90: 6561 7465 6420 6e65 7720 6665 6174 7572  eated new featur
+0000bea0: 6573 2023 2323 2323 0a20 2020 2072 656d  es #####.    rem
+0000beb0: 5f76 6172 7320 3d20 636f 7079 2e64 6565  _vars = copy.dee
+0000bec0: 7063 6f70 7928 6361 7476 6172 7329 0a20  pcopy(catvars). 
+0000bed0: 2020 2023 2323 2323 2323 2323 2320 4e6f     ########## No
+0000bee0: 7720 7765 206e 6565 6420 746f 2073 656c  w we need to sel
+0000bef0: 6563 7420 7468 6520 7269 6768 7420 6d6f  ect the right mo
+0000bf00: 6465 6c20 746f 2072 756e 2072 6570 6561  del to run repea
+0000bf10: 7465 646c 7920 2323 2323 0a20 2020 2069  tedly ####.    i
+0000bf20: 6620 7365 7474 696e 6773 2e6d 6f64 656c  f settings.model
+0000bf30: 7479 7065 2021 3d20 2752 6567 7265 7373  type != 'Regress
+0000bf40: 696f 6e27 3a0a 2020 2020 2020 2020 2323  ion':.        ##
+0000bf50: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000bf60: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000bf70: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000bf80: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000bf90: 2323 2323 2323 2323 0a20 2020 2020 2020  ########.       
+0000bfa0: 2023 2323 2323 2323 2323 2323 2020 204c   ###########   L
+0000bfb0: 2041 2042 2045 204c 2020 2020 4520 4e20   A B E L    E N 
+0000bfc0: 4320 4f20 4420 4920 4e20 4720 2020 4f20  C O D I N G   O 
+0000bfd0: 4620 2020 5420 4120 5220 4720 4520 5420  F   T A R G E T 
+0000bfe0: 2020 2323 2323 2323 2323 230a 2020 2020    #########.    
+0000bff0: 2020 2020 2323 2323 2323 2323 2323 2323      ############
+0000c000: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000c010: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000c020: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000c030: 2323 2323 2323 2323 2323 2323 2323 0a20  ##############. 
+0000c040: 2020 2020 2020 2023 2323 2054 6869 7320         ### This 
+0000c050: 6973 2074 6f20 636f 6e76 6572 7420 7468  is to convert th
+0000c060: 6520 7461 7267 6574 206c 6162 656c 7320  e target labels 
+0000c070: 746f 2070 726f 7065 7220 6e75 6d65 7269  to proper numeri
+0000c080: 6320 636f 6c75 6d6e 7320 2323 2323 2323  c columns ######
+0000c090: 0a20 2020 2020 2020 2074 6172 6765 745f  .        target_
+0000c0a0: 636f 6e76 6572 7369 6f6e 5f66 6c61 6720  conversion_flag 
+0000c0b0: 3d20 4661 6c73 650a 2020 2020 2020 2020  = False.        
+0000c0c0: 6361 745f 7461 7267 6574 7320 3d20 6461  cat_targets = da
+0000c0d0: 7461 6e61 6d65 5b74 6172 6765 745d 2e73  taname[target].s
+0000c0e0: 656c 6563 745f 6474 7970 6573 2869 6e63  elect_dtypes(inc
+0000c0f0: 6c75 6465 3d27 6f62 6a65 6374 2729 2e63  lude='object').c
+0000c100: 6f6c 756d 6e73 2e74 6f6c 6973 7428 2920  olumns.tolist() 
+0000c110: 2b20 6461 7461 6e61 6d65 5b74 6172 6765  + dataname[targe
+0000c120: 745d 2e73 656c 6563 745f 6474 7970 6573  t].select_dtypes
+0000c130: 2869 6e63 6c75 6465 3d27 6361 7465 676f  (include='catego
+0000c140: 7279 2729 2e63 6f6c 756d 6e73 2e74 6f6c  ry').columns.tol
+0000c150: 6973 7428 290a 2020 2020 2020 2020 636f  ist().        co
+0000c160: 7079 5f74 6172 6765 7473 203d 2063 6f70  py_targets = cop
+0000c170: 792e 6465 6570 636f 7079 2874 6172 6765  y.deepcopy(targe
+0000c180: 7473 290a 2020 2020 2020 2020 666f 7220  ts).        for 
+0000c190: 6561 6368 5f74 6172 6765 7420 696e 2063  each_target in c
+0000c1a0: 6f70 795f 7461 7267 6574 733a 0a20 2020  opy_targets:.   
+0000c1b0: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+0000c1c0: 6361 745f 7461 7267 6574 7320 6f72 2073  cat_targets or s
+0000c1d0: 6f72 7465 6428 6e70 2e75 6e69 7175 6528  orted(np.unique(
+0000c1e0: 6461 7461 6e61 6d65 5b65 6163 685f 7461  dataname[each_ta
+0000c1f0: 7267 6574 5d2e 7661 6c75 6573 2929 5b30  rget].values))[0
+0000c200: 5d20 213d 2030 3a0a 2020 2020 2020 2020  ] != 0:.        
+0000c210: 2020 2020 2020 2020 2020 2020 7072 696e              prin
+0000c220: 7428 2720 2020 2074 6172 6765 7420 6c61  t('    target la
+0000c230: 6265 6c73 206e 6565 6420 746f 2062 6520  bels need to be 
+0000c240: 636f 6e76 6572 7465 642e 2e2e 2729 0a20  converted...'). 
+0000c250: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c260: 2020 2074 6172 6765 745f 636f 6e76 6572     target_conver
+0000c270: 7369 6f6e 5f66 6c61 6720 3d20 5472 7565  sion_flag = True
+0000c280: 0a20 2020 2020 2020 2023 2323 2063 6865  .        ### che
+0000c290: 636b 2069 6620 7468 6579 2061 7265 206e  ck if they are n
+0000c2a0: 6f74 2073 7461 7274 696e 6720 6672 6f6d  ot starting from
+0000c2b0: 207a 6572 6f20 2323 2323 2323 2323 2323   zero ##########
+0000c2c0: 2323 2323 2323 2323 0a20 2020 2020 2020  ########.       
+0000c2d0: 2063 6f70 795f 7461 7267 6574 7320 3d20   copy_targets = 
+0000c2e0: 636f 7079 2e64 6565 7063 6f70 7928 7461  copy.deepcopy(ta
+0000c2f0: 7267 6574 290a 2020 2020 2020 2020 666f  rget).        fo
+0000c300: 7220 6561 6368 5f74 6172 6765 7420 696e  r each_target in
+0000c310: 2063 6f70 795f 7461 7267 6574 733a 0a20   copy_targets:. 
+0000c320: 2020 2020 2020 2020 2020 2069 6620 7461             if ta
+0000c330: 7267 6574 5f63 6f6e 7665 7273 696f 6e5f  rget_conversion_
+0000c340: 666c 6167 3a0a 2020 2020 2020 2020 2020  flag:.          
+0000c350: 2020 2020 2020 6d6c 6220 3d20 4d79 5f4c        mlb = My_L
+0000c360: 6162 656c 456e 636f 6465 7228 290a 2020  abelEncoder().  
+0000c370: 2020 2020 2020 2020 2020 2020 2020 6461                da
+0000c380: 7461 6e61 6d65 5b65 6163 685f 7461 7267  taname[each_targ
+0000c390: 6574 5d20 3d20 6d6c 622e 6669 745f 7472  et] = mlb.fit_tr
+0000c3a0: 616e 7366 6f72 6d28 6461 7461 6e61 6d65  ansform(dataname
+0000c3b0: 5b65 6163 685f 7461 7267 6574 5d29 0a20  [each_target]). 
+0000c3c0: 2020 2020 2020 2020 2020 2020 2020 2074                 t
+0000c3d0: 7279 3a0a 2020 2020 2020 2020 2020 2020  ry:.            
+0000c3e0: 2020 2020 2020 2020 2323 2041 6674 6572          ## After
+0000c3f0: 2063 6f6e 7665 7274 696e 6720 7472 6169   converting trai
+0000c400: 6e2c 206a 7573 7420 6c6f 6164 2069 7420  n, just load it 
+0000c410: 696e 746f 2064 6173 6b20 6167 6169 6e20  into dask again 
+0000c420: 2323 0a20 2020 2020 2020 2020 2020 2020  ##.             
+0000c430: 2020 2020 2020 2074 7261 696e 5b65 6163         train[eac
+0000c440: 685f 7461 7267 6574 5d20 3d20 6464 2e66  h_target] = dd.f
+0000c450: 726f 6d5f 7061 6e64 6173 2864 6174 616e  rom_pandas(datan
+0000c460: 616d 655b 6561 6368 5f74 6172 6765 745d  ame[each_target]
+0000c470: 2c20 6e70 6172 7469 7469 6f6e 733d 6e5f  , npartitions=n_
+0000c480: 776f 726b 6572 7329 0a20 2020 2020 2020  workers).       
+0000c490: 2020 2020 2020 2020 2065 7863 6570 743a           except:
+0000c4a0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000c4b0: 2020 2020 2070 7269 6e74 2827 436f 756c       print('Coul
+0000c4c0: 6420 6e6f 7420 636f 6e76 6572 7420 6461  d not convert da
+0000c4d0: 736b 2064 6174 6166 7261 6d65 2074 6172  sk dataframe tar
+0000c4e0: 6765 7420 696e 746f 206e 756d 6572 6963  get into numeric
+0000c4f0: 2e20 4368 6563 6b20 796f 7572 2069 6e70  . Check your inp
+0000c500: 7574 2e20 436f 6e74 696e 7569 6e67 2e2e  ut. Continuing..
+0000c510: 2e27 290a 2020 2020 2020 2020 2020 2020  .').            
+0000c520: 2020 2020 6966 2074 6573 745f 6461 7461      if test_data
+0000c530: 2069 7320 6e6f 7420 4e6f 6e65 3a0a 2020   is not None:.  
+0000c540: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c550: 2020 6966 2065 6163 685f 7461 7267 6574    if each_target
+0000c560: 2069 6e20 7465 7374 5f64 6174 612e 636f   in test_data.co
+0000c570: 6c75 6d6e 733a 0a20 2020 2020 2020 2020  lumns:.         
+0000c580: 2020 2020 2020 2020 2020 2020 2020 2074                 t
+0000c590: 6573 745f 6461 7461 5b65 6163 685f 7461  est_data[each_ta
+0000c5a0: 7267 6574 5d20 3d20 6d6c 622e 7472 616e  rget] = mlb.tran
+0000c5b0: 7366 6f72 6d28 7465 7374 5f64 6174 615b  sform(test_data[
+0000c5c0: 6561 6368 5f74 6172 6765 745d 290a 2020  each_target]).  
+0000c5d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c5e0: 2020 2020 2020 7472 793a 0a20 2020 2020        try:.     
+0000c5f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c600: 2020 2020 2020 2023 2320 4166 7465 7220         ## After 
+0000c610: 636f 6e76 6572 7469 6e67 2074 6573 742c  converting test,
+0000c620: 206a 7573 7420 6c6f 6164 2069 7420 696e   just load it in
+0000c630: 746f 2064 6173 6b20 6167 6169 6e20 2323  to dask again ##
+0000c640: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000c650: 2020 2020 2020 2020 2020 2020 2074 6573               tes
+0000c660: 745b 6561 6368 5f74 6172 6765 745d 203d  t[each_target] =
+0000c670: 2064 642e 6672 6f6d 5f70 616e 6461 7328   dd.from_pandas(
+0000c680: 7465 7374 5f64 6174 615b 6561 6368 5f74  test_data[each_t
+0000c690: 6172 6765 745d 2c20 6e70 6172 7469 7469  arget], npartiti
+0000c6a0: 6f6e 733d 6e5f 776f 726b 6572 7329 0a20  ons=n_workers). 
+0000c6b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c6c0: 2020 2020 2020 2065 7863 6570 743a 0a20         except:. 
+0000c6d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000c6e0: 2020 2020 2020 2020 2020 2070 7269 6e74             print
+0000c6f0: 2827 436f 756c 6420 6e6f 7420 636f 6e76  ('Could not conv
+0000c700: 6572 7420 6461 736b 2064 6174 6166 7261  ert dask datafra
+0000c710: 6d65 2074 6172 6765 7420 696e 746f 206e  me target into n
+0000c720: 756d 6572 6963 2e20 4368 6563 6b20 796f  umeric. Check yo
+0000c730: 7572 2069 6e70 7574 2e20 436f 6e74 696e  ur input. Contin
+0000c740: 7569 6e67 2e2e 2e27 290a 2020 2020 2020  uing...').      
+0000c750: 2020 2020 2020 2020 2020 7072 696e 7428            print(
+0000c760: 2743 6f6d 706c 6574 6564 206c 6162 656c  'Completed label
+0000c770: 2065 6e63 6f64 696e 6720 6f66 2074 6172   encoding of tar
+0000c780: 6765 7420 7661 7269 6162 6c65 203d 2025  get variable = %
+0000c790: 7327 2025 6561 6368 5f74 6172 6765 7429  s' %each_target)
+0000c7a0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000c7b0: 2070 7269 6e74 2827 486f 7720 6d6f 6465   print('How mode
+0000c7c0: 6c20 7072 6564 6963 7469 6f6e 7320 6e65  l predictions ne
+0000c7d0: 6564 2074 6f20 6265 2074 7261 6e73 666f  ed to be transfo
+0000c7e0: 726d 6564 2066 6f72 2025 733a 5c6e 5c74  rmed for %s:\n\t
+0000c7f0: 2573 2720 2528 6561 6368 5f74 6172 6765  %s' %(each_targe
+0000c800: 742c 206d 6c62 2e69 6e76 6572 7365 5f74  t, mlb.inverse_t
+0000c810: 7261 6e73 666f 726d 6572 2929 0a0a 2020  ransformer))..  
+0000c820: 2020 2323 2323 2323 2323 2323 2323 2323    ##############
+0000c830: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000c840: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000c850: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000c860: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000c870: 2323 2323 2323 2323 0a20 2020 2023 2323  ########.    ###
+0000c880: 2323 2320 2020 2042 2045 2046 204f 2052  ###    B E F O R
+0000c890: 2045 2020 2020 5520 5320 4920 4e20 4720   E    U S I N G 
+0000c8a0: 2020 2044 2041 2054 2041 2042 2055 204e     D A T A B U N
+0000c8b0: 2043 2048 2020 4320 4820 4520 4320 4b20   C H  C H E C K 
 0000c8c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000c8d0: 2323 2323 2323 2323 2323 2323 2323 0a20  ##############. 
-0000c8e0: 2020 2023 2320 4265 666f 7265 2075 7369     ## Before usi
-0000c8f0: 6e67 2044 6174 6142 756e 6368 2063 6865  ng DataBunch che
-0000c900: 636b 2069 6620 6365 7274 6169 6e20 656e  ck if certain en
-0000c910: 636f 6465 7273 2077 6f72 6b20 7769 7468  coders work with
-0000c920: 2063 6572 7461 696e 206b 696e 6420 6f66   certain kind of
-0000c930: 2064 6174 6121 0a20 2020 2069 6620 6665   data!.    if fe
-0000c940: 6174 7572 655f 7479 7065 3a0a 2020 2020  ature_type:.    
-0000c950: 2020 2020 6669 6e61 6c5f 6361 745f 656e      final_cat_en
-0000c960: 636f 6465 7273 203d 2066 6561 7475 7265  coders = feature
-0000c970: 5f74 7970 650a 2020 2020 656c 7365 3a0a  _type.    else:.
-0000c980: 2020 2020 2020 2020 6669 6e61 6c5f 6361          final_ca
-0000c990: 745f 656e 636f 6465 7273 203d 205b 5d0a  t_encoders = [].
-0000c9a0: 2020 2020 6966 2073 6574 7469 6e67 732e      if settings.
-0000c9b0: 6d6f 6465 6c74 7970 6520 3d3d 2027 4d75  modeltype == 'Mu
-0000c9c0: 6c74 695f 436c 6173 7369 6669 6361 7469  lti_Classificati
-0000c9d0: 6f6e 273a 0a20 2020 2020 2020 2023 2323  on':.        ###
-0000c9e0: 2079 6f75 206d 7573 7420 7075 7420 6120   you must put a 
-0000c9f0: 506f 6c79 6e6f 6d69 616c 2057 7261 7070  Polynomial Wrapp
-0000ca00: 6572 206f 6e20 7468 6520 6361 745f 656e  er on the cat_en
-0000ca10: 636f 6465 7220 696e 2063 6173 6520 7468  coder in case th
-0000ca20: 6520 6d6f 6465 6c20 6973 206d 756c 7469  e model is multi
-0000ca30: 2d63 6c61 7373 0a20 2020 2020 2020 2069  -class.        i
-0000ca40: 6620 6669 6e61 6c5f 6361 745f 656e 636f  f final_cat_enco
-0000ca50: 6465 7273 3a0a 2020 2020 2020 2020 2020  ders:.          
-0000ca60: 2020 6669 6e61 6c5f 6361 745f 656e 636f    final_cat_enco
-0000ca70: 6465 7273 203d 205b 506f 6c79 6e6f 6d69  ders = [Polynomi
-0000ca80: 616c 5772 6170 7065 7228 7829 2066 6f72  alWrapper(x) for
-0000ca90: 2078 2069 6e20 6669 6e61 6c5f 6361 745f   x in final_cat_
-0000caa0: 656e 636f 6465 7273 2069 6620 7820 696e  encoders if x in
-0000cab0: 2073 6574 7469 6e67 732e 7461 7267 6574   settings.target
-0000cac0: 5f65 6e63 6f64 6572 735f 6e61 6d65 735d  _encoders_names]
-0000cad0: 0a20 2020 2065 6c69 6620 7365 7474 696e  .    elif settin
-0000cae0: 6773 2e6d 6f64 656c 7479 7065 203d 3d20  gs.modeltype == 
-0000caf0: 2752 6567 7265 7373 696f 6e27 3a0a 2020  'Regression':.  
-0000cb00: 2020 2020 2020 6966 2066 696e 616c 5f63        if final_c
-0000cb10: 6174 5f65 6e63 6f64 6572 733a 0a20 2020  at_encoders:.   
-0000cb20: 2020 2020 2020 2020 2069 6620 2757 4f45           if 'WOE
-0000cb30: 456e 636f 6465 7227 2069 6e20 6669 6e61  Encoder' in fina
-0000cb40: 6c5f 6361 745f 656e 636f 6465 7273 3a0a  l_cat_encoders:.
-0000cb50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cb60: 7072 696e 7428 2752 656d 6f76 696e 6720  print('Removing 
-0000cb70: 574f 4545 6e63 6f64 6572 2066 726f 6d20  WOEEncoder from 
-0000cb80: 6c69 7374 206f 6620 656e 636f 6465 7273  list of encoders
-0000cb90: 2073 696e 6365 2069 7420 6361 6e6e 6f74   since it cannot
-0000cba0: 2062 6520 7573 6564 2066 6f72 2074 6869   be used for thi
-0000cbb0: 7320 5265 6772 6573 7369 6f6e 2070 726f  s Regression pro
-0000cbc0: 626c 656d 2e27 290a 2020 2020 2020 2020  blem.').        
-0000cbd0: 2020 2020 6669 6e61 6c5f 6361 745f 656e      final_cat_en
-0000cbe0: 636f 6465 7273 203d 205b 7820 666f 7220  coders = [x for 
-0000cbf0: 7820 696e 2066 696e 616c 5f63 6174 5f65  x in final_cat_e
-0000cc00: 6e63 6f64 6572 7320 6966 2078 2021 3d20  ncoders if x != 
-0000cc10: 2757 4f45 456e 636f 6465 7227 205d 0a20  'WOEEncoder' ]. 
-0000cc20: 2020 2023 2323 2323 2323 2323 2323 2323     #############
-0000cc30: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000cc40: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000cc50: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000cc60: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000cc70: 2323 2323 2323 2323 230a 2020 2020 2323  #########.    ##
-0000cc80: 2323 2323 2020 2020 4620 4520 4120 5420  ####    F E A T 
-0000cc90: 5520 5220 4520 2020 2045 204e 2047 2047  U R E    E N G G
-0000cca0: 2020 2020 5520 5320 4920 4e20 4720 2020      U S I N G   
-0000ccb0: 2044 2041 2054 2041 2042 2055 204e 2043   D A T A B U N C
-0000ccc0: 2048 2020 2323 2323 2323 2323 2323 2323   H  ############
-0000ccd0: 2323 2323 2323 230a 2020 2020 2323 2323  #######.    ####
-0000cce0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000ccf0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000cd00: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000cd10: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000cd20: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000cd30: 2323 0a20 2020 2069 6620 6665 6174 7572  ##.    if featur
-0000cd40: 655f 6765 6e20 6f72 2066 6561 7475 7265  e_gen or feature
-0000cd50: 5f74 7970 653a 0a20 2020 2020 2020 2069  _type:.        i
-0000cd60: 6620 6973 696e 7374 616e 6365 2874 6573  f isinstance(tes
-0000cd70: 745f 6461 7461 2c20 7374 7229 206f 7220  t_data, str) or 
-0000cd80: 7465 7374 5f64 6174 6120 6973 204e 6f6e  test_data is Non
-0000cd90: 653a 0a20 2020 2020 2020 2020 2020 2070  e:.            p
-0000cda0: 7269 6e74 2827 2020 2020 5374 6172 7469  rint('    Starti
-0000cdb0: 6e67 2066 6561 7475 7265 2065 6e67 696e  ng feature engin
-0000cdc0: 6565 7269 6e67 2e2e 2e53 696e 6365 206e  eering...Since n
-0000cdd0: 6f20 7465 7374 2064 6174 6120 6973 2067  o test data is g
-0000cde0: 6976 656e 2c20 7370 6c69 7474 696e 6720  iven, splitting 
-0000cdf0: 7472 6169 6e20 696e 746f 2074 776f 2e2e  train into two..
-0000ce00: 2e27 290a 2020 2020 2020 2020 2020 2020  .').            
-0000ce10: 6966 2073 6574 7469 6e67 732e 6d75 6c74  if settings.mult
-0000ce20: 695f 6c61 6265 6c3a 0a20 2020 2020 2020  i_label:.       
-0000ce30: 2020 2020 2020 2020 2023 2323 2069 6620           ### if 
-0000ce40: 6974 2069 7320 6120 6d75 6c74 695f 6c61  it is a multi_la
-0000ce50: 6265 6c20 7072 6f62 6c65 6d2c 206c 6561  bel problem, lea
-0000ce60: 7665 2074 6172 6765 7420 6173 2069 7420  ve target as it 
-0000ce70: 6973 202d 2061 206c 6973 7421 0a20 2020  is - a list!.   
-0000ce80: 2020 2020 2020 2020 2020 2020 2058 5f74               X_t
-0000ce90: 7261 696e 2c20 585f 7465 7374 2c20 795f  rain, X_test, y_
-0000cea0: 7472 6169 6e2c 2079 5f74 6573 7420 3d20  train, y_test = 
-0000ceb0: 7472 6169 6e5f 7465 7374 5f73 706c 6974  train_test_split
-0000cec0: 2864 6174 616e 616d 655b 7072 6564 735d  (dataname[preds]
-0000ced0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-0000cee0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cef0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cf00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cf10: 2020 6461 7461 6e61 6d65 5b74 6172 6765    dataname[targe
-0000cf20: 745d 2c0a 2020 2020 2020 2020 2020 2020  t],.            
+0000c8d0: 2323 230a 2020 2020 2323 2323 2323 2323  ###.    ########
+0000c8e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000c8f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000c900: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000c910: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000c920: 2323 2323 2323 2323 2323 2323 2323 0a20  ##############. 
+0000c930: 2020 2023 2320 4265 666f 7265 2075 7369     ## Before usi
+0000c940: 6e67 2044 6174 6142 756e 6368 2063 6865  ng DataBunch che
+0000c950: 636b 2069 6620 6365 7274 6169 6e20 656e  ck if certain en
+0000c960: 636f 6465 7273 2077 6f72 6b20 7769 7468  coders work with
+0000c970: 2063 6572 7461 696e 206b 696e 6420 6f66   certain kind of
+0000c980: 2064 6174 6121 0a20 2020 2069 6620 6665   data!.    if fe
+0000c990: 6174 7572 655f 7479 7065 3a0a 2020 2020  ature_type:.    
+0000c9a0: 2020 2020 6669 6e61 6c5f 6361 745f 656e      final_cat_en
+0000c9b0: 636f 6465 7273 203d 2066 6561 7475 7265  coders = feature
+0000c9c0: 5f74 7970 650a 2020 2020 656c 7365 3a0a  _type.    else:.
+0000c9d0: 2020 2020 2020 2020 6669 6e61 6c5f 6361          final_ca
+0000c9e0: 745f 656e 636f 6465 7273 203d 205b 5d0a  t_encoders = [].
+0000c9f0: 2020 2020 6966 2073 6574 7469 6e67 732e      if settings.
+0000ca00: 6d6f 6465 6c74 7970 6520 3d3d 2027 4d75  modeltype == 'Mu
+0000ca10: 6c74 695f 436c 6173 7369 6669 6361 7469  lti_Classificati
+0000ca20: 6f6e 273a 0a20 2020 2020 2020 2023 2323  on':.        ###
+0000ca30: 2079 6f75 206d 7573 7420 7075 7420 6120   you must put a 
+0000ca40: 506f 6c79 6e6f 6d69 616c 2057 7261 7070  Polynomial Wrapp
+0000ca50: 6572 206f 6e20 7468 6520 6361 745f 656e  er on the cat_en
+0000ca60: 636f 6465 7220 696e 2063 6173 6520 7468  coder in case th
+0000ca70: 6520 6d6f 6465 6c20 6973 206d 756c 7469  e model is multi
+0000ca80: 2d63 6c61 7373 0a20 2020 2020 2020 2069  -class.        i
+0000ca90: 6620 6669 6e61 6c5f 6361 745f 656e 636f  f final_cat_enco
+0000caa0: 6465 7273 3a0a 2020 2020 2020 2020 2020  ders:.          
+0000cab0: 2020 6669 6e61 6c5f 6361 745f 656e 636f    final_cat_enco
+0000cac0: 6465 7273 203d 205b 506f 6c79 6e6f 6d69  ders = [Polynomi
+0000cad0: 616c 5772 6170 7065 7228 7829 2066 6f72  alWrapper(x) for
+0000cae0: 2078 2069 6e20 6669 6e61 6c5f 6361 745f   x in final_cat_
+0000caf0: 656e 636f 6465 7273 2069 6620 7820 696e  encoders if x in
+0000cb00: 2073 6574 7469 6e67 732e 7461 7267 6574   settings.target
+0000cb10: 5f65 6e63 6f64 6572 735f 6e61 6d65 735d  _encoders_names]
+0000cb20: 0a20 2020 2065 6c69 6620 7365 7474 696e  .    elif settin
+0000cb30: 6773 2e6d 6f64 656c 7479 7065 203d 3d20  gs.modeltype == 
+0000cb40: 2752 6567 7265 7373 696f 6e27 3a0a 2020  'Regression':.  
+0000cb50: 2020 2020 2020 6966 2066 696e 616c 5f63        if final_c
+0000cb60: 6174 5f65 6e63 6f64 6572 733a 0a20 2020  at_encoders:.   
+0000cb70: 2020 2020 2020 2020 2069 6620 2757 4f45           if 'WOE
+0000cb80: 456e 636f 6465 7227 2069 6e20 6669 6e61  Encoder' in fina
+0000cb90: 6c5f 6361 745f 656e 636f 6465 7273 3a0a  l_cat_encoders:.
+0000cba0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cbb0: 7072 696e 7428 2752 656d 6f76 696e 6720  print('Removing 
+0000cbc0: 574f 4545 6e63 6f64 6572 2066 726f 6d20  WOEEncoder from 
+0000cbd0: 6c69 7374 206f 6620 656e 636f 6465 7273  list of encoders
+0000cbe0: 2073 696e 6365 2069 7420 6361 6e6e 6f74   since it cannot
+0000cbf0: 2062 6520 7573 6564 2066 6f72 2074 6869   be used for thi
+0000cc00: 7320 5265 6772 6573 7369 6f6e 2070 726f  s Regression pro
+0000cc10: 626c 656d 2e27 290a 2020 2020 2020 2020  blem.').        
+0000cc20: 2020 2020 6669 6e61 6c5f 6361 745f 656e      final_cat_en
+0000cc30: 636f 6465 7273 203d 205b 7820 666f 7220  coders = [x for 
+0000cc40: 7820 696e 2066 696e 616c 5f63 6174 5f65  x in final_cat_e
+0000cc50: 6e63 6f64 6572 7320 6966 2078 2021 3d20  ncoders if x != 
+0000cc60: 2757 4f45 456e 636f 6465 7227 205d 0a20  'WOEEncoder' ]. 
+0000cc70: 2020 2023 2323 2323 2323 2323 2323 2323     #############
+0000cc80: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000cc90: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000cca0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000ccb0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000ccc0: 2323 2323 2323 2323 230a 2020 2020 2323  #########.    ##
+0000ccd0: 2323 2323 2020 2020 4620 4520 4120 5420  ####    F E A T 
+0000cce0: 5520 5220 4520 2020 2045 204e 2047 2047  U R E    E N G G
+0000ccf0: 2020 2020 5520 5320 4920 4e20 4720 2020      U S I N G   
+0000cd00: 2044 2041 2054 2041 2042 2055 204e 2043   D A T A B U N C
+0000cd10: 2048 2020 2323 2323 2323 2323 2323 2323   H  ############
+0000cd20: 2323 2323 2323 230a 2020 2020 2323 2323  #######.    ####
+0000cd30: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000cd40: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000cd50: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000cd60: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000cd70: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000cd80: 2323 0a20 2020 2069 6620 6665 6174 7572  ##.    if featur
+0000cd90: 655f 6765 6e20 6f72 2066 6561 7475 7265  e_gen or feature
+0000cda0: 5f74 7970 653a 0a20 2020 2020 2020 2069  _type:.        i
+0000cdb0: 6620 6973 696e 7374 616e 6365 2874 6573  f isinstance(tes
+0000cdc0: 745f 6461 7461 2c20 7374 7229 206f 7220  t_data, str) or 
+0000cdd0: 7465 7374 5f64 6174 6120 6973 204e 6f6e  test_data is Non
+0000cde0: 653a 0a20 2020 2020 2020 2020 2020 2070  e:.            p
+0000cdf0: 7269 6e74 2827 2020 2020 5374 6172 7469  rint('    Starti
+0000ce00: 6e67 2066 6561 7475 7265 2065 6e67 696e  ng feature engin
+0000ce10: 6565 7269 6e67 2e2e 2e53 696e 6365 206e  eering...Since n
+0000ce20: 6f20 7465 7374 2064 6174 6120 6973 2067  o test data is g
+0000ce30: 6976 656e 2c20 7370 6c69 7474 696e 6720  iven, splitting 
+0000ce40: 7472 6169 6e20 696e 746f 2074 776f 2e2e  train into two..
+0000ce50: 2e27 290a 2020 2020 2020 2020 2020 2020  .').            
+0000ce60: 6966 2073 6574 7469 6e67 732e 6d75 6c74  if settings.mult
+0000ce70: 695f 6c61 6265 6c3a 0a20 2020 2020 2020  i_label:.       
+0000ce80: 2020 2020 2020 2020 2023 2323 2069 6620           ### if 
+0000ce90: 6974 2069 7320 6120 6d75 6c74 695f 6c61  it is a multi_la
+0000cea0: 6265 6c20 7072 6f62 6c65 6d2c 206c 6561  bel problem, lea
+0000ceb0: 7665 2074 6172 6765 7420 6173 2069 7420  ve target as it 
+0000cec0: 6973 202d 2061 206c 6973 7421 0a20 2020  is - a list!.   
+0000ced0: 2020 2020 2020 2020 2020 2020 2058 5f74               X_t
+0000cee0: 7261 696e 2c20 585f 7465 7374 2c20 795f  rain, X_test, y_
+0000cef0: 7472 6169 6e2c 2079 5f74 6573 7420 3d20  train, y_test = 
+0000cf00: 7472 6169 6e5f 7465 7374 5f73 706c 6974  train_test_split
+0000cf10: 2864 6174 616e 616d 655b 7072 6564 735d  (dataname[preds]
+0000cf20: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
 0000cf30: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000cf40: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000cf50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cf60: 2020 2020 7465 7374 5f73 697a 653d 302e      test_size=0.
-0000cf70: 322c 0a20 2020 2020 2020 2020 2020 2020  2,.             
+0000cf60: 2020 6461 7461 6e61 6d65 5b74 6172 6765    dataname[targe
+0000cf70: 745d 2c0a 2020 2020 2020 2020 2020 2020  t],.            
 0000cf80: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000cf90: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000cfa0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000cfb0: 2020 2072 616e 646f 6d5f 7374 6174 653d     random_state=
-0000cfc0: 5241 4e44 4f4d 5f53 4545 4429 0a20 2020  RANDOM_SEED).   
-0000cfd0: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
-0000cfe0: 2020 2020 2020 2020 2020 2020 2020 2023                 #
-0000cff0: 2323 2069 6620 6974 206e 6f74 2061 206d  ## if it not a m
-0000d000: 756c 7469 5f6c 6162 656c 2070 726f 626c  ulti_label probl
-0000d010: 656d 2c20 6d61 6b65 2074 6172 6765 7420  em, make target 
-0000d020: 6173 2074 6172 6765 745b 305d 0a20 2020  as target[0].   
-0000d030: 2020 2020 2020 2020 2020 2020 2058 5f74               X_t
-0000d040: 7261 696e 2c20 585f 7465 7374 2c20 795f  rain, X_test, y_
-0000d050: 7472 6169 6e2c 2079 5f74 6573 7420 3d20  train, y_test = 
-0000d060: 7472 6169 6e5f 7465 7374 5f73 706c 6974  train_test_split
-0000d070: 2864 6174 616e 616d 655b 7072 6564 735d  (dataname[preds]
-0000d080: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-0000d090: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d0a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d0b0: 2020 2020 2020 2020 2020 2020 2020 6461                da
-0000d0c0: 7461 6e61 6d65 5b74 6172 6765 745b 305d  taname[target[0]
-0000d0d0: 5d2c 0a20 2020 2020 2020 2020 2020 2020  ],.             
+0000cfb0: 2020 2020 7465 7374 5f73 697a 653d 302e      test_size=0.
+0000cfc0: 322c 0a20 2020 2020 2020 2020 2020 2020  2,.             
+0000cfd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cfe0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000cff0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d000: 2020 2072 616e 646f 6d5f 7374 6174 653d     random_state=
+0000d010: 5241 4e44 4f4d 5f53 4545 4429 0a20 2020  RANDOM_SEED).   
+0000d020: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
+0000d030: 2020 2020 2020 2020 2020 2020 2020 2023                 #
+0000d040: 2323 2069 6620 6974 206e 6f74 2061 206d  ## if it not a m
+0000d050: 756c 7469 5f6c 6162 656c 2070 726f 626c  ulti_label probl
+0000d060: 656d 2c20 6d61 6b65 2074 6172 6765 7420  em, make target 
+0000d070: 6173 2074 6172 6765 745b 305d 0a20 2020  as target[0].   
+0000d080: 2020 2020 2020 2020 2020 2020 2058 5f74               X_t
+0000d090: 7261 696e 2c20 585f 7465 7374 2c20 795f  rain, X_test, y_
+0000d0a0: 7472 6169 6e2c 2079 5f74 6573 7420 3d20  train, y_test = 
+0000d0b0: 7472 6169 6e5f 7465 7374 5f73 706c 6974  train_test_split
+0000d0c0: 2864 6174 616e 616d 655b 7072 6564 735d  (dataname[preds]
+0000d0d0: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
 0000d0e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000d0f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d100: 2020 2020 2020 2020 2020 2020 2020 2074                 t
-0000d110: 6573 745f 7369 7a65 3d30 2e32 2c0a 2020  est_size=0.2,.  
-0000d120: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d100: 2020 2020 2020 2020 2020 2020 2020 6461                da
+0000d110: 7461 6e61 6d65 5b74 6172 6765 745b 305d  taname[target[0]
+0000d120: 5d2c 0a20 2020 2020 2020 2020 2020 2020  ],.             
 0000d130: 2020 2020 2020 2020 2020 2020 2020 2020                  
 0000d140: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d150: 2020 2020 2020 2020 2020 7261 6e64 6f6d            random
-0000d160: 5f73 7461 7465 3d52 414e 444f 4d5f 5345  _state=RANDOM_SE
-0000d170: 4544 290a 2020 2020 2020 2020 656c 7365  ED).        else
-0000d180: 3a0a 2020 2020 2020 2020 2020 2020 7072  :.            pr
-0000d190: 696e 7428 2720 2020 2053 7461 7274 696e  int('    Startin
-0000d1a0: 6720 6665 6174 7572 6520 656e 6769 6e65  g feature engine
-0000d1b0: 6572 696e 672e 2e2e 5369 6e63 6520 7465  ering...Since te
-0000d1c0: 7374 2064 6174 6120 6973 2067 6976 656e  st data is given
-0000d1d0: 2c20 7573 696e 6720 7472 6169 6e20 616e  , using train an
-0000d1e0: 6420 7465 7374 2e2e 2e27 290a 2020 2020  d test...').    
-0000d1f0: 2020 2020 2020 2020 585f 7472 6169 6e20          X_train 
-0000d200: 3d20 6461 7461 6e61 6d65 5b70 7265 6473  = dataname[preds
-0000d210: 5d0a 2020 2020 2020 2020 2020 2020 6966  ].            if
-0000d220: 2073 6574 7469 6e67 732e 6d75 6c74 695f   settings.multi_
-0000d230: 6c61 6265 6c3a 0a20 2020 2020 2020 2020  label:.         
-0000d240: 2020 2020 2020 2079 5f74 7261 696e 203d         y_train =
-0000d250: 2064 6174 616e 616d 655b 7461 7267 6574   dataname[target
-0000d260: 5d0a 2020 2020 2020 2020 2020 2020 656c  ].            el
-0000d270: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
-0000d280: 2020 2020 795f 7472 6169 6e20 3d20 6461      y_train = da
-0000d290: 7461 6e61 6d65 5b74 6172 6765 745b 305d  taname[target[0]
-0000d2a0: 5d0a 2020 2020 2020 2020 2020 2020 585f  ].            X_
-0000d2b0: 7465 7374 203d 2074 6573 745f 6461 7461  test = test_data
-0000d2c0: 5b70 7265 6473 5d0a 2020 2020 2020 2020  [preds].        
-0000d2d0: 2020 2020 7472 793a 0a20 2020 2020 2020      try:.       
-0000d2e0: 2020 2020 2020 2020 2079 5f74 6573 7420           y_test 
-0000d2f0: 3d20 7465 7374 5f64 6174 615b 7461 7267  = test_data[targ
-0000d300: 6574 5d0a 2020 2020 2020 2020 2020 2020  et].            
-0000d310: 6578 6365 7074 3a0a 2020 2020 2020 2020  except:.        
-0000d320: 2020 2020 2020 2020 795f 7465 7374 203d          y_test =
-0000d330: 204e 6f6e 650a 2020 2020 2020 2020 585f   None.        X_
-0000d340: 7472 6169 6e5f 696e 6465 7820 3d20 585f  train_index = X_
-0000d350: 7472 6169 6e2e 696e 6465 780a 2020 2020  train.index.    
-0000d360: 2020 2020 585f 7465 7374 5f69 6e64 6578      X_test_index
-0000d370: 203d 2058 5f74 6573 742e 696e 6465 780a   = X_test.index.
-0000d380: 2020 2020 2020 2020 0a20 2020 2020 2020          .       
-0000d390: 2023 2323 2323 2323 2323 2323 2323 2323   ###############
-0000d3a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000d3b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000d3c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000d3d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000d3e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000d3f0: 2323 230a 2020 2020 2020 2020 2323 2323  ###.        ####
-0000d400: 2323 2043 6174 6567 6f72 795f 456e 636f  ## Category_Enco
-0000d410: 6465 7273 2064 6f65 7320 6e6f 7420 776f  ders does not wo
-0000d420: 726b 2077 6974 6820 4461 736b 202d 2073  rk with Dask - s
-0000d430: 6f20 646f 6e27 7420 7365 6e64 2069 6e20  o don't send in 
-0000d440: 4461 736b 2064 6174 6166 7261 6d65 7320  Dask dataframes 
-0000d450: 746f 2044 6174 6142 756e 6368 210a 2020  to DataBunch!.  
-0000d460: 2020 2020 2020 2323 2323 2323 2323 2323        ##########
-0000d470: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000d480: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000d490: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000d4a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000d4b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000d4c0: 2323 2323 2323 2323 0a20 2020 2020 2020  ########.       
-0000d4d0: 2064 6174 615f 7475 706c 6520 3d20 4461   data_tuple = Da
-0000d4e0: 7461 4275 6e63 6828 585f 7472 6169 6e3d  taBunch(X_train=
-0000d4f0: 585f 7472 6169 6e2c 0a20 2020 2020 2020  X_train,.       
-0000d500: 2020 2020 2020 2020 2020 2020 2079 5f74               y_t
-0000d510: 7261 696e 3d79 5f74 7261 696e 2c0a 2020  rain=y_train,.  
-0000d520: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d530: 2020 585f 7465 7374 3d58 5f74 6573 742c    X_test=X_test,
-0000d540: 2023 2062 6520 7375 7265 2074 6f20 7370   # be sure to sp
-0000d550: 6563 6966 7920 585f 7465 7374 2c20 6265  ecify X_test, be
-0000d560: 6361 7573 6520 7468 6520 656e 636f 6465  cause the encode
-0000d570: 7220 6e65 6564 7320 616c 6c20 6461 7461  r needs all data
-0000d580: 7365 7420 746f 2077 6f72 6b2e 0a20 2020  set to work..   
-0000d590: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d5a0: 2063 6174 5f66 6561 7475 7265 7320 3d20   cat_features = 
-0000d5b0: 6361 7476 6172 732c 0a20 2020 2020 2020  catvars,.       
-0000d5c0: 2020 2020 2020 2020 2020 2020 2063 6c65               cle
-0000d5d0: 616e 5f61 6e64 5f65 6e63 6f64 5f64 6174  an_and_encod_dat
-0000d5e0: 613d 5472 7565 2c0a 2020 2020 2020 2020  a=True,.        
-0000d5f0: 2020 2020 2020 2020 2020 2020 6361 745f              cat_
-0000d600: 656e 636f 6465 725f 6e61 6d65 733d 6669  encoder_names=fi
-0000d610: 6e61 6c5f 6361 745f 656e 636f 6465 7273  nal_cat_encoders
-0000d620: 2c20 2320 6669 6e61 6c20 6c69 7374 206f  , # final list o
-0000d630: 6620 456e 636f 6465 7273 2073 656c 6563  f Encoders selec
-0000d640: 7465 640a 2020 2020 2020 2020 2020 2020  ted.            
-0000d650: 2020 2020 2020 2020 636c 6561 6e5f 6e61          clean_na
-0000d660: 6e3d 5472 7565 2c20 2320 6669 6c6c 6e61  n=True, # fillna
-0000d670: 6e0a 2020 2020 2020 2020 2020 2020 2020  n.              
-0000d680: 2020 2020 2020 6e75 6d5f 6765 6e65 7261        num_genera
-0000d690: 746f 725f 6665 6174 7572 6573 3d6e 702e  tor_features=np.
-0000d6a0: 7768 6572 6528 2769 6e74 6572 6163 7469  where('interacti
-0000d6b0: 6f6e 7327 2069 6e20 6665 6174 7572 655f  ons' in feature_
-0000d6c0: 6765 6e2c 5472 7565 2c20 4661 6c73 6529  gen,True, False)
-0000d6d0: 2e74 6f6c 6973 7428 292c 2023 2047 656e  .tolist(), # Gen
-0000d6e0: 6572 6174 6520 696e 7465 7261 6374 696f  erate interactio
-0000d6f0: 6e20 4e75 6d20 4665 6174 7572 6573 0a20  n Num Features. 
-0000d700: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d710: 2020 2067 726f 7570 5f67 656e 6572 6174     group_generat
-0000d720: 6f72 5f66 6561 7475 7265 733d 6e70 2e77  or_features=np.w
-0000d730: 6865 7265 2827 6772 6f75 7062 7927 2069  here('groupby' i
-0000d740: 6e20 6665 6174 7572 655f 6765 6e2c 5472  n feature_gen,Tr
-0000d750: 7565 2c20 4661 6c73 6529 2e74 6f6c 6973  ue, False).tolis
-0000d760: 7428 292c 2023 2047 656e 6572 6174 6520  t(), # Generate 
-0000d770: 6772 6f75 7062 7920 4665 6174 7572 6573  groupby Features
-0000d780: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000d790: 2020 2020 2074 6172 6765 745f 656e 635f       target_enc_
-0000d7a0: 6361 745f 6665 6174 7572 6573 3d74 6172  cat_features=tar
-0000d7b0: 6765 745f 656e 635f 6361 745f 6665 6174  get_enc_cat_feat
-0000d7c0: 7572 6573 2c23 2047 656e 6572 6174 6520  ures,# Generate 
-0000d7d0: 7461 7267 6574 2065 6e63 6f64 6564 2066  target encoded f
-0000d7e0: 6561 7475 7265 730a 2020 2020 2020 2020  eatures.        
-0000d7f0: 2020 2020 2020 2020 2020 2020 6e6f 726d              norm
-0000d800: 616c 697a 6174 696f 6e3d 4661 6c73 652c  alization=False,
-0000d810: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000d820: 2020 2020 2072 616e 646f 6d5f 7374 6174       random_stat
-0000d830: 653d 5241 4e44 4f4d 5f53 4545 442c 0a20  e=RANDOM_SEED,. 
-0000d840: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000d850: 2020 2029 0a20 2020 2020 2020 2023 2323     ).        ###
-0000d860: 2320 4e6f 7720 796f 7520 6361 6e20 7072  # Now you can pr
-0000d870: 6f63 6573 7320 7468 6520 7475 706c 6520  ocess the tuple 
-0000d880: 7468 6973 2077 6179 2023 2323 2323 2323  this way #######
-0000d890: 2323 0a20 2020 2020 2020 2069 6620 7479  ##.        if ty
-0000d8a0: 7065 2879 5f74 7261 696e 2920 3d3d 2064  pe(y_train) == d
-0000d8b0: 6173 6b2e 6461 7461 6672 616d 652e 636f  ask.dataframe.co
-0000d8c0: 7265 2e44 6174 6146 7261 6d65 3a0a 2020  re.DataFrame:.  
-0000d8d0: 2020 2020 2020 2020 2020 2323 2320 7369            ### si
-0000d8e0: 6e63 6520 795f 7472 6169 6e20 6973 2064  nce y_train is d
-0000d8f0: 6173 6b20 6466 2061 6e64 2064 6174 615f  ask df and data_
-0000d900: 7475 706c 652e 585f 7472 6169 6e20 6973  tuple.X_train is
-0000d910: 2061 2070 616e 6461 7320 6466 2c20 796f   a pandas df, yo
-0000d920: 7520 6361 6e27 7420 6d65 7267 6520 7468  u can't merge th
-0000d930: 656d 2e0a 2020 2020 2020 2020 2020 2020  em..            
-0000d940: 795f 7472 6169 6e20 3d20 795f 7472 6169  y_train = y_trai
-0000d950: 6e2e 636f 6d70 7574 6528 2920 2023 2323  n.compute()  ###
-0000d960: 2072 656d 656d 6265 7220 796f 7520 6669   remember you fi
-0000d970: 7273 7420 6861 7665 2074 6f20 636f 6e76  rst have to conv
-0000d980: 6572 7420 7468 656d 2074 6f20 6120 7061  ert them to a pa
-0000d990: 6e64 6173 2064 660a 2020 2020 2020 2020  ndas df.        
-0000d9a0: 6461 7461 3120 3d20 7064 2e63 6f6e 6361  data1 = pd.conca
-0000d9b0: 7428 5b64 6174 615f 7475 706c 652e 585f  t([data_tuple.X_
-0000d9c0: 7472 6169 6e2c 2079 5f74 7261 696e 5d2c  train, y_train],
-0000d9d0: 2061 7869 733d 3129 2023 2323 2064 6174   axis=1) ### dat
-0000d9e0: 615f 7475 706c 6520 646f 6573 206e 6f74  a_tuple does not
-0000d9f0: 2068 6176 6520 6120 795f 7472 6169 6e2c   have a y_train,
-0000da00: 2072 656d 656d 6265 7221 0a20 2020 2020   remember!.     
-0000da10: 2020 200a 2020 2020 2020 2020 6966 2069     .        if i
-0000da20: 7369 6e73 7461 6e63 6528 7465 7374 5f64  sinstance(test_d
-0000da30: 6174 612c 2073 7472 2920 6f72 2074 6573  ata, str) or tes
-0000da40: 745f 6461 7461 2069 7320 4e6f 6e65 3a0a  t_data is None:.
-0000da50: 2020 2020 2020 2020 2020 2020 2323 2320              ### 
-0000da60: 5369 6e63 6520 796f 7520 6861 7665 2064  Since you have d
-0000da70: 6f6e 6520 6120 7472 6169 6e5f 7465 7374  one a train_test
-0000da80: 5f73 706c 6974 2075 7369 6e67 2072 616e  _split using ran
-0000da90: 646f 6d69 7a65 6420 7370 6c69 742c 2079  domized split, y
-0000daa0: 6f75 206e 6565 6420 746f 2070 7574 2069  ou need to put i
-0000dab0: 7420 6261 636b 2061 6761 696e 2e0a 2020  t back again..  
-0000dac0: 2020 2020 2020 2020 2020 6966 2074 7970            if typ
-0000dad0: 6528 795f 7465 7374 2920 3d3d 2064 6173  e(y_test) == das
-0000dae0: 6b2e 6461 7461 6672 616d 652e 636f 7265  k.dataframe.core
-0000daf0: 2e44 6174 6146 7261 6d65 3a0a 2020 2020  .DataFrame:.    
-0000db00: 2020 2020 2020 2020 2020 2020 2323 2320              ### 
-0000db10: 7369 6e63 6520 795f 7472 6169 6e20 6973  since y_train is
-0000db20: 2064 6173 6b20 6466 2061 6e64 2064 6174   dask df and dat
-0000db30: 615f 7475 706c 652e 585f 7472 6169 6e20  a_tuple.X_train 
-0000db40: 6973 2061 2070 616e 6461 7320 6466 2c20  is a pandas df, 
-0000db50: 796f 7520 6361 6e27 7420 6d65 7267 6520  you can't merge 
-0000db60: 7468 656d 2e0a 2020 2020 2020 2020 2020  them..          
-0000db70: 2020 2020 2020 795f 7465 7374 203d 2079        y_test = y
-0000db80: 5f74 6573 742e 636f 6d70 7574 6528 2920  _test.compute() 
-0000db90: 2023 2323 2072 656d 656d 6265 7220 796f   ### remember yo
-0000dba0: 7520 6669 7273 7420 6861 7665 2074 6f20  u first have to 
-0000dbb0: 636f 6e76 6572 7420 7468 656d 2074 6f20  convert them to 
-0000dbc0: 6120 7061 6e64 6173 2064 660a 2020 2020  a pandas df.    
-0000dbd0: 2020 2020 2020 2020 6461 7461 3220 3d20          data2 = 
-0000dbe0: 7064 2e63 6f6e 6361 7428 5b64 6174 615f  pd.concat([data_
-0000dbf0: 7475 706c 652e 585f 7465 7374 2c20 795f  tuple.X_test, y_
-0000dc00: 7465 7374 5d2c 2061 7869 733d 3129 0a20  test], axis=1). 
-0000dc10: 2020 2020 2020 2020 2020 2064 6174 616e             datan
-0000dc20: 616d 6520 3d20 6461 7461 312e 6170 7065  ame = data1.appe
-0000dc30: 6e64 2864 6174 6132 290a 2020 2020 2020  nd(data2).      
-0000dc40: 2020 2020 2020 2323 2320 536f 6d65 7469        ### Someti
-0000dc50: 6d65 7320 7468 6572 6520 6172 6520 6475  mes there are du
-0000dc60: 706c 6963 6174 6520 7661 6c75 6573 2069  plicate values i
-0000dc70: 6e20 696e 6465 7820 7768 656e 2079 6f75  n index when you
-0000dc80: 2061 7070 656e 642e 2053 6f20 6a75 7374   append. So just
-0000dc90: 2072 656d 6f76 6520 6475 706c 6963 6174   remove duplicat
-0000dca0: 6573 2068 6572 650a 2020 2020 2020 2020  es here.        
-0000dcb0: 2020 2020 6461 7461 6e61 6d65 203d 2064      dataname = d
-0000dcc0: 6174 616e 616d 655b 7e64 6174 616e 616d  ataname[~datanam
-0000dcd0: 652e 696e 6465 782e 6475 706c 6963 6174  e.index.duplicat
-0000dce0: 6564 2829 5d0a 2020 2020 2020 2020 2020  ed()].          
-0000dcf0: 2020 6461 7461 6e61 6d65 203d 2064 6174    dataname = dat
-0000dd00: 616e 616d 652e 7265 696e 6465 7828 7472  aname.reindex(tr
-0000dd10: 6169 6e5f 696e 6465 7829 0a20 2020 2020  ain_index).     
-0000dd20: 2020 2020 2020 2070 7269 6e74 2827 2020         print('  
-0000dd30: 2020 436f 6d70 6c65 7465 6420 6665 6174    Completed feat
-0000dd40: 7572 6520 656e 6769 6e65 6572 696e 672e  ure engineering.
-0000dd50: 2053 6861 7065 206f 6620 5472 6169 6e20   Shape of Train 
-0000dd60: 2877 6974 6820 7461 7267 6574 2920 3d20  (with target) = 
-0000dd70: 2573 2720 2528 6461 7461 6e61 6d65 2e73  %s' %(dataname.s
-0000dd80: 6861 7065 2c29 290a 2020 2020 2020 2020  hape,)).        
-0000dd90: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
-0000dda0: 2020 7472 793a 0a20 2020 2020 2020 2020    try:.         
-0000ddb0: 2020 2020 2020 2069 6620 7479 7065 2879         if type(y
-0000ddc0: 5f74 6573 7429 203d 3d20 6461 736b 2e64  _test) == dask.d
-0000ddd0: 6174 6166 7261 6d65 2e63 6f72 652e 4461  ataframe.core.Da
-0000dde0: 7461 4672 616d 653a 0a20 2020 2020 2020  taFrame:.       
-0000ddf0: 2020 2020 2020 2020 2020 2020 2023 2323               ###
-0000de00: 2073 696e 6365 2079 5f74 7261 696e 2069   since y_train i
-0000de10: 7320 6461 736b 2064 6620 616e 6420 6461  s dask df and da
-0000de20: 7461 5f74 7570 6c65 2e58 5f74 7261 696e  ta_tuple.X_train
-0000de30: 2069 7320 6120 7061 6e64 6173 2064 662c   is a pandas df,
-0000de40: 2079 6f75 2063 616e 2774 206d 6572 6765   you can't merge
-0000de50: 2074 6865 6d2e 0a20 2020 2020 2020 2020   them..         
-0000de60: 2020 2020 2020 2020 2020 2079 5f74 6573             y_tes
-0000de70: 7420 3d20 795f 7465 7374 2e63 6f6d 7075  t = y_test.compu
-0000de80: 7465 2829 2020 2323 2320 7265 6d65 6d62  te()  ### rememb
-0000de90: 6572 2079 6f75 2066 6972 7374 2068 6176  er you first hav
-0000dea0: 6520 746f 2063 6f6e 7665 7274 2074 6865  e to convert the
-0000deb0: 6d20 746f 2061 2070 616e 6461 7320 6466  m to a pandas df
-0000dec0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000ded0: 2074 6573 745f 6461 7461 203d 2070 642e   test_data = pd.
-0000dee0: 636f 6e63 6174 285b 6461 7461 5f74 7570  concat([data_tup
-0000def0: 6c65 2e58 5f74 6573 742c 2079 5f74 6573  le.X_test, y_tes
-0000df00: 745d 2c20 6178 6973 3d31 290a 2020 2020  t], axis=1).    
-0000df10: 2020 2020 2020 2020 6578 6365 7074 3a0a          except:.
-0000df20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000df30: 7465 7374 5f64 6174 6120 3d20 636f 7079  test_data = copy
-0000df40: 2e64 6565 7063 6f70 7928 6461 7461 5f74  .deepcopy(data_t
-0000df50: 7570 6c65 2e58 5f74 6573 7429 0a20 2020  uple.X_test).   
-0000df60: 2020 2020 2020 2020 2023 2323 2053 6f6d           ### Som
-0000df70: 6574 696d 6573 2074 6865 7265 2061 7265  etimes there are
-0000df80: 2064 7570 6c69 6361 7465 2076 616c 7565   duplicate value
-0000df90: 7320 696e 2069 6e64 6578 2077 6865 6e20  s in index when 
-0000dfa0: 796f 7520 6170 7065 6e64 2e20 536f 206a  you append. So j
-0000dfb0: 7573 7420 7265 6d6f 7665 2064 7570 6c69  ust remove dupli
-0000dfc0: 6361 7465 7320 6865 7265 0a20 2020 2020  cates here.     
-0000dfd0: 2020 2020 2020 2074 6573 745f 6461 7461         test_data
-0000dfe0: 203d 2074 6573 745f 6461 7461 5b7e 7465   = test_data[~te
-0000dff0: 7374 5f64 6174 612e 696e 6465 782e 6475  st_data.index.du
-0000e000: 706c 6963 6174 6564 2829 5d0a 2020 2020  plicated()].    
-0000e010: 2020 2020 2020 2020 7465 7374 5f64 6174          test_dat
-0000e020: 6120 3d20 7465 7374 5f64 6174 612e 7265  a = test_data.re
-0000e030: 696e 6465 7828 7465 7374 5f69 6e64 6578  index(test_index
-0000e040: 290a 2020 2020 2020 2020 2020 2020 6461  ).            da
-0000e050: 7461 6e61 6d65 203d 2063 6f70 792e 6465  taname = copy.de
-0000e060: 6570 636f 7079 2864 6174 6131 290a 2020  epcopy(data1).  
-0000e070: 2020 2020 2020 2020 2020 7072 696e 7428            print(
-0000e080: 2720 2020 2043 6f6d 706c 6574 6564 2066  '    Completed f
-0000e090: 6561 7475 7265 2065 6e67 696e 6565 7269  eature engineeri
-0000e0a0: 6e67 2e20 5368 6170 6520 6f66 2054 6573  ng. Shape of Tes
-0000e0b0: 7420 2877 6974 6820 7461 7267 6574 2920  t (with target) 
-0000e0c0: 3d20 2573 2720 2528 7465 7374 5f64 6174  = %s' %(test_dat
-0000e0d0: 612e 7368 6170 652c 2929 0a20 2020 2020  a.shape,)).     
-0000e0e0: 2020 2023 2323 2323 2323 2323 2323 2323     #############
-0000e0f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000e100: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000e110: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000e120: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000e130: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000e140: 2323 2323 0a20 2020 2020 2020 2023 2323  ####.        ###
-0000e150: 2323 2320 5472 6169 6e20 616e 6420 5465  ### Train and Te
-0000e160: 7374 2061 7265 2063 7572 7265 6e74 6c79  st are currently
-0000e170: 2070 616e 6461 7320 6461 7461 2066 7261   pandas data fra
-0000e180: 6d65 7320 6576 656e 2069 6620 6461 736b  mes even if dask
-0000e190: 5f78 6762 6f6f 7374 5f66 6c61 6720 6973  _xgboost_flag is
-0000e1a0: 2054 7275 6520 2323 2323 2323 2323 0a20   True ########. 
-0000e1b0: 2020 2020 2020 2023 2323 2323 2320 2020         ######   
-0000e1c0: 5468 6174 2069 7320 6265 6361 7573 6520  That is because 
-0000e1d0: 7765 2063 6f6d 6269 6e65 6420 7468 656d  we combined them
-0000e1e0: 2061 6674 6572 2066 6561 7475 7265 2065   after feature e
-0000e1f0: 6e67 6720 746f 2075 7369 6e67 2043 6174  ngg to using Cat
-0000e200: 6567 6f72 795f 456e 636f 6465 7273 2020  egory_Encoders  
-0000e210: 2323 2323 2323 2323 0a20 2020 2020 2020  ########.       
-0000e220: 2023 2323 2323 2323 2323 2323 2323 2323   ###############
-0000e230: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000e240: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000e250: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000e260: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000e270: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000e280: 2323 0a20 2020 2020 2020 2070 7265 6473  ##.        preds
-0000e290: 203d 205b 7820 666f 7220 7820 696e 206c   = [x for x in l
-0000e2a0: 6973 7428 6461 7461 6e61 6d65 2920 6966  ist(dataname) if
-0000e2b0: 2078 206e 6f74 2069 6e20 7461 7267 6574   x not in target
-0000e2c0: 5d0a 2020 2020 2020 2020 6e75 6d76 6172  ].        numvar
-0000e2d0: 7320 3d20 6461 7461 6e61 6d65 5b70 7265  s = dataname[pre
-0000e2e0: 6473 5d2e 7365 6c65 6374 5f64 7479 7065  ds].select_dtype
-0000e2f0: 7328 696e 636c 7564 6520 3d20 276e 756d  s(include = 'num
-0000e300: 6265 7227 292e 636f 6c75 6d6e 732e 746f  ber').columns.to
-0000e310: 6c69 7374 2829 0a20 2020 2020 2020 2069  list().        i
-0000e320: 6620 6361 745f 7661 7273 3a0a 2020 2020  f cat_vars:.    
-0000e330: 2020 2020 2020 2020 2323 2323 2069 6620          #### if 
-0000e340: 6361 745f 7661 7273 2069 6e70 7574 2069  cat_vars input i
-0000e350: 7320 6769 7665 6e2c 2075 7365 2069 7421  s given, use it!
-0000e360: 0a20 2020 2020 2020 2020 2020 2063 6174  .            cat
-0000e370: 7661 7273 203d 2063 6f70 792e 6465 6570  vars = copy.deep
-0000e380: 636f 7079 2863 6174 5f76 6172 7329 0a20  copy(cat_vars). 
-0000e390: 2020 2020 2020 2020 2020 206e 756d 7661             numva
-0000e3a0: 7273 203d 206c 6566 745f 7375 6274 7261  rs = left_subtra
-0000e3b0: 6374 2870 7265 6473 2c20 6361 7476 6172  ct(preds, catvar
-0000e3c0: 7329 0a20 2020 2020 2020 2065 6c73 653a  s).        else:
-0000e3d0: 0a20 2020 2020 2020 2020 2020 2063 6174  .            cat
-0000e3e0: 7661 7273 203d 206c 6566 745f 7375 6274  vars = left_subt
-0000e3f0: 7261 6374 2870 7265 6473 2c20 6e75 6d76  ract(preds, numv
-0000e400: 6172 7329 0a20 2020 2023 2323 2323 2323  ars).    #######
-0000e410: 2323 2323 2323 2323 2323 2323 2323 2320  ############### 
-0000e420: 2020 4920 4d20 5020 4f20 5220 5420 4120    I M P O R T A 
-0000e430: 4e20 5420 2323 2323 2323 2323 2323 2323  N T ############
-0000e440: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000e450: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000e460: 2323 0a20 2020 2023 2323 2323 2320 5468  ##.    ###### Th
-0000e470: 6973 2074 6f70 5f6e 756d 2064 6563 6964  is top_num decid
-0000e480: 6573 2068 6f77 206d 616e 7920 746f 705f  es how many top_
-0000e490: 6e20 6665 6174 7572 6573 2058 4742 2073  n features XGB s
-0000e4a0: 656c 6563 7473 2069 6e20 6561 6368 2069  elects in each i
-0000e4b0: 7465 7261 7469 6f6e 2e0a 2020 2020 2323  teration..    ##
-0000e4c0: 2323 2020 5468 6572 6520 6120 746f 7461  ##  There a tota
-0000e4d0: 6c20 6f66 2035 2069 7465 7261 7469 6f6e  l of 5 iteration
-0000e4e0: 732e 2048 656e 6365 2035 7831 3020 6d65  s. Hence 5x10 me
-0000e4f0: 616e 7320 6d61 7869 6d75 6d20 3530 2066  ans maximum 50 f
-0000e500: 6561 7475 7265 7320 7769 6c6c 2062 6520  eatures will be 
-0000e510: 7365 6c65 6374 6564 2e0a 2020 2020 2323  selected..    ##
-0000e520: 2323 2320 2049 6620 7468 6572 6520 6172  ###  If there ar
-0000e530: 6520 6d6f 7265 2074 6861 6e20 3530 2076  e more than 50 v
-0000e540: 6172 6961 626c 6573 2c20 7468 656e 206d  ariables, then m
-0000e550: 6178 696d 756d 2032 3525 206f 6620 6974  aximum 25% of it
-0000e560: 7320 7661 7269 6162 6c65 7320 7769 6c6c  s variables will
-0000e570: 2062 6520 7365 6c65 6374 6564 0a20 2020   be selected.   
-0000e580: 2069 6620 6c65 6e28 7072 6564 7329 203c   if len(preds) <
-0000e590: 3d20 3530 3a0a 2020 2020 2020 2020 2374  = 50:.        #t
-0000e5a0: 6f70 5f6e 756d 203d 2031 300a 2020 2020  op_num = 10.    
-0000e5b0: 2020 2020 746f 705f 6e75 6d20 3d20 696e      top_num = in
-0000e5c0: 7428 6d61 7828 322c 206c 656e 2870 7265  t(max(2, len(pre
-0000e5d0: 6473 292a 302e 3235 2929 0a20 2020 2065  ds)*0.25)).    e
-0000e5e0: 6c73 653a 0a20 2020 2020 2020 2023 2323  lse:.        ###
-0000e5f0: 2074 6865 206d 6178 696d 756d 206e 756d   the maximum num
-0000e600: 6265 7220 6f66 2076 6172 6961 626c 6573  ber of variables
-0000e610: 2077 696c 6c20 3235 2520 6f66 2070 7265   will 25% of pre
-0000e620: 6473 2077 6869 6368 206d 6561 6e73 2077  ds which means w
-0000e630: 6520 6469 7669 6465 2062 7920 3520 616e  e divide by 5 an
-0000e640: 6420 6765 7420 3525 2068 6572 650a 2020  d get 5% here.  
-0000e650: 2020 2020 2020 2323 2320 5468 6520 6669        ### The fi
-0000e660: 7665 2069 7465 7261 7469 6f6e 7320 7265  ve iterations re
-0000e670: 7375 6c74 2069 6e20 3130 2520 6265 696e  sult in 10% bein
-0000e680: 6720 6368 6f73 656e 2069 6e20 6561 6368  g chosen in each
-0000e690: 2069 7465 7261 7469 6f6e 2e20 4865 6e63   iteration. Henc
-0000e6a0: 6520 6d61 7820 3530 2520 6f66 2076 6172  e max 50% of var
-0000e6b0: 6961 626c 6573 210a 2020 2020 2020 2020  iables!.        
-0000e6c0: 746f 705f 6e75 6d20 3d20 696e 7428 6c65  top_num = int(le
-0000e6d0: 6e28 7072 6564 7329 2a30 2e32 3029 0a20  n(preds)*0.20). 
-0000e6e0: 2020 2023 2323 2323 2323 2323 2323 2323     #############
-0000e6f0: 2323 2323 2323 2323 2320 2020 4920 4d20  #########   I M 
-0000e700: 5020 4f20 5220 5420 4120 4e20 5420 2323  P O R T A N T ##
-0000e710: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000e720: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000e730: 2323 2323 2323 2323 2323 2323 0a20 2020  ############.   
-0000e740: 2069 6d70 6f72 7461 6e74 5f63 6174 7320   important_cats 
-0000e750: 3d20 636f 7079 2e64 6565 7063 6f70 7928  = copy.deepcopy(
-0000e760: 6361 7476 6172 7329 0a20 2020 2064 6174  catvars).    dat
-0000e770: 615f 6469 6d20 3d20 696e 7428 286c 656e  a_dim = int((len
-0000e780: 2864 6174 616e 616d 6529 2a64 6174 616e  (dataname)*datan
-0000e790: 616d 652e 7368 6170 655b 315d 292f 3165  ame.shape[1])/1e
-0000e7a0: 3629 0a20 2020 2023 2323 2323 2323 2323  6).    #########
-0000e7b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000e7c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000e7d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000e7e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000e7f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000e800: 2323 2323 2323 230a 2020 2020 2323 2323  #######.    ####
-0000e810: 2323 2323 2323 2323 2020 2020 2053 2020  ########     S  
-0000e820: 2055 2020 4c20 204f 2020 2056 2020 2020   U  L  O   V    
-0000e830: 2020 204d 2020 2045 2020 2054 2020 2048     M   E   T   H
-0000e840: 2020 204f 2020 4420 2020 2020 2023 2323     O  D      ###
-0000e850: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000e860: 2323 2323 2323 2323 2323 2323 0a20 2020  ############.   
-0000e870: 2023 2323 2320 4966 2074 6865 2064 6174   #### If the dat
-0000e880: 6120 6469 6d65 6e73 696f 6e20 6973 206c  a dimension is l
-0000e890: 6573 7320 7468 616e 2035 6f20 4d69 6c6c  ess than 5o Mill
-0000e8a0: 696f 6e20 7468 656e 2064 6f20 5355 4c4f  ion then do SULO
-0000e8b0: 5620 2d20 6f74 6865 7277 6973 6520 736b  V - otherwise sk
-0000e8c0: 6970 2069 7421 2023 2323 2323 2323 2323  ip it! #########
-0000e8d0: 0a20 2020 2023 2323 2323 2323 2323 2323  .    ###########
-0000e8e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000e8f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000e900: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000e910: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000e920: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000e930: 2323 2323 230a 2020 2020 0a20 2020 2063  #####.    .    c
-0000e940: 6f6c 735f 7769 7468 5f69 6e66 696e 6974  ols_with_infinit
-0000e950: 7920 3d20 4544 415f 6669 6e64 5f72 656d  y = EDA_find_rem
-0000e960: 6f76 655f 636f 6c75 6d6e 735f 7769 7468  ove_columns_with
-0000e970: 5f69 6e66 696e 6974 7928 6461 7461 6e61  _infinity(datana
-0000e980: 6d65 290a 2020 2020 2320 6669 7273 7420  me).    # first 
-0000e990: 796f 7520 6d75 7374 2064 726f 7020 726f  you must drop ro
-0000e9a0: 7773 2074 6861 7420 6861 7665 2069 6e66  ws that have inf
-0000e9b0: 2069 6e20 7468 656d 2023 2323 230a 2020   in them ####.  
-0000e9c0: 2020 6966 2063 6f6c 735f 7769 7468 5f69    if cols_with_i
-0000e9d0: 6e66 696e 6974 793a 0a20 2020 2020 2020  nfinity:.       
-0000e9e0: 2070 7269 6e74 2827 4472 6f70 7065 6420   print('Dropped 
-0000e9f0: 2564 2063 6f6c 756d 6e73 2077 6869 6368  %d columns which
-0000ea00: 2063 6f6e 7461 696e 2069 6e66 696e 6974   contain infinit
-0000ea10: 7920 696e 2064 6174 6173 6574 2720 256c  y in dataset' %l
-0000ea20: 656e 2863 6f6c 735f 7769 7468 5f69 6e66  en(cols_with_inf
-0000ea30: 696e 6974 7929 290a 2020 2020 2020 2020  inity)).        
-0000ea40: 2364 6174 616e 616d 6520 3d20 4645 5f64  #dataname = FE_d
-0000ea50: 726f 705f 726f 7773 5f77 6974 685f 696e  rop_rows_with_in
-0000ea60: 6669 6e69 7479 2864 6174 616e 616d 652c  finity(dataname,
-0000ea70: 2063 6f6c 735f 7769 7468 5f69 6e66 696e   cols_with_infin
-0000ea80: 6974 792c 2066 696c 6c5f 7661 6c75 653d  ity, fill_value=
-0000ea90: 5472 7565 290a 2020 2020 2020 2020 6461  True).        da
-0000eaa0: 7461 6e61 6d65 203d 2064 6174 616e 616d  taname = datanam
-0000eab0: 652e 6472 6f70 2863 6f6c 735f 7769 7468  e.drop(cols_with
-0000eac0: 5f69 6e66 696e 6974 792c 2061 7869 733d  _infinity, axis=
-0000ead0: 3129 0a20 2020 2020 2020 2070 7269 6e74  1).        print
-0000eae0: 2827 2573 2720 2563 6f6c 735f 7769 7468  ('%s' %cols_with
-0000eaf0: 5f69 6e66 696e 6974 7929 0a20 2020 2020  _infinity).     
-0000eb00: 2020 2069 6620 6973 696e 7374 616e 6365     if isinstance
-0000eb10: 2874 6573 745f 6461 7461 2c73 7472 2920  (test_data,str) 
-0000eb20: 6f72 2074 6573 745f 6461 7461 2069 7320  or test_data is 
-0000eb30: 4e6f 6e65 3a0a 2020 2020 2020 2020 2020  None:.          
-0000eb40: 2020 7061 7373 0a20 2020 2020 2020 2065    pass.        e
-0000eb50: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
-0000eb60: 2074 6573 745f 6461 7461 203d 2074 6573   test_data = tes
-0000eb70: 745f 6461 7461 2e64 726f 7028 636f 6c73  t_data.drop(cols
-0000eb80: 5f77 6974 685f 696e 6669 6e69 7479 2c20  _with_infinity, 
-0000eb90: 6178 6973 3d31 290a 2020 2020 2020 2020  axis=1).        
-0000eba0: 2020 2020 7072 696e 7428 2720 2020 2020      print('     
-0000ebb0: 6472 6f70 7065 6420 2573 2063 6f6c 756d  dropped %s colum
-0000ebc0: 6e73 2077 6974 6820 696e 6669 6e69 7479  ns with infinity
-0000ebd0: 2066 726f 6d20 7465 7374 2064 6174 612e   from test data.
-0000ebe0: 2e2e 2720 256c 656e 2863 6f6c 735f 7769  ..' %len(cols_wi
-0000ebf0: 7468 5f69 6e66 696e 6974 7929 290a 2020  th_infinity)).  
-0000ec00: 2020 2020 2020 6e75 6d76 6172 7320 3d20        numvars = 
-0000ec10: 6c65 6674 5f73 7562 7472 6163 7428 6e75  left_subtract(nu
-0000ec20: 6d76 6172 732c 2063 6f6c 735f 7769 7468  mvars, cols_with
-0000ec30: 5f69 6e66 696e 6974 7929 0a20 2020 2020  _infinity).     
-0000ec40: 2020 2070 7269 6e74 2827 2020 2020 206e     print('     n
-0000ec50: 756d 6572 6963 2066 6561 7475 7265 7320  umeric features 
-0000ec60: 6c65 6674 203d 2025 7327 2025 6c65 6e28  left = %s' %len(
-0000ec70: 6e75 6d76 6172 7329 290a 2020 2020 2323  numvars)).    ##
-0000ec80: 2323 2323 2320 2054 6869 7320 6973 2077  #####  This is w
-0000ec90: 6865 7265 2079 6f75 2073 7461 7274 2074  here you start t
-0000eca0: 6865 2053 554c 4f56 2070 726f 6365 7373  he SULOV process
-0000ecb0: 2023 2323 2323 2323 2323 2323 2323 2323   ###############
-0000ecc0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000ecd0: 2323 2320 2020 200a 2020 2020 7374 6172  ###    .    star
-0000ece0: 745f 7469 6d65 3120 3d20 7469 6d65 2e74  t_time1 = time.t
-0000ecf0: 696d 6528 290a 2020 2020 6966 206c 656e  ime().    if len
-0000ed00: 286e 756d 7661 7273 2920 3e20 3120 616e  (numvars) > 1 an
-0000ed10: 6420 6e6f 7420 736b 6970 5f73 756c 6f76  d not skip_sulov
-0000ed20: 3a0a 2020 2020 2020 2020 6966 2064 6174  :.        if dat
-0000ed30: 615f 6469 6d20 3c20 3530 3a0a 2020 2020  a_dim < 50:.    
-0000ed40: 2020 2020 2020 2020 7472 793a 0a20 2020          try:.   
-0000ed50: 2020 2020 2020 2020 2020 2020 2066 696e               fin
-0000ed60: 616c 5f6c 6973 7420 3d20 4645 5f72 656d  al_list = FE_rem
-0000ed70: 6f76 655f 7661 7269 6162 6c65 735f 7573  ove_variables_us
-0000ed80: 696e 675f 5355 4c4f 565f 6d65 7468 6f64  ing_SULOV_method
-0000ed90: 2864 6174 616e 616d 652c 6e75 6d76 6172  (dataname,numvar
-0000eda0: 732c 7365 7474 696e 6773 2e6d 6f64 656c  s,settings.model
-0000edb0: 7479 7065 2c74 6172 6765 742c 0a20 2020  type,target,.   
-0000edc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000edd0: 2020 2020 2020 2020 2020 636f 7272 5f6c            corr_l
-0000ede0: 696d 6974 2c76 6572 626f 7365 2c20 6461  imit,verbose, da
-0000edf0: 736b 5f78 6762 6f6f 7374 5f66 6c61 6729  sk_xgboost_flag)
-0000ee00: 0a20 2020 2020 2020 2020 2020 2065 7863  .            exc
-0000ee10: 6570 743a 0a20 2020 2020 2020 2020 2020  ept:.           
-0000ee20: 2020 2020 2070 7269 6e74 2827 2020 2020       print('    
-0000ee30: 5355 4c4f 5620 6d65 7468 6f64 2069 7320  SULOV method is 
-0000ee40: 6572 726f 7269 6e67 2e20 436f 6e74 696e  erroring. Contin
-0000ee50: 7569 6e67 202e 2e2e 2729 0a20 2020 2020  uing ...').     
-0000ee60: 2020 2020 2020 2020 2020 2066 696e 616c             final
-0000ee70: 5f6c 6973 7420 3d20 636f 7079 2e64 6565  _list = copy.dee
-0000ee80: 7063 6f70 7928 6e75 6d76 6172 7329 0a20  pcopy(numvars). 
-0000ee90: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
-0000eea0: 2020 2020 2020 2020 2020 2020 2070 7269               pri
-0000eeb0: 6e74 2827 2020 2020 5275 6e6e 696e 6720  nt('    Running 
-0000eec0: 5355 4c4f 5620 6f6e 2073 6d61 6c6c 6572  SULOV on smaller
-0000eed0: 2064 6174 6173 6574 2073 616d 706c 6520   dataset sample 
-0000eee0: 7369 6e63 6520 6461 7461 2073 697a 6520  since data size 
-0000eef0: 2573 206d 203e 2035 3020 6d2e 2043 6f6e  %s m > 50 m. Con
-0000ef00: 7469 6e75 696e 6720 2e2e 2e27 2025 696e  tinuing ...' %in
-0000ef10: 7428 6461 7461 5f64 696d 2929 0a20 2020  t(data_dim)).   
-0000ef20: 2020 2020 2020 2020 2020 2020 2069 6620               if 
-0000ef30: 7365 7474 696e 6773 2e6d 6f64 656c 7479  settings.modelty
-0000ef40: 7065 2021 3d20 2752 6567 7265 7373 696f  pe != 'Regressio
-0000ef50: 6e27 3a0a 2020 2020 2020 2020 2020 2020  n':.            
-0000ef60: 2020 2020 2020 2020 6461 7461 5f74 656d          data_tem
-0000ef70: 7020 3d20 6461 7461 6e61 6d65 2e73 616d  p = dataname.sam
-0000ef80: 706c 6528 6e3d 3130 3030 302c 2072 6570  ple(n=10000, rep
-0000ef90: 6c61 6365 3d54 7275 652c 2072 616e 646f  lace=True, rando
-0000efa0: 6d5f 7374 6174 653d 3939 290a 2020 2020  m_state=99).    
-0000efb0: 2020 2020 2020 2020 2020 2020 656c 7365              else
-0000efc0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-0000efd0: 2020 2020 2020 6461 7461 5f74 656d 7020        data_temp 
-0000efe0: 3d20 6461 7461 6e61 6d65 5b3a 3130 3030  = dataname[:1000
-0000eff0: 305d 0a20 2020 2020 2020 2020 2020 2020  0].             
-0000f000: 2020 2066 696e 616c 5f6c 6973 7420 3d20     final_list = 
-0000f010: 4645 5f72 656d 6f76 655f 7661 7269 6162  FE_remove_variab
-0000f020: 6c65 735f 7573 696e 675f 5355 4c4f 565f  les_using_SULOV_
-0000f030: 6d65 7468 6f64 2864 6174 615f 7465 6d70  method(data_temp
-0000f040: 2c6e 756d 7661 7273 2c73 6574 7469 6e67  ,numvars,setting
-0000f050: 732e 6d6f 6465 6c74 7970 652c 7461 7267  s.modeltype,targ
-0000f060: 6574 2c0a 2020 2020 2020 2020 2020 2020  et,.            
-0000f070: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f080: 2063 6f72 725f 6c69 6d69 742c 7665 7262   corr_limit,verb
-0000f090: 6f73 652c 2064 6173 6b5f 7867 626f 6f73  ose, dask_xgboos
-0000f0a0: 745f 666c 6167 290a 2020 2020 2020 2020  t_flag).        
-0000f0b0: 2020 2020 2020 2020 6465 6c20 6461 7461          del data
-0000f0c0: 5f74 656d 700a 2020 2020 656c 6966 2073  _temp.    elif s
-0000f0d0: 6b69 705f 7375 6c6f 763a 0a20 2020 2020  kip_sulov:.     
-0000f0e0: 2020 2070 7269 6e74 2827 2020 2020 536b     print('    Sk
-0000f0f0: 6970 7069 6e67 2053 554c 4f56 206d 6574  ipping SULOV met
-0000f100: 686f 642e 2043 6f6e 7469 6e75 696e 6720  hod. Continuing 
-0000f110: 2e2e 2e27 290a 2020 2020 2020 2020 6669  ...').        fi
-0000f120: 6e61 6c5f 6c69 7374 203d 2063 6f70 792e  nal_list = copy.
-0000f130: 6465 6570 636f 7079 286e 756d 7661 7273  deepcopy(numvars
-0000f140: 290a 2020 2020 656c 7365 3a0a 2020 2020  ).    else:.    
-0000f150: 2020 2020 7072 696e 7428 2720 2020 2053      print('    S
-0000f160: 6b69 7070 696e 6720 5355 4c4f 5620 6d65  kipping SULOV me
-0000f170: 7468 6f64 2073 696e 6365 2074 6865 7265  thod since there
-0000f180: 2061 7265 206e 6f20 636f 6e74 696e 756f   are no continuo
-0000f190: 7573 2076 6172 732e 2043 6f6e 7469 6e75  us vars. Continu
-0000f1a0: 696e 6720 2e2e 2e27 290a 2020 2020 2020  ing ...').      
-0000f1b0: 2020 6669 6e61 6c5f 6c69 7374 203d 2063    final_list = c
-0000f1c0: 6f70 792e 6465 6570 636f 7079 286e 756d  opy.deepcopy(num
-0000f1d0: 7661 7273 290a 2020 2020 2323 2323 2323  vars).    ######
-0000f1e0: 2320 5468 6973 2069 7320 7768 6572 6520  # This is where 
-0000f1f0: 796f 7520 6472 6177 2068 6f77 2066 6561  you draw how fea
-0000f200: 7475 7265 7769 7a20 776f 726b 7320 7768  turewiz works wh
-0000f210: 656e 2074 6865 2076 6572 626f 7365 203d  en the verbose =
-0000f220: 2032 2023 2323 2323 2323 2323 2323 0a20   2 ###########. 
-0000f230: 2020 2070 7269 6e74 2827 5469 6d65 2074     print('Time t
-0000f240: 616b 656e 2066 6f72 2053 554c 4f56 206d  aken for SULOV m
-0000f250: 6574 686f 6420 3d20 2530 2e30 6620 7365  ethod = %0.0f se
-0000f260: 636f 6e64 7327 2025 2874 696d 652e 7469  conds' %(time.ti
-0000f270: 6d65 2829 2d73 7461 7274 5f74 696d 6531  me()-start_time1
-0000f280: 2929 0a20 2020 2023 2323 2320 4e6f 7720  )).    #### Now 
-0000f290: 7765 2063 7265 6174 6520 696e 7465 7261  we create intera
-0000f2a0: 6374 696f 6e20 7661 7269 6162 6c65 7320  ction variables 
-0000f2b0: 6265 7477 6565 6e20 6361 7465 676f 7269  between categori
-0000f2c0: 6361 6c20 6665 6174 7572 6573 2023 2323  cal features ###
-0000f2d0: 2323 2323 230a 2020 2020 6966 2076 6572  #####.    if ver
-0000f2e0: 626f 7365 3a0a 2020 2020 2020 2020 7072  bose:.        pr
-0000f2f0: 696e 7428 2720 2020 2041 6464 696e 6720  int('    Adding 
-0000f300: 2573 2063 6174 6567 6f72 6963 616c 2076  %s categorical v
-0000f310: 6172 6961 626c 6573 2074 6f20 7265 6475  ariables to redu
-0000f320: 6365 6420 6e75 6d65 7269 6320 7661 7269  ced numeric vari
-0000f330: 6162 6c65 7320 206f 6620 2564 2720 2528  ables  of %d' %(
-0000f340: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-0000f350: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0000f360: 206c 656e 2869 6d70 6f72 7461 6e74 5f63   len(important_c
-0000f370: 6174 7329 2c6c 656e 2866 696e 616c 5f6c  ats),len(final_l
-0000f380: 6973 7429 2929 0a20 2020 2069 6620 2069  ist))).    if  i
-0000f390: 7369 6e73 7461 6e63 6528 6669 6e61 6c5f  sinstance(final_
-0000f3a0: 6c69 7374 2c6e 702e 6e64 6172 7261 7929  list,np.ndarray)
-0000f3b0: 3a0a 2020 2020 2020 2020 6669 6e61 6c5f  :.        final_
-0000f3c0: 6c69 7374 203d 2066 696e 616c 5f6c 6973  list = final_lis
-0000f3d0: 742e 746f 6c69 7374 2829 0a20 2020 2070  t.tolist().    p
-0000f3e0: 7265 6473 203d 2066 696e 616c 5f6c 6973  reds = final_lis
-0000f3f0: 742b 696d 706f 7274 616e 745f 6361 7473  t+important_cats
-0000f400: 0a20 2020 2069 6620 7665 7262 6f73 6520  .    if verbose 
-0000f410: 616e 6420 6c65 6e28 7072 6564 7329 203c  and len(preds) <
-0000f420: 3d20 3330 3a0a 2020 2020 2020 2020 7072  = 30:.        pr
-0000f430: 696e 7428 2746 696e 616c 206c 6973 7420  int('Final list 
-0000f440: 6f66 2073 656c 6563 7465 6420 2573 2076  of selected %s v
-0000f450: 6172 7320 6166 7465 7220 5355 4c4f 5620  ars after SULOV 
-0000f460: 3d20 2573 2720 2528 6c65 6e28 7072 6564  = %s' %(len(pred
-0000f470: 7329 2c20 7072 6564 7329 290a 2020 2020  s), preds)).    
-0000f480: 656c 7365 3a0a 2020 2020 2020 2020 7072  else:.        pr
-0000f490: 696e 7428 2746 696e 616c 6c79 2025 7320  int('Finally %s 
-0000f4a0: 7661 7273 2073 656c 6563 7465 6420 6166  vars selected af
-0000f4b0: 7465 7220 5355 4c4f 5627 2025 286c 656e  ter SULOV' %(len
-0000f4c0: 2870 7265 6473 2929 290a 2020 2020 2323  (preds))).    ##
-0000f4d0: 2323 2323 2359 6f75 206d 7573 7420 636f  #####You must co
-0000f4e0: 6e76 6572 7420 6361 7465 676f 7279 2076  nvert category v
-0000f4f0: 6172 6961 626c 6573 2069 6e74 6f20 696e  ariables into in
-0000f500: 7465 6765 7273 2023 2323 2323 2323 2323  tegers #########
-0000f510: 2323 2323 2323 2020 2020 0a20 2020 2070  ######    .    p
-0000f520: 7269 6e74 2827 436f 6e76 6572 7469 6e67  rint('Converting
-0000f530: 2061 6c6c 2066 6561 7475 7265 7320 746f   all features to
-0000f540: 206e 756d 6572 6963 2062 6566 6f72 6520   numeric before 
-0000f550: 7365 6e64 696e 6720 746f 2058 4742 6f6f  sending to XGBoo
-0000f560: 7374 2e2e 2e27 290a 2020 2020 6966 2069  st...').    if i
-0000f570: 7369 6e73 7461 6e63 6528 7461 7267 6574  sinstance(target
-0000f580: 2c20 7374 7229 3a0a 2020 2020 2020 2020  , str):.        
-0000f590: 6461 7461 6e61 6d65 203d 2064 6174 616e  dataname = datan
-0000f5a0: 616d 655b 7072 6564 732b 5b74 6172 6765  ame[preds+[targe
-0000f5b0: 745d 5d0a 2020 2020 656c 7365 3a0a 2020  t]].    else:.  
-0000f5c0: 2020 2020 2020 6461 7461 6e61 6d65 203d        dataname =
-0000f5d0: 2064 6174 616e 616d 655b 7072 6564 732b   dataname[preds+
-0000f5e0: 7461 7267 6574 5d0a 2020 2020 0a20 2020  target].    .   
-0000f5f0: 2069 6620 6e6f 7420 7465 7374 5f64 6174   if not test_dat
-0000f600: 6120 6973 204e 6f6e 653a 0a20 2020 2020  a is None:.     
-0000f610: 2020 2074 6573 745f 6461 7461 203d 2074     test_data = t
-0000f620: 6573 745f 6461 7461 5b70 7265 6473 5d0a  est_data[preds].
-0000f630: 2020 2020 6966 206c 656e 2869 6d70 6f72      if len(impor
-0000f640: 7461 6e74 5f63 6174 7329 203e 2030 3a0a  tant_cats) > 0:.
-0000f650: 2020 2020 2020 2020 6461 7461 6e61 6d65          dataname
-0000f660: 2c20 7465 7374 5f64 6174 612c 2065 7272  , test_data, err
-0000f670: 6f72 5f63 6f6c 756d 6e73 203d 2046 455f  or_columns = FE_
-0000f680: 636f 6e76 6572 745f 616c 6c5f 6f62 6a65  convert_all_obje
-0000f690: 6374 5f63 6f6c 756d 6e73 5f74 6f5f 6e75  ct_columns_to_nu
-0000f6a0: 6d65 7269 6328 6461 7461 6e61 6d65 2c20  meric(dataname, 
-0000f6b0: 2074 6573 745f 6461 7461 2c20 7072 6564   test_data, pred
-0000f6c0: 7329 0a20 2020 2020 2020 2069 6d70 6f72  s).        impor
-0000f6d0: 7461 6e74 5f63 6174 7320 3d20 6c65 6674  tant_cats = left
-0000f6e0: 5f73 7562 7472 6163 7428 696d 706f 7274  _subtract(import
-0000f6f0: 616e 745f 6361 7473 2c20 6572 726f 725f  ant_cats, error_
-0000f700: 636f 6c75 6d6e 7329 0a20 2020 2020 2020  columns).       
-0000f710: 2069 6620 6c65 6e28 6572 726f 725f 636f   if len(error_co
-0000f720: 6c75 6d6e 7329 203e 2030 3a0a 2020 2020  lumns) > 0:.    
-0000f730: 2020 2020 2020 2020 7072 696e 7428 2720          print(' 
-0000f740: 2020 2072 656d 6f76 696e 6720 2573 206f     removing %s o
-0000f750: 626a 6563 7420 636f 6c75 6d6e 7320 7468  bject columns th
-0000f760: 6174 2063 6f75 6c64 206e 6f74 2062 6520  at could not be 
-0000f770: 636f 6e76 6572 7465 6420 746f 206e 756d  converted to num
-0000f780: 6572 6963 2720 256c 656e 2865 7272 6f72  eric' %len(error
-0000f790: 5f63 6f6c 756d 6e73 2929 0a20 2020 2020  _columns)).     
-0000f7a0: 2020 2020 2020 2070 7265 6473 203d 206c         preds = l
-0000f7b0: 6973 7428 7365 7428 7072 6564 7329 2d73  ist(set(preds)-s
-0000f7c0: 6574 2865 7272 6f72 5f63 6f6c 756d 6e73  et(error_columns
-0000f7d0: 2929 0a20 2020 2020 2020 2020 2020 2064  )).            d
-0000f7e0: 6174 616e 616d 652e 6472 6f70 2865 7272  ataname.drop(err
-0000f7f0: 6f72 5f63 6f6c 756d 6e73 2c20 6178 6973  or_columns, axis
-0000f800: 3d31 2c20 696e 706c 6163 653d 5472 7565  =1, inplace=True
-0000f810: 290a 2020 2020 2020 2020 656c 7365 3a0a  ).        else:.
-0000f820: 2020 2020 2020 2020 2020 2020 7072 696e              prin
-0000f830: 7428 2720 2020 2074 6865 7265 2077 6572  t('    there wer
-0000f840: 6520 6e6f 206d 6978 6564 2064 6174 6120  e no mixed data 
-0000f850: 7479 7065 7320 6f72 206f 626a 6563 7420  types or object 
-0000f860: 636f 6c75 6d6e 7320 7468 6174 2065 7272  columns that err
-0000f870: 6f72 6564 2e20 4461 7461 2069 7320 616c  ored. Data is al
-0000f880: 6c20 6e75 6d65 7269 632e 2e2e 2729 0a20  l numeric...'). 
-0000f890: 2020 2020 2020 2070 7269 6e74 2827 5368         print('Sh
-0000f8a0: 6170 6520 6f66 2074 7261 696e 2064 6174  ape of train dat
-0000f8b0: 6120 6166 7465 7220 6164 6469 6e67 206d  a after adding m
-0000f8c0: 6973 7369 6e67 2076 616c 7565 7320 666c  issing values fl
-0000f8d0: 6167 7320 3d20 2573 2720 2528 6461 7461  ags = %s' %(data
-0000f8e0: 6e61 6d65 2e73 6861 7065 2c29 2029 0a20  name.shape,) ). 
-0000f8f0: 2020 2020 2020 2070 7265 6473 203d 205b         preds = [
-0000f900: 7820 666f 7220 7820 696e 206c 6973 7428  x for x in list(
-0000f910: 6461 7461 6e61 6d65 2920 6966 2078 206e  dataname) if x n
-0000f920: 6f74 2069 6e20 7461 7267 6574 735d 0a20  ot in targets]. 
-0000f930: 2020 2020 2020 2069 6620 6e6f 7420 7465         if not te
-0000f940: 7374 5f64 6174 6120 6973 204e 6f6e 653a  st_data is None:
-0000f950: 0a20 2020 2020 2020 2020 2020 2074 6573  .            tes
-0000f960: 745f 6461 7461 2e64 726f 7028 6572 726f  t_data.drop(erro
-0000f970: 725f 636f 6c75 6d6e 732c 2061 7869 733d  r_columns, axis=
-0000f980: 312c 2069 6e70 6c61 6365 3d54 7275 6529  1, inplace=True)
-0000f990: 0a20 2020 2020 2020 2020 2020 2070 7269  .            pri
-0000f9a0: 6e74 2827 2020 2020 5368 6170 6520 6f66  nt('    Shape of
-0000f9b0: 2074 6573 7420 6461 7461 2061 6674 6572   test data after
-0000f9c0: 2061 6464 696e 6720 6d69 7373 696e 6720   adding missing 
-0000f9d0: 7661 6c75 6573 2066 6c61 6773 2020 3d20  values flags  = 
-0000f9e0: 2573 2720 2528 7465 7374 5f64 6174 612e  %s' %(test_data.
-0000f9f0: 7368 6170 652c 2920 290a 2020 2020 6966  shape,) ).    if
-0000fa00: 2076 6572 626f 7365 3a0a 2020 2020 2020   verbose:.      
-0000fa10: 2020 7072 696e 7428 2723 2323 2323 2323    print('#######
-0000fa20: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000fa30: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000fa40: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000fa50: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000fa60: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000fa70: 2729 0a20 2020 2020 2020 2070 7269 6e74  ').        print
-0000fa80: 2827 2323 2323 2320 2020 2052 2045 2043  ('#####    R E C
-0000fa90: 2055 2052 2053 2049 2056 2045 2020 2058   U R S I V E   X
-0000faa0: 2047 2042 204f 204f 2053 2054 203a 2046   G B O O S T : F
-0000fab0: 2045 2041 2054 2055 2052 2045 2020 2053   E A T U R E   S
-0000fac0: 2045 204c 2045 2043 2054 2049 204f 204e   E L E C T I O N
-0000fad0: 2020 2323 2323 2323 2327 290a 2020 2020    #######').    
-0000fae0: 2020 2020 7072 696e 7428 2723 2323 2323      print('#####
-0000faf0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000fb00: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000d150: 2020 2020 2020 2020 2020 2020 2020 2074                 t
+0000d160: 6573 745f 7369 7a65 3d30 2e32 2c0a 2020  est_size=0.2,.  
+0000d170: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d180: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d190: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d1a0: 2020 2020 2020 2020 2020 7261 6e64 6f6d            random
+0000d1b0: 5f73 7461 7465 3d52 414e 444f 4d5f 5345  _state=RANDOM_SE
+0000d1c0: 4544 290a 2020 2020 2020 2020 656c 7365  ED).        else
+0000d1d0: 3a0a 2020 2020 2020 2020 2020 2020 7072  :.            pr
+0000d1e0: 696e 7428 2720 2020 2053 7461 7274 696e  int('    Startin
+0000d1f0: 6720 6665 6174 7572 6520 656e 6769 6e65  g feature engine
+0000d200: 6572 696e 672e 2e2e 5369 6e63 6520 7465  ering...Since te
+0000d210: 7374 2064 6174 6120 6973 2067 6976 656e  st data is given
+0000d220: 2c20 7573 696e 6720 7472 6169 6e20 616e  , using train an
+0000d230: 6420 7465 7374 2e2e 2e27 290a 2020 2020  d test...').    
+0000d240: 2020 2020 2020 2020 585f 7472 6169 6e20          X_train 
+0000d250: 3d20 6461 7461 6e61 6d65 5b70 7265 6473  = dataname[preds
+0000d260: 5d0a 2020 2020 2020 2020 2020 2020 6966  ].            if
+0000d270: 2073 6574 7469 6e67 732e 6d75 6c74 695f   settings.multi_
+0000d280: 6c61 6265 6c3a 0a20 2020 2020 2020 2020  label:.         
+0000d290: 2020 2020 2020 2079 5f74 7261 696e 203d         y_train =
+0000d2a0: 2064 6174 616e 616d 655b 7461 7267 6574   dataname[target
+0000d2b0: 5d0a 2020 2020 2020 2020 2020 2020 656c  ].            el
+0000d2c0: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+0000d2d0: 2020 2020 795f 7472 6169 6e20 3d20 6461      y_train = da
+0000d2e0: 7461 6e61 6d65 5b74 6172 6765 745b 305d  taname[target[0]
+0000d2f0: 5d0a 2020 2020 2020 2020 2020 2020 585f  ].            X_
+0000d300: 7465 7374 203d 2074 6573 745f 6461 7461  test = test_data
+0000d310: 5b70 7265 6473 5d0a 2020 2020 2020 2020  [preds].        
+0000d320: 2020 2020 7472 793a 0a20 2020 2020 2020      try:.       
+0000d330: 2020 2020 2020 2020 2079 5f74 6573 7420           y_test 
+0000d340: 3d20 7465 7374 5f64 6174 615b 7461 7267  = test_data[targ
+0000d350: 6574 5d0a 2020 2020 2020 2020 2020 2020  et].            
+0000d360: 6578 6365 7074 3a0a 2020 2020 2020 2020  except:.        
+0000d370: 2020 2020 2020 2020 795f 7465 7374 203d          y_test =
+0000d380: 204e 6f6e 650a 2020 2020 2020 2020 585f   None.        X_
+0000d390: 7472 6169 6e5f 696e 6465 7820 3d20 585f  train_index = X_
+0000d3a0: 7472 6169 6e2e 696e 6465 780a 2020 2020  train.index.    
+0000d3b0: 2020 2020 585f 7465 7374 5f69 6e64 6578      X_test_index
+0000d3c0: 203d 2058 5f74 6573 742e 696e 6465 780a   = X_test.index.
+0000d3d0: 2020 2020 2020 2020 0a20 2020 2020 2020          .       
+0000d3e0: 2023 2323 2323 2323 2323 2323 2323 2323   ###############
+0000d3f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000d400: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000d410: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000d420: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000d430: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000d440: 2323 230a 2020 2020 2020 2020 2323 2323  ###.        ####
+0000d450: 2323 2043 6174 6567 6f72 795f 456e 636f  ## Category_Enco
+0000d460: 6465 7273 2064 6f65 7320 6e6f 7420 776f  ders does not wo
+0000d470: 726b 2077 6974 6820 4461 736b 202d 2073  rk with Dask - s
+0000d480: 6f20 646f 6e27 7420 7365 6e64 2069 6e20  o don't send in 
+0000d490: 4461 736b 2064 6174 6166 7261 6d65 7320  Dask dataframes 
+0000d4a0: 746f 2044 6174 6142 756e 6368 210a 2020  to DataBunch!.  
+0000d4b0: 2020 2020 2020 2323 2323 2323 2323 2323        ##########
+0000d4c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000d4d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000d4e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000d4f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000d500: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000d510: 2323 2323 2323 2323 0a20 2020 2020 2020  ########.       
+0000d520: 2064 6174 615f 7475 706c 6520 3d20 4461   data_tuple = Da
+0000d530: 7461 4275 6e63 6828 585f 7472 6169 6e3d  taBunch(X_train=
+0000d540: 585f 7472 6169 6e2c 0a20 2020 2020 2020  X_train,.       
+0000d550: 2020 2020 2020 2020 2020 2020 2079 5f74               y_t
+0000d560: 7261 696e 3d79 5f74 7261 696e 2c0a 2020  rain=y_train,.  
+0000d570: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d580: 2020 585f 7465 7374 3d58 5f74 6573 742c    X_test=X_test,
+0000d590: 2023 2062 6520 7375 7265 2074 6f20 7370   # be sure to sp
+0000d5a0: 6563 6966 7920 585f 7465 7374 2c20 6265  ecify X_test, be
+0000d5b0: 6361 7573 6520 7468 6520 656e 636f 6465  cause the encode
+0000d5c0: 7220 6e65 6564 7320 616c 6c20 6461 7461  r needs all data
+0000d5d0: 7365 7420 746f 2077 6f72 6b2e 0a20 2020  set to work..   
+0000d5e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d5f0: 2063 6174 5f66 6561 7475 7265 7320 3d20   cat_features = 
+0000d600: 6361 7476 6172 732c 0a20 2020 2020 2020  catvars,.       
+0000d610: 2020 2020 2020 2020 2020 2020 2063 6c65               cle
+0000d620: 616e 5f61 6e64 5f65 6e63 6f64 5f64 6174  an_and_encod_dat
+0000d630: 613d 5472 7565 2c0a 2020 2020 2020 2020  a=True,.        
+0000d640: 2020 2020 2020 2020 2020 2020 6361 745f              cat_
+0000d650: 656e 636f 6465 725f 6e61 6d65 733d 6669  encoder_names=fi
+0000d660: 6e61 6c5f 6361 745f 656e 636f 6465 7273  nal_cat_encoders
+0000d670: 2c20 2320 6669 6e61 6c20 6c69 7374 206f  , # final list o
+0000d680: 6620 456e 636f 6465 7273 2073 656c 6563  f Encoders selec
+0000d690: 7465 640a 2020 2020 2020 2020 2020 2020  ted.            
+0000d6a0: 2020 2020 2020 2020 636c 6561 6e5f 6e61          clean_na
+0000d6b0: 6e3d 5472 7565 2c20 2320 6669 6c6c 6e61  n=True, # fillna
+0000d6c0: 6e0a 2020 2020 2020 2020 2020 2020 2020  n.              
+0000d6d0: 2020 2020 2020 6e75 6d5f 6765 6e65 7261        num_genera
+0000d6e0: 746f 725f 6665 6174 7572 6573 3d6e 702e  tor_features=np.
+0000d6f0: 7768 6572 6528 2769 6e74 6572 6163 7469  where('interacti
+0000d700: 6f6e 7327 2069 6e20 6665 6174 7572 655f  ons' in feature_
+0000d710: 6765 6e2c 5472 7565 2c20 4661 6c73 6529  gen,True, False)
+0000d720: 2e74 6f6c 6973 7428 292c 2023 2047 656e  .tolist(), # Gen
+0000d730: 6572 6174 6520 696e 7465 7261 6374 696f  erate interactio
+0000d740: 6e20 4e75 6d20 4665 6174 7572 6573 0a20  n Num Features. 
+0000d750: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d760: 2020 2067 726f 7570 5f67 656e 6572 6174     group_generat
+0000d770: 6f72 5f66 6561 7475 7265 733d 6e70 2e77  or_features=np.w
+0000d780: 6865 7265 2827 6772 6f75 7062 7927 2069  here('groupby' i
+0000d790: 6e20 6665 6174 7572 655f 6765 6e2c 5472  n feature_gen,Tr
+0000d7a0: 7565 2c20 4661 6c73 6529 2e74 6f6c 6973  ue, False).tolis
+0000d7b0: 7428 292c 2023 2047 656e 6572 6174 6520  t(), # Generate 
+0000d7c0: 6772 6f75 7062 7920 4665 6174 7572 6573  groupby Features
+0000d7d0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000d7e0: 2020 2020 2074 6172 6765 745f 656e 635f       target_enc_
+0000d7f0: 6361 745f 6665 6174 7572 6573 3d74 6172  cat_features=tar
+0000d800: 6765 745f 656e 635f 6361 745f 6665 6174  get_enc_cat_feat
+0000d810: 7572 6573 2c23 2047 656e 6572 6174 6520  ures,# Generate 
+0000d820: 7461 7267 6574 2065 6e63 6f64 6564 2066  target encoded f
+0000d830: 6561 7475 7265 730a 2020 2020 2020 2020  eatures.        
+0000d840: 2020 2020 2020 2020 2020 2020 6e6f 726d              norm
+0000d850: 616c 697a 6174 696f 6e3d 4661 6c73 652c  alization=False,
+0000d860: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000d870: 2020 2020 2072 616e 646f 6d5f 7374 6174       random_stat
+0000d880: 653d 5241 4e44 4f4d 5f53 4545 442c 0a20  e=RANDOM_SEED,. 
+0000d890: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000d8a0: 2020 2029 0a20 2020 2020 2020 2023 2323     ).        ###
+0000d8b0: 2320 4e6f 7720 796f 7520 6361 6e20 7072  # Now you can pr
+0000d8c0: 6f63 6573 7320 7468 6520 7475 706c 6520  ocess the tuple 
+0000d8d0: 7468 6973 2077 6179 2023 2323 2323 2323  this way #######
+0000d8e0: 2323 0a20 2020 2020 2020 2069 6620 7479  ##.        if ty
+0000d8f0: 7065 2879 5f74 7261 696e 2920 3d3d 2064  pe(y_train) == d
+0000d900: 6173 6b2e 6461 7461 6672 616d 652e 636f  ask.dataframe.co
+0000d910: 7265 2e44 6174 6146 7261 6d65 3a0a 2020  re.DataFrame:.  
+0000d920: 2020 2020 2020 2020 2020 2323 2320 7369            ### si
+0000d930: 6e63 6520 795f 7472 6169 6e20 6973 2064  nce y_train is d
+0000d940: 6173 6b20 6466 2061 6e64 2064 6174 615f  ask df and data_
+0000d950: 7475 706c 652e 585f 7472 6169 6e20 6973  tuple.X_train is
+0000d960: 2061 2070 616e 6461 7320 6466 2c20 796f   a pandas df, yo
+0000d970: 7520 6361 6e27 7420 6d65 7267 6520 7468  u can't merge th
+0000d980: 656d 2e0a 2020 2020 2020 2020 2020 2020  em..            
+0000d990: 795f 7472 6169 6e20 3d20 795f 7472 6169  y_train = y_trai
+0000d9a0: 6e2e 636f 6d70 7574 6528 2920 2023 2323  n.compute()  ###
+0000d9b0: 2072 656d 656d 6265 7220 796f 7520 6669   remember you fi
+0000d9c0: 7273 7420 6861 7665 2074 6f20 636f 6e76  rst have to conv
+0000d9d0: 6572 7420 7468 656d 2074 6f20 6120 7061  ert them to a pa
+0000d9e0: 6e64 6173 2064 660a 2020 2020 2020 2020  ndas df.        
+0000d9f0: 6461 7461 3120 3d20 7064 2e63 6f6e 6361  data1 = pd.conca
+0000da00: 7428 5b64 6174 615f 7475 706c 652e 585f  t([data_tuple.X_
+0000da10: 7472 6169 6e2c 2079 5f74 7261 696e 5d2c  train, y_train],
+0000da20: 2061 7869 733d 3129 2023 2323 2064 6174   axis=1) ### dat
+0000da30: 615f 7475 706c 6520 646f 6573 206e 6f74  a_tuple does not
+0000da40: 2068 6176 6520 6120 795f 7472 6169 6e2c   have a y_train,
+0000da50: 2072 656d 656d 6265 7221 0a20 2020 2020   remember!.     
+0000da60: 2020 200a 2020 2020 2020 2020 6966 2069     .        if i
+0000da70: 7369 6e73 7461 6e63 6528 7465 7374 5f64  sinstance(test_d
+0000da80: 6174 612c 2073 7472 2920 6f72 2074 6573  ata, str) or tes
+0000da90: 745f 6461 7461 2069 7320 4e6f 6e65 3a0a  t_data is None:.
+0000daa0: 2020 2020 2020 2020 2020 2020 2323 2320              ### 
+0000dab0: 5369 6e63 6520 796f 7520 6861 7665 2064  Since you have d
+0000dac0: 6f6e 6520 6120 7472 6169 6e5f 7465 7374  one a train_test
+0000dad0: 5f73 706c 6974 2075 7369 6e67 2072 616e  _split using ran
+0000dae0: 646f 6d69 7a65 6420 7370 6c69 742c 2079  domized split, y
+0000daf0: 6f75 206e 6565 6420 746f 2070 7574 2069  ou need to put i
+0000db00: 7420 6261 636b 2061 6761 696e 2e0a 2020  t back again..  
+0000db10: 2020 2020 2020 2020 2020 6966 2074 7970            if typ
+0000db20: 6528 795f 7465 7374 2920 3d3d 2064 6173  e(y_test) == das
+0000db30: 6b2e 6461 7461 6672 616d 652e 636f 7265  k.dataframe.core
+0000db40: 2e44 6174 6146 7261 6d65 3a0a 2020 2020  .DataFrame:.    
+0000db50: 2020 2020 2020 2020 2020 2020 2323 2320              ### 
+0000db60: 7369 6e63 6520 795f 7472 6169 6e20 6973  since y_train is
+0000db70: 2064 6173 6b20 6466 2061 6e64 2064 6174   dask df and dat
+0000db80: 615f 7475 706c 652e 585f 7472 6169 6e20  a_tuple.X_train 
+0000db90: 6973 2061 2070 616e 6461 7320 6466 2c20  is a pandas df, 
+0000dba0: 796f 7520 6361 6e27 7420 6d65 7267 6520  you can't merge 
+0000dbb0: 7468 656d 2e0a 2020 2020 2020 2020 2020  them..          
+0000dbc0: 2020 2020 2020 795f 7465 7374 203d 2079        y_test = y
+0000dbd0: 5f74 6573 742e 636f 6d70 7574 6528 2920  _test.compute() 
+0000dbe0: 2023 2323 2072 656d 656d 6265 7220 796f   ### remember yo
+0000dbf0: 7520 6669 7273 7420 6861 7665 2074 6f20  u first have to 
+0000dc00: 636f 6e76 6572 7420 7468 656d 2074 6f20  convert them to 
+0000dc10: 6120 7061 6e64 6173 2064 660a 2020 2020  a pandas df.    
+0000dc20: 2020 2020 2020 2020 6461 7461 3220 3d20          data2 = 
+0000dc30: 7064 2e63 6f6e 6361 7428 5b64 6174 615f  pd.concat([data_
+0000dc40: 7475 706c 652e 585f 7465 7374 2c20 795f  tuple.X_test, y_
+0000dc50: 7465 7374 5d2c 2061 7869 733d 3129 0a20  test], axis=1). 
+0000dc60: 2020 2020 2020 2020 2020 2064 6174 616e             datan
+0000dc70: 616d 6520 3d20 6461 7461 312e 6170 7065  ame = data1.appe
+0000dc80: 6e64 2864 6174 6132 290a 2020 2020 2020  nd(data2).      
+0000dc90: 2020 2020 2020 2323 2320 536f 6d65 7469        ### Someti
+0000dca0: 6d65 7320 7468 6572 6520 6172 6520 6475  mes there are du
+0000dcb0: 706c 6963 6174 6520 7661 6c75 6573 2069  plicate values i
+0000dcc0: 6e20 696e 6465 7820 7768 656e 2079 6f75  n index when you
+0000dcd0: 2061 7070 656e 642e 2053 6f20 6a75 7374   append. So just
+0000dce0: 2072 656d 6f76 6520 6475 706c 6963 6174   remove duplicat
+0000dcf0: 6573 2068 6572 650a 2020 2020 2020 2020  es here.        
+0000dd00: 2020 2020 6461 7461 6e61 6d65 203d 2064      dataname = d
+0000dd10: 6174 616e 616d 655b 7e64 6174 616e 616d  ataname[~datanam
+0000dd20: 652e 696e 6465 782e 6475 706c 6963 6174  e.index.duplicat
+0000dd30: 6564 2829 5d0a 2020 2020 2020 2020 2020  ed()].          
+0000dd40: 2020 6461 7461 6e61 6d65 203d 2064 6174    dataname = dat
+0000dd50: 616e 616d 652e 7265 696e 6465 7828 7472  aname.reindex(tr
+0000dd60: 6169 6e5f 696e 6465 7829 0a20 2020 2020  ain_index).     
+0000dd70: 2020 2020 2020 2070 7269 6e74 2827 2020         print('  
+0000dd80: 2020 436f 6d70 6c65 7465 6420 6665 6174    Completed feat
+0000dd90: 7572 6520 656e 6769 6e65 6572 696e 672e  ure engineering.
+0000dda0: 2053 6861 7065 206f 6620 5472 6169 6e20   Shape of Train 
+0000ddb0: 2877 6974 6820 7461 7267 6574 2920 3d20  (with target) = 
+0000ddc0: 2573 2720 2528 6461 7461 6e61 6d65 2e73  %s' %(dataname.s
+0000ddd0: 6861 7065 2c29 290a 2020 2020 2020 2020  hape,)).        
+0000dde0: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
+0000ddf0: 2020 7472 793a 0a20 2020 2020 2020 2020    try:.         
+0000de00: 2020 2020 2020 2069 6620 7479 7065 2879         if type(y
+0000de10: 5f74 6573 7429 203d 3d20 6461 736b 2e64  _test) == dask.d
+0000de20: 6174 6166 7261 6d65 2e63 6f72 652e 4461  ataframe.core.Da
+0000de30: 7461 4672 616d 653a 0a20 2020 2020 2020  taFrame:.       
+0000de40: 2020 2020 2020 2020 2020 2020 2023 2323               ###
+0000de50: 2073 696e 6365 2079 5f74 7261 696e 2069   since y_train i
+0000de60: 7320 6461 736b 2064 6620 616e 6420 6461  s dask df and da
+0000de70: 7461 5f74 7570 6c65 2e58 5f74 7261 696e  ta_tuple.X_train
+0000de80: 2069 7320 6120 7061 6e64 6173 2064 662c   is a pandas df,
+0000de90: 2079 6f75 2063 616e 2774 206d 6572 6765   you can't merge
+0000dea0: 2074 6865 6d2e 0a20 2020 2020 2020 2020   them..         
+0000deb0: 2020 2020 2020 2020 2020 2079 5f74 6573             y_tes
+0000dec0: 7420 3d20 795f 7465 7374 2e63 6f6d 7075  t = y_test.compu
+0000ded0: 7465 2829 2020 2323 2320 7265 6d65 6d62  te()  ### rememb
+0000dee0: 6572 2079 6f75 2066 6972 7374 2068 6176  er you first hav
+0000def0: 6520 746f 2063 6f6e 7665 7274 2074 6865  e to convert the
+0000df00: 6d20 746f 2061 2070 616e 6461 7320 6466  m to a pandas df
+0000df10: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000df20: 2074 6573 745f 6461 7461 203d 2070 642e   test_data = pd.
+0000df30: 636f 6e63 6174 285b 6461 7461 5f74 7570  concat([data_tup
+0000df40: 6c65 2e58 5f74 6573 742c 2079 5f74 6573  le.X_test, y_tes
+0000df50: 745d 2c20 6178 6973 3d31 290a 2020 2020  t], axis=1).    
+0000df60: 2020 2020 2020 2020 6578 6365 7074 3a0a          except:.
+0000df70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000df80: 7465 7374 5f64 6174 6120 3d20 636f 7079  test_data = copy
+0000df90: 2e64 6565 7063 6f70 7928 6461 7461 5f74  .deepcopy(data_t
+0000dfa0: 7570 6c65 2e58 5f74 6573 7429 0a20 2020  uple.X_test).   
+0000dfb0: 2020 2020 2020 2020 2023 2323 2053 6f6d           ### Som
+0000dfc0: 6574 696d 6573 2074 6865 7265 2061 7265  etimes there are
+0000dfd0: 2064 7570 6c69 6361 7465 2076 616c 7565   duplicate value
+0000dfe0: 7320 696e 2069 6e64 6578 2077 6865 6e20  s in index when 
+0000dff0: 796f 7520 6170 7065 6e64 2e20 536f 206a  you append. So j
+0000e000: 7573 7420 7265 6d6f 7665 2064 7570 6c69  ust remove dupli
+0000e010: 6361 7465 7320 6865 7265 0a20 2020 2020  cates here.     
+0000e020: 2020 2020 2020 2074 6573 745f 6461 7461         test_data
+0000e030: 203d 2074 6573 745f 6461 7461 5b7e 7465   = test_data[~te
+0000e040: 7374 5f64 6174 612e 696e 6465 782e 6475  st_data.index.du
+0000e050: 706c 6963 6174 6564 2829 5d0a 2020 2020  plicated()].    
+0000e060: 2020 2020 2020 2020 7465 7374 5f64 6174          test_dat
+0000e070: 6120 3d20 7465 7374 5f64 6174 612e 7265  a = test_data.re
+0000e080: 696e 6465 7828 7465 7374 5f69 6e64 6578  index(test_index
+0000e090: 290a 2020 2020 2020 2020 2020 2020 6461  ).            da
+0000e0a0: 7461 6e61 6d65 203d 2063 6f70 792e 6465  taname = copy.de
+0000e0b0: 6570 636f 7079 2864 6174 6131 290a 2020  epcopy(data1).  
+0000e0c0: 2020 2020 2020 2020 2020 7072 696e 7428            print(
+0000e0d0: 2720 2020 2043 6f6d 706c 6574 6564 2066  '    Completed f
+0000e0e0: 6561 7475 7265 2065 6e67 696e 6565 7269  eature engineeri
+0000e0f0: 6e67 2e20 5368 6170 6520 6f66 2054 6573  ng. Shape of Tes
+0000e100: 7420 2877 6974 6820 7461 7267 6574 2920  t (with target) 
+0000e110: 3d20 2573 2720 2528 7465 7374 5f64 6174  = %s' %(test_dat
+0000e120: 612e 7368 6170 652c 2929 0a20 2020 2020  a.shape,)).     
+0000e130: 2020 2023 2323 2323 2323 2323 2323 2323     #############
+0000e140: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000e150: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000e160: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000e170: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000e180: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000e190: 2323 2323 0a20 2020 2020 2020 2023 2323  ####.        ###
+0000e1a0: 2323 2320 5472 6169 6e20 616e 6420 5465  ### Train and Te
+0000e1b0: 7374 2061 7265 2063 7572 7265 6e74 6c79  st are currently
+0000e1c0: 2070 616e 6461 7320 6461 7461 2066 7261   pandas data fra
+0000e1d0: 6d65 7320 6576 656e 2069 6620 6461 736b  mes even if dask
+0000e1e0: 5f78 6762 6f6f 7374 5f66 6c61 6720 6973  _xgboost_flag is
+0000e1f0: 2054 7275 6520 2323 2323 2323 2323 0a20   True ########. 
+0000e200: 2020 2020 2020 2023 2323 2323 2320 2020         ######   
+0000e210: 5468 6174 2069 7320 6265 6361 7573 6520  That is because 
+0000e220: 7765 2063 6f6d 6269 6e65 6420 7468 656d  we combined them
+0000e230: 2061 6674 6572 2066 6561 7475 7265 2065   after feature e
+0000e240: 6e67 6720 746f 2075 7369 6e67 2043 6174  ngg to using Cat
+0000e250: 6567 6f72 795f 456e 636f 6465 7273 2020  egory_Encoders  
+0000e260: 2323 2323 2323 2323 0a20 2020 2020 2020  ########.       
+0000e270: 2023 2323 2323 2323 2323 2323 2323 2323   ###############
+0000e280: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000e290: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000e2a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000e2b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000e2c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000e2d0: 2323 0a20 2020 2020 2020 2070 7265 6473  ##.        preds
+0000e2e0: 203d 205b 7820 666f 7220 7820 696e 206c   = [x for x in l
+0000e2f0: 6973 7428 6461 7461 6e61 6d65 2920 6966  ist(dataname) if
+0000e300: 2078 206e 6f74 2069 6e20 7461 7267 6574   x not in target
+0000e310: 5d0a 2020 2020 2020 2020 6e75 6d76 6172  ].        numvar
+0000e320: 7320 3d20 6461 7461 6e61 6d65 5b70 7265  s = dataname[pre
+0000e330: 6473 5d2e 7365 6c65 6374 5f64 7479 7065  ds].select_dtype
+0000e340: 7328 696e 636c 7564 6520 3d20 276e 756d  s(include = 'num
+0000e350: 6265 7227 292e 636f 6c75 6d6e 732e 746f  ber').columns.to
+0000e360: 6c69 7374 2829 0a20 2020 2020 2020 2069  list().        i
+0000e370: 6620 6361 745f 7661 7273 3a0a 2020 2020  f cat_vars:.    
+0000e380: 2020 2020 2020 2020 2323 2323 2069 6620          #### if 
+0000e390: 6361 745f 7661 7273 2069 6e70 7574 2069  cat_vars input i
+0000e3a0: 7320 6769 7665 6e2c 2075 7365 2069 7421  s given, use it!
+0000e3b0: 0a20 2020 2020 2020 2020 2020 2063 6174  .            cat
+0000e3c0: 7661 7273 203d 2063 6f70 792e 6465 6570  vars = copy.deep
+0000e3d0: 636f 7079 2863 6174 5f76 6172 7329 0a20  copy(cat_vars). 
+0000e3e0: 2020 2020 2020 2020 2020 206e 756d 7661             numva
+0000e3f0: 7273 203d 206c 6566 745f 7375 6274 7261  rs = left_subtra
+0000e400: 6374 2870 7265 6473 2c20 6361 7476 6172  ct(preds, catvar
+0000e410: 7329 0a20 2020 2020 2020 2065 6c73 653a  s).        else:
+0000e420: 0a20 2020 2020 2020 2020 2020 2063 6174  .            cat
+0000e430: 7661 7273 203d 206c 6566 745f 7375 6274  vars = left_subt
+0000e440: 7261 6374 2870 7265 6473 2c20 6e75 6d76  ract(preds, numv
+0000e450: 6172 7329 0a20 2020 2023 2323 2323 2323  ars).    #######
+0000e460: 2323 2323 2323 2323 2323 2323 2323 2320  ############### 
+0000e470: 2020 4920 4d20 5020 4f20 5220 5420 4120    I M P O R T A 
+0000e480: 4e20 5420 2323 2323 2323 2323 2323 2323  N T ############
+0000e490: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000e4a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000e4b0: 2323 0a20 2020 2023 2323 2323 2320 5468  ##.    ###### Th
+0000e4c0: 6973 2074 6f70 5f6e 756d 2064 6563 6964  is top_num decid
+0000e4d0: 6573 2068 6f77 206d 616e 7920 746f 705f  es how many top_
+0000e4e0: 6e20 6665 6174 7572 6573 2058 4742 2073  n features XGB s
+0000e4f0: 656c 6563 7473 2069 6e20 6561 6368 2069  elects in each i
+0000e500: 7465 7261 7469 6f6e 2e0a 2020 2020 2323  teration..    ##
+0000e510: 2323 2020 5468 6572 6520 6120 746f 7461  ##  There a tota
+0000e520: 6c20 6f66 2035 2069 7465 7261 7469 6f6e  l of 5 iteration
+0000e530: 732e 2048 656e 6365 2035 7831 3020 6d65  s. Hence 5x10 me
+0000e540: 616e 7320 6d61 7869 6d75 6d20 3530 2066  ans maximum 50 f
+0000e550: 6561 7475 7265 7320 7769 6c6c 2062 6520  eatures will be 
+0000e560: 7365 6c65 6374 6564 2e0a 2020 2020 2323  selected..    ##
+0000e570: 2323 2320 2049 6620 7468 6572 6520 6172  ###  If there ar
+0000e580: 6520 6d6f 7265 2074 6861 6e20 3530 2076  e more than 50 v
+0000e590: 6172 6961 626c 6573 2c20 7468 656e 206d  ariables, then m
+0000e5a0: 6178 696d 756d 2032 3525 206f 6620 6974  aximum 25% of it
+0000e5b0: 7320 7661 7269 6162 6c65 7320 7769 6c6c  s variables will
+0000e5c0: 2062 6520 7365 6c65 6374 6564 0a20 2020   be selected.   
+0000e5d0: 2069 6620 6c65 6e28 7072 6564 7329 203c   if len(preds) <
+0000e5e0: 3d20 3530 3a0a 2020 2020 2020 2020 2374  = 50:.        #t
+0000e5f0: 6f70 5f6e 756d 203d 2031 300a 2020 2020  op_num = 10.    
+0000e600: 2020 2020 746f 705f 6e75 6d20 3d20 696e      top_num = in
+0000e610: 7428 6d61 7828 322c 206c 656e 2870 7265  t(max(2, len(pre
+0000e620: 6473 292a 302e 3235 2929 0a20 2020 2065  ds)*0.25)).    e
+0000e630: 6c73 653a 0a20 2020 2020 2020 2023 2323  lse:.        ###
+0000e640: 2074 6865 206d 6178 696d 756d 206e 756d   the maximum num
+0000e650: 6265 7220 6f66 2076 6172 6961 626c 6573  ber of variables
+0000e660: 2077 696c 6c20 3235 2520 6f66 2070 7265   will 25% of pre
+0000e670: 6473 2077 6869 6368 206d 6561 6e73 2077  ds which means w
+0000e680: 6520 6469 7669 6465 2062 7920 3520 616e  e divide by 5 an
+0000e690: 6420 6765 7420 3525 2068 6572 650a 2020  d get 5% here.  
+0000e6a0: 2020 2020 2020 2323 2320 5468 6520 6669        ### The fi
+0000e6b0: 7665 2069 7465 7261 7469 6f6e 7320 7265  ve iterations re
+0000e6c0: 7375 6c74 2069 6e20 3130 2520 6265 696e  sult in 10% bein
+0000e6d0: 6720 6368 6f73 656e 2069 6e20 6561 6368  g chosen in each
+0000e6e0: 2069 7465 7261 7469 6f6e 2e20 4865 6e63   iteration. Henc
+0000e6f0: 6520 6d61 7820 3530 2520 6f66 2076 6172  e max 50% of var
+0000e700: 6961 626c 6573 210a 2020 2020 2020 2020  iables!.        
+0000e710: 746f 705f 6e75 6d20 3d20 696e 7428 6c65  top_num = int(le
+0000e720: 6e28 7072 6564 7329 2a30 2e32 3029 0a20  n(preds)*0.20). 
+0000e730: 2020 2023 2323 2323 2323 2323 2323 2323     #############
+0000e740: 2323 2323 2323 2323 2320 2020 4920 4d20  #########   I M 
+0000e750: 5020 4f20 5220 5420 4120 4e20 5420 2323  P O R T A N T ##
+0000e760: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000e770: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000e780: 2323 2323 2323 2323 2323 2323 0a20 2020  ############.   
+0000e790: 2069 6d70 6f72 7461 6e74 5f63 6174 7320   important_cats 
+0000e7a0: 3d20 636f 7079 2e64 6565 7063 6f70 7928  = copy.deepcopy(
+0000e7b0: 6361 7476 6172 7329 0a20 2020 2064 6174  catvars).    dat
+0000e7c0: 615f 6469 6d20 3d20 696e 7428 286c 656e  a_dim = int((len
+0000e7d0: 2864 6174 616e 616d 6529 2a64 6174 616e  (dataname)*datan
+0000e7e0: 616d 652e 7368 6170 655b 315d 292f 3165  ame.shape[1])/1e
+0000e7f0: 3629 0a20 2020 2023 2323 2323 2323 2323  6).    #########
+0000e800: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000e810: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000e820: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000e830: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000e840: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000e850: 2323 2323 2323 230a 2020 2020 2323 2323  #######.    ####
+0000e860: 2323 2323 2323 2323 2020 2020 2053 2020  ########     S  
+0000e870: 2055 2020 4c20 204f 2020 2056 2020 2020   U  L  O   V    
+0000e880: 2020 204d 2020 2045 2020 2054 2020 2048     M   E   T   H
+0000e890: 2020 204f 2020 4420 2020 2020 2023 2323     O  D      ###
+0000e8a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000e8b0: 2323 2323 2323 2323 2323 2323 0a20 2020  ############.   
+0000e8c0: 2023 2323 2320 4966 2074 6865 2064 6174   #### If the dat
+0000e8d0: 6120 6469 6d65 6e73 696f 6e20 6973 206c  a dimension is l
+0000e8e0: 6573 7320 7468 616e 2035 6f20 4d69 6c6c  ess than 5o Mill
+0000e8f0: 696f 6e20 7468 656e 2064 6f20 5355 4c4f  ion then do SULO
+0000e900: 5620 2d20 6f74 6865 7277 6973 6520 736b  V - otherwise sk
+0000e910: 6970 2069 7421 2023 2323 2323 2323 2323  ip it! #########
+0000e920: 0a20 2020 2023 2323 2323 2323 2323 2323  .    ###########
+0000e930: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000e940: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000e950: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000e960: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000e970: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000e980: 2323 2323 230a 2020 2020 0a20 2020 2063  #####.    .    c
+0000e990: 6f6c 735f 7769 7468 5f69 6e66 696e 6974  ols_with_infinit
+0000e9a0: 7920 3d20 4544 415f 6669 6e64 5f72 656d  y = EDA_find_rem
+0000e9b0: 6f76 655f 636f 6c75 6d6e 735f 7769 7468  ove_columns_with
+0000e9c0: 5f69 6e66 696e 6974 7928 6461 7461 6e61  _infinity(datana
+0000e9d0: 6d65 290a 2020 2020 2320 6669 7273 7420  me).    # first 
+0000e9e0: 796f 7520 6d75 7374 2064 726f 7020 726f  you must drop ro
+0000e9f0: 7773 2074 6861 7420 6861 7665 2069 6e66  ws that have inf
+0000ea00: 2069 6e20 7468 656d 2023 2323 230a 2020   in them ####.  
+0000ea10: 2020 6966 2063 6f6c 735f 7769 7468 5f69    if cols_with_i
+0000ea20: 6e66 696e 6974 793a 0a20 2020 2020 2020  nfinity:.       
+0000ea30: 2070 7269 6e74 2827 4472 6f70 7065 6420   print('Dropped 
+0000ea40: 2564 2063 6f6c 756d 6e73 2077 6869 6368  %d columns which
+0000ea50: 2063 6f6e 7461 696e 2069 6e66 696e 6974   contain infinit
+0000ea60: 7920 696e 2064 6174 6173 6574 2720 256c  y in dataset' %l
+0000ea70: 656e 2863 6f6c 735f 7769 7468 5f69 6e66  en(cols_with_inf
+0000ea80: 696e 6974 7929 290a 2020 2020 2020 2020  inity)).        
+0000ea90: 2364 6174 616e 616d 6520 3d20 4645 5f64  #dataname = FE_d
+0000eaa0: 726f 705f 726f 7773 5f77 6974 685f 696e  rop_rows_with_in
+0000eab0: 6669 6e69 7479 2864 6174 616e 616d 652c  finity(dataname,
+0000eac0: 2063 6f6c 735f 7769 7468 5f69 6e66 696e   cols_with_infin
+0000ead0: 6974 792c 2066 696c 6c5f 7661 6c75 653d  ity, fill_value=
+0000eae0: 5472 7565 290a 2020 2020 2020 2020 6461  True).        da
+0000eaf0: 7461 6e61 6d65 203d 2064 6174 616e 616d  taname = datanam
+0000eb00: 652e 6472 6f70 2863 6f6c 735f 7769 7468  e.drop(cols_with
+0000eb10: 5f69 6e66 696e 6974 792c 2061 7869 733d  _infinity, axis=
+0000eb20: 3129 0a20 2020 2020 2020 2070 7269 6e74  1).        print
+0000eb30: 2827 2573 2720 2563 6f6c 735f 7769 7468  ('%s' %cols_with
+0000eb40: 5f69 6e66 696e 6974 7929 0a20 2020 2020  _infinity).     
+0000eb50: 2020 2069 6620 6973 696e 7374 616e 6365     if isinstance
+0000eb60: 2874 6573 745f 6461 7461 2c73 7472 2920  (test_data,str) 
+0000eb70: 6f72 2074 6573 745f 6461 7461 2069 7320  or test_data is 
+0000eb80: 4e6f 6e65 3a0a 2020 2020 2020 2020 2020  None:.          
+0000eb90: 2020 7061 7373 0a20 2020 2020 2020 2065    pass.        e
+0000eba0: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+0000ebb0: 2074 6573 745f 6461 7461 203d 2074 6573   test_data = tes
+0000ebc0: 745f 6461 7461 2e64 726f 7028 636f 6c73  t_data.drop(cols
+0000ebd0: 5f77 6974 685f 696e 6669 6e69 7479 2c20  _with_infinity, 
+0000ebe0: 6178 6973 3d31 290a 2020 2020 2020 2020  axis=1).        
+0000ebf0: 2020 2020 7072 696e 7428 2720 2020 2020      print('     
+0000ec00: 6472 6f70 7065 6420 2573 2063 6f6c 756d  dropped %s colum
+0000ec10: 6e73 2077 6974 6820 696e 6669 6e69 7479  ns with infinity
+0000ec20: 2066 726f 6d20 7465 7374 2064 6174 612e   from test data.
+0000ec30: 2e2e 2720 256c 656e 2863 6f6c 735f 7769  ..' %len(cols_wi
+0000ec40: 7468 5f69 6e66 696e 6974 7929 290a 2020  th_infinity)).  
+0000ec50: 2020 2020 2020 6e75 6d76 6172 7320 3d20        numvars = 
+0000ec60: 6c65 6674 5f73 7562 7472 6163 7428 6e75  left_subtract(nu
+0000ec70: 6d76 6172 732c 2063 6f6c 735f 7769 7468  mvars, cols_with
+0000ec80: 5f69 6e66 696e 6974 7929 0a20 2020 2020  _infinity).     
+0000ec90: 2020 2070 7269 6e74 2827 2020 2020 206e     print('     n
+0000eca0: 756d 6572 6963 2066 6561 7475 7265 7320  umeric features 
+0000ecb0: 6c65 6674 203d 2025 7327 2025 6c65 6e28  left = %s' %len(
+0000ecc0: 6e75 6d76 6172 7329 290a 2020 2020 2323  numvars)).    ##
+0000ecd0: 2323 2323 2320 2054 6869 7320 6973 2077  #####  This is w
+0000ece0: 6865 7265 2079 6f75 2073 7461 7274 2074  here you start t
+0000ecf0: 6865 2053 554c 4f56 2070 726f 6365 7373  he SULOV process
+0000ed00: 2023 2323 2323 2323 2323 2323 2323 2323   ###############
+0000ed10: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000ed20: 2323 2320 2020 200a 2020 2020 7374 6172  ###    .    star
+0000ed30: 745f 7469 6d65 3120 3d20 7469 6d65 2e74  t_time1 = time.t
+0000ed40: 696d 6528 290a 2020 2020 6966 206c 656e  ime().    if len
+0000ed50: 286e 756d 7661 7273 2920 3e20 3120 616e  (numvars) > 1 an
+0000ed60: 6420 6e6f 7420 736b 6970 5f73 756c 6f76  d not skip_sulov
+0000ed70: 3a0a 2020 2020 2020 2020 6966 2064 6174  :.        if dat
+0000ed80: 615f 6469 6d20 3c20 3530 3a0a 2020 2020  a_dim < 50:.    
+0000ed90: 2020 2020 2020 2020 7472 793a 0a20 2020          try:.   
+0000eda0: 2020 2020 2020 2020 2020 2020 2066 696e               fin
+0000edb0: 616c 5f6c 6973 7420 3d20 4645 5f72 656d  al_list = FE_rem
+0000edc0: 6f76 655f 7661 7269 6162 6c65 735f 7573  ove_variables_us
+0000edd0: 696e 675f 5355 4c4f 565f 6d65 7468 6f64  ing_SULOV_method
+0000ede0: 2864 6174 616e 616d 652c 6e75 6d76 6172  (dataname,numvar
+0000edf0: 732c 7365 7474 696e 6773 2e6d 6f64 656c  s,settings.model
+0000ee00: 7479 7065 2c74 6172 6765 742c 0a20 2020  type,target,.   
+0000ee10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000ee20: 2020 2020 2020 2020 2020 636f 7272 5f6c            corr_l
+0000ee30: 696d 6974 2c76 6572 626f 7365 2c20 6461  imit,verbose, da
+0000ee40: 736b 5f78 6762 6f6f 7374 5f66 6c61 6729  sk_xgboost_flag)
+0000ee50: 0a20 2020 2020 2020 2020 2020 2065 7863  .            exc
+0000ee60: 6570 743a 0a20 2020 2020 2020 2020 2020  ept:.           
+0000ee70: 2020 2020 2070 7269 6e74 2827 2020 2020       print('    
+0000ee80: 5355 4c4f 5620 6d65 7468 6f64 2069 7320  SULOV method is 
+0000ee90: 6572 726f 7269 6e67 2e20 436f 6e74 696e  erroring. Contin
+0000eea0: 7569 6e67 202e 2e2e 2729 0a20 2020 2020  uing ...').     
+0000eeb0: 2020 2020 2020 2020 2020 2066 696e 616c             final
+0000eec0: 5f6c 6973 7420 3d20 636f 7079 2e64 6565  _list = copy.dee
+0000eed0: 7063 6f70 7928 6e75 6d76 6172 7329 0a20  pcopy(numvars). 
+0000eee0: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
+0000eef0: 2020 2020 2020 2020 2020 2020 2070 7269               pri
+0000ef00: 6e74 2827 2020 2020 5275 6e6e 696e 6720  nt('    Running 
+0000ef10: 5355 4c4f 5620 6f6e 2073 6d61 6c6c 6572  SULOV on smaller
+0000ef20: 2064 6174 6173 6574 2073 616d 706c 6520   dataset sample 
+0000ef30: 7369 6e63 6520 6461 7461 2073 697a 6520  since data size 
+0000ef40: 2573 206d 203e 2035 3020 6d2e 2043 6f6e  %s m > 50 m. Con
+0000ef50: 7469 6e75 696e 6720 2e2e 2e27 2025 696e  tinuing ...' %in
+0000ef60: 7428 6461 7461 5f64 696d 2929 0a20 2020  t(data_dim)).   
+0000ef70: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+0000ef80: 7365 7474 696e 6773 2e6d 6f64 656c 7479  settings.modelty
+0000ef90: 7065 2021 3d20 2752 6567 7265 7373 696f  pe != 'Regressio
+0000efa0: 6e27 3a0a 2020 2020 2020 2020 2020 2020  n':.            
+0000efb0: 2020 2020 2020 2020 6461 7461 5f74 656d          data_tem
+0000efc0: 7020 3d20 6461 7461 6e61 6d65 2e73 616d  p = dataname.sam
+0000efd0: 706c 6528 6e3d 3130 3030 302c 2072 6570  ple(n=10000, rep
+0000efe0: 6c61 6365 3d54 7275 652c 2072 616e 646f  lace=True, rando
+0000eff0: 6d5f 7374 6174 653d 3939 290a 2020 2020  m_state=99).    
+0000f000: 2020 2020 2020 2020 2020 2020 656c 7365              else
+0000f010: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+0000f020: 2020 2020 2020 6461 7461 5f74 656d 7020        data_temp 
+0000f030: 3d20 6461 7461 6e61 6d65 5b3a 3130 3030  = dataname[:1000
+0000f040: 305d 0a20 2020 2020 2020 2020 2020 2020  0].             
+0000f050: 2020 2066 696e 616c 5f6c 6973 7420 3d20     final_list = 
+0000f060: 4645 5f72 656d 6f76 655f 7661 7269 6162  FE_remove_variab
+0000f070: 6c65 735f 7573 696e 675f 5355 4c4f 565f  les_using_SULOV_
+0000f080: 6d65 7468 6f64 2864 6174 615f 7465 6d70  method(data_temp
+0000f090: 2c6e 756d 7661 7273 2c73 6574 7469 6e67  ,numvars,setting
+0000f0a0: 732e 6d6f 6465 6c74 7970 652c 7461 7267  s.modeltype,targ
+0000f0b0: 6574 2c0a 2020 2020 2020 2020 2020 2020  et,.            
+0000f0c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000f0d0: 2063 6f72 725f 6c69 6d69 742c 7665 7262   corr_limit,verb
+0000f0e0: 6f73 652c 2064 6173 6b5f 7867 626f 6f73  ose, dask_xgboos
+0000f0f0: 745f 666c 6167 290a 2020 2020 2020 2020  t_flag).        
+0000f100: 2020 2020 2020 2020 6465 6c20 6461 7461          del data
+0000f110: 5f74 656d 700a 2020 2020 656c 6966 2073  _temp.    elif s
+0000f120: 6b69 705f 7375 6c6f 763a 0a20 2020 2020  kip_sulov:.     
+0000f130: 2020 2070 7269 6e74 2827 2020 2020 536b     print('    Sk
+0000f140: 6970 7069 6e67 2053 554c 4f56 206d 6574  ipping SULOV met
+0000f150: 686f 642e 2043 6f6e 7469 6e75 696e 6720  hod. Continuing 
+0000f160: 2e2e 2e27 290a 2020 2020 2020 2020 6669  ...').        fi
+0000f170: 6e61 6c5f 6c69 7374 203d 2063 6f70 792e  nal_list = copy.
+0000f180: 6465 6570 636f 7079 286e 756d 7661 7273  deepcopy(numvars
+0000f190: 290a 2020 2020 656c 7365 3a0a 2020 2020  ).    else:.    
+0000f1a0: 2020 2020 7072 696e 7428 2720 2020 2053      print('    S
+0000f1b0: 6b69 7070 696e 6720 5355 4c4f 5620 6d65  kipping SULOV me
+0000f1c0: 7468 6f64 2073 696e 6365 2074 6865 7265  thod since there
+0000f1d0: 2061 7265 206e 6f20 636f 6e74 696e 756f   are no continuo
+0000f1e0: 7573 2076 6172 732e 2043 6f6e 7469 6e75  us vars. Continu
+0000f1f0: 696e 6720 2e2e 2e27 290a 2020 2020 2020  ing ...').      
+0000f200: 2020 6669 6e61 6c5f 6c69 7374 203d 2063    final_list = c
+0000f210: 6f70 792e 6465 6570 636f 7079 286e 756d  opy.deepcopy(num
+0000f220: 7661 7273 290a 2020 2020 2323 2323 2323  vars).    ######
+0000f230: 2320 5468 6973 2069 7320 7768 6572 6520  # This is where 
+0000f240: 796f 7520 6472 6177 2068 6f77 2066 6561  you draw how fea
+0000f250: 7475 7265 7769 7a20 776f 726b 7320 7768  turewiz works wh
+0000f260: 656e 2074 6865 2076 6572 626f 7365 203d  en the verbose =
+0000f270: 2032 2023 2323 2323 2323 2323 2323 0a20   2 ###########. 
+0000f280: 2020 2070 7269 6e74 2827 5469 6d65 2074     print('Time t
+0000f290: 616b 656e 2066 6f72 2053 554c 4f56 206d  aken for SULOV m
+0000f2a0: 6574 686f 6420 3d20 2530 2e30 6620 7365  ethod = %0.0f se
+0000f2b0: 636f 6e64 7327 2025 2874 696d 652e 7469  conds' %(time.ti
+0000f2c0: 6d65 2829 2d73 7461 7274 5f74 696d 6531  me()-start_time1
+0000f2d0: 2929 0a20 2020 2023 2323 2320 4e6f 7720  )).    #### Now 
+0000f2e0: 7765 2063 7265 6174 6520 696e 7465 7261  we create intera
+0000f2f0: 6374 696f 6e20 7661 7269 6162 6c65 7320  ction variables 
+0000f300: 6265 7477 6565 6e20 6361 7465 676f 7269  between categori
+0000f310: 6361 6c20 6665 6174 7572 6573 2023 2323  cal features ###
+0000f320: 2323 2323 230a 2020 2020 6966 2076 6572  #####.    if ver
+0000f330: 626f 7365 3a0a 2020 2020 2020 2020 7072  bose:.        pr
+0000f340: 696e 7428 2720 2020 2041 6464 696e 6720  int('    Adding 
+0000f350: 2573 2063 6174 6567 6f72 6963 616c 2076  %s categorical v
+0000f360: 6172 6961 626c 6573 2074 6f20 7265 6475  ariables to redu
+0000f370: 6365 6420 6e75 6d65 7269 6320 7661 7269  ced numeric vari
+0000f380: 6162 6c65 7320 206f 6620 2564 2720 2528  ables  of %d' %(
+0000f390: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0000f3a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0000f3b0: 206c 656e 2869 6d70 6f72 7461 6e74 5f63   len(important_c
+0000f3c0: 6174 7329 2c6c 656e 2866 696e 616c 5f6c  ats),len(final_l
+0000f3d0: 6973 7429 2929 0a20 2020 2069 6620 2069  ist))).    if  i
+0000f3e0: 7369 6e73 7461 6e63 6528 6669 6e61 6c5f  sinstance(final_
+0000f3f0: 6c69 7374 2c6e 702e 6e64 6172 7261 7929  list,np.ndarray)
+0000f400: 3a0a 2020 2020 2020 2020 6669 6e61 6c5f  :.        final_
+0000f410: 6c69 7374 203d 2066 696e 616c 5f6c 6973  list = final_lis
+0000f420: 742e 746f 6c69 7374 2829 0a20 2020 2070  t.tolist().    p
+0000f430: 7265 6473 203d 2066 696e 616c 5f6c 6973  reds = final_lis
+0000f440: 742b 696d 706f 7274 616e 745f 6361 7473  t+important_cats
+0000f450: 0a20 2020 2069 6620 7665 7262 6f73 6520  .    if verbose 
+0000f460: 616e 6420 6c65 6e28 7072 6564 7329 203c  and len(preds) <
+0000f470: 3d20 3330 3a0a 2020 2020 2020 2020 7072  = 30:.        pr
+0000f480: 696e 7428 2746 696e 616c 206c 6973 7420  int('Final list 
+0000f490: 6f66 2073 656c 6563 7465 6420 2573 2076  of selected %s v
+0000f4a0: 6172 7320 6166 7465 7220 5355 4c4f 5620  ars after SULOV 
+0000f4b0: 3d20 2573 2720 2528 6c65 6e28 7072 6564  = %s' %(len(pred
+0000f4c0: 7329 2c20 7072 6564 7329 290a 2020 2020  s), preds)).    
+0000f4d0: 656c 7365 3a0a 2020 2020 2020 2020 7072  else:.        pr
+0000f4e0: 696e 7428 2746 696e 616c 6c79 2025 7320  int('Finally %s 
+0000f4f0: 7661 7273 2073 656c 6563 7465 6420 6166  vars selected af
+0000f500: 7465 7220 5355 4c4f 5627 2025 286c 656e  ter SULOV' %(len
+0000f510: 2870 7265 6473 2929 290a 2020 2020 2323  (preds))).    ##
+0000f520: 2323 2323 2359 6f75 206d 7573 7420 636f  #####You must co
+0000f530: 6e76 6572 7420 6361 7465 676f 7279 2076  nvert category v
+0000f540: 6172 6961 626c 6573 2069 6e74 6f20 696e  ariables into in
+0000f550: 7465 6765 7273 2023 2323 2323 2323 2323  tegers #########
+0000f560: 2323 2323 2323 2020 2020 0a20 2020 2070  ######    .    p
+0000f570: 7269 6e74 2827 436f 6e76 6572 7469 6e67  rint('Converting
+0000f580: 2061 6c6c 2066 6561 7475 7265 7320 746f   all features to
+0000f590: 206e 756d 6572 6963 2062 6566 6f72 6520   numeric before 
+0000f5a0: 7365 6e64 696e 6720 746f 2058 4742 6f6f  sending to XGBoo
+0000f5b0: 7374 2e2e 2e27 290a 2020 2020 6966 2069  st...').    if i
+0000f5c0: 7369 6e73 7461 6e63 6528 7461 7267 6574  sinstance(target
+0000f5d0: 2c20 7374 7229 3a0a 2020 2020 2020 2020  , str):.        
+0000f5e0: 6461 7461 6e61 6d65 203d 2064 6174 616e  dataname = datan
+0000f5f0: 616d 655b 7072 6564 732b 5b74 6172 6765  ame[preds+[targe
+0000f600: 745d 5d0a 2020 2020 656c 7365 3a0a 2020  t]].    else:.  
+0000f610: 2020 2020 2020 6461 7461 6e61 6d65 203d        dataname =
+0000f620: 2064 6174 616e 616d 655b 7072 6564 732b   dataname[preds+
+0000f630: 7461 7267 6574 5d0a 2020 2020 0a20 2020  target].    .   
+0000f640: 2069 6620 6e6f 7420 7465 7374 5f64 6174   if not test_dat
+0000f650: 6120 6973 204e 6f6e 653a 0a20 2020 2020  a is None:.     
+0000f660: 2020 2074 6573 745f 6461 7461 203d 2074     test_data = t
+0000f670: 6573 745f 6461 7461 5b70 7265 6473 5d0a  est_data[preds].
+0000f680: 2020 2020 6966 206c 656e 2869 6d70 6f72      if len(impor
+0000f690: 7461 6e74 5f63 6174 7329 203e 2030 3a0a  tant_cats) > 0:.
+0000f6a0: 2020 2020 2020 2020 6461 7461 6e61 6d65          dataname
+0000f6b0: 2c20 7465 7374 5f64 6174 612c 2065 7272  , test_data, err
+0000f6c0: 6f72 5f63 6f6c 756d 6e73 203d 2046 455f  or_columns = FE_
+0000f6d0: 636f 6e76 6572 745f 616c 6c5f 6f62 6a65  convert_all_obje
+0000f6e0: 6374 5f63 6f6c 756d 6e73 5f74 6f5f 6e75  ct_columns_to_nu
+0000f6f0: 6d65 7269 6328 6461 7461 6e61 6d65 2c20  meric(dataname, 
+0000f700: 2074 6573 745f 6461 7461 2c20 7072 6564   test_data, pred
+0000f710: 7329 0a20 2020 2020 2020 2069 6d70 6f72  s).        impor
+0000f720: 7461 6e74 5f63 6174 7320 3d20 6c65 6674  tant_cats = left
+0000f730: 5f73 7562 7472 6163 7428 696d 706f 7274  _subtract(import
+0000f740: 616e 745f 6361 7473 2c20 6572 726f 725f  ant_cats, error_
+0000f750: 636f 6c75 6d6e 7329 0a20 2020 2020 2020  columns).       
+0000f760: 2069 6620 6c65 6e28 6572 726f 725f 636f   if len(error_co
+0000f770: 6c75 6d6e 7329 203e 2030 3a0a 2020 2020  lumns) > 0:.    
+0000f780: 2020 2020 2020 2020 7072 696e 7428 2720          print(' 
+0000f790: 2020 2072 656d 6f76 696e 6720 2573 206f     removing %s o
+0000f7a0: 626a 6563 7420 636f 6c75 6d6e 7320 7468  bject columns th
+0000f7b0: 6174 2063 6f75 6c64 206e 6f74 2062 6520  at could not be 
+0000f7c0: 636f 6e76 6572 7465 6420 746f 206e 756d  converted to num
+0000f7d0: 6572 6963 2720 256c 656e 2865 7272 6f72  eric' %len(error
+0000f7e0: 5f63 6f6c 756d 6e73 2929 0a20 2020 2020  _columns)).     
+0000f7f0: 2020 2020 2020 2070 7265 6473 203d 206c         preds = l
+0000f800: 6973 7428 7365 7428 7072 6564 7329 2d73  ist(set(preds)-s
+0000f810: 6574 2865 7272 6f72 5f63 6f6c 756d 6e73  et(error_columns
+0000f820: 2929 0a20 2020 2020 2020 2020 2020 2064  )).            d
+0000f830: 6174 616e 616d 652e 6472 6f70 2865 7272  ataname.drop(err
+0000f840: 6f72 5f63 6f6c 756d 6e73 2c20 6178 6973  or_columns, axis
+0000f850: 3d31 2c20 696e 706c 6163 653d 5472 7565  =1, inplace=True
+0000f860: 290a 2020 2020 2020 2020 656c 7365 3a0a  ).        else:.
+0000f870: 2020 2020 2020 2020 2020 2020 7072 696e              prin
+0000f880: 7428 2720 2020 2074 6865 7265 2077 6572  t('    there wer
+0000f890: 6520 6e6f 206d 6978 6564 2064 6174 6120  e no mixed data 
+0000f8a0: 7479 7065 7320 6f72 206f 626a 6563 7420  types or object 
+0000f8b0: 636f 6c75 6d6e 7320 7468 6174 2065 7272  columns that err
+0000f8c0: 6f72 6564 2e20 4461 7461 2069 7320 616c  ored. Data is al
+0000f8d0: 6c20 6e75 6d65 7269 632e 2e2e 2729 0a20  l numeric...'). 
+0000f8e0: 2020 2020 2020 2070 7269 6e74 2827 5368         print('Sh
+0000f8f0: 6170 6520 6f66 2074 7261 696e 2064 6174  ape of train dat
+0000f900: 6120 6166 7465 7220 6164 6469 6e67 206d  a after adding m
+0000f910: 6973 7369 6e67 2076 616c 7565 7320 666c  issing values fl
+0000f920: 6167 7320 3d20 2573 2720 2528 6461 7461  ags = %s' %(data
+0000f930: 6e61 6d65 2e73 6861 7065 2c29 2029 0a20  name.shape,) ). 
+0000f940: 2020 2020 2020 2070 7265 6473 203d 205b         preds = [
+0000f950: 7820 666f 7220 7820 696e 206c 6973 7428  x for x in list(
+0000f960: 6461 7461 6e61 6d65 2920 6966 2078 206e  dataname) if x n
+0000f970: 6f74 2069 6e20 7461 7267 6574 735d 0a20  ot in targets]. 
+0000f980: 2020 2020 2020 2069 6620 6e6f 7420 7465         if not te
+0000f990: 7374 5f64 6174 6120 6973 204e 6f6e 653a  st_data is None:
+0000f9a0: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+0000f9b0: 6c65 6e28 6572 726f 725f 636f 6c75 6d6e  len(error_column
+0000f9c0: 7329 203e 2030 3a0a 2020 2020 2020 2020  s) > 0:.        
+0000f9d0: 2020 2020 2020 2020 7465 7374 5f64 6174          test_dat
+0000f9e0: 612e 6472 6f70 2865 7272 6f72 5f63 6f6c  a.drop(error_col
+0000f9f0: 756d 6e73 2c20 6178 6973 3d31 2c20 696e  umns, axis=1, in
+0000fa00: 706c 6163 653d 5472 7565 290a 2020 2020  place=True).    
+0000fa10: 2020 2020 2020 2020 7072 696e 7428 2720          print(' 
+0000fa20: 2020 2053 6861 7065 206f 6620 7465 7374     Shape of test
+0000fa30: 2064 6174 6120 6166 7465 7220 6164 6469   data after addi
+0000fa40: 6e67 206d 6973 7369 6e67 2076 616c 7565  ng missing value
+0000fa50: 7320 666c 6167 7320 203d 2025 7327 2025  s flags  = %s' %
+0000fa60: 2874 6573 745f 6461 7461 2e73 6861 7065  (test_data.shape
+0000fa70: 2c29 2029 0a20 2020 200a 2020 2020 6966  ,) ).    .    if
+0000fa80: 206e 6f74 2073 6b69 705f 7867 626f 6f73   not skip_xgboos
+0000fa90: 743a 0a20 2020 2020 2020 2023 2323 2054  t:.        ### T
+0000faa0: 6869 7320 6973 2077 6865 7265 2077 6520  his is where we 
+0000fab0: 7065 7266 6f72 6d20 7468 6520 7265 6375  perform the recu
+0000fac0: 7273 6976 6520 5847 426f 6f73 7420 6d65  rsive XGBoost me
+0000fad0: 7468 6f64 2023 2323 2323 2323 2323 2323  thod ###########
+0000fae0: 2323 230a 2020 2020 2020 2020 6966 2076  ###.        if v
+0000faf0: 6572 626f 7365 3a0a 2020 2020 2020 2020  erbose:.        
+0000fb00: 2020 2020 7072 696e 7428 2723 2323 2323      print('#####
 0000fb10: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 0000fb20: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 0000fb30: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000fb40: 2323 2729 0a20 2020 200a 2020 2020 696d  ##').    .    im
-0000fb50: 706f 7274 616e 745f 6665 6174 7572 6573  portant_features
-0000fb60: 203d 205b 5d0a 2020 2020 2323 2323 2323   = [].    ######
-0000fb70: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000fb80: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000fb90: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000fba0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000fbb0: 230a 2020 2020 2323 2323 2320 2020 5468  #.    #####   Th
-0000fbc0: 6973 2069 7320 666f 7220 4441 534b 2058  is is for DASK X
-0000fbd0: 4742 2052 6567 7265 7373 6f72 2061 6e64  GB Regressor and
-0000fbe0: 2058 4742 2043 6c61 7373 6966 6965 7220   XGB Classifier 
-0000fbf0: 7072 6f62 6c65 6d73 2023 2323 230a 2020  problems ####.  
-0000fc00: 2020 2323 2323 2323 2323 2323 2323 2323    ##############
+0000fb40: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000fb50: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000fb60: 2323 2729 0a20 2020 2020 2020 2020 2020  ##').           
+0000fb70: 2070 7269 6e74 2827 2323 2323 2320 2020   print('#####   
+0000fb80: 2052 2045 2043 2055 2052 2053 2049 2056   R E C U R S I V
+0000fb90: 2045 2020 2058 2047 2042 204f 204f 2053   E   X G B O O S
+0000fba0: 2054 203a 2046 2045 2041 2054 2055 2052   T : F E A T U R
+0000fbb0: 2045 2020 2053 2045 204c 2045 2043 2054   E   S E L E C T
+0000fbc0: 2049 204f 204e 2020 2323 2323 2323 2327   I O N  #######'
+0000fbd0: 290a 2020 2020 2020 2020 2020 2020 7072  ).            pr
+0000fbe0: 696e 7428 2723 2323 2323 2323 2323 2323  int('###########
+0000fbf0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000fc00: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 0000fc10: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 0000fc20: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000fc30: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000fc40: 2323 2323 2323 2323 230a 2020 2020 6966  #########.    if
-0000fc50: 2073 6574 7469 6e67 732e 6d75 6c74 695f   settings.multi_
-0000fc60: 6c61 6265 6c3a 0a20 2020 2020 2020 2023  label:.        #
-0000fc70: 2323 206f 6e6c 7920 7265 6775 6c61 7220  ## only regular 
-0000fc80: 7867 626f 6f73 7420 7769 7468 206d 756c  xgboost with mul
-0000fc90: 7469 2d6f 7574 7075 7420 6361 6e20 776f  ti-output can wo
-0000fca0: 726b 2077 656c 6c20 696e 206d 756c 7469  rk well in multi
-0000fcb0: 2d6c 6162 656c 2073 6574 7469 6e67 7320  -label settings 
-0000fcc0: 230a 2020 2020 2020 2020 6461 736b 5f78  #.        dask_x
-0000fcd0: 6762 6f6f 7374 5f66 6c61 6720 3d20 4661  gboost_flag = Fa
-0000fce0: 6c73 6520 0a20 2020 2062 7374 5f6d 6f64  lse .    bst_mod
-0000fcf0: 656c 7320 3d20 5b5d 0a0a 2020 2020 2323  els = []..    ##
-0000fd00: 2323 2323 2323 2320 2020 5468 6973 2069  #######   This i
-0000fd10: 7320 666f 7220 4441 534b 2044 6174 6166  s for DASK Dataf
-0000fd20: 7261 6d65 7320 5847 426f 6f73 7420 7472  rames XGBoost tr
-0000fd30: 6169 6e69 6e67 2023 2323 2323 2323 2323  aining #########
-0000fd40: 2323 2323 2323 2323 2323 230a 2020 2020  ###########.    
-0000fd50: 7472 793a 0a20 2020 2020 2020 2078 6762  try:.        xgb
-0000fd60: 2e73 6574 5f63 6f6e 6669 6728 7665 7262  .set_config(verb
-0000fd70: 6f73 6974 793d 3029 0a20 2020 2065 7863  osity=0).    exc
-0000fd80: 6570 743a 0a20 2020 2020 2020 2023 2320  ept:.        ## 
-0000fd90: 536f 6d65 2063 6173 6573 2c20 7468 6973  Some cases, this
-0000fda0: 2065 7272 6f72 732c 2073 6f20 7061 7373   errors, so pass
-0000fdb0: 2023 2323 0a20 2020 2020 2020 2070 6173   ###.        pas
-0000fdc0: 730a 2020 2020 2323 2323 2323 2323 2323  s.    ##########
-0000fdd0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000fde0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000fdf0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000fe00: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000fe10: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000fe20: 2323 2323 2323 230a 2020 2020 2323 2323  #######.    ####
-0000fe30: 2323 2323 2020 204e 6f77 2069 6620 6461  ####   Now if da
-0000fe40: 736b 5f78 6762 6f6f 7374 5f66 6c61 6720  sk_xgboost_flag 
-0000fe50: 6973 2054 7275 652c 2063 6f6e 7665 7274  is True, convert
-0000fe60: 2070 616e 6461 7320 6466 7320 6261 636b   pandas dfs back
-0000fe70: 2074 6f20 4461 736b 2044 6174 6166 7261   to Dask Datafra
-0000fe80: 6d65 7320 2020 2020 2323 2323 230a 2020  mes     #####.  
-0000fe90: 2020 2323 2323 2323 2323 2323 2323 2323    ##############
-0000fea0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000feb0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000fec0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000fed0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000fee0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0000fef0: 2323 230a 2020 2020 6966 2064 6173 6b5f  ###.    if dask_
-0000ff00: 7867 626f 6f73 745f 666c 6167 3a0a 2020  xgboost_flag:.  
-0000ff10: 2020 2020 2020 2323 2320 7765 2072 656c        ### we rel
-0000ff20: 6f61 6420 7468 6520 6461 7461 6672 616d  oad the datafram
-0000ff30: 6573 2069 6e74 6f20 6461 736b 2073 696e  es into dask sin
-0000ff40: 6365 2063 6f6c 756d 6e73 206d 6179 2068  ce columns may h
-0000ff50: 6176 6520 6265 656e 2064 726f 7070 6564  ave been dropped
-0000ff60: 2023 230a 2020 2020 2020 2020 6966 2076   ##.        if v
-0000ff70: 6572 626f 7365 3a0a 2020 2020 2020 2020  erbose:.        
-0000ff80: 2020 2020 7072 696e 7428 2720 2020 2075      print('    u
-0000ff90: 7369 6e67 2044 4153 4b20 5847 426f 6f73  sing DASK XGBoos
-0000ffa0: 7427 2920 200a 2020 2020 2020 2020 7472  t')  .        tr
-0000ffb0: 6169 6e20 3d20 6c6f 6164 5f64 6173 6b5f  ain = load_dask_
-0000ffc0: 6461 7461 2864 6174 616e 616d 652c 2073  data(dataname, s
-0000ffd0: 6570 290a 2020 2020 2020 2020 6966 206e  ep).        if n
-0000ffe0: 6f74 2074 6573 745f 6461 7461 2069 7320  ot test_data is 
-0000fff0: 4e6f 6e65 3a0a 2020 2020 2020 2020 2020  None:.          
-00010000: 2020 7465 7374 203d 206c 6f61 645f 6461    test = load_da
-00010010: 736b 5f64 6174 6128 7465 7374 5f64 6174  sk_data(test_dat
-00010020: 612c 2073 6570 290a 2020 2020 656c 7365  a, sep).    else
-00010030: 3a0a 2020 2020 2020 2020 2323 2320 7765  :.        ### we
-00010040: 2072 656c 6f61 6420 7468 6520 6461 7461   reload the data
-00010050: 6672 616d 6573 2069 6e74 6f20 6461 736b  frames into dask
-00010060: 2073 696e 6365 2063 6f6c 756d 6e73 206d   since columns m
-00010070: 6179 2068 6176 6520 6265 656e 2064 726f  ay have been dro
-00010080: 7070 6564 2023 230a 2020 2020 2020 2020  pped ##.        
-00010090: 6966 2076 6572 626f 7365 3a0a 2020 2020  if verbose:.    
-000100a0: 2020 2020 2020 2020 7072 696e 7428 2720          print(' 
-000100b0: 2020 2075 7369 6e67 2072 6567 756c 6172     using regular
-000100c0: 2058 4742 6f6f 7374 2729 200a 2020 2020   XGBoost') .    
-000100d0: 2020 2020 7472 6169 6e20 3d20 636f 7079      train = copy
-000100e0: 2e64 6565 7063 6f70 7928 6461 7461 6e61  .deepcopy(datana
-000100f0: 6d65 290a 2020 2020 2020 2020 7465 7374  me).        test
-00010100: 203d 2063 6f70 792e 6465 6570 636f 7079   = copy.deepcopy
-00010110: 2874 6573 745f 6461 7461 290a 2020 2020  (test_data).    
-00010120: 2323 2323 2323 2323 2020 436f 6e76 6572  ########  Conver
-00010130: 7369 6f6e 2063 6f6d 706c 6574 6564 2066  sion completed f
-00010140: 6f72 2074 7261 696e 2061 6e64 2074 6573  or train and tes
-00010150: 7420 6461 7461 2023 2323 2323 2323 2323  t data #########
-00010160: 230a 2020 2023 2323 2320 4966 2043 6174  #.   #### If Cat
-00010170: 6567 6f72 7920 456e 636f 6469 6e67 2074  egory Encoding t
-00010180: 6f6f 6b20 706c 6163 652c 2074 6865 7365  ook place, these
-00010190: 2063 6174 2076 6172 6961 626c 6573 2061   cat variables a
-000101a0: 7265 206e 6f20 6c6f 6e67 6572 206e 6565  re no longer nee
-000101b0: 6465 6420 696e 2054 7261 696e 2e20 536f  ded in Train. So
-000101c0: 2072 656d 6f76 6520 7468 656d 210a 2020   remove them!.  
-000101d0: 2020 6966 2066 6561 7475 7265 5f67 656e    if feature_gen
-000101e0: 206f 7220 6665 6174 7572 655f 7479 7065   or feature_type
-000101f0: 3a0a 2020 2020 2020 2020 7072 696e 7428  :.        print(
-00010200: 2753 696e 6365 2025 7320 6361 7465 676f  'Since %s catego
-00010210: 7279 2065 6e63 6f64 696e 6720 6973 2064  ry encoding is d
-00010220: 6f6e 652c 2064 726f 7070 696e 6720 6f72  one, dropping or
-00010230: 6967 696e 616c 2063 6174 6567 6f72 6963  iginal categoric
-00010240: 616c 2076 6172 7320 6672 6f6d 2070 7265  al vars from pre
-00010250: 6469 6374 6f72 732e 2e2e 2720 2566 6561  dictors...' %fea
-00010260: 7475 7265 5f67 656e 290a 2020 2020 2020  ture_gen).      
-00010270: 2020 7072 6564 7320 3d20 6c65 6674 5f73    preds = left_s
-00010280: 7562 7472 6163 7428 7072 6564 732c 2063  ubtract(preds, c
-00010290: 6174 7661 7273 290a 2020 2020 6966 2064  atvars).    if d
-000102a0: 6173 6b5f 7867 626f 6f73 745f 666c 6167  ask_xgboost_flag
-000102b0: 3a0a 2020 2020 2020 2020 7472 6169 6e5f  :.        train_
-000102c0: 7020 3d20 7472 6169 6e5b 7072 6564 735d  p = train[preds]
-000102d0: 0a20 2020 2065 6c73 653a 0a20 2020 2020  .    else:.     
-000102e0: 2020 2074 7261 696e 5f70 203d 2064 6174     train_p = dat
-000102f0: 616e 616d 655b 7072 6564 735d 0a20 2020  aname[preds].   
-00010300: 2023 2323 2323 2323 2320 4c69 6d69 7420   ######## Limit 
-00010310: 7468 6520 6e75 6d62 6572 206f 6620 6974  the number of it
-00010320: 6572 6174 696f 6e73 2074 6f20 3520 6f72  erations to 5 or
-00010330: 2073 6f20 2323 2323 2323 230a 2020 2020   so #######.    
-00010340: 6966 2074 7261 696e 5f70 2e73 6861 7065  if train_p.shape
-00010350: 5b31 5d20 3c3d 2031 303a 0a20 2020 2020  [1] <= 10:.     
-00010360: 2020 2069 7465 725f 6c69 6d69 7420 3d20     iter_limit = 
-00010370: 320a 2020 2020 656c 7365 3a0a 2020 2020  2.    else:.    
-00010380: 2020 2020 6974 6572 5f6c 696d 6974 203d      iter_limit =
-00010390: 2069 6e74 2874 7261 696e 5f70 2e73 6861   int(train_p.sha
-000103a0: 7065 5b31 5d2f 352b 302e 3529 0a20 2020  pe[1]/5+0.5).   
-000103b0: 2069 6620 7665 7262 6f73 653a 0a20 2020   if verbose:.   
-000103c0: 2020 2020 2070 7269 6e74 2827 2020 2020       print('    
-000103d0: 5461 6b69 6e67 2074 6f70 2025 7320 6665  Taking top %s fe
-000103e0: 6174 7572 6573 2070 6572 2069 7465 7261  atures per itera
-000103f0: 7469 6f6e 2e2e 2e27 2025 746f 705f 6e75  tion...' %top_nu
-00010400: 6d29 0a20 2020 2069 6620 6461 736b 5f78  m).    if dask_x
-00010410: 6762 6f6f 7374 5f66 6c61 673a 0a20 2020  gboost_flag:.   
-00010420: 2020 2020 2069 6620 7665 7262 6f73 653a       if verbose:
-00010430: 0a20 2020 2020 2020 2020 2020 2070 7269  .            pri
-00010440: 6e74 2827 2020 2020 4461 736b 2076 6572  nt('    Dask ver
-00010450: 7369 6f6e 203d 2025 7327 2025 6461 736b  sion = %s' %dask
-00010460: 2e5f 5f76 6572 7369 6f6e 5f5f 290a 2020  .__version__).  
-00010470: 2020 2020 2020 2323 2320 596f 7520 6361        ### You ca
-00010480: 6e20 7265 6d6f 7665 2064 6173 6b5f 6d6c  n remove dask_ml
-00010490: 2068 6572 6520 7369 6e63 6520 796f 7520   here since you 
-000104a0: 646f 6e27 7420 646f 2061 6e79 2073 706c  don't do any spl
-000104b0: 6974 206f 6620 7472 6169 6e20 7465 7374  it of train test
-000104c0: 2068 6572 6520 2323 2323 2323 2323 2323   here ##########
-000104d0: 0a20 2020 2020 2020 2023 6672 6f6d 2064  .        #from d
-000104e0: 6173 6b5f 6d6c 2e6d 6f64 656c 5f73 656c  ask_ml.model_sel
-000104f0: 6563 7469 6f6e 2069 6d70 6f72 7420 7472  ection import tr
-00010500: 6169 6e5f 7465 7374 5f73 706c 6974 0a20  ain_test_split. 
-00010510: 2020 2020 2020 2023 2323 2063 6865 636b         ### check
-00010520: 2061 7661 696c 6162 6c65 206d 656d 6f72   available memor
-00010530: 7920 616e 6420 616c 6c6f 6361 7465 2061  y and allocate a
-00010540: 7420 6c65 6173 7420 3147 4220 6f66 2069  t least 1GB of i
-00010550: 7420 696e 2074 6865 2043 6c69 656e 7420  t in the Client 
-00010560: 696e 2044 4153 4b20 2323 2323 2323 2323  in DASK ########
-00010570: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00010580: 2323 2323 230a 2020 2020 2020 2020 6e5f  #####.        n_
-00010590: 776f 726b 6572 7320 3d20 6765 745f 6370  workers = get_cp
-000105a0: 755f 776f 726b 6572 5f63 6f75 6e74 2829  u_worker_count()
-000105b0: 0a20 2020 2020 2020 2023 2323 2041 766f  .        ### Avo
-000105c0: 6964 2072 6564 7563 696e 6720 7468 6520  id reducing the 
-000105d0: 6672 6565 206d 656d 6f72 7920 2d20 6c65  free memory - le
-000105e0: 6176 6520 6974 2061 7320 6269 6720 6173  ave it as big as
-000105f0: 2069 7420 7761 6e74 7320 746f 2062 6520   it wants to be 
-00010600: 2323 230a 2020 2020 2020 2020 6d65 6d6f  ###.        memo
-00010610: 7279 5f66 7265 6520 3d20 7374 7228 6d61  ry_free = str(ma
-00010620: 7828 312c 2069 6e74 2870 7375 7469 6c2e  x(1, int(psutil.
-00010630: 7669 7274 7561 6c5f 6d65 6d6f 7279 2829  virtual_memory()
-00010640: 5b30 5d2f 286e 5f77 6f72 6b65 7273 2a31  [0]/(n_workers*1
-00010650: 6539 2929 2929 2b27 4742 270a 2020 2020  e9))))+'GB'.    
-00010660: 2020 2020 7072 696e 7428 2720 2020 2055      print('    U
-00010670: 7369 6e67 2044 6173 6b20 5847 426f 6f73  sing Dask XGBoos
-00010680: 7420 616c 676f 7269 7468 6d20 7769 7468  t algorithm with
-00010690: 2025 7320 7669 7274 7561 6c20 4350 5573   %s virtual CPUs
-000106a0: 2061 6e64 2025 7320 6d65 6d6f 7279 206c   and %s memory l
-000106b0: 696d 6974 2e2e 2e27 2025 2867 6574 5f63  imit...' %(get_c
-000106c0: 7075 5f77 6f72 6b65 725f 636f 756e 7428  pu_worker_count(
-000106d0: 292c 206d 656d 6f72 795f 6672 6565 2929  ), memory_free))
-000106e0: 0a20 2020 2020 2020 2063 6c69 656e 7420  .        client 
-000106f0: 3d20 436c 6965 6e74 286e 5f77 6f72 6b65  = Client(n_worke
-00010700: 7273 3d20 6e5f 776f 726b 6572 732c 2074  rs= n_workers, t
-00010710: 6872 6561 6473 5f70 6572 5f77 6f72 6b65  hreads_per_worke
-00010720: 723d 312c 2070 726f 6365 7373 6573 3d54  r=1, processes=T
-00010730: 7275 652c 2073 696c 656e 6365 5f6c 6f67  rue, silence_log
-00010740: 733d 3530 2c0a 2020 2020 2020 2020 2020  s=50,.          
-00010750: 2020 2020 2020 2020 2020 2020 2020 6d65                me
-00010760: 6d6f 7279 5f6c 696d 6974 3d6d 656d 6f72  mory_limit=memor
-00010770: 795f 6672 6565 290a 2020 2020 2020 2020  y_free).        
-00010780: 7072 696e 7428 2744 6173 6b20 636c 6965  print('Dask clie
-00010790: 6e74 2063 6f6e 6669 6775 7261 7469 6f6e  nt configuration
-000107a0: 3a20 2573 2720 2563 6c69 656e 7429 0a20  : %s' %client). 
-000107b0: 2020 2020 2020 2069 6d70 6f72 7420 6763         import gc
-000107c0: 0a20 2020 2020 2020 2063 6c69 656e 742e  .        client.
-000107d0: 7275 6e28 6763 2e63 6f6c 6c65 6374 2920  run(gc.collect) 
-000107e0: 0a20 2020 2020 2020 2023 7472 6169 6e5f  .        #train_
-000107f0: 7020 3d20 636c 6965 6e74 2e70 6572 7369  p = client.persi
-00010800: 7374 2874 7261 696e 5f70 290a 2020 2020  st(train_p).    
-00010810: 6966 2076 6572 626f 7365 3a0a 2020 2020  if verbose:.    
-00010820: 2020 2020 7072 696e 7428 2720 2020 2058      print('    X
-00010830: 4742 6f6f 7374 2076 6572 7369 6f6e 2075  GBoost version u
-00010840: 7369 6e67 2025 7320 6173 2074 7265 6520  sing %s as tree 
-00010850: 6d65 7468 6f64 3a20 2573 2720 2528 7867  method: %s' %(xg
-00010860: 622e 5f5f 7665 7273 696f 6e5f 5f2c 2074  b.__version__, t
-00010870: 7265 655f 6d65 7468 6f64 2929 0a20 2020  ree_method)).   
-00010880: 2023 2323 2054 6869 7320 6973 2074 6f20   ### This is to 
-00010890: 636f 6e76 6572 7420 7468 6520 7461 7267  convert the targ
-000108a0: 6574 206c 6162 656c 7320 746f 2070 726f  et labels to pro
-000108b0: 7065 7220 6e75 6d65 7269 6320 636f 6c75  per numeric colu
-000108c0: 6d6e 7320 2323 2323 2323 0a20 2020 2063  mns ######.    c
-000108d0: 6174 5f74 6172 6765 7473 203d 2064 6174  at_targets = dat
-000108e0: 616e 616d 655b 7461 7267 6574 5d2e 7365  aname[target].se
-000108f0: 6c65 6374 5f64 7479 7065 7328 696e 636c  lect_dtypes(incl
-00010900: 7564 653d 276f 626a 6563 7427 292e 636f  ude='object').co
-00010910: 6c75 6d6e 732e 746f 6c69 7374 2829 202b  lumns.tolist() +
-00010920: 2064 6174 616e 616d 655b 7461 7267 6574   dataname[target
-00010930: 5d2e 7365 6c65 6374 5f64 7479 7065 7328  ].select_dtypes(
-00010940: 696e 636c 7564 653d 2763 6174 6567 6f72  include='categor
-00010950: 7927 292e 636f 6c75 6d6e 732e 746f 6c69  y').columns.toli
-00010960: 7374 2829 0a20 2020 2023 2323 2063 6865  st().    ### che
-00010970: 636b 2069 6620 7468 6579 2061 7265 206e  ck if they are n
-00010980: 6f74 2073 7461 7274 696e 6720 6672 6f6d  ot starting from
-00010990: 207a 6572 6f20 2323 2323 2323 2323 2323   zero ##########
-000109a0: 2323 2323 2323 2323 0a20 2020 2069 6620  ########.    if 
-000109b0: 6461 736b 5f78 6762 6f6f 7374 5f66 6c61  dask_xgboost_fla
-000109c0: 673a 0a20 2020 2020 2020 2023 2323 2074  g:.        ### t
-000109d0: 7261 696e 2069 7320 616c 7265 6164 7920  rain is already 
-000109e0: 6120 6461 736b 2064 6174 6166 7261 6d65  a dask dataframe
-000109f0: 202d 3e20 796f 7520 6361 6e20 6c65 6176   -> you can leav
-00010a00: 6520 6974 2061 7320 6974 2069 730a 2020  e it as it is.  
-00010a10: 2020 2020 2020 795f 7472 6169 6e20 3d20        y_train = 
-00010a20: 7472 6169 6e5b 7461 7267 6574 5d0a 2020  train[target].  
-00010a30: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
-00010a40: 2323 2320 7472 6169 6e20 6973 2061 6c72  ### train is alr
-00010a50: 6561 6479 2061 2072 6567 756c 6172 2064  eady a regular d
-00010a60: 6174 6166 7261 6d65 202d 3e20 796f 7520  ataframe -> you 
-00010a70: 6361 6e20 6c65 6176 6520 6974 2061 7320  can leave it as 
-00010a80: 6974 2069 730a 2020 2020 2020 2020 795f  it is.        y_
-00010a90: 7472 6169 6e20 3d20 6461 7461 6e61 6d65  train = dataname
-00010aa0: 5b74 6172 6765 745d 0a20 2020 2023 2323  [target].    ###
-00010ab0: 2320 4e6f 7720 7765 2070 726f 6365 7373  # Now we process
-00010ac0: 2074 6865 206e 756d 6572 6963 2020 7661   the numeric  va
-00010ad0: 6c75 6573 2074 6872 6f75 6768 2044 4153  lues through DAS
-00010ae0: 4b20 5847 426f 6f73 7420 7265 7065 6174  K XGBoost repeat
-00010af0: 6564 6c79 2023 2323 2323 2323 2323 2323  edly ###########
-00010b00: 2323 2323 2323 2323 0a20 2020 2074 7279  ########.    try
-00010b10: 3a0a 2020 2020 2020 2020 666f 7220 6920  :.        for i 
-00010b20: 696e 2072 616e 6765 2830 2c74 7261 696e  in range(0,train
-00010b30: 5f70 2e73 6861 7065 5b31 5d2c 6974 6572  _p.shape[1],iter
-00010b40: 5f6c 696d 6974 293a 0a20 2020 2020 2020  _limit):.       
-00010b50: 2020 2020 2073 7461 7274 5f74 696d 6532       start_time2
-00010b60: 203d 2074 696d 652e 7469 6d65 2829 0a20   = time.time(). 
-00010b70: 2020 2020 2020 2020 2020 2069 6d70 5f66             imp_f
-00010b80: 6561 7473 203d 205b 5d0a 2020 2020 2020  eats = [].      
-00010b90: 2020 2020 2020 6966 2074 7261 696e 5f70        if train_p
-00010ba0: 2e73 6861 7065 5b31 5d2d 6920 3c20 6974  .shape[1]-i < it
-00010bb0: 6572 5f6c 696d 6974 3a0a 2020 2020 2020  er_limit:.      
-00010bc0: 2020 2020 2020 2020 2020 585f 7472 6169            X_trai
-00010bd0: 6e20 3d20 7472 6169 6e5f 702e 696c 6f63  n = train_p.iloc
-00010be0: 5b3a 2c69 3a5d 0a20 2020 2020 2020 2020  [:,i:].         
-00010bf0: 2020 2020 2020 2063 6f6c 735f 7365 6c20         cols_sel 
-00010c00: 3d20 585f 7472 6169 6e2e 636f 6c75 6d6e  = X_train.column
-00010c10: 732e 746f 6c69 7374 2829 0a20 2020 2020  s.tolist().     
-00010c20: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
-00010c30: 2020 2020 2020 2020 2020 2020 2058 5f74               X_t
-00010c40: 7261 696e 203d 2074 7261 696e 5f70 5b6c  rain = train_p[l
-00010c50: 6973 7428 7472 6169 6e5f 702e 636f 6c75  ist(train_p.colu
-00010c60: 6d6e 732e 7661 6c75 6573 295b 693a 7472  mns.values)[i:tr
-00010c70: 6169 6e5f 702e 7368 6170 655b 315d 5d5d  ain_p.shape[1]]]
-00010c80: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00010c90: 2063 6f6c 735f 7365 6c20 3d20 585f 7472   cols_sel = X_tr
-00010ca0: 6169 6e2e 636f 6c75 6d6e 732e 746f 6c69  ain.columns.toli
-00010cb0: 7374 2829 0a20 2020 2020 2020 2020 2020  st().           
-00010cc0: 2023 2323 2323 2054 6869 7320 6973 2077   ##### This is w
-00010cd0: 6865 7265 2079 6f75 2072 6570 6561 7420  here you repeat 
-00010ce0: 7468 6520 7472 6169 6e69 6e67 2061 6e64  the training and
-00010cf0: 2066 696e 6469 6e67 2066 6561 7475 7265   finding feature
-00010d00: 2069 6d70 6f72 7461 6e63 6573 0a20 2020   importances.   
-00010d10: 2020 2020 2020 2020 2069 6620 6461 736b           if dask
-00010d20: 5f78 6762 6f6f 7374 5f66 6c61 673a 0a20  _xgboost_flag:. 
-00010d30: 2020 2020 2020 2020 2020 2020 2020 2072                 r
-00010d40: 6f77 7320 3d20 585f 7472 6169 6e2e 636f  ows = X_train.co
-00010d50: 6d70 7574 6528 292e 7368 6170 655b 305d  mpute().shape[0]
-00010d60: 0a20 2020 2020 2020 2020 2020 2065 6c73  .            els
-00010d70: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
-00010d80: 2020 2072 6f77 7320 3d20 585f 7472 6169     rows = X_trai
-00010d90: 6e2e 7368 6170 655b 305d 0a20 2020 2020  n.shape[0].     
-00010da0: 2020 2020 2020 2069 6620 726f 7773 203e         if rows >
-00010db0: 3d20 3130 3030 3030 3a0a 2020 2020 2020  = 100000:.      
-00010dc0: 2020 2020 2020 2020 2020 6e75 6d5f 726f            num_ro
-00010dd0: 756e 6473 203d 2032 300a 2020 2020 2020  unds = 20.      
-00010de0: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
-00010df0: 2020 2020 2020 2020 2020 2020 6e75 6d5f              num_
-00010e00: 726f 756e 6473 203d 2031 3030 0a20 2020  rounds = 100.   
-00010e10: 2020 2020 2020 2020 2069 6620 6920 3d3d           if i ==
-00010e20: 2030 3a0a 2020 2020 2020 2020 2020 2020   0:.            
-00010e30: 2020 2020 7072 696e 7428 274e 756d 6265      print('Numbe
-00010e40: 7220 6f66 2062 6f6f 7374 6572 2072 6f75  r of booster rou
-00010e50: 6e64 7320 3d20 2573 2720 256e 756d 5f72  nds = %s' %num_r
-00010e60: 6f75 6e64 7329 0a20 2020 2020 2020 2020  ounds).         
-00010e70: 2020 2069 6620 7472 6169 6e5f 702e 7368     if train_p.sh
-00010e80: 6170 655b 315d 2d69 203c 2032 3a0a 2020  ape[1]-i < 2:.  
-00010e90: 2020 2020 2020 2020 2020 2020 2020 2323                ##
-00010ea0: 2320 4966 2074 6865 7265 2069 7320 6a75  # If there is ju
-00010eb0: 7374 206f 6e65 2076 6172 6961 626c 6520  st one variable 
-00010ec0: 6c65 6674 2c20 7468 656e 206a 7573 7420  left, then just 
-00010ed0: 736b 6970 2069 7420 2323 2323 230a 2020  skip it #####.  
-00010ee0: 2020 2020 2020 2020 2020 2020 2020 636f                co
-00010ef0: 6e74 696e 7565 0a20 2020 2020 2020 2020  ntinue.         
-00010f00: 2020 2023 2323 2323 2323 2323 2020 2054     #########   T
-00010f10: 6869 7320 6973 2077 6865 7265 2077 6520  his is where we 
-00010f20: 6368 6563 6b20 7461 7267 6574 2074 7970  check target typ
-00010f30: 6520 2323 2323 2323 2323 2323 0a20 2020  e ##########.   
-00010f40: 2020 2020 2020 2020 2069 6620 6e6f 7420           if not 
-00010f50: 795f 7472 6169 6e2e 6474 7970 6573 5b30  y_train.dtypes[0
-00010f60: 5d20 696e 205b 6e70 2e66 6c6f 6174 3136  ] in [np.float16
-00010f70: 2c20 6e70 2e66 6c6f 6174 3332 2c20 6e70  , np.float32, np
-00010f80: 2e66 6c6f 6174 3634 2c20 6e70 2e69 6e74  .float64, np.int
-00010f90: 382c 6e70 2e69 6e74 3136 2c6e 702e 696e  8,np.int16,np.in
-00010fa0: 7433 322c 6e70 2e69 6e74 3634 5d3a 0a20  t32,np.int64]:. 
-00010fb0: 2020 2020 2020 2020 2020 2020 2020 2079                 y
-00010fc0: 5f74 7261 696e 203d 2079 5f74 7261 696e  _train = y_train
-00010fd0: 2e61 7374 7970 6528 696e 7429 200a 2020  .astype(int) .  
-00010fe0: 2020 2020 2020 2020 2020 6966 2073 6574            if set
-00010ff0: 7469 6e67 732e 6d6f 6465 6c74 7970 6520  tings.modeltype 
-00011000: 3d3d 2027 5265 6772 6573 7369 6f6e 273a  == 'Regression':
-00011010: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00011020: 206f 626a 6563 7469 7665 203d 2027 7265   objective = 're
-00011030: 673a 7371 7561 7265 6465 7272 6f72 270a  g:squarederror'.
-00011040: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011050: 7061 7261 6d73 203d 207b 276f 626a 6563  params = {'objec
-00011060: 7469 7665 273a 206f 626a 6563 7469 7665  tive': objective
-00011070: 2c20 0a20 2020 2020 2020 2020 2020 2020  , .             
+0000fc30: 2323 2323 2323 2323 2323 2323 2729 0a20  ############'). 
+0000fc40: 2020 2020 2020 200a 2020 2020 2020 2020         .        
+0000fc50: 696d 706f 7274 616e 745f 6665 6174 7572  important_featur
+0000fc60: 6573 203d 205b 5d0a 2020 2020 2020 2020  es = [].        
+0000fc70: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000fc80: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000fc90: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000fca0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000fcb0: 2323 2323 2323 230a 2020 2020 2020 2020  #######.        
+0000fcc0: 2323 2323 2320 2020 5468 6973 2069 7320  #####   This is 
+0000fcd0: 666f 7220 4441 534b 2058 4742 2052 6567  for DASK XGB Reg
+0000fce0: 7265 7373 6f72 2061 6e64 2058 4742 2043  ressor and XGB C
+0000fcf0: 6c61 7373 6966 6965 7220 7072 6f62 6c65  lassifier proble
+0000fd00: 6d73 2023 2323 230a 2020 2020 2020 2020  ms ####.        
+0000fd10: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000fd20: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000fd30: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000fd40: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000fd50: 2323 2323 2323 230a 2020 2020 2020 2020  #######.        
+0000fd60: 6966 2073 6574 7469 6e67 732e 6d75 6c74  if settings.mult
+0000fd70: 695f 6c61 6265 6c3a 0a20 2020 2020 2020  i_label:.       
+0000fd80: 2020 2020 2023 2323 206f 6e6c 7920 7265       ### only re
+0000fd90: 6775 6c61 7220 7867 626f 6f73 7420 7769  gular xgboost wi
+0000fda0: 7468 206d 756c 7469 2d6f 7574 7075 7420  th multi-output 
+0000fdb0: 6361 6e20 776f 726b 2077 656c 6c20 696e  can work well in
+0000fdc0: 206d 756c 7469 2d6c 6162 656c 2073 6574   multi-label set
+0000fdd0: 7469 6e67 7320 230a 2020 2020 2020 2020  tings #.        
+0000fde0: 2020 2020 6461 736b 5f78 6762 6f6f 7374      dask_xgboost
+0000fdf0: 5f66 6c61 6720 3d20 4661 6c73 6520 0a20  _flag = False . 
+0000fe00: 2020 2020 2020 2062 7374 5f6d 6f64 656c         bst_model
+0000fe10: 7320 3d20 5b5d 0a0a 2020 2020 2020 2020  s = []..        
+0000fe20: 2323 2323 2323 2323 2320 2020 5468 6973  #########   This
+0000fe30: 2069 7320 666f 7220 4441 534b 2044 6174   is for DASK Dat
+0000fe40: 6166 7261 6d65 7320 5847 426f 6f73 7420  aframes XGBoost 
+0000fe50: 7472 6169 6e69 6e67 2023 2323 2323 2323  training #######
+0000fe60: 2323 2323 2323 2323 2323 2323 230a 2020  #############.  
+0000fe70: 2020 2020 2020 7472 793a 0a20 2020 2020        try:.     
+0000fe80: 2020 2020 2020 2078 6762 2e73 6574 5f63         xgb.set_c
+0000fe90: 6f6e 6669 6728 7665 7262 6f73 6974 793d  onfig(verbosity=
+0000fea0: 3029 0a20 2020 2020 2020 2065 7863 6570  0).        excep
+0000feb0: 743a 0a20 2020 2020 2020 2020 2020 2023  t:.            #
+0000fec0: 2320 536f 6d65 2063 6173 6573 2c20 7468  # Some cases, th
+0000fed0: 6973 2065 7272 6f72 732c 2073 6f20 7061  is errors, so pa
+0000fee0: 7373 2023 2323 0a20 2020 2020 2020 2020  ss ###.         
+0000fef0: 2020 2070 6173 730a 2020 2020 2020 2020     pass.        
+0000ff00: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000ff10: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000ff20: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000ff30: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000ff40: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000ff50: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000ff60: 230a 2020 2020 2020 2020 2323 2323 2323  #.        ######
+0000ff70: 2323 2020 204e 6f77 2069 6620 6461 736b  ##   Now if dask
+0000ff80: 5f78 6762 6f6f 7374 5f66 6c61 6720 6973  _xgboost_flag is
+0000ff90: 2054 7275 652c 2063 6f6e 7665 7274 2070   True, convert p
+0000ffa0: 616e 6461 7320 6466 7320 6261 636b 2074  andas dfs back t
+0000ffb0: 6f20 4461 736b 2044 6174 6166 7261 6d65  o Dask Dataframe
+0000ffc0: 7320 2020 2020 2323 2323 230a 2020 2020  s     #####.    
+0000ffd0: 2020 2020 2323 2323 2323 2323 2323 2323      ############
+0000ffe0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0000fff0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00010000: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00010010: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00010020: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00010030: 2323 2323 230a 2020 2020 2020 2020 6966  #####.        if
+00010040: 2064 6173 6b5f 7867 626f 6f73 745f 666c   dask_xgboost_fl
+00010050: 6167 3a0a 2020 2020 2020 2020 2020 2020  ag:.            
+00010060: 2323 2320 7765 2072 656c 6f61 6420 7468  ### we reload th
+00010070: 6520 6461 7461 6672 616d 6573 2069 6e74  e dataframes int
+00010080: 6f20 6461 736b 2073 696e 6365 2063 6f6c  o dask since col
+00010090: 756d 6e73 206d 6179 2068 6176 6520 6265  umns may have be
+000100a0: 656e 2064 726f 7070 6564 2023 230a 2020  en dropped ##.  
+000100b0: 2020 2020 2020 2020 2020 6966 2076 6572            if ver
+000100c0: 626f 7365 3a0a 2020 2020 2020 2020 2020  bose:.          
+000100d0: 2020 2020 2020 7072 696e 7428 2720 2020        print('   
+000100e0: 2075 7369 6e67 2044 4153 4b20 5847 426f   using DASK XGBo
+000100f0: 6f73 7427 2920 200a 2020 2020 2020 2020  ost')  .        
+00010100: 2020 2020 7472 6169 6e20 3d20 6c6f 6164      train = load
+00010110: 5f64 6173 6b5f 6461 7461 2864 6174 616e  _dask_data(datan
+00010120: 616d 652c 2073 6570 290a 2020 2020 2020  ame, sep).      
+00010130: 2020 2020 2020 6966 206e 6f74 2074 6573        if not tes
+00010140: 745f 6461 7461 2069 7320 4e6f 6e65 3a0a  t_data is None:.
+00010150: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010160: 7465 7374 203d 206c 6f61 645f 6461 736b  test = load_dask
+00010170: 5f64 6174 6128 7465 7374 5f64 6174 612c  _data(test_data,
+00010180: 2073 6570 290a 2020 2020 2020 2020 656c   sep).        el
+00010190: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+000101a0: 2323 2320 7765 2072 656c 6f61 6420 7468  ### we reload th
+000101b0: 6520 6461 7461 6672 616d 6573 2069 6e74  e dataframes int
+000101c0: 6f20 6461 736b 2073 696e 6365 2063 6f6c  o dask since col
+000101d0: 756d 6e73 206d 6179 2068 6176 6520 6265  umns may have be
+000101e0: 656e 2064 726f 7070 6564 2023 230a 2020  en dropped ##.  
+000101f0: 2020 2020 2020 2020 2020 6966 2076 6572            if ver
+00010200: 626f 7365 3a0a 2020 2020 2020 2020 2020  bose:.          
+00010210: 2020 2020 2020 7072 696e 7428 2720 2020        print('   
+00010220: 2075 7369 6e67 2072 6567 756c 6172 2058   using regular X
+00010230: 4742 6f6f 7374 2729 200a 2020 2020 2020  GBoost') .      
+00010240: 2020 2020 2020 7472 6169 6e20 3d20 636f        train = co
+00010250: 7079 2e64 6565 7063 6f70 7928 6461 7461  py.deepcopy(data
+00010260: 6e61 6d65 290a 2020 2020 2020 2020 2020  name).          
+00010270: 2020 7465 7374 203d 2063 6f70 792e 6465    test = copy.de
+00010280: 6570 636f 7079 2874 6573 745f 6461 7461  epcopy(test_data
+00010290: 290a 2020 2020 2020 2020 2323 2323 2323  ).        ######
+000102a0: 2323 2020 436f 6e76 6572 7369 6f6e 2063  ##  Conversion c
+000102b0: 6f6d 706c 6574 6564 2066 6f72 2074 7261  ompleted for tra
+000102c0: 696e 2061 6e64 2074 6573 7420 6461 7461  in and test data
+000102d0: 2023 2323 2323 2323 2323 230a 2020 2020   ##########.    
+000102e0: 2020 2020 2323 2323 2049 6620 4361 7465      #### If Cate
+000102f0: 676f 7279 2045 6e63 6f64 696e 6720 746f  gory Encoding to
+00010300: 6f6b 2070 6c61 6365 2c20 7468 6573 6520  ok place, these 
+00010310: 6361 7420 7661 7269 6162 6c65 7320 6172  cat variables ar
+00010320: 6520 6e6f 206c 6f6e 6765 7220 6e65 6564  e no longer need
+00010330: 6564 2069 6e20 5472 6169 6e2e 2053 6f20  ed in Train. So 
+00010340: 7265 6d6f 7665 2074 6865 6d21 0a20 2020  remove them!.   
+00010350: 2020 2020 2069 6620 6665 6174 7572 655f       if feature_
+00010360: 6765 6e20 6f72 2066 6561 7475 7265 5f74  gen or feature_t
+00010370: 7970 653a 0a20 2020 2020 2020 2020 2020  ype:.           
+00010380: 2070 7269 6e74 2827 5369 6e63 6520 2573   print('Since %s
+00010390: 2063 6174 6567 6f72 7920 656e 636f 6469   category encodi
+000103a0: 6e67 2069 7320 646f 6e65 2c20 6472 6f70  ng is done, drop
+000103b0: 7069 6e67 206f 7269 6769 6e61 6c20 6361  ping original ca
+000103c0: 7465 676f 7269 6361 6c20 7661 7273 2066  tegorical vars f
+000103d0: 726f 6d20 7072 6564 6963 746f 7273 2e2e  rom predictors..
+000103e0: 2e27 2025 6665 6174 7572 655f 6765 6e29  .' %feature_gen)
+000103f0: 0a20 2020 2020 2020 2020 2020 2070 7265  .            pre
+00010400: 6473 203d 206c 6566 745f 7375 6274 7261  ds = left_subtra
+00010410: 6374 2870 7265 6473 2c20 6361 7476 6172  ct(preds, catvar
+00010420: 7329 0a20 2020 2020 2020 2069 6620 6461  s).        if da
+00010430: 736b 5f78 6762 6f6f 7374 5f66 6c61 673a  sk_xgboost_flag:
+00010440: 0a20 2020 2020 2020 2020 2020 2074 7261  .            tra
+00010450: 696e 5f70 203d 2074 7261 696e 5b70 7265  in_p = train[pre
+00010460: 6473 5d0a 2020 2020 2020 2020 656c 7365  ds].        else
+00010470: 3a0a 2020 2020 2020 2020 2020 2020 7472  :.            tr
+00010480: 6169 6e5f 7020 3d20 6461 7461 6e61 6d65  ain_p = dataname
+00010490: 5b70 7265 6473 5d0a 2020 2020 2020 2020  [preds].        
+000104a0: 2323 2323 2323 2323 204c 696d 6974 2074  ######## Limit t
+000104b0: 6865 206e 756d 6265 7220 6f66 2069 7465  he number of ite
+000104c0: 7261 7469 6f6e 7320 746f 2035 206f 7220  rations to 5 or 
+000104d0: 736f 2023 2323 2323 2323 0a20 2020 2020  so #######.     
+000104e0: 2020 2069 6620 7472 6169 6e5f 702e 7368     if train_p.sh
+000104f0: 6170 655b 315d 203c 3d20 3130 3a0a 2020  ape[1] <= 10:.  
+00010500: 2020 2020 2020 2020 2020 6974 6572 5f6c            iter_l
+00010510: 696d 6974 203d 2032 0a20 2020 2020 2020  imit = 2.       
+00010520: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+00010530: 2020 2069 7465 725f 6c69 6d69 7420 3d20     iter_limit = 
+00010540: 696e 7428 7472 6169 6e5f 702e 7368 6170  int(train_p.shap
+00010550: 655b 315d 2f35 2b30 2e35 290a 2020 2020  e[1]/5+0.5).    
+00010560: 2020 2020 6966 2076 6572 626f 7365 3a0a      if verbose:.
+00010570: 2020 2020 2020 2020 2020 2020 7072 696e              prin
+00010580: 7428 2720 2020 2054 616b 696e 6720 746f  t('    Taking to
+00010590: 7020 2573 2066 6561 7475 7265 7320 7065  p %s features pe
+000105a0: 7220 6974 6572 6174 696f 6e2e 2e2e 2720  r iteration...' 
+000105b0: 2574 6f70 5f6e 756d 290a 2020 2020 2020  %top_num).      
+000105c0: 2020 6966 2064 6173 6b5f 7867 626f 6f73    if dask_xgboos
+000105d0: 745f 666c 6167 3a0a 2020 2020 2020 2020  t_flag:.        
+000105e0: 2020 2020 6966 2076 6572 626f 7365 3a0a      if verbose:.
+000105f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010600: 7072 696e 7428 2720 2020 2044 6173 6b20  print('    Dask 
+00010610: 7665 7273 696f 6e20 3d20 2573 2720 2564  version = %s' %d
+00010620: 6173 6b2e 5f5f 7665 7273 696f 6e5f 5f29  ask.__version__)
+00010630: 0a20 2020 2020 2020 2020 2020 2023 2323  .            ###
+00010640: 2059 6f75 2063 616e 2072 656d 6f76 6520   You can remove 
+00010650: 6461 736b 5f6d 6c20 6865 7265 2073 696e  dask_ml here sin
+00010660: 6365 2079 6f75 2064 6f6e 2774 2064 6f20  ce you don't do 
+00010670: 616e 7920 7370 6c69 7420 6f66 2074 7261  any split of tra
+00010680: 696e 2074 6573 7420 6865 7265 2023 2323  in test here ###
+00010690: 2323 2323 2323 230a 2020 2020 2020 2020  #######.        
+000106a0: 2020 2020 2366 726f 6d20 6461 736b 5f6d      #from dask_m
+000106b0: 6c2e 6d6f 6465 6c5f 7365 6c65 6374 696f  l.model_selectio
+000106c0: 6e20 696d 706f 7274 2074 7261 696e 5f74  n import train_t
+000106d0: 6573 745f 7370 6c69 740a 2020 2020 2020  est_split.      
+000106e0: 2020 2020 2020 2323 2320 6368 6563 6b20        ### check 
+000106f0: 6176 6169 6c61 626c 6520 6d65 6d6f 7279  available memory
+00010700: 2061 6e64 2061 6c6c 6f63 6174 6520 6174   and allocate at
+00010710: 206c 6561 7374 2031 4742 206f 6620 6974   least 1GB of it
+00010720: 2069 6e20 7468 6520 436c 6965 6e74 2069   in the Client i
+00010730: 6e20 4441 534b 2023 2323 2323 2323 2323  n DASK #########
+00010740: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00010750: 2323 2323 0a20 2020 2020 2020 2020 2020  ####.           
+00010760: 206e 5f77 6f72 6b65 7273 203d 2067 6574   n_workers = get
+00010770: 5f63 7075 5f77 6f72 6b65 725f 636f 756e  _cpu_worker_coun
+00010780: 7428 290a 2020 2020 2020 2020 2020 2020  t().            
+00010790: 2323 2320 4176 6f69 6420 7265 6475 6369  ### Avoid reduci
+000107a0: 6e67 2074 6865 2066 7265 6520 6d65 6d6f  ng the free memo
+000107b0: 7279 202d 206c 6561 7665 2069 7420 6173  ry - leave it as
+000107c0: 2062 6967 2061 7320 6974 2077 616e 7473   big as it wants
+000107d0: 2074 6f20 6265 2023 2323 0a20 2020 2020   to be ###.     
+000107e0: 2020 2020 2020 206d 656d 6f72 795f 6672         memory_fr
+000107f0: 6565 203d 2073 7472 286d 6178 2831 2c20  ee = str(max(1, 
+00010800: 696e 7428 7073 7574 696c 2e76 6972 7475  int(psutil.virtu
+00010810: 616c 5f6d 656d 6f72 7928 295b 305d 2f28  al_memory()[0]/(
+00010820: 6e5f 776f 726b 6572 732a 3165 3929 2929  n_workers*1e9)))
+00010830: 292b 2747 4227 0a20 2020 2020 2020 2020  )+'GB'.         
+00010840: 2020 2070 7269 6e74 2827 2020 2020 5573     print('    Us
+00010850: 696e 6720 4461 736b 2058 4742 6f6f 7374  ing Dask XGBoost
+00010860: 2061 6c67 6f72 6974 686d 2077 6974 6820   algorithm with 
+00010870: 2573 2076 6972 7475 616c 2043 5055 7320  %s virtual CPUs 
+00010880: 616e 6420 2573 206d 656d 6f72 7920 6c69  and %s memory li
+00010890: 6d69 742e 2e2e 2720 2528 6765 745f 6370  mit...' %(get_cp
+000108a0: 755f 776f 726b 6572 5f63 6f75 6e74 2829  u_worker_count()
+000108b0: 2c20 6d65 6d6f 7279 5f66 7265 6529 290a  , memory_free)).
+000108c0: 2020 2020 2020 2020 2020 2020 636c 6965              clie
+000108d0: 6e74 203d 2043 6c69 656e 7428 6e5f 776f  nt = Client(n_wo
+000108e0: 726b 6572 733d 206e 5f77 6f72 6b65 7273  rkers= n_workers
+000108f0: 2c20 7468 7265 6164 735f 7065 725f 776f  , threads_per_wo
+00010900: 726b 6572 3d31 2c20 7072 6f63 6573 7365  rker=1, processe
+00010910: 733d 5472 7565 2c20 7369 6c65 6e63 655f  s=True, silence_
+00010920: 6c6f 6773 3d35 302c 0a20 2020 2020 2020  logs=50,.       
+00010930: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010940: 2020 2020 206d 656d 6f72 795f 6c69 6d69       memory_limi
+00010950: 743d 6d65 6d6f 7279 5f66 7265 6529 0a20  t=memory_free). 
+00010960: 2020 2020 2020 2020 2020 2070 7269 6e74             print
+00010970: 2827 4461 736b 2063 6c69 656e 7420 636f  ('Dask client co
+00010980: 6e66 6967 7572 6174 696f 6e3a 2025 7327  nfiguration: %s'
+00010990: 2025 636c 6965 6e74 290a 2020 2020 2020   %client).      
+000109a0: 2020 2020 2020 696d 706f 7274 2067 630a        import gc.
+000109b0: 2020 2020 2020 2020 2020 2020 636c 6965              clie
+000109c0: 6e74 2e72 756e 2867 632e 636f 6c6c 6563  nt.run(gc.collec
+000109d0: 7429 200a 2020 2020 2020 2020 2020 2020  t) .            
+000109e0: 2374 7261 696e 5f70 203d 2063 6c69 656e  #train_p = clien
+000109f0: 742e 7065 7273 6973 7428 7472 6169 6e5f  t.persist(train_
+00010a00: 7029 0a20 2020 2020 2020 2069 6620 7665  p).        if ve
+00010a10: 7262 6f73 653a 0a20 2020 2020 2020 2020  rbose:.         
+00010a20: 2020 2070 7269 6e74 2827 2020 2020 5847     print('    XG
+00010a30: 426f 6f73 7420 7665 7273 696f 6e20 7573  Boost version us
+00010a40: 696e 6720 2573 2061 7320 7472 6565 206d  ing %s as tree m
+00010a50: 6574 686f 643a 2025 7327 2025 2878 6762  ethod: %s' %(xgb
+00010a60: 2e5f 5f76 6572 7369 6f6e 5f5f 2c20 7472  .__version__, tr
+00010a70: 6565 5f6d 6574 686f 6429 290a 2020 2020  ee_method)).    
+00010a80: 2020 2020 2323 2320 5468 6973 2069 7320      ### This is 
+00010a90: 746f 2063 6f6e 7665 7274 2074 6865 2074  to convert the t
+00010aa0: 6172 6765 7420 6c61 6265 6c73 2074 6f20  arget labels to 
+00010ab0: 7072 6f70 6572 206e 756d 6572 6963 2063  proper numeric c
+00010ac0: 6f6c 756d 6e73 2023 2323 2323 230a 2020  olumns ######.  
+00010ad0: 2020 2020 2020 6361 745f 7461 7267 6574        cat_target
+00010ae0: 7320 3d20 6461 7461 6e61 6d65 5b74 6172  s = dataname[tar
+00010af0: 6765 745d 2e73 656c 6563 745f 6474 7970  get].select_dtyp
+00010b00: 6573 2869 6e63 6c75 6465 3d27 6f62 6a65  es(include='obje
+00010b10: 6374 2729 2e63 6f6c 756d 6e73 2e74 6f6c  ct').columns.tol
+00010b20: 6973 7428 2920 2b20 6461 7461 6e61 6d65  ist() + dataname
+00010b30: 5b74 6172 6765 745d 2e73 656c 6563 745f  [target].select_
+00010b40: 6474 7970 6573 2869 6e63 6c75 6465 3d27  dtypes(include='
+00010b50: 6361 7465 676f 7279 2729 2e63 6f6c 756d  category').colum
+00010b60: 6e73 2e74 6f6c 6973 7428 290a 2020 2020  ns.tolist().    
+00010b70: 2020 2020 2323 2320 6368 6563 6b20 6966      ### check if
+00010b80: 2074 6865 7920 6172 6520 6e6f 7420 7374   they are not st
+00010b90: 6172 7469 6e67 2066 726f 6d20 7a65 726f  arting from zero
+00010ba0: 2023 2323 2323 2323 2323 2323 2323 2323   ###############
+00010bb0: 2323 230a 2020 2020 2020 2020 6966 2064  ###.        if d
+00010bc0: 6173 6b5f 7867 626f 6f73 745f 666c 6167  ask_xgboost_flag
+00010bd0: 3a0a 2020 2020 2020 2020 2020 2020 2323  :.            ##
+00010be0: 2320 7472 6169 6e20 6973 2061 6c72 6561  # train is alrea
+00010bf0: 6479 2061 2064 6173 6b20 6461 7461 6672  dy a dask datafr
+00010c00: 616d 6520 2d3e 2079 6f75 2063 616e 206c  ame -> you can l
+00010c10: 6561 7665 2069 7420 6173 2069 7420 6973  eave it as it is
+00010c20: 0a20 2020 2020 2020 2020 2020 2079 5f74  .            y_t
+00010c30: 7261 696e 203d 2074 7261 696e 5b74 6172  rain = train[tar
+00010c40: 6765 745d 0a20 2020 2020 2020 2065 6c73  get].        els
+00010c50: 653a 0a20 2020 2020 2020 2020 2020 2023  e:.            #
+00010c60: 2323 2074 7261 696e 2069 7320 616c 7265  ## train is alre
+00010c70: 6164 7920 6120 7265 6775 6c61 7220 6461  ady a regular da
+00010c80: 7461 6672 616d 6520 2d3e 2079 6f75 2063  taframe -> you c
+00010c90: 616e 206c 6561 7665 2069 7420 6173 2069  an leave it as i
+00010ca0: 7420 6973 0a20 2020 2020 2020 2020 2020  t is.           
+00010cb0: 2079 5f74 7261 696e 203d 2064 6174 616e   y_train = datan
+00010cc0: 616d 655b 7461 7267 6574 5d0a 2020 2020  ame[target].    
+00010cd0: 2020 2020 2323 2323 204e 6f77 2077 6520      #### Now we 
+00010ce0: 7072 6f63 6573 7320 7468 6520 6e75 6d65  process the nume
+00010cf0: 7269 6320 2076 616c 7565 7320 7468 726f  ric  values thro
+00010d00: 7567 6820 4441 534b 2058 4742 6f6f 7374  ugh DASK XGBoost
+00010d10: 2072 6570 6561 7465 646c 7920 2323 2323   repeatedly ####
+00010d20: 2323 2323 2323 2323 2323 2323 2323 230a  ###############.
+00010d30: 2020 2020 2020 2020 7472 793a 0a20 2020          try:.   
+00010d40: 2020 2020 2020 2020 2066 6f72 2069 2069           for i i
+00010d50: 6e20 7261 6e67 6528 302c 7472 6169 6e5f  n range(0,train_
+00010d60: 702e 7368 6170 655b 315d 2c69 7465 725f  p.shape[1],iter_
+00010d70: 6c69 6d69 7429 3a0a 2020 2020 2020 2020  limit):.        
+00010d80: 2020 2020 2020 2020 7374 6172 745f 7469          start_ti
+00010d90: 6d65 3220 3d20 7469 6d65 2e74 696d 6528  me2 = time.time(
+00010da0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+00010db0: 2020 696d 705f 6665 6174 7320 3d20 5b5d    imp_feats = []
+00010dc0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00010dd0: 2069 6620 7472 6169 6e5f 702e 7368 6170   if train_p.shap
+00010de0: 655b 315d 2d69 203c 2069 7465 725f 6c69  e[1]-i < iter_li
+00010df0: 6d69 743a 0a20 2020 2020 2020 2020 2020  mit:.           
+00010e00: 2020 2020 2020 2020 2058 5f74 7261 696e           X_train
+00010e10: 203d 2074 7261 696e 5f70 2e69 6c6f 635b   = train_p.iloc[
+00010e20: 3a2c 693a 5d0a 2020 2020 2020 2020 2020  :,i:].          
+00010e30: 2020 2020 2020 2020 2020 636f 6c73 5f73            cols_s
+00010e40: 656c 203d 2058 5f74 7261 696e 2e63 6f6c  el = X_train.col
+00010e50: 756d 6e73 2e74 6f6c 6973 7428 290a 2020  umns.tolist().  
+00010e60: 2020 2020 2020 2020 2020 2020 2020 656c                el
+00010e70: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+00010e80: 2020 2020 2020 2020 585f 7472 6169 6e20          X_train 
+00010e90: 3d20 7472 6169 6e5f 705b 6c69 7374 2874  = train_p[list(t
+00010ea0: 7261 696e 5f70 2e63 6f6c 756d 6e73 2e76  rain_p.columns.v
+00010eb0: 616c 7565 7329 5b69 3a74 7261 696e 5f70  alues)[i:train_p
+00010ec0: 2e73 6861 7065 5b31 5d5d 5d0a 2020 2020  .shape[1]]].    
+00010ed0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010ee0: 636f 6c73 5f73 656c 203d 2058 5f74 7261  cols_sel = X_tra
+00010ef0: 696e 2e63 6f6c 756d 6e73 2e74 6f6c 6973  in.columns.tolis
+00010f00: 7428 290a 2020 2020 2020 2020 2020 2020  t().            
+00010f10: 2020 2020 2323 2323 2320 5468 6973 2069      ##### This i
+00010f20: 7320 7768 6572 6520 796f 7520 7265 7065  s where you repe
+00010f30: 6174 2074 6865 2074 7261 696e 696e 6720  at the training 
+00010f40: 616e 6420 6669 6e64 696e 6720 6665 6174  and finding feat
+00010f50: 7572 6520 696d 706f 7274 616e 6365 730a  ure importances.
+00010f60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00010f70: 6966 2064 6173 6b5f 7867 626f 6f73 745f  if dask_xgboost_
+00010f80: 666c 6167 3a0a 2020 2020 2020 2020 2020  flag:.          
+00010f90: 2020 2020 2020 2020 2020 726f 7773 203d            rows =
+00010fa0: 2058 5f74 7261 696e 2e63 6f6d 7075 7465   X_train.compute
+00010fb0: 2829 2e73 6861 7065 5b30 5d0a 2020 2020  ().shape[0].    
+00010fc0: 2020 2020 2020 2020 2020 2020 656c 7365              else
+00010fd0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00010fe0: 2020 2020 2020 726f 7773 203d 2058 5f74        rows = X_t
+00010ff0: 7261 696e 2e73 6861 7065 5b30 5d0a 2020  rain.shape[0].  
+00011000: 2020 2020 2020 2020 2020 2020 2020 6966                if
+00011010: 2072 6f77 7320 3e3d 2031 3030 3030 303a   rows >= 100000:
+00011020: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00011030: 2020 2020 206e 756d 5f72 6f75 6e64 7320       num_rounds 
+00011040: 3d20 3230 0a20 2020 2020 2020 2020 2020  = 20.           
+00011050: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+00011060: 2020 2020 2020 2020 2020 2020 2020 206e                 n
+00011070: 756d 5f72 6f75 6e64 7320 3d20 3130 300a  um_rounds = 100.
 00011080: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011090: 2020 2020 2020 2273 696c 656e 7422 3a54        "silent":T
-000110a0: 7275 652c 2022 7665 7262 6f73 6974 7922  rue, "verbosity"
-000110b0: 3a20 302c 2027 6d69 6e5f 6368 696c 645f  : 0, 'min_child_
-000110c0: 7765 6967 6874 273a 2030 2e35 7d0a 2020  weight': 0.5}.  
-000110d0: 2020 2020 2020 2020 2020 656c 7365 3a0a            else:.
-000110e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000110f0: 2323 2323 2054 6869 7320 6973 2066 6f72  #### This is for
-00011100: 2043 6c61 7373 6966 6965 7273 206f 6e6c   Classifiers onl
-00011110: 7920 2323 2323 2323 2323 2323 2020 2020  y ##########    
-00011120: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011130: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00011140: 2069 6620 7365 7474 696e 6773 2e6d 6f64   if settings.mod
-00011150: 656c 7479 7065 203d 3d20 2742 696e 6172  eltype == 'Binar
-00011160: 795f 436c 6173 7369 6669 6361 7469 6f6e  y_Classification
-00011170: 273a 0a20 2020 2020 2020 2020 2020 2020  ':.             
-00011180: 2020 2020 2020 206f 626a 6563 7469 7665         objective
-00011190: 203d 2027 6269 6e61 7279 3a6c 6f67 6973   = 'binary:logis
-000111a0: 7469 6327 0a20 2020 2020 2020 2020 2020  tic'.           
-000111b0: 2020 2020 2020 2020 206e 756d 5f63 6c61           num_cla
-000111c0: 7373 203d 2031 0a20 2020 2020 2020 2020  ss = 1.         
-000111d0: 2020 2020 2020 2020 2020 2070 6172 616d             param
-000111e0: 7320 3d20 7b27 6f62 6a65 6374 6976 6527  s = {'objective'
-000111f0: 3a20 6f62 6a65 6374 6976 652c 2027 6e75  : objective, 'nu
-00011200: 6d5f 636c 6173 7327 3a20 6e75 6d5f 636c  m_class': num_cl
-00011210: 6173 732c 0a20 2020 2020 2020 2020 2020  ass,.           
-00011220: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011230: 2020 2020 2020 2020 2022 7369 6c65 6e74           "silent
-00011240: 223a 5472 7565 2c20 2022 7665 7262 6f73  ":True,  "verbos
-00011250: 6974 7922 3a20 302c 2020 276d 696e 5f63  ity": 0,  'min_c
-00011260: 6869 6c64 5f77 6569 6768 7427 3a20 302e  hild_weight': 0.
-00011270: 357d 0a20 2020 2020 2020 2020 2020 2020  5}.             
-00011280: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
-00011290: 2020 2020 2020 2020 2020 2020 206f 626a               obj
-000112a0: 6563 7469 7665 203d 2027 6d75 6c74 693a  ective = 'multi:
-000112b0: 736f 6674 6d61 7827 0a20 2020 2020 2020  softmax'.       
-000112c0: 2020 2020 2020 2020 2020 2020 206e 756d               num
-000112d0: 5f63 6c61 7373 2020 3d20 2064 6174 616e  _class  =  datan
-000112e0: 616d 655b 7461 7267 6574 5d2e 6e75 6e69  ame[target].nuni
-000112f0: 7175 6528 295b 305d 0a20 2020 2020 2020  que()[0].       
-00011300: 2020 2020 2020 2020 2020 2020 2070 6172               par
-00011310: 616d 7320 3d20 7b27 6f62 6a65 6374 6976  ams = {'objectiv
-00011320: 6527 3a20 6f62 6a65 6374 6976 652c 200a  e': objective, .
-00011330: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011340: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011350: 2020 2020 2273 696c 656e 7422 3a54 7275      "silent":Tru
-00011360: 652c 2022 7665 7262 6f73 6974 7922 3a20  e, "verbosity": 
-00011370: 302c 2020 2027 6d69 6e5f 6368 696c 645f  0,   'min_child_
-00011380: 7765 6967 6874 273a 2030 2e35 2c20 276e  weight': 0.5, 'n
-00011390: 756d 5f63 6c61 7373 273a 206e 756d 5f63  um_class': num_c
-000113a0: 6c61 7373 7d0a 2020 2020 2020 2020 2020  lass}.          
-000113b0: 2020 2323 2323 2323 2323 2323 2323 2323    ##############
-000113c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000113d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000113e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000113f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00011400: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00011410: 2323 2323 2323 2323 2323 2323 2323 0a20  ##############. 
-00011420: 2020 2020 2020 2020 2020 2023 2323 2323             #####
-00011430: 2323 2323 2054 6869 7320 6973 2077 6865  #### This is whe
-00011440: 7265 2077 6520 6669 6e64 206f 7574 2077  re we find out w
-00011450: 6865 7468 6572 2074 6f20 7573 6520 7369  hether to use si
-00011460: 6e67 6c65 206f 7220 6d75 6c74 692d 6c61  ngle or multi-la
-00011470: 6265 6c20 666f 7220 7867 626f 6f73 7420  bel for xgboost 
-00011480: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00011490: 2323 2323 2323 230a 2020 2020 2020 2020  #######.        
-000114a0: 2020 2020 2323 2323 2323 2323 2323 2323      ############
-000114b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000114c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000114d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000114e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000114f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00011500: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00011510: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-00011520: 7365 7474 696e 6773 2e6d 756c 7469 5f6c  settings.multi_l
-00011530: 6162 656c 3a0a 2020 2020 2020 2020 2020  abel:.          
-00011540: 2020 2020 2020 6966 2073 6574 7469 6e67        if setting
-00011550: 732e 6d6f 6465 6c74 7970 6520 3d3d 2027  s.modeltype == '
-00011560: 5265 6772 6573 7369 6f6e 273a 0a20 2020  Regression':.   
-00011570: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011580: 2063 6c66 203d 2058 4742 5265 6772 6573   clf = XGBRegres
-00011590: 736f 7228 6e5f 6a6f 6273 3d2d 312c 206e  sor(n_jobs=-1, n
-000115a0: 5f65 7374 696d 6174 6f72 733d 3130 302c  _estimators=100,
-000115b0: 206d 6178 5f64 6570 7468 3d34 2c20 7261   max_depth=4, ra
-000115c0: 6e64 6f6d 5f73 7461 7465 3d39 3929 0a20  ndom_state=99). 
-000115d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000115e0: 2020 2063 6c66 2e73 6574 5f70 6172 616d     clf.set_param
-000115f0: 7328 2a2a 7061 7261 6d73 290a 2020 2020  s(**params).    
+00011090: 6966 2069 203d 3d20 303a 0a20 2020 2020  if i == 0:.     
+000110a0: 2020 2020 2020 2020 2020 2020 2020 2070                 p
+000110b0: 7269 6e74 2827 2020 2020 4e75 6d62 6572  rint('    Number
+000110c0: 206f 6620 626f 6f73 7465 7220 726f 756e   of booster roun
+000110d0: 6473 203d 2025 7327 2025 6e75 6d5f 726f  ds = %s' %num_ro
+000110e0: 756e 6473 290a 2020 2020 2020 2020 2020  unds).          
+000110f0: 2020 2020 2020 6966 2074 7261 696e 5f70        if train_p
+00011100: 2e73 6861 7065 5b31 5d2d 6920 3c20 323a  .shape[1]-i < 2:
+00011110: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00011120: 2020 2020 2023 2323 2049 6620 7468 6572       ### If ther
+00011130: 6520 6973 206a 7573 7420 6f6e 6520 7661  e is just one va
+00011140: 7269 6162 6c65 206c 6566 742c 2074 6865  riable left, the
+00011150: 6e20 6a75 7374 2073 6b69 7020 6974 2023  n just skip it #
+00011160: 2323 2323 0a20 2020 2020 2020 2020 2020  ####.           
+00011170: 2020 2020 2020 2020 2063 6f6e 7469 6e75           continu
+00011180: 650a 2020 2020 2020 2020 2020 2020 2020  e.              
+00011190: 2020 2323 2323 2323 2323 2320 2020 5468    #########   Th
+000111a0: 6973 2069 7320 7768 6572 6520 7765 2063  is is where we c
+000111b0: 6865 636b 2074 6172 6765 7420 7479 7065  heck target type
+000111c0: 2023 2323 2323 2323 2323 230a 2020 2020   ##########.    
+000111d0: 2020 2020 2020 2020 2020 2020 6966 206e              if n
+000111e0: 6f74 2079 5f74 7261 696e 2e64 7479 7065  ot y_train.dtype
+000111f0: 735b 305d 2069 6e20 5b6e 702e 666c 6f61  s[0] in [np.floa
+00011200: 7431 362c 206e 702e 666c 6f61 7433 322c  t16, np.float32,
+00011210: 206e 702e 666c 6f61 7436 342c 206e 702e   np.float64, np.
+00011220: 696e 7438 2c6e 702e 696e 7431 362c 6e70  int8,np.int16,np
+00011230: 2e69 6e74 3332 2c6e 702e 696e 7436 345d  .int32,np.int64]
+00011240: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00011250: 2020 2020 2020 795f 7472 6169 6e20 3d20        y_train = 
+00011260: 795f 7472 6169 6e2e 6173 7479 7065 2869  y_train.astype(i
+00011270: 6e74 2920 0a20 2020 2020 2020 2020 2020  nt) .           
+00011280: 2020 2020 2069 6620 7365 7474 696e 6773       if settings
+00011290: 2e6d 6f64 656c 7479 7065 203d 3d20 2752  .modeltype == 'R
+000112a0: 6567 7265 7373 696f 6e27 3a0a 2020 2020  egression':.    
+000112b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000112c0: 6f62 6a65 6374 6976 6520 3d20 2772 6567  objective = 'reg
+000112d0: 3a73 7175 6172 6564 6572 726f 7227 0a20  :squarederror'. 
+000112e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000112f0: 2020 2070 6172 616d 7320 3d20 7b27 6f62     params = {'ob
+00011300: 6a65 6374 6976 6527 3a20 6f62 6a65 6374  jective': object
+00011310: 6976 652c 200a 2020 2020 2020 2020 2020  ive, .          
+00011320: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011330: 2020 2020 2020 2020 2020 2273 696c 656e            "silen
+00011340: 7422 3a54 7275 652c 2022 7665 7262 6f73  t":True, "verbos
+00011350: 6974 7922 3a20 302c 2027 6d69 6e5f 6368  ity": 0, 'min_ch
+00011360: 696c 645f 7765 6967 6874 273a 2030 2e35  ild_weight': 0.5
+00011370: 7d0a 2020 2020 2020 2020 2020 2020 2020  }.              
+00011380: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+00011390: 2020 2020 2020 2020 2020 2020 2323 2323              ####
+000113a0: 2054 6869 7320 6973 2066 6f72 2043 6c61   This is for Cla
+000113b0: 7373 6966 6965 7273 206f 6e6c 7920 2323  ssifiers only ##
+000113c0: 2323 2323 2323 2323 2020 2020 2020 2020  ########        
+000113d0: 2020 2020 2020 2020 2020 2020 0a20 2020              .   
+000113e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000113f0: 2069 6620 7365 7474 696e 6773 2e6d 6f64   if settings.mod
+00011400: 656c 7479 7065 203d 3d20 2742 696e 6172  eltype == 'Binar
+00011410: 795f 436c 6173 7369 6669 6361 7469 6f6e  y_Classification
+00011420: 273a 0a20 2020 2020 2020 2020 2020 2020  ':.             
+00011430: 2020 2020 2020 2020 2020 206f 626a 6563             objec
+00011440: 7469 7665 203d 2027 6269 6e61 7279 3a6c  tive = 'binary:l
+00011450: 6f67 6973 7469 6327 0a20 2020 2020 2020  ogistic'.       
+00011460: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011470: 206e 756d 5f63 6c61 7373 203d 2031 0a20   num_class = 1. 
+00011480: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011490: 2020 2020 2020 2070 6172 616d 7320 3d20         params = 
+000114a0: 7b27 6f62 6a65 6374 6976 6527 3a20 6f62  {'objective': ob
+000114b0: 6a65 6374 6976 652c 2027 6e75 6d5f 636c  jective, 'num_cl
+000114c0: 6173 7327 3a20 6e75 6d5f 636c 6173 732c  ass': num_class,
+000114d0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000114e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000114f0: 2020 2020 2020 2020 2022 7369 6c65 6e74           "silent
+00011500: 223a 5472 7565 2c20 2022 7665 7262 6f73  ":True,  "verbos
+00011510: 6974 7922 3a20 302c 2020 276d 696e 5f63  ity": 0,  'min_c
+00011520: 6869 6c64 5f77 6569 6768 7427 3a20 302e  hild_weight': 0.
+00011530: 357d 0a20 2020 2020 2020 2020 2020 2020  5}.             
+00011540: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
+00011550: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011560: 2020 2020 206f 626a 6563 7469 7665 203d       objective =
+00011570: 2027 6d75 6c74 693a 736f 6674 6d61 7827   'multi:softmax'
+00011580: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00011590: 2020 2020 2020 2020 206e 756d 5f63 6c61           num_cla
+000115a0: 7373 2020 3d20 2064 6174 616e 616d 655b  ss  =  dataname[
+000115b0: 7461 7267 6574 5d2e 6e75 6e69 7175 6528  target].nunique(
+000115c0: 295b 305d 0a20 2020 2020 2020 2020 2020  )[0].           
+000115d0: 2020 2020 2020 2020 2020 2020 2070 6172               par
+000115e0: 616d 7320 3d20 7b27 6f62 6a65 6374 6976  ams = {'objectiv
+000115f0: 6527 3a20 6f62 6a65 6374 6976 652c 200a  e': objective, .
 00011600: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011610: 6273 7420 3d20 4d75 6c74 694f 7574 7075  bst = MultiOutpu
-00011620: 7452 6567 7265 7373 6f72 2863 6c66 290a  tRegressor(clf).
-00011630: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011640: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
-00011650: 2020 2020 2020 2020 2020 636c 6620 3d20            clf = 
-00011660: 5847 4243 6c61 7373 6966 6965 7228 6e5f  XGBClassifier(n_
-00011670: 6a6f 6273 3d2d 312c 206e 5f65 7374 696d  jobs=-1, n_estim
-00011680: 6174 6f72 733d 3130 302c 206d 6178 5f64  ators=100, max_d
-00011690: 6570 7468 3d34 2c20 7261 6e64 6f6d 5f73  epth=4, random_s
-000116a0: 7461 7465 3d39 3929 0a20 2020 2020 2020  tate=99).       
-000116b0: 2020 2020 2020 2020 2020 2020 2063 6c66               clf
-000116c0: 2e73 6574 5f70 6172 616d 7328 2a2a 7061  .set_params(**pa
-000116d0: 7261 6d73 290a 2020 2020 2020 2020 2020  rams).          
-000116e0: 2020 2020 2020 2020 2020 6273 7420 3d20            bst = 
-000116f0: 4d75 6c74 694f 7574 7075 7443 6c61 7373  MultiOutputClass
-00011700: 6966 6965 7228 636c 6629 0a20 2020 2020  ifier(clf).     
-00011710: 2020 2020 2020 2020 2020 2062 7374 2e66             bst.f
-00011720: 6974 2858 5f74 7261 696e 2c20 795f 7472  it(X_train, y_tr
-00011730: 6169 6e29 0a20 2020 2020 2020 2020 2020  ain).           
-00011740: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
-00011750: 2020 2020 2020 2069 6620 6e6f 7420 6461         if not da
-00011760: 736b 5f78 6762 6f6f 7374 5f66 6c61 673a  sk_xgboost_flag:
-00011770: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00011780: 2020 2020 2023 2323 2323 2323 2323 2323       ###########
+00011610: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011620: 2020 2020 2020 2020 2273 696c 656e 7422          "silent"
+00011630: 3a54 7275 652c 2022 7665 7262 6f73 6974  :True, "verbosit
+00011640: 7922 3a20 302c 2020 2027 6d69 6e5f 6368  y": 0,   'min_ch
+00011650: 696c 645f 7765 6967 6874 273a 2030 2e35  ild_weight': 0.5
+00011660: 2c20 276e 756d 5f63 6c61 7373 273a 206e  , 'num_class': n
+00011670: 756d 5f63 6c61 7373 7d0a 2020 2020 2020  um_class}.      
+00011680: 2020 2020 2020 2020 2020 2323 2323 2323            ######
+00011690: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000116a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000116b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000116c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000116d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000116e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000116f0: 2323 2323 2323 0a20 2020 2020 2020 2020  ######.         
+00011700: 2020 2020 2020 2023 2323 2323 2323 2323         #########
+00011710: 2054 6869 7320 6973 2077 6865 7265 2077   This is where w
+00011720: 6520 6669 6e64 206f 7574 2077 6865 7468  e find out wheth
+00011730: 6572 2074 6f20 7573 6520 7369 6e67 6c65  er to use single
+00011740: 206f 7220 6d75 6c74 692d 6c61 6265 6c20   or multi-label 
+00011750: 666f 7220 7867 626f 6f73 7420 2323 2323  for xgboost ####
+00011760: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00011770: 2323 230a 2020 2020 2020 2020 2020 2020  ###.            
+00011780: 2020 2020 2323 2323 2323 2323 2323 2323      ############
 00011790: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 000117a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 000117b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 000117c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000117d0: 2323 2323 230a 2020 2020 2020 2020 2020  #####.          
-000117e0: 2020 2020 2020 2020 2020 2323 2323 2323            ######
-000117f0: 2323 2320 2054 7261 696e 696e 6720 5265  ###  Training Re
-00011800: 6775 6c61 7220 5847 426f 6f73 7420 6f6e  gular XGBoost on
-00011810: 2070 616e 6461 7320 6461 7461 6672 616d   pandas datafram
-00011820: 6573 206f 6e6c 7920 2323 2323 2323 2323  es only ########
-00011830: 2323 2323 2323 2323 2323 0a20 2020 2020  ##########.     
-00011840: 2020 2020 2020 2020 2020 2020 2020 2023                 #
-00011850: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00011860: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00011870: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00011880: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00011890: 2323 2323 2323 2323 2323 2323 2323 230a  ###############.
-000118a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000118b0: 2020 2020 2323 2323 206e 6f77 2074 6869      #### now thi
-000118c0: 7320 7472 6169 6e69 6e67 2076 6961 2062  s training via b
-000118d0: 7374 2077 6f72 6b73 2077 656c 6c20 666f  st works well fo
-000118e0: 7220 626f 7468 2078 6762 6f6f 7374 2030  r both xgboost 0
-000118f0: 2e30 2e39 3020 6173 2077 656c 6c20 6173  .0.90 as well as
-00011900: 2031 2e35 2e31 2023 230a 2020 2020 2020   1.5.1 ##.      
-00011910: 2020 2020 2020 2020 2020 2020 2020 0a20                . 
-00011920: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011930: 2020 2074 7279 3a0a 2020 2020 2020 2020     try:.        
+000117d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000117e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000117f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00011800: 2069 6620 7365 7474 696e 6773 2e6d 756c   if settings.mul
+00011810: 7469 5f6c 6162 656c 3a0a 2020 2020 2020  ti_label:.      
+00011820: 2020 2020 2020 2020 2020 2020 2020 6966                if
+00011830: 2073 6574 7469 6e67 732e 6d6f 6465 6c74   settings.modelt
+00011840: 7970 6520 3d3d 2027 5265 6772 6573 7369  ype == 'Regressi
+00011850: 6f6e 273a 0a20 2020 2020 2020 2020 2020  on':.           
+00011860: 2020 2020 2020 2020 2020 2020 2063 6c66               clf
+00011870: 203d 2058 4742 5265 6772 6573 736f 7228   = XGBRegressor(
+00011880: 6e5f 6a6f 6273 3d2d 312c 206e 5f65 7374  n_jobs=-1, n_est
+00011890: 696d 6174 6f72 733d 3130 302c 206d 6178  imators=100, max
+000118a0: 5f64 6570 7468 3d34 2c20 7261 6e64 6f6d  _depth=4, random
+000118b0: 5f73 7461 7465 3d39 3929 0a20 2020 2020  _state=99).     
+000118c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000118d0: 2020 2063 6c66 2e73 6574 5f70 6172 616d     clf.set_param
+000118e0: 7328 2a2a 7061 7261 6d73 290a 2020 2020  s(**params).    
+000118f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011900: 2020 2020 6273 7420 3d20 4d75 6c74 694f      bst = MultiO
+00011910: 7574 7075 7452 6567 7265 7373 6f72 2863  utputRegressor(c
+00011920: 6c66 290a 2020 2020 2020 2020 2020 2020  lf).            
+00011930: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
 00011940: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011950: 6474 7261 696e 203d 2078 6762 2e44 4d61  dtrain = xgb.DMa
-00011960: 7472 6978 2858 5f74 7261 696e 2c20 795f  trix(X_train, y_
-00011970: 7472 6169 6e2c 2065 6e61 626c 655f 6361  train, enable_ca
-00011980: 7465 676f 7269 6361 6c3d 5472 7565 2c20  tegorical=True, 
-00011990: 6665 6174 7572 655f 6e61 6d65 733d 636f  feature_names=co
-000119a0: 6c73 5f73 656c 290a 2020 2020 2020 2020  ls_sel).        
-000119b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000119c0: 6273 7420 3d20 7867 622e 7472 6169 6e28  bst = xgb.train(
-000119d0: 7061 7261 6d73 2c20 6474 7261 696e 2c20  params, dtrain, 
-000119e0: 6e75 6d5f 626f 6f73 745f 726f 756e 643d  num_boost_round=
-000119f0: 6e75 6d5f 726f 756e 6473 2920 2020 2020  num_rounds)     
-00011a00: 2020 2020 2020 2020 2020 200a 2020 2020             .    
+00011950: 2020 2020 2020 636c 6620 3d20 5847 4243        clf = XGBC
+00011960: 6c61 7373 6966 6965 7228 6e5f 6a6f 6273  lassifier(n_jobs
+00011970: 3d2d 312c 206e 5f65 7374 696d 6174 6f72  =-1, n_estimator
+00011980: 733d 3130 302c 206d 6178 5f64 6570 7468  s=100, max_depth
+00011990: 3d34 2c20 7261 6e64 6f6d 5f73 7461 7465  =4, random_state
+000119a0: 3d39 3929 0a20 2020 2020 2020 2020 2020  =99).           
+000119b0: 2020 2020 2020 2020 2020 2020 2063 6c66               clf
+000119c0: 2e73 6574 5f70 6172 616d 7328 2a2a 7061  .set_params(**pa
+000119d0: 7261 6d73 290a 2020 2020 2020 2020 2020  rams).          
+000119e0: 2020 2020 2020 2020 2020 2020 2020 6273                bs
+000119f0: 7420 3d20 4d75 6c74 694f 7574 7075 7443  t = MultiOutputC
+00011a00: 6c61 7373 6966 6965 7228 636c 6629 0a20  lassifier(clf). 
 00011a10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011a20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011a30: 200a 2020 2020 2020 2020 2020 2020 2020   .              
-00011a40: 2020 2020 2020 6578 6365 7074 2045 7863        except Exc
-00011a50: 6570 7469 6f6e 2061 7320 6572 726f 725f  eption as error_
-00011a60: 6d73 673a 0a20 2020 2020 2020 2020 2020  msg:.           
-00011a70: 2020 2020 2020 2020 2020 2020 2070 7269               pri
-00011a80: 6e74 2827 5265 6775 6c61 7220 5847 426f  nt('Regular XGBo
-00011a90: 6f73 7420 6973 2063 7261 7368 696e 6720  ost is crashing 
-00011aa0: 6475 6520 746f 3a20 2573 2720 2565 7272  due to: %s' %err
-00011ab0: 6f72 5f6d 7367 290a 2020 2020 2020 2020  or_msg).        
-00011ac0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011ad0: 6966 2073 6574 7469 6e67 732e 6d6f 6465  if settings.mode
-00011ae0: 6c74 7970 6520 3d3d 2027 5265 6772 6573  ltype == 'Regres
-00011af0: 7369 6f6e 273a 0a20 2020 2020 2020 2020  sion':.         
-00011b00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011b10: 2020 2070 6172 616d 7320 3d20 7b27 7472     params = {'tr
-00011b20: 6565 5f6d 6574 686f 6427 3a20 6370 755f  ee_method': cpu_
-00011b30: 7472 6565 5f6d 6574 686f 642c 2027 6770  tree_method, 'gp
-00011b40: 755f 6964 273a 204e 6f6e 657d 0a20 2020  u_id': None}.   
-00011b50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011b60: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
-00011b70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011b80: 2020 2020 2020 2070 6172 616d 7320 3d20         params = 
-00011b90: 7b27 7472 6565 5f6d 6574 686f 6427 3a20  {'tree_method': 
-00011ba0: 6370 755f 7472 6565 5f6d 6574 686f 642c  cpu_tree_method,
-00011bb0: 276e 756d 5f63 6c61 7373 273a 206e 756d  'num_class': num
-00011bc0: 5f63 6c61 7373 2c20 2767 7075 5f69 6427  _class, 'gpu_id'
-00011bd0: 3a20 4e6f 6e65 7d0a 2020 2020 2020 2020  : None}.        
-00011be0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011bf0: 7072 696e 7428 6572 726f 725f 6d73 6729  print(error_msg)
-00011c00: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00011c10: 2020 2020 2020 2020 2062 7374 203d 2078           bst = x
-00011c20: 6762 2e74 7261 696e 2870 6172 616d 732c  gb.train(params,
-00011c30: 2064 7472 6169 6e2c 206e 756d 5f62 6f6f   dtrain, num_boo
-00011c40: 7374 5f72 6f75 6e64 3d6e 756d 5f72 6f75  st_round=num_rou
-00011c50: 6e64 7329 2020 2020 2020 2020 2020 2020  nds)            
-00011c60: 2020 2020 0a20 2020 2020 2020 2020 2020      .           
-00011c70: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
-00011c80: 2020 2020 2020 2020 2020 2020 2020 2023                 #
-00011c90: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00011ca0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00011cb0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00011cc0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00011cd0: 2323 2323 2323 2323 2323 2323 2323 230a  ###############.
+00011a20: 2020 2062 7374 2e66 6974 2858 5f74 7261     bst.fit(X_tra
+00011a30: 696e 2c20 795f 7472 6169 6e29 0a20 2020  in, y_train).   
+00011a40: 2020 2020 2020 2020 2020 2020 2065 6c73               els
+00011a50: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+00011a60: 2020 2020 2020 2069 6620 6e6f 7420 6461         if not da
+00011a70: 736b 5f78 6762 6f6f 7374 5f66 6c61 673a  sk_xgboost_flag:
+00011a80: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00011a90: 2020 2020 2020 2020 2023 2323 2323 2323           #######
+00011aa0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00011ab0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00011ac0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00011ad0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00011ae0: 2323 2323 2323 2323 230a 2020 2020 2020  #########.      
+00011af0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011b00: 2020 2323 2323 2323 2323 2320 2054 7261    #########  Tra
+00011b10: 696e 696e 6720 5265 6775 6c61 7220 5847  ining Regular XG
+00011b20: 426f 6f73 7420 6f6e 2070 616e 6461 7320  Boost on pandas 
+00011b30: 6461 7461 6672 616d 6573 206f 6e6c 7920  dataframes only 
+00011b40: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00011b50: 2323 0a20 2020 2020 2020 2020 2020 2020  ##.             
+00011b60: 2020 2020 2020 2020 2020 2023 2323 2323             #####
+00011b70: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00011b80: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00011b90: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00011ba0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00011bb0: 2323 2323 2323 2323 2323 230a 2020 2020  ###########.    
+00011bc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011bd0: 2020 2020 2323 2323 206e 6f77 2074 6869      #### now thi
+00011be0: 7320 7472 6169 6e69 6e67 2076 6961 2062  s training via b
+00011bf0: 7374 2077 6f72 6b73 2077 656c 6c20 666f  st works well fo
+00011c00: 7220 626f 7468 2078 6762 6f6f 7374 2030  r both xgboost 0
+00011c10: 2e30 2e39 3020 6173 2077 656c 6c20 6173  .0.90 as well as
+00011c20: 2031 2e35 2e31 2023 230a 2020 2020 2020   1.5.1 ##.      
+00011c30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011c40: 2020 0a20 2020 2020 2020 2020 2020 2020    .             
+00011c50: 2020 2020 2020 2020 2020 2074 7279 3a0a             try:.
+00011c60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011c70: 2020 2020 2020 2020 2020 2020 6474 7261              dtra
+00011c80: 696e 203d 2078 6762 2e44 4d61 7472 6978  in = xgb.DMatrix
+00011c90: 2858 5f74 7261 696e 2c20 795f 7472 6169  (X_train, y_trai
+00011ca0: 6e2c 2065 6e61 626c 655f 6361 7465 676f  n, enable_catego
+00011cb0: 7269 6361 6c3d 5472 7565 2c20 6665 6174  rical=True, feat
+00011cc0: 7572 655f 6e61 6d65 733d 636f 6c73 5f73  ure_names=cols_s
+00011cd0: 656c 290a 2020 2020 2020 2020 2020 2020  el).            
 00011ce0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011cf0: 2020 2020 2323 2323 2323 2323 2323 2020      ##########  
-00011d00: 2054 7261 696e 696e 6720 5847 426f 6f73   Training XGBoos
-00011d10: 7420 6d6f 6465 6c20 7573 696e 6720 6461  t model using da
-00011d20: 736b 5f78 6762 6f6f 7374 2023 2323 2323  sk_xgboost #####
-00011d30: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00011d40: 2323 2323 0a20 2020 2020 2020 2020 2020  ####.           
-00011d50: 2020 2020 2020 2020 2023 2323 2323 2323           #######
-00011d60: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00011d70: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00011d80: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00011d90: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00011da0: 2323 2323 2323 2323 230a 2020 2020 2020  #########.      
-00011db0: 2020 2020 2020 2020 2020 2020 2020 2323                ##
-00011dc0: 2320 7468 6520 6474 7261 696e 2073 796e  # the dtrain syn
-00011dd0: 7461 7820 6361 6e20 6f6e 6c79 2062 6520  tax can only be 
-00011de0: 7573 6564 2078 6762 6f6f 7374 2031 2e35  used xgboost 1.5
-00011df0: 3020 6f72 2067 7265 6174 6572 2e20 446f  0 or greater. Do
-00011e00: 6e74 2075 7365 2069 7420 756e 7469 6c20  nt use it until 
-00011e10: 7468 656e 2e0a 2020 2020 2020 2020 2020  then..          
-00011e20: 2020 2020 2020 2020 2020 2323 2320 7573            ### us
-00011e30: 6520 7468 6520 6e65 7874 206c 696e 6520  e the next line 
-00011e40: 666f 7220 6e65 7720 7867 626f 6f73 7420  for new xgboost 
-00011e50: 7665 7273 696f 6e20 312e 352e 3120 6162  version 1.5.1 ab
-00011e60: 6420 6869 6768 6572 2023 2323 2323 2323  d higher #######
-00011e70: 2323 0a20 2020 2020 2020 2020 2020 2020  ##.             
-00011e80: 2020 2020 2020 2074 7279 3a0a 2020 2020         try:.    
+00011cf0: 6273 7420 3d20 7867 622e 7472 6169 6e28  bst = xgb.train(
+00011d00: 7061 7261 6d73 2c20 6474 7261 696e 2c20  params, dtrain, 
+00011d10: 6e75 6d5f 626f 6f73 745f 726f 756e 643d  num_boost_round=
+00011d20: 6e75 6d5f 726f 756e 6473 2920 2020 2020  num_rounds)     
+00011d30: 2020 2020 2020 2020 2020 200a 2020 2020             .    
+00011d40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011d50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011d60: 2020 2020 0a20 2020 2020 2020 2020 2020      .           
+00011d70: 2020 2020 2020 2020 2020 2020 2065 7863               exc
+00011d80: 6570 7420 4578 6365 7074 696f 6e20 6173  ept Exception as
+00011d90: 2065 7272 6f72 5f6d 7367 3a0a 2020 2020   error_msg:.    
+00011da0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011db0: 2020 2020 2020 2020 7072 696e 7428 2752          print('R
+00011dc0: 6567 756c 6172 2058 4742 6f6f 7374 2069  egular XGBoost i
+00011dd0: 7320 6372 6173 6869 6e67 2064 7565 2074  s crashing due t
+00011de0: 6f3a 2025 7327 2025 6572 726f 725f 6d73  o: %s' %error_ms
+00011df0: 6729 0a20 2020 2020 2020 2020 2020 2020  g).             
+00011e00: 2020 2020 2020 2020 2020 2020 2020 2069                 i
+00011e10: 6620 7365 7474 696e 6773 2e6d 6f64 656c  f settings.model
+00011e20: 7479 7065 203d 3d20 2752 6567 7265 7373  type == 'Regress
+00011e30: 696f 6e27 3a0a 2020 2020 2020 2020 2020  ion':.          
+00011e40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011e50: 2020 2020 2020 7061 7261 6d73 203d 207b        params = {
+00011e60: 2774 7265 655f 6d65 7468 6f64 273a 2063  'tree_method': c
+00011e70: 7075 5f74 7265 655f 6d65 7468 6f64 2c20  pu_tree_method, 
+00011e80: 2767 7075 5f69 6427 3a20 4e6f 6e65 7d0a  'gpu_id': None}.
 00011e90: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011ea0: 2020 2020 2323 2323 2053 594e 5441 5820      #### SYNTAX 
-00011eb0: 4245 4c4f 5720 574f 524b 5320 5745 4c4c  BELOW WORKS WELL
-00011ec0: 2e20 4255 5420 594f 5520 4341 4e4e 4f54  . BUT YOU CANNOT
-00011ed0: 2044 4f20 4556 414c 5320 5749 5448 2044   DO EVALS WITH D
-00011ee0: 4153 4b20 5847 424f 4f53 5420 4153 204f  ASK XGBOOST AS O
-00011ef0: 4620 4e4f 5720 2323 2323 0a20 2020 2020  F NOW ####.     
-00011f00: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011f10: 2020 2023 6474 7261 696e 203d 2078 6762     #dtrain = xgb
-00011f20: 2e64 6173 6b2e 4461 736b 444d 6174 7269  .dask.DaskDMatri
-00011f30: 7828 636c 6965 6e74 2c20 585f 7472 6169  x(client, X_trai
-00011f40: 6e2c 2079 5f74 7261 696e 290a 2020 2020  n, y_train).    
+00011ea0: 2020 2020 2020 2020 2020 2020 656c 7365              else
+00011eb0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00011ec0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00011ed0: 2020 7061 7261 6d73 203d 207b 2774 7265    params = {'tre
+00011ee0: 655f 6d65 7468 6f64 273a 2063 7075 5f74  e_method': cpu_t
+00011ef0: 7265 655f 6d65 7468 6f64 2c27 6e75 6d5f  ree_method,'num_
+00011f00: 636c 6173 7327 3a20 6e75 6d5f 636c 6173  class': num_clas
+00011f10: 732c 2027 6770 755f 6964 273a 204e 6f6e  s, 'gpu_id': Non
+00011f20: 657d 0a20 2020 2020 2020 2020 2020 2020  e}.             
+00011f30: 2020 2020 2020 2020 2020 2020 2020 2070                 p
+00011f40: 7269 6e74 2865 7272 6f72 5f6d 7367 290a  rint(error_msg).
 00011f50: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011f60: 2020 2020 2362 7374 203d 2078 6762 2e64      #bst = xgb.d
-00011f70: 6173 6b2e 7472 6169 6e28 636c 6965 6e74  ask.train(client
-00011f80: 2c20 7061 7261 6d73 2c20 6474 7261 696e  , params, dtrain
-00011f90: 2c20 6e75 6d5f 626f 6f73 745f 726f 756e  , num_boost_roun
-00011fa0: 643d 6e75 6d5f 726f 756e 6473 290a 2020  d=num_rounds).  
-00011fb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00011fc0: 2020 2020 2020 6273 7420 3d20 6461 736b        bst = dask
-00011fd0: 5f78 6762 6f6f 7374 5f74 7261 696e 696e  _xgboost_trainin
-00011fe0: 6728 585f 7472 6169 6e2c 2079 5f74 7261  g(X_train, y_tra
-00011ff0: 696e 2c20 7061 7261 6d73 290a 2020 2020  in, params).    
-00012000: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012010: 6578 6365 7074 2045 7863 6570 7469 6f6e  except Exception
-00012020: 2061 7320 6572 726f 725f 6d73 673a 0a20   as error_msg:. 
-00012030: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012040: 2020 2020 2020 2069 6620 7365 7474 696e         if settin
-00012050: 6773 2e6d 6f64 656c 7479 7065 203d 3d20  gs.modeltype == 
-00012060: 2752 6567 7265 7373 696f 6e27 3a0a 2020  'Regression':.  
-00012070: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012080: 2020 2020 2020 2020 2020 7061 7261 6d73            params
-00012090: 203d 207b 2774 7265 655f 6d65 7468 6f64   = {'tree_method
-000120a0: 273a 2063 7075 5f74 7265 655f 6d65 7468  ': cpu_tree_meth
-000120b0: 6f64 7d0a 2020 2020 2020 2020 2020 2020  od}.            
-000120c0: 2020 2020 2020 2020 2020 2020 656c 7365              else
-000120d0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-000120e0: 2020 2020 2020 2020 2020 2020 2020 7061                pa
-000120f0: 7261 6d73 203d 207b 2774 7265 655f 6d65  rams = {'tree_me
-00012100: 7468 6f64 273a 2063 7075 5f74 7265 655f  thod': cpu_tree_
-00012110: 6d65 7468 6f64 2c27 6e75 6d5f 636c 6173  method,'num_clas
-00012120: 7327 3a20 6e75 6d5f 636c 6173 737d 0a20  s': num_class}. 
-00012130: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00012140: 2020 2020 2020 2064 7472 6169 6e20 3d20         dtrain = 
-00012150: 7867 622e 444d 6174 7269 7828 585f 7472  xgb.DMatrix(X_tr
-00012160: 6169 6e2c 206c 6162 656c 3d79 5f74 7261  ain, label=y_tra
-00012170: 696e 2c20 6665 6174 7572 655f 6e61 6d65  in, feature_name
-00012180: 733d 636f 6c73 5f73 656c 290a 2020 2020  s=cols_sel).    
-00012190: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000121a0: 2020 2020 6273 7420 3d20 7867 622e 6461      bst = xgb.da
-000121b0: 736b 2e74 7261 696e 2863 6c69 656e 743d  sk.train(client=
-000121c0: 636c 6965 6e74 2c20 7061 7261 6d73 3d70  client, params=p
-000121d0: 6172 616d 732c 2064 7472 6169 6e3d 6474  arams, dtrain=dt
-000121e0: 7261 696e 2c20 6e75 6d5f 626f 6f73 745f  rain, num_boost_
-000121f0: 726f 756e 643d 6e75 6d5f 726f 756e 6473  round=num_rounds
-00012200: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-00012210: 2020 2020 2020 2020 2020 7072 696e 7428            print(
-00012220: 6572 726f 725f 6d73 6729 0a20 2020 2020  error_msg).     
-00012230: 2020 2020 2020 2023 2323 2323 2323 2323         #########
-00012240: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00012250: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00012260: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00012270: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00012280: 2323 2323 2323 230a 2020 2020 2020 2020  #######.        
-00012290: 2020 2020 6966 206e 6f74 2064 6173 6b5f      if not dask_
-000122a0: 7867 626f 6f73 745f 666c 6167 3a0a 2020  xgboost_flag:.  
-000122b0: 2020 2020 2020 2020 2020 2020 2020 6273                bs
-000122c0: 745f 6d6f 6465 6c73 2e61 7070 656e 6428  t_models.append(
-000122d0: 6273 7429 0a20 2020 2020 2020 2020 2020  bst).           
-000122e0: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
-000122f0: 2020 2020 2020 2062 7374 5f6d 6f64 656c         bst_model
-00012300: 732e 6170 7065 6e64 2862 7374 5b27 626f  s.append(bst['bo
-00012310: 6f73 7465 7227 5d29 2020 2020 2020 2020  oster'])        
-00012320: 2020 2020 2020 2020 0a20 2020 2020 2020          .       
-00012330: 2020 2020 2023 2323 2323 2074 6f20 6765       ##### to ge
-00012340: 7420 7468 6520 7061 7261 6d73 206f 6620  t the params of 
-00012350: 616e 2078 6762 6f6f 7374 2062 6f6f 7374  an xgboost boost
-00012360: 6572 206f 626a 6563 7420 796f 7520 6861  er object you ha
-00012370: 7665 2074 6f20 646f 2074 6865 2066 6f6c  ve to do the fol
-00012380: 6c6f 7769 6e67 2073 7465 7073 3a0a 2020  lowing steps:.  
-00012390: 2020 2020 2020 2020 2020 6966 2076 6572            if ver
-000123a0: 626f 7365 203e 3d20 333a 0a20 2020 2020  bose >= 3:.     
-000123b0: 2020 2020 2020 2020 2020 2069 6620 6e6f             if no
-000123c0: 7420 6461 736b 5f78 6762 6f6f 7374 5f66  t dask_xgboost_f
-000123d0: 6c61 6720 3a0a 2020 2020 2020 2020 2020  lag :.          
-000123e0: 2020 2020 2020 2020 2020 7072 696e 7428            print(
-000123f0: 2752 6567 756c 6172 2058 4742 6f6f 7374  'Regular XGBoost
-00012400: 206d 6f64 656c 2070 6172 616d 6574 6572   model parameter
-00012410: 733a 5c6e 2729 0a20 2020 2020 2020 2020  s:\n').         
-00012420: 2020 2020 2020 2020 2020 2063 6f6e 6669             confi
-00012430: 6720 3d20 6a73 6f6e 2e6c 6f61 6473 2862  g = json.loads(b
-00012440: 7374 2e73 6176 655f 636f 6e66 6967 2829  st.save_config()
-00012450: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-00012460: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
-00012470: 2020 2020 2020 2020 2020 2020 7072 696e              prin
-00012480: 7428 2744 6173 6b20 5847 426f 6f73 7420  t('Dask XGBoost 
-00012490: 6d6f 6465 6c20 7061 7261 6d65 7465 7273  model parameters
-000124a0: 3a5c 6e27 290a 2020 2020 2020 2020 2020  :\n').          
-000124b0: 2020 2020 2020 2020 2020 626f 6f20 3d20            boo = 
-000124c0: 6273 745b 2762 6f6f 7374 6572 275d 0a20  bst['booster']. 
-000124d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000124e0: 2020 2063 6f6e 6669 6720 3d20 6a73 6f6e     config = json
-000124f0: 2e6c 6f61 6473 2862 6f6f 2e73 6176 655f  .loads(boo.save_
-00012500: 636f 6e66 6967 2829 290a 2020 2020 2020  config()).      
-00012510: 2020 2020 2020 2020 2020 7072 696e 7428            print(
-00012520: 636f 6e66 6967 290a 2020 2020 2020 2020  config).        
-00012530: 2020 2020 2323 2323 2075 7365 2074 6869      #### use thi
-00012540: 7320 6e65 7874 206f 6e65 2066 6f72 2064  s next one for d
-00012550: 6173 6b5f 7867 626f 6f73 7420 6f6c 6420  ask_xgboost old 
-00012560: 2323 2323 2323 2323 2323 2323 2323 2320  ############### 
-00012570: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
-00012580: 7365 7474 696e 6773 2e6d 756c 7469 5f6c  settings.multi_l
-00012590: 6162 656c 3a0a 2020 2020 2020 2020 2020  abel:.          
-000125a0: 2020 2020 2020 696d 705f 6665 6174 7320        imp_feats 
-000125b0: 3d20 6469 6374 287a 6970 2858 5f74 7261  = dict(zip(X_tra
-000125c0: 696e 2e63 6f6c 756d 6e73 2c20 6273 742e  in.columns, bst.
-000125d0: 6573 7469 6d61 746f 7273 5f5b 305d 2e66  estimators_[0].f
-000125e0: 6561 7475 7265 5f69 6d70 6f72 7461 6e63  eature_importanc
-000125f0: 6573 5f29 290a 2020 2020 2020 2020 2020  es_)).          
-00012600: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
-00012610: 2020 2020 2020 2020 6966 206e 6f74 2064          if not d
-00012620: 6173 6b5f 7867 626f 6f73 745f 666c 6167  ask_xgboost_flag
-00012630: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00012640: 2020 2020 2020 696d 705f 6665 6174 7320        imp_feats 
-00012650: 3d20 6273 742e 6765 745f 7363 6f72 6528  = bst.get_score(
-00012660: 666d 6170 3d27 272c 2069 6d70 6f72 7461  fmap='', importa
-00012670: 6e63 655f 7479 7065 3d27 746f 7461 6c5f  nce_type='total_
-00012680: 6761 696e 2729 0a20 2020 2020 2020 2020  gain').         
-00012690: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
-000126a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000126b0: 2069 6d70 5f66 6561 7473 203d 2062 7374   imp_feats = bst
-000126c0: 5b27 626f 6f73 7465 7227 5d2e 6765 745f  ['booster'].get_
-000126d0: 7363 6f72 6528 666d 6170 3d27 272c 2069  score(fmap='', i
-000126e0: 6d70 6f72 7461 6e63 655f 7479 7065 3d27  mportance_type='
-000126f0: 746f 7461 6c5f 6761 696e 2729 0a20 2020  total_gain').   
-00012700: 2020 2020 2020 2020 2023 2323 2073 6b69           ### ski
-00012710: 7020 7468 6520 6e65 7874 2073 7461 7465  p the next state
-00012720: 6d65 6e74 2073 696e 6365 2069 7420 6973  ment since it is
-00012730: 2064 7570 6c69 6361 7469 6e67 2074 6865   duplicating the
-00012740: 2077 6f72 6b20 6f66 2073 6f72 745f 7661   work of sort_va
-00012750: 6c75 6573 2023 230a 2020 2020 2020 2020  lues ##.        
-00012760: 2020 2020 2369 6d70 5f66 6561 7473 203d      #imp_feats =
-00012770: 2064 6963 7428 736f 7274 6564 2869 6d70   dict(sorted(imp
-00012780: 5f66 6561 7473 2e69 7465 6d73 2829 2c72  _feats.items(),r
-00012790: 6576 6572 7365 3d54 7275 652c 206b 6579  everse=True, key
-000127a0: 3d6c 616d 6264 6120 6974 656d 3a20 6974  =lambda item: it
-000127b0: 656d 5b31 5d29 290a 2020 2020 2020 2020  em[1])).        
-000127c0: 2020 2020 2323 2320 646f 696e 6720 7468      ### doing th
-000127d0: 6973 2066 6f72 2073 696e 676c 652d 6c61  is for single-la
-000127e0: 6265 6c20 6973 2061 206c 6974 746c 6520  bel is a little 
-000127f0: 6469 6666 6572 656e 7420 6672 6f6d 2073  different from s
-00012800: 6574 7469 6e67 732e 6d75 6c74 695f 6c61  ettings.multi_la
-00012810: 6265 6c20 2323 2323 2323 2323 230a 0a20  bel #########.. 
-00012820: 2020 2020 2020 2020 2020 2023 696d 705f             #imp_
-00012830: 6665 6174 7320 3d20 6d6f 6465 6c5f 7867  feats = model_xg
-00012840: 622e 6765 745f 626f 6f73 7465 7228 292e  b.get_booster().
-00012850: 6765 745f 7363 6f72 6528 696d 706f 7274  get_score(import
-00012860: 616e 6365 5f74 7970 653d 2767 6169 6e27  ance_type='gain'
-00012870: 290a 2020 2020 2020 2020 2020 2020 2370  ).            #p
-00012880: 7269 6e74 2827 2564 2069 7465 7261 7469  rint('%d iterati
-00012890: 6f6e 3a20 696d 705f 6665 6174 7320 3d20  on: imp_feats = 
-000128a0: 2573 2720 2528 692b 312c 696d 705f 6665  %s' %(i+1,imp_fe
-000128b0: 6174 7329 290a 2020 2020 2020 2020 2020  ats)).          
-000128c0: 2020 6966 206c 656e 2870 642e 5365 7269    if len(pd.Seri
-000128d0: 6573 2869 6d70 5f66 6561 7473 295b 7064  es(imp_feats)[pd
-000128e0: 2e53 6572 6965 7328 696d 705f 6665 6174  .Series(imp_feat
-000128f0: 7329 2e73 6f72 745f 7661 6c75 6573 2861  s).sort_values(a
-00012900: 7363 656e 6469 6e67 3d46 616c 7365 292f  scending=False)/
-00012910: 7064 2e53 6572 6965 7328 696d 705f 6665  pd.Series(imp_fe
-00012920: 6174 7329 2e76 616c 7565 732e 6d61 7828  ats).values.max(
-00012930: 293e 3d30 2e35 5d29 203e 2031 3a0a 2020  )>=0.5]) > 1:.  
-00012940: 2020 2020 2020 2020 2020 2020 2020 7072                pr
-00012950: 696e 745f 6665 6174 7320 3d20 2870 642e  int_feats = (pd.
-00012960: 5365 7269 6573 2869 6d70 5f66 6561 7473  Series(imp_feats
-00012970: 295b 7064 2e53 6572 6965 7328 696d 705f  )[pd.Series(imp_
-00012980: 6665 6174 7329 2e73 6f72 745f 7661 6c75  feats).sort_valu
-00012990: 6573 2861 7363 656e 6469 6e67 3d46 616c  es(ascending=Fal
-000129a0: 7365 292f 7064 2e53 6572 6965 7328 696d  se)/pd.Series(im
-000129b0: 705f 6665 6174 7329 2e76 616c 7565 732e  p_feats).values.
-000129c0: 6d61 7828 293e 3d30 2e35 5d29 2e69 6e64  max()>=0.5]).ind
-000129d0: 6578 2e74 6f6c 6973 7428 290a 2020 2020  ex.tolist().    
-000129e0: 2020 2020 2020 2020 2020 2020 6966 206c              if l
-000129f0: 656e 2870 7269 6e74 5f66 6561 7473 2920  en(print_feats) 
-00012a00: 3c20 746f 705f 6e75 6d3a 0a20 2020 2020  < top_num:.     
-00012a10: 2020 2020 2020 2020 2020 2020 2020 2070                 p
-00012a20: 7269 6e74 5f66 6561 7473 203d 2070 642e  rint_feats = pd.
-00012a30: 5365 7269 6573 2869 6d70 5f66 6561 7473  Series(imp_feats
-00012a40: 292e 736f 7274 5f76 616c 7565 7328 6173  ).sort_values(as
-00012a50: 6365 6e64 696e 673d 4661 6c73 6529 5b3a  cending=False)[:
-00012a60: 746f 705f 6e75 6d5d 2e69 6e64 6578 2e74  top_num].index.t
-00012a70: 6f6c 6973 7428 290a 2020 2020 2020 2020  olist().        
-00012a80: 2020 2020 2020 2020 6966 206c 656e 2870          if len(p
-00012a90: 7269 6e74 5f66 6561 7473 2920 3c3d 2033  rint_feats) <= 3
-00012aa0: 303a 0a20 2020 2020 2020 2020 2020 2020  0:.             
-00012ab0: 2020 2020 2020 2070 7269 6e74 2827 2020         print('  
-00012ac0: 2020 2020 2020 5365 6c65 6374 6564 3a20        Selected: 
-00012ad0: 2573 2720 2570 7269 6e74 5f66 6561 7473  %s' %print_feats
-00012ae0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-00012af0: 2020 696d 706f 7274 616e 745f 6665 6174    important_feat
-00012b00: 7572 6573 202b 3d20 7072 696e 745f 6665  ures += print_fe
-00012b10: 6174 730a 2020 2020 2020 2020 2020 2020  ats.            
-00012b20: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
-00012b30: 2020 2020 2020 7072 696e 745f 6665 6174        print_feat
-00012b40: 7320 3d20 7064 2e53 6572 6965 7328 696d  s = pd.Series(im
-00012b50: 705f 6665 6174 7329 2e73 6f72 745f 7661  p_feats).sort_va
-00012b60: 6c75 6573 2861 7363 656e 6469 6e67 3d46  lues(ascending=F
-00012b70: 616c 7365 295b 3a74 6f70 5f6e 756d 5d2e  alse)[:top_num].
-00012b80: 696e 6465 782e 746f 6c69 7374 2829 0a20  index.tolist(). 
-00012b90: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-00012ba0: 6620 6c65 6e28 7072 696e 745f 6665 6174  f len(print_feat
-00012bb0: 7329 203c 3d20 3330 3a0a 2020 2020 2020  s) <= 30:.      
-00012bc0: 2020 2020 2020 2020 2020 2020 2020 7072                pr
-00012bd0: 696e 7428 2720 2020 2020 2020 2053 656c  int('        Sel
-00012be0: 6563 7465 643a 2025 7327 2025 7064 2e53  ected: %s' %pd.S
-00012bf0: 6572 6965 7328 696d 705f 6665 6174 7329  eries(imp_feats)
-00012c00: 2e73 6f72 745f 7661 6c75 6573 2861 7363  .sort_values(asc
-00012c10: 656e 6469 6e67 3d46 616c 7365 295b 3a74  ending=False)[:t
-00012c20: 6f70 5f6e 756d 5d2e 696e 6465 782e 746f  op_num].index.to
-00012c30: 6c69 7374 2829 290a 2020 2020 2020 2020  list()).        
-00012c40: 2020 2020 2020 2020 696d 706f 7274 616e          importan
-00012c50: 745f 6665 6174 7572 6573 202b 3d20 7072  t_features += pr
-00012c60: 696e 745f 6665 6174 730a 2020 2020 2020  int_feats.      
-00012c70: 2020 2020 2020 2323 2323 2323 2320 206f        #######  o
-00012c80: 7264 6572 2074 6869 7320 696e 2074 6865  rder this in the
-00012c90: 2073 616d 6520 6f72 6465 7220 696e 2077   same order in w
-00012ca0: 6869 6368 2074 6865 7920 7765 7265 2063  hich they were c
-00012cb0: 6f6c 6c65 6374 6564 2023 2323 2323 230a  ollected ######.
-00012cc0: 2020 2020 2020 2020 2020 2020 696d 706f              impo
-00012cd0: 7274 616e 745f 6665 6174 7572 6573 203d  rtant_features =
-00012ce0: 206c 6973 7428 4f72 6465 7265 6444 6963   list(OrderedDic
-00012cf0: 742e 6672 6f6d 6b65 7973 2869 6d70 6f72  t.fromkeys(impor
-00012d00: 7461 6e74 5f66 6561 7475 7265 7329 290a  tant_features)).
-00012d10: 2020 2020 2020 2020 2020 2020 6966 2064              if d
-00012d20: 6173 6b5f 7867 626f 6f73 745f 666c 6167  ask_xgboost_flag
-00012d30: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00012d40: 2020 7072 696e 7428 2720 2020 2020 2020    print('       
-00012d50: 2020 2020 2054 696d 6520 7461 6b65 6e20       Time taken 
-00012d60: 666f 7220 4441 534b 2058 4742 6f6f 7374  for DASK XGBoost
-00012d70: 2066 6561 7475 7265 2073 656c 6563 7469   feature selecti
-00012d80: 6f6e 203d 2025 302e 3066 2073 6563 6f6e  on = %0.0f secon
-00012d90: 6473 2720 2528 7469 6d65 2e74 696d 6528  ds' %(time.time(
-00012da0: 292d 7374 6172 745f 7469 6d65 3229 290a  )-start_time2)).
-00012db0: 2020 2020 2020 2020 2020 2020 656c 7365              else
-00012dc0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00012dd0: 2020 7072 696e 7428 2720 2020 2020 2020    print('       
-00012de0: 2020 2020 2054 696d 6520 7461 6b65 6e20       Time taken 
-00012df0: 666f 7220 7265 6775 6c61 7220 5847 426f  for regular XGBo
-00012e00: 6f73 7420 6665 6174 7572 6520 7365 6c65  ost feature sele
-00012e10: 6374 696f 6e20 3d20 2530 2e30 6620 7365  ction = %0.0f se
-00012e20: 636f 6e64 7327 2025 2874 696d 652e 7469  conds' %(time.ti
-00012e30: 6d65 2829 2d73 7461 7274 5f74 696d 6532  me()-start_time2
-00012e40: 2929 0a20 2020 2020 2020 2023 2323 2320  )).        #### 
-00012e50: 706c 6f74 2061 6c6c 2074 6865 2066 6561  plot all the fea
-00012e60: 7475 7265 2069 6d70 6f72 7461 6e63 6573  ture importances
-00012e70: 2069 6e20 6120 6772 6964 2023 2323 2323   in a grid #####
-00012e80: 2323 2323 2323 0a20 2020 2020 2020 2069  ######.        i
-00012e90: 6620 7665 7262 6f73 6520 3e3d 2032 3a0a  f verbose >= 2:.
-00012ea0: 2020 2020 2020 2020 2020 2020 6966 2073              if s
-00012eb0: 6574 7469 6e67 732e 6d75 6c74 695f 6c61  ettings.multi_la
-00012ec0: 6265 6c3a 0a20 2020 2020 2020 2020 2020  bel:.           
-00012ed0: 2020 2020 2064 7261 775f 6665 6174 7572       draw_featur
-00012ee0: 655f 696d 706f 7274 616e 6365 735f 6d75  e_importances_mu
-00012ef0: 6c74 695f 6c61 6265 6c28 6273 745f 6d6f  lti_label(bst_mo
-00012f00: 6465 6c73 2c20 6461 736b 5f78 6762 6f6f  dels, dask_xgboo
-00012f10: 7374 5f66 6c61 6729 0a20 2020 2020 2020  st_flag).       
-00012f20: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
-00012f30: 2020 2020 2020 2020 2020 2064 7261 775f             draw_
-00012f40: 6665 6174 7572 655f 696d 706f 7274 616e  feature_importan
-00012f50: 6365 735f 7369 6e67 6c65 5f6c 6162 656c  ces_single_label
-00012f60: 2862 7374 5f6d 6f64 656c 732c 2064 6173  (bst_models, das
-00012f70: 6b5f 7867 626f 6f73 745f 666c 6167 290a  k_xgboost_flag).
-00012f80: 2020 2020 6578 6365 7074 2045 7863 6570      except Excep
-00012f90: 7469 6f6e 2061 7320 653a 0a20 2020 2020  tion as e:.     
-00012fa0: 2020 2069 6620 6461 736b 5f78 6762 6f6f     if dask_xgboo
-00012fb0: 7374 5f66 6c61 673a 0a20 2020 2020 2020  st_flag:.       
-00012fc0: 2020 2020 2070 7269 6e74 2827 4461 736b       print('Dask
-00012fd0: 2058 4742 6f6f 7374 2069 7320 6372 6173   XGBoost is cras
-00012fe0: 6869 6e67 2064 7565 2074 6f20 2573 2e20  hing due to %s. 
-00012ff0: 5265 7475 726e 696e 6720 7769 7468 2063  Returning with c
-00013000: 7572 7265 6e74 6c79 2073 656c 6563 7465  urrently selecte
-00013010: 6420 6665 6174 7572 6573 2e2e 2e27 2025  d features...' %
-00013020: 6529 0a20 2020 2020 2020 2065 6c73 653a  e).        else:
-00013030: 0a20 2020 2020 2020 2020 2020 2070 7269  .            pri
-00013040: 6e74 2827 5265 6775 6c61 7220 5847 426f  nt('Regular XGBo
-00013050: 6f73 7420 6973 2063 7261 7368 696e 6720  ost is crashing 
-00013060: 6475 6520 746f 2025 732e 2052 6574 7572  due to %s. Retur
-00013070: 6e69 6e67 2077 6974 6820 6375 7272 656e  ning with curren
-00013080: 746c 7920 7365 6c65 6374 6564 2066 6561  tly selected fea
-00013090: 7475 7265 732e 2e2e 2720 2565 290a 2020  tures...' %e).  
-000130a0: 2020 2020 2020 696d 706f 7274 616e 745f        important_
-000130b0: 6665 6174 7572 6573 203d 2063 6f70 792e  features = copy.
-000130c0: 6465 6570 636f 7079 2870 7265 6473 290a  deepcopy(preds).
-000130d0: 2020 2020 2323 2323 2323 2020 2020 4520      ######    E 
-000130e0: 2020 204e 2020 2020 2044 2020 2020 2020     N     D      
-000130f0: 4f20 2046 2020 2020 2020 5820 2047 2020  O  F      X  G  
-00013100: 4220 204f 2020 4f20 2053 2020 5420 2020  B  O  O  S  T   
-00013110: 2053 2045 204c 2045 2043 2054 2049 204f   S E L E C T I O
-00013120: 204e 2023 2323 2323 2323 2323 2323 2323   N #############
-00013130: 2323 2323 2323 230a 2020 2020 7072 696e  #######.    prin
-00013140: 7428 2720 2020 2043 6f6d 706c 6574 6564  t('    Completed
-00013150: 2058 4742 6f6f 7374 2066 6561 7475 7265   XGBoost feature
-00013160: 2073 656c 6563 7469 6f6e 2069 6e20 2530   selection in %0
-00013170: 2e30 6620 7365 636f 6e64 7327 2025 2874  .0f seconds' %(t
-00013180: 696d 652e 7469 6d65 2829 2d73 7461 7274  ime.time()-start
-00013190: 5f74 696d 6532 2929 0a20 2020 2069 6620  _time2)).    if 
-000131a0: 6c65 6e28 6964 636f 6c73 2920 3e20 303a  len(idcols) > 0:
-000131b0: 0a20 2020 2020 2020 2070 7269 6e74 2827  .        print('
-000131c0: 2020 2020 416c 6572 743a 204e 6f20 4944      Alert: No ID
-000131d0: 2076 6172 6961 626c 6573 2025 7320 6172   variables %s ar
-000131e0: 6520 696e 636c 7564 6564 2069 6e20 7365  e included in se
-000131f0: 6c65 6374 6564 2066 6561 7475 7265 7327  lected features'
-00013200: 2025 6964 636f 6c73 290a 2020 2020 6966   %idcols).    if
-00013210: 2076 6572 626f 7365 3a0a 2020 2020 2020   verbose:.      
-00013220: 2020 7072 696e 7428 2223 2323 2323 2323    print("#######
-00013230: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00013240: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00013250: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00013260: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00013270: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00013280: 2229 0a20 2020 2020 2020 2070 7269 6e74  ").        print
-00013290: 2822 2323 2323 2320 2020 2020 2020 2020  ("#####         
-000132a0: 2046 2045 2041 2054 2055 2052 2045 2020   F E A T U R E  
-000132b0: 2053 2045 204c 2045 2043 2054 2049 204f   S E L E C T I O
-000132c0: 204e 2020 2043 204f 204d 2050 204c 2045   N   C O M P L E
-000132d0: 2054 2045 2044 2020 2020 2020 2020 2020   T E D          
-000132e0: 2020 2323 2323 2323 2322 290a 2020 2020    #######").    
-000132f0: 2020 2020 7072 696e 7428 2223 2323 2323      print("#####
-00013300: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00013310: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00013320: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00013330: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00013340: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00013350: 2323 2229 0a20 2020 2064 6963 746f 203d  ##").    dicto =
-00013360: 207b 7d0a 2020 2020 6d69 7373 696e 675f   {}.    missing_
-00013370: 666c 6167 7331 203d 205b 7b78 3a78 5b3a  flags1 = [{x:x[:
-00013380: 2d31 335d 7d20 666f 7220 7820 696e 2069  -13]} for x in i
-00013390: 6d70 6f72 7461 6e74 5f66 6561 7475 7265  mportant_feature
-000133a0: 7320 6966 2027 4d69 7373 696e 675f 466c  s if 'Missing_Fl
-000133b0: 6167 2720 696e 2078 5d0a 2020 2020 666f  ag' in x].    fo
-000133c0: 7220 6561 6368 5f66 6c61 6720 696e 206d  r each_flag in m
-000133d0: 6973 7369 6e67 5f66 6c61 6773 313a 0a20  issing_flags1:. 
-000133e0: 2020 2020 2020 2070 7269 6e74 2827 416c         print('Al
-000133f0: 6572 743a 2044 6f6e 7420 666f 7267 6574  ert: Dont forget
-00013400: 2074 6f20 6164 6420 6120 6d69 7373 696e   to add a missin
-00013410: 6720 666c 6167 2074 6f20 2573 2074 6f20  g flag to %s to 
-00013420: 6372 6561 7465 2025 7320 636f 6c75 6d6e  create %s column
-00013430: 2720 2528 6c69 7374 2865 6163 685f 666c  ' %(list(each_fl
-00013440: 6167 2e76 616c 7565 7328 2929 5b30 5d2c  ag.values())[0],
-00013450: 206c 6973 7428 6561 6368 5f66 6c61 672e   list(each_flag.
-00013460: 6b65 7973 2829 295b 305d 2929 0a20 2020  keys())[0])).   
-00013470: 2020 2020 2064 6963 746f 2e75 7064 6174       dicto.updat
-00013480: 6528 6561 6368 5f66 6c61 6729 0a20 2020  e(each_flag).   
-00013490: 2069 6620 6c65 6e28 6469 6374 6f29 203e   if len(dicto) >
-000134a0: 2030 3a0a 2020 2020 2020 2020 696d 706f   0:.        impo
-000134b0: 7274 616e 745f 6665 6174 7572 6573 203d  rtant_features =
-000134c0: 2020 5b64 6963 746f 2e67 6574 2869 7465    [dicto.get(ite
-000134d0: 6d2c 6974 656d 2920 2066 6f72 2069 7465  m,item)  for ite
-000134e0: 6d20 696e 2069 6d70 6f72 7461 6e74 5f66  m in important_f
-000134f0: 6561 7475 7265 735d 0a20 2020 2069 6620  eatures].    if 
-00013500: 6c65 6e28 696d 706f 7274 616e 745f 6665  len(important_fe
-00013510: 6174 7572 6573 2920 3c3d 2033 303a 0a20  atures) <= 30:. 
-00013520: 2020 2020 2020 2070 7269 6e74 2827 5365         print('Se
-00013530: 6c65 6374 6564 2025 6420 696d 706f 7274  lected %d import
-00013540: 616e 7420 6665 6174 7572 6573 3a5c 6e25  ant features:\n%
-00013550: 7327 2025 286c 656e 2869 6d70 6f72 7461  s' %(len(importa
-00013560: 6e74 5f66 6561 7475 7265 7329 2c20 696d  nt_features), im
-00013570: 706f 7274 616e 745f 6665 6174 7572 6573  portant_features
-00013580: 2929 0a20 2020 2065 6c73 653a 0a20 2020  )).    else:.   
-00013590: 2020 2020 2070 7269 6e74 2827 5365 6c65       print('Sele
-000135a0: 6374 6564 2025 6420 696d 706f 7274 616e  cted %d importan
-000135b0: 7420 6665 6174 7572 6573 2e20 546f 6f20  t features. Too 
-000135c0: 6d61 6e79 2074 6f20 7072 696e 742e 2e2e  many to print...
-000135d0: 2720 256c 656e 2869 6d70 6f72 7461 6e74  ' %len(important
-000135e0: 5f66 6561 7475 7265 7329 290a 2020 2020  _features)).    
-000135f0: 6e75 6d76 6172 7320 3d20 5b78 2066 6f72  numvars = [x for
-00013600: 2078 2069 6e20 6e75 6d76 6172 7320 6966   x in numvars if
-00013610: 2078 2069 6e20 696d 706f 7274 616e 745f   x in important_
-00013620: 6665 6174 7572 6573 5d0a 2020 2020 696d  features].    im
-00013630: 706f 7274 616e 745f 6361 7473 203d 205b  portant_cats = [
-00013640: 7820 666f 7220 7820 696e 2069 6d70 6f72  x for x in impor
-00013650: 7461 6e74 5f63 6174 7320 6966 2078 2069  tant_cats if x i
-00013660: 6e20 696d 706f 7274 616e 745f 6665 6174  n important_feat
-00013670: 7572 6573 5d0a 2020 2020 7072 696e 7428  ures].    print(
-00013680: 2754 6f74 616c 2054 696d 6520 7461 6b65  'Total Time take
-00013690: 6e20 666f 7220 6665 6174 7572 6577 697a  n for featurewiz
-000136a0: 2073 656c 6563 7469 6f6e 203d 2025 302e   selection = %0.
-000136b0: 3066 2073 6563 6f6e 6473 2720 2528 7469  0f seconds' %(ti
-000136c0: 6d65 2e74 696d 6528 292d 7374 6172 745f  me.time()-start_
-000136d0: 7469 6d65 2929 0a20 2020 2023 2323 2320  time)).    #### 
-000136e0: 4e6f 7720 6368 616e 6765 2074 6865 2066  Now change the f
-000136f0: 6561 7475 7265 206e 616d 6573 2062 6163  eature names bac
-00013700: 6b20 746f 206f 7269 6769 6e61 6c20 6665  k to original fe
-00013710: 6174 7572 6520 6e61 6d65 7320 2323 2323  ature names ####
-00013720: 2323 2323 2323 2323 2323 2323 0a20 2020  ############.   
-00013730: 2069 7465 6d5f 7265 706c 6163 6572 203d   item_replacer =
-00013740: 2063 6f6c 5f6e 616d 655f 6d61 7070 6572   col_name_mapper
-00013750: 2e67 6574 2020 2320 466f 7220 6661 7374  .get  # For fast
-00013760: 6572 2067 6574 732e 0a20 2020 2023 2323  er gets..    ###
+00011f60: 2020 2020 2020 2020 2020 2020 6273 7420              bst 
+00011f70: 3d20 7867 622e 7472 6169 6e28 7061 7261  = xgb.train(para
+00011f80: 6d73 2c20 6474 7261 696e 2c20 6e75 6d5f  ms, dtrain, num_
+00011f90: 626f 6f73 745f 726f 756e 643d 6e75 6d5f  boost_round=num_
+00011fa0: 726f 756e 6473 2920 2020 2020 2020 2020  rounds)         
+00011fb0: 2020 2020 2020 200a 2020 2020 2020 2020         .        
+00011fc0: 2020 2020 2020 2020 2020 2020 656c 7365              else
+00011fd0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00011fe0: 2020 2020 2020 2020 2020 2323 2323 2323            ######
+00011ff0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00012000: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00012010: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00012020: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00012030: 2323 2323 2323 2323 2323 0a20 2020 2020  ##########.     
+00012040: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012050: 2020 2023 2323 2323 2323 2323 2320 2020     ##########   
+00012060: 5472 6169 6e69 6e67 2058 4742 6f6f 7374  Training XGBoost
+00012070: 206d 6f64 656c 2075 7369 6e67 2064 6173   model using das
+00012080: 6b5f 7867 626f 6f73 7420 2323 2323 2323  k_xgboost ######
+00012090: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000120a0: 2323 230a 2020 2020 2020 2020 2020 2020  ###.            
+000120b0: 2020 2020 2020 2020 2020 2020 2323 2323              ####
+000120c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000120d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000120e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000120f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00012100: 2323 2323 2323 2323 2323 2323 0a20 2020  ############.   
+00012110: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012120: 2020 2020 2023 2323 2074 6865 2064 7472       ### the dtr
+00012130: 6169 6e20 7379 6e74 6178 2063 616e 206f  ain syntax can o
+00012140: 6e6c 7920 6265 2075 7365 6420 7867 626f  nly be used xgbo
+00012150: 6f73 7420 312e 3530 206f 7220 6772 6561  ost 1.50 or grea
+00012160: 7465 722e 2044 6f6e 7420 7573 6520 6974  ter. Dont use it
+00012170: 2075 6e74 696c 2074 6865 6e2e 0a20 2020   until then..   
+00012180: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012190: 2020 2020 2023 2323 2075 7365 2074 6865       ### use the
+000121a0: 206e 6578 7420 6c69 6e65 2066 6f72 206e   next line for n
+000121b0: 6577 2078 6762 6f6f 7374 2076 6572 7369  ew xgboost versi
+000121c0: 6f6e 2031 2e35 2e31 2061 6264 2068 6967  on 1.5.1 abd hig
+000121d0: 6865 7220 2323 2323 2323 2323 230a 2020  her #########.  
+000121e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000121f0: 2020 2020 2020 7472 793a 0a20 2020 2020        try:.     
+00012200: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012210: 2020 2020 2020 2023 2323 2320 5359 4e54         #### SYNT
+00012220: 4158 2042 454c 4f57 2057 4f52 4b53 2057  AX BELOW WORKS W
+00012230: 454c 4c2e 2042 5554 2059 4f55 2043 414e  ELL. BUT YOU CAN
+00012240: 4e4f 5420 444f 2045 5641 4c53 2057 4954  NOT DO EVALS WIT
+00012250: 4820 4441 534b 2058 4742 4f4f 5354 2041  H DASK XGBOOST A
+00012260: 5320 4f46 204e 4f57 2023 2323 230a 2020  S OF NOW ####.  
+00012270: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012280: 2020 2020 2020 2020 2020 2364 7472 6169            #dtrai
+00012290: 6e20 3d20 7867 622e 6461 736b 2e44 6173  n = xgb.dask.Das
+000122a0: 6b44 4d61 7472 6978 2863 6c69 656e 742c  kDMatrix(client,
+000122b0: 2058 5f74 7261 696e 2c20 795f 7472 6169   X_train, y_trai
+000122c0: 6e29 0a20 2020 2020 2020 2020 2020 2020  n).             
+000122d0: 2020 2020 2020 2020 2020 2020 2020 2023                 #
+000122e0: 6273 7420 3d20 7867 622e 6461 736b 2e74  bst = xgb.dask.t
+000122f0: 7261 696e 2863 6c69 656e 742c 2070 6172  rain(client, par
+00012300: 616d 732c 2064 7472 6169 6e2c 206e 756d  ams, dtrain, num
+00012310: 5f62 6f6f 7374 5f72 6f75 6e64 3d6e 756d  _boost_round=num
+00012320: 5f72 6f75 6e64 7329 0a20 2020 2020 2020  _rounds).       
+00012330: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012340: 2020 2020 2062 7374 203d 2064 6173 6b5f       bst = dask_
+00012350: 7867 626f 6f73 745f 7472 6169 6e69 6e67  xgboost_training
+00012360: 2858 5f74 7261 696e 2c20 795f 7472 6169  (X_train, y_trai
+00012370: 6e2c 2070 6172 616d 7329 0a20 2020 2020  n, params).     
+00012380: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012390: 2020 2065 7863 6570 7420 4578 6365 7074     except Except
+000123a0: 696f 6e20 6173 2065 7272 6f72 5f6d 7367  ion as error_msg
+000123b0: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+000123c0: 2020 2020 2020 2020 2020 2020 2020 6966                if
+000123d0: 2073 6574 7469 6e67 732e 6d6f 6465 6c74   settings.modelt
+000123e0: 7970 6520 3d3d 2027 5265 6772 6573 7369  ype == 'Regressi
+000123f0: 6f6e 273a 0a20 2020 2020 2020 2020 2020  on':.           
+00012400: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012410: 2020 2020 2070 6172 616d 7320 3d20 7b27       params = {'
+00012420: 7472 6565 5f6d 6574 686f 6427 3a20 6370  tree_method': cp
+00012430: 755f 7472 6565 5f6d 6574 686f 647d 0a20  u_tree_method}. 
+00012440: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012450: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
+00012460: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00012470: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012480: 2070 6172 616d 7320 3d20 7b27 7472 6565   params = {'tree
+00012490: 5f6d 6574 686f 6427 3a20 6370 755f 7472  _method': cpu_tr
+000124a0: 6565 5f6d 6574 686f 642c 276e 756d 5f63  ee_method,'num_c
+000124b0: 6c61 7373 273a 206e 756d 5f63 6c61 7373  lass': num_class
+000124c0: 7d0a 2020 2020 2020 2020 2020 2020 2020  }.              
+000124d0: 2020 2020 2020 2020 2020 2020 2020 6474                dt
+000124e0: 7261 696e 203d 2078 6762 2e44 4d61 7472  rain = xgb.DMatr
+000124f0: 6978 2858 5f74 7261 696e 2c20 6c61 6265  ix(X_train, labe
+00012500: 6c3d 795f 7472 6169 6e2c 2066 6561 7475  l=y_train, featu
+00012510: 7265 5f6e 616d 6573 3d63 6f6c 735f 7365  re_names=cols_se
+00012520: 6c29 0a20 2020 2020 2020 2020 2020 2020  l).             
+00012530: 2020 2020 2020 2020 2020 2020 2020 2062                 b
+00012540: 7374 203d 2078 6762 2e64 6173 6b2e 7472  st = xgb.dask.tr
+00012550: 6169 6e28 636c 6965 6e74 3d63 6c69 656e  ain(client=clien
+00012560: 742c 2070 6172 616d 733d 7061 7261 6d73  t, params=params
+00012570: 2c20 6474 7261 696e 3d64 7472 6169 6e2c  , dtrain=dtrain,
+00012580: 206e 756d 5f62 6f6f 7374 5f72 6f75 6e64   num_boost_round
+00012590: 3d6e 756d 5f72 6f75 6e64 7329 0a20 2020  =num_rounds).   
+000125a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000125b0: 2020 2020 2020 2020 2070 7269 6e74 2865           print(e
+000125c0: 7272 6f72 5f6d 7367 290a 2020 2020 2020  rror_msg).      
+000125d0: 2020 2020 2020 2020 2020 2323 2323 2323            ######
+000125e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000125f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00012600: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00012610: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00012620: 2323 2323 2323 2323 2323 0a20 2020 2020  ##########.     
+00012630: 2020 2020 2020 2020 2020 2069 6620 6e6f             if no
+00012640: 7420 6461 736b 5f78 6762 6f6f 7374 5f66  t dask_xgboost_f
+00012650: 6c61 673a 0a20 2020 2020 2020 2020 2020  lag:.           
+00012660: 2020 2020 2020 2020 2062 7374 5f6d 6f64           bst_mod
+00012670: 656c 732e 6170 7065 6e64 2862 7374 290a  els.append(bst).
+00012680: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012690: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
+000126a0: 2020 2020 2020 2020 2020 6273 745f 6d6f            bst_mo
+000126b0: 6465 6c73 2e61 7070 656e 6428 6273 745b  dels.append(bst[
+000126c0: 2762 6f6f 7374 6572 275d 2920 2020 2020  'booster'])     
+000126d0: 2020 2020 2020 2020 2020 200a 2020 2020             .    
+000126e0: 2020 2020 2020 2020 2020 2020 2323 2323              ####
+000126f0: 2320 746f 2067 6574 2074 6865 2070 6172  # to get the par
+00012700: 616d 7320 6f66 2061 6e20 7867 626f 6f73  ams of an xgboos
+00012710: 7420 626f 6f73 7465 7220 6f62 6a65 6374  t booster object
+00012720: 2079 6f75 2068 6176 6520 746f 2064 6f20   you have to do 
+00012730: 7468 6520 666f 6c6c 6f77 696e 6720 7374  the following st
+00012740: 6570 733a 0a20 2020 2020 2020 2020 2020  eps:.           
+00012750: 2020 2020 2069 6620 7665 7262 6f73 6520       if verbose 
+00012760: 3e3d 2033 3a0a 2020 2020 2020 2020 2020  >= 3:.          
+00012770: 2020 2020 2020 2020 2020 6966 206e 6f74            if not
+00012780: 2064 6173 6b5f 7867 626f 6f73 745f 666c   dask_xgboost_fl
+00012790: 6167 203a 0a20 2020 2020 2020 2020 2020  ag :.           
+000127a0: 2020 2020 2020 2020 2020 2020 2070 7269               pri
+000127b0: 6e74 2827 5265 6775 6c61 7220 5847 426f  nt('Regular XGBo
+000127c0: 6f73 7420 6d6f 6465 6c20 7061 7261 6d65  ost model parame
+000127d0: 7465 7273 3a5c 6e27 290a 2020 2020 2020  ters:\n').      
+000127e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000127f0: 2020 636f 6e66 6967 203d 206a 736f 6e2e    config = json.
+00012800: 6c6f 6164 7328 6273 742e 7361 7665 5f63  loads(bst.save_c
+00012810: 6f6e 6669 6728 2929 0a20 2020 2020 2020  onfig()).       
+00012820: 2020 2020 2020 2020 2020 2020 2065 6c73               els
+00012830: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+00012840: 2020 2020 2020 2020 2020 2070 7269 6e74             print
+00012850: 2827 4461 736b 2058 4742 6f6f 7374 206d  ('Dask XGBoost m
+00012860: 6f64 656c 2070 6172 616d 6574 6572 733a  odel parameters:
+00012870: 5c6e 2729 0a20 2020 2020 2020 2020 2020  \n').           
+00012880: 2020 2020 2020 2020 2020 2020 2062 6f6f               boo
+00012890: 203d 2062 7374 5b27 626f 6f73 7465 7227   = bst['booster'
+000128a0: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
+000128b0: 2020 2020 2020 2020 2020 636f 6e66 6967            config
+000128c0: 203d 206a 736f 6e2e 6c6f 6164 7328 626f   = json.loads(bo
+000128d0: 6f2e 7361 7665 5f63 6f6e 6669 6728 2929  o.save_config())
+000128e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000128f0: 2020 2020 2070 7269 6e74 2863 6f6e 6669       print(confi
+00012900: 6729 0a20 2020 2020 2020 2020 2020 2020  g).             
+00012910: 2020 2023 2323 2320 7573 6520 7468 6973     #### use this
+00012920: 206e 6578 7420 6f6e 6520 666f 7220 6461   next one for da
+00012930: 736b 5f78 6762 6f6f 7374 206f 6c64 2023  sk_xgboost old #
+00012940: 2323 2323 2323 2323 2323 2323 2323 200a  ############## .
+00012950: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00012960: 6966 2073 6574 7469 6e67 732e 6d75 6c74  if settings.mult
+00012970: 695f 6c61 6265 6c3a 0a20 2020 2020 2020  i_label:.       
+00012980: 2020 2020 2020 2020 2020 2020 2069 6d70               imp
+00012990: 5f66 6561 7473 203d 2064 6963 7428 7a69  _feats = dict(zi
+000129a0: 7028 585f 7472 6169 6e2e 636f 6c75 6d6e  p(X_train.column
+000129b0: 732c 2062 7374 2e65 7374 696d 6174 6f72  s, bst.estimator
+000129c0: 735f 5b30 5d2e 6665 6174 7572 655f 696d  s_[0].feature_im
+000129d0: 706f 7274 616e 6365 735f 2929 0a20 2020  portances_)).   
+000129e0: 2020 2020 2020 2020 2020 2020 2065 6c73               els
+000129f0: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+00012a00: 2020 2020 2020 2069 6620 6e6f 7420 6461         if not da
+00012a10: 736b 5f78 6762 6f6f 7374 5f66 6c61 673a  sk_xgboost_flag:
+00012a20: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00012a30: 2020 2020 2020 2020 2069 6d70 5f66 6561           imp_fea
+00012a40: 7473 203d 2062 7374 2e67 6574 5f73 636f  ts = bst.get_sco
+00012a50: 7265 2866 6d61 703d 2727 2c20 696d 706f  re(fmap='', impo
+00012a60: 7274 616e 6365 5f74 7970 653d 2774 6f74  rtance_type='tot
+00012a70: 616c 5f67 6169 6e27 290a 2020 2020 2020  al_gain').      
+00012a80: 2020 2020 2020 2020 2020 2020 2020 656c                el
+00012a90: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+00012aa0: 2020 2020 2020 2020 2020 2020 696d 705f              imp_
+00012ab0: 6665 6174 7320 3d20 6273 745b 2762 6f6f  feats = bst['boo
+00012ac0: 7374 6572 275d 2e67 6574 5f73 636f 7265  ster'].get_score
+00012ad0: 2866 6d61 703d 2727 2c20 696d 706f 7274  (fmap='', import
+00012ae0: 616e 6365 5f74 7970 653d 2774 6f74 616c  ance_type='total
+00012af0: 5f67 6169 6e27 290a 2020 2020 2020 2020  _gain').        
+00012b00: 2020 2020 2020 2020 2323 2320 736b 6970          ### skip
+00012b10: 2074 6865 206e 6578 7420 7374 6174 656d   the next statem
+00012b20: 656e 7420 7369 6e63 6520 6974 2069 7320  ent since it is 
+00012b30: 6475 706c 6963 6174 696e 6720 7468 6520  duplicating the 
+00012b40: 776f 726b 206f 6620 736f 7274 5f76 616c  work of sort_val
+00012b50: 7565 7320 2323 0a20 2020 2020 2020 2020  ues ##.         
+00012b60: 2020 2020 2020 2023 696d 705f 6665 6174         #imp_feat
+00012b70: 7320 3d20 6469 6374 2873 6f72 7465 6428  s = dict(sorted(
+00012b80: 696d 705f 6665 6174 732e 6974 656d 7328  imp_feats.items(
+00012b90: 292c 7265 7665 7273 653d 5472 7565 2c20  ),reverse=True, 
+00012ba0: 6b65 793d 6c61 6d62 6461 2069 7465 6d3a  key=lambda item:
+00012bb0: 2069 7465 6d5b 315d 2929 0a20 2020 2020   item[1])).     
+00012bc0: 2020 2020 2020 2020 2020 2023 2323 2064             ### d
+00012bd0: 6f69 6e67 2074 6869 7320 666f 7220 7369  oing this for si
+00012be0: 6e67 6c65 2d6c 6162 656c 2069 7320 6120  ngle-label is a 
+00012bf0: 6c69 7474 6c65 2064 6966 6665 7265 6e74  little different
+00012c00: 2066 726f 6d20 7365 7474 696e 6773 2e6d   from settings.m
+00012c10: 756c 7469 5f6c 6162 656c 2023 2323 2323  ulti_label #####
+00012c20: 2323 2323 0a0a 2020 2020 2020 2020 2020  ####..          
+00012c30: 2020 2020 2020 2369 6d70 5f66 6561 7473        #imp_feats
+00012c40: 203d 206d 6f64 656c 5f78 6762 2e67 6574   = model_xgb.get
+00012c50: 5f62 6f6f 7374 6572 2829 2e67 6574 5f73  _booster().get_s
+00012c60: 636f 7265 2869 6d70 6f72 7461 6e63 655f  core(importance_
+00012c70: 7479 7065 3d27 6761 696e 2729 0a20 2020  type='gain').   
+00012c80: 2020 2020 2020 2020 2020 2020 2023 7072               #pr
+00012c90: 696e 7428 2725 6420 6974 6572 6174 696f  int('%d iteratio
+00012ca0: 6e3a 2069 6d70 5f66 6561 7473 203d 2025  n: imp_feats = %
+00012cb0: 7327 2025 2869 2b31 2c69 6d70 5f66 6561  s' %(i+1,imp_fea
+00012cc0: 7473 2929 0a20 2020 2020 2020 2020 2020  ts)).           
+00012cd0: 2020 2020 2069 6620 6c65 6e28 7064 2e53       if len(pd.S
+00012ce0: 6572 6965 7328 696d 705f 6665 6174 7329  eries(imp_feats)
+00012cf0: 5b70 642e 5365 7269 6573 2869 6d70 5f66  [pd.Series(imp_f
+00012d00: 6561 7473 292e 736f 7274 5f76 616c 7565  eats).sort_value
+00012d10: 7328 6173 6365 6e64 696e 673d 4661 6c73  s(ascending=Fals
+00012d20: 6529 2f70 642e 5365 7269 6573 2869 6d70  e)/pd.Series(imp
+00012d30: 5f66 6561 7473 292e 7661 6c75 6573 2e6d  _feats).values.m
+00012d40: 6178 2829 3e3d 302e 355d 2920 3e20 313a  ax()>=0.5]) > 1:
+00012d50: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00012d60: 2020 2020 2070 7269 6e74 5f66 6561 7473       print_feats
+00012d70: 203d 2028 7064 2e53 6572 6965 7328 696d   = (pd.Series(im
+00012d80: 705f 6665 6174 7329 5b70 642e 5365 7269  p_feats)[pd.Seri
+00012d90: 6573 2869 6d70 5f66 6561 7473 292e 736f  es(imp_feats).so
+00012da0: 7274 5f76 616c 7565 7328 6173 6365 6e64  rt_values(ascend
+00012db0: 696e 673d 4661 6c73 6529 2f70 642e 5365  ing=False)/pd.Se
+00012dc0: 7269 6573 2869 6d70 5f66 6561 7473 292e  ries(imp_feats).
+00012dd0: 7661 6c75 6573 2e6d 6178 2829 3e3d 302e  values.max()>=0.
+00012de0: 355d 292e 696e 6465 782e 746f 6c69 7374  5]).index.tolist
+00012df0: 2829 0a20 2020 2020 2020 2020 2020 2020  ().             
+00012e00: 2020 2020 2020 2069 6620 6c65 6e28 7072         if len(pr
+00012e10: 696e 745f 6665 6174 7329 203c 2074 6f70  int_feats) < top
+00012e20: 5f6e 756d 3a0a 2020 2020 2020 2020 2020  _num:.          
+00012e30: 2020 2020 2020 2020 2020 2020 2020 7072                pr
+00012e40: 696e 745f 6665 6174 7320 3d20 7064 2e53  int_feats = pd.S
+00012e50: 6572 6965 7328 696d 705f 6665 6174 7329  eries(imp_feats)
+00012e60: 2e73 6f72 745f 7661 6c75 6573 2861 7363  .sort_values(asc
+00012e70: 656e 6469 6e67 3d46 616c 7365 295b 3a74  ending=False)[:t
+00012e80: 6f70 5f6e 756d 5d2e 696e 6465 782e 746f  op_num].index.to
+00012e90: 6c69 7374 2829 0a20 2020 2020 2020 2020  list().         
+00012ea0: 2020 2020 2020 2020 2020 2069 6620 6c65             if le
+00012eb0: 6e28 7072 696e 745f 6665 6174 7329 203c  n(print_feats) <
+00012ec0: 3d20 3330 3a0a 2020 2020 2020 2020 2020  = 30:.          
+00012ed0: 2020 2020 2020 2020 2020 2020 2020 7072                pr
+00012ee0: 696e 7428 2720 2020 2020 2020 2053 656c  int('        Sel
+00012ef0: 6563 7465 643a 2025 7327 2025 7072 696e  ected: %s' %prin
+00012f00: 745f 6665 6174 7329 0a20 2020 2020 2020  t_feats).       
+00012f10: 2020 2020 2020 2020 2020 2020 2069 6d70               imp
+00012f20: 6f72 7461 6e74 5f66 6561 7475 7265 7320  ortant_features 
+00012f30: 2b3d 2070 7269 6e74 5f66 6561 7473 0a20  += print_feats. 
+00012f40: 2020 2020 2020 2020 2020 2020 2020 2065                 e
+00012f50: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+00012f60: 2020 2020 2020 2020 2070 7269 6e74 5f66           print_f
+00012f70: 6561 7473 203d 2070 642e 5365 7269 6573  eats = pd.Series
+00012f80: 2869 6d70 5f66 6561 7473 292e 736f 7274  (imp_feats).sort
+00012f90: 5f76 616c 7565 7328 6173 6365 6e64 696e  _values(ascendin
+00012fa0: 673d 4661 6c73 6529 5b3a 746f 705f 6e75  g=False)[:top_nu
+00012fb0: 6d5d 2e69 6e64 6578 2e74 6f6c 6973 7428  m].index.tolist(
+00012fc0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+00012fd0: 2020 2020 2020 6966 206c 656e 2870 7269        if len(pri
+00012fe0: 6e74 5f66 6561 7473 2920 3c3d 2033 303a  nt_feats) <= 30:
+00012ff0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00013000: 2020 2020 2020 2020 2070 7269 6e74 2827           print('
+00013010: 2020 2020 2020 2020 5365 6c65 6374 6564          Selected
+00013020: 3a20 2573 2720 2570 642e 5365 7269 6573  : %s' %pd.Series
+00013030: 2869 6d70 5f66 6561 7473 292e 736f 7274  (imp_feats).sort
+00013040: 5f76 616c 7565 7328 6173 6365 6e64 696e  _values(ascendin
+00013050: 673d 4661 6c73 6529 5b3a 746f 705f 6e75  g=False)[:top_nu
+00013060: 6d5d 2e69 6e64 6578 2e74 6f6c 6973 7428  m].index.tolist(
+00013070: 2929 0a20 2020 2020 2020 2020 2020 2020  )).             
+00013080: 2020 2020 2020 2069 6d70 6f72 7461 6e74         important
+00013090: 5f66 6561 7475 7265 7320 2b3d 2070 7269  _features += pri
+000130a0: 6e74 5f66 6561 7473 0a20 2020 2020 2020  nt_feats.       
+000130b0: 2020 2020 2020 2020 2023 2323 2323 2323           #######
+000130c0: 2020 6f72 6465 7220 7468 6973 2069 6e20    order this in 
+000130d0: 7468 6520 7361 6d65 206f 7264 6572 2069  the same order i
+000130e0: 6e20 7768 6963 6820 7468 6579 2077 6572  n which they wer
+000130f0: 6520 636f 6c6c 6563 7465 6420 2323 2323  e collected ####
+00013100: 2323 0a20 2020 2020 2020 2020 2020 2020  ##.             
+00013110: 2020 2069 6d70 6f72 7461 6e74 5f66 6561     important_fea
+00013120: 7475 7265 7320 3d20 6c69 7374 284f 7264  tures = list(Ord
+00013130: 6572 6564 4469 6374 2e66 726f 6d6b 6579  eredDict.fromkey
+00013140: 7328 696d 706f 7274 616e 745f 6665 6174  s(important_feat
+00013150: 7572 6573 2929 0a20 2020 2020 2020 2020  ures)).         
+00013160: 2020 2020 2020 2069 6620 6461 736b 5f78         if dask_x
+00013170: 6762 6f6f 7374 5f66 6c61 673a 0a20 2020  gboost_flag:.   
+00013180: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013190: 2070 7269 6e74 2827 2020 2020 2020 2020   print('        
+000131a0: 2020 2020 5469 6d65 2074 616b 656e 2066      Time taken f
+000131b0: 6f72 2044 4153 4b20 5847 426f 6f73 7420  or DASK XGBoost 
+000131c0: 6665 6174 7572 6520 7365 6c65 6374 696f  feature selectio
+000131d0: 6e20 3d20 2530 2e30 6620 7365 636f 6e64  n = %0.0f second
+000131e0: 7327 2025 2874 696d 652e 7469 6d65 2829  s' %(time.time()
+000131f0: 2d73 7461 7274 5f74 696d 6532 2929 0a20  -start_time2)). 
+00013200: 2020 2020 2020 2020 2020 2020 2020 2065                 e
+00013210: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+00013220: 2020 2020 2020 2020 2070 7269 6e74 2827           print('
+00013230: 2020 2020 2020 2020 2020 2020 5469 6d65              Time
+00013240: 2074 616b 656e 2066 6f72 2072 6567 756c   taken for regul
+00013250: 6172 2058 4742 6f6f 7374 2066 6561 7475  ar XGBoost featu
+00013260: 7265 2073 656c 6563 7469 6f6e 203d 2025  re selection = %
+00013270: 302e 3066 2073 6563 6f6e 6473 2720 2528  0.0f seconds' %(
+00013280: 7469 6d65 2e74 696d 6528 292d 7374 6172  time.time()-star
+00013290: 745f 7469 6d65 3229 290a 2020 2020 2020  t_time2)).      
+000132a0: 2020 2020 2020 2323 2323 2070 6c6f 7420        #### plot 
+000132b0: 616c 6c20 7468 6520 6665 6174 7572 6520  all the feature 
+000132c0: 696d 706f 7274 616e 6365 7320 696e 2061  importances in a
+000132d0: 2067 7269 6420 2323 2323 2323 2323 2323   grid ##########
+000132e0: 230a 2020 2020 2020 2020 2020 2020 6966  #.            if
+000132f0: 2076 6572 626f 7365 203e 3d20 323a 0a20   verbose >= 2:. 
+00013300: 2020 2020 2020 2020 2020 2020 2020 2069                 i
+00013310: 6620 7365 7474 696e 6773 2e6d 756c 7469  f settings.multi
+00013320: 5f6c 6162 656c 3a0a 2020 2020 2020 2020  _label:.        
+00013330: 2020 2020 2020 2020 2020 2020 6472 6177              draw
+00013340: 5f66 6561 7475 7265 5f69 6d70 6f72 7461  _feature_importa
+00013350: 6e63 6573 5f6d 756c 7469 5f6c 6162 656c  nces_multi_label
+00013360: 2862 7374 5f6d 6f64 656c 732c 2064 6173  (bst_models, das
+00013370: 6b5f 7867 626f 6f73 745f 666c 6167 290a  k_xgboost_flag).
+00013380: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013390: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
+000133a0: 2020 2020 2020 2020 2020 6472 6177 5f66            draw_f
+000133b0: 6561 7475 7265 5f69 6d70 6f72 7461 6e63  eature_importanc
+000133c0: 6573 5f73 696e 676c 655f 6c61 6265 6c28  es_single_label(
+000133d0: 6273 745f 6d6f 6465 6c73 2c20 6461 736b  bst_models, dask
+000133e0: 5f78 6762 6f6f 7374 5f66 6c61 6729 0a20  _xgboost_flag). 
+000133f0: 2020 2020 2020 2065 7863 6570 7420 4578         except Ex
+00013400: 6365 7074 696f 6e20 6173 2065 3a0a 2020  ception as e:.  
+00013410: 2020 2020 2020 2020 2020 6966 2064 6173            if das
+00013420: 6b5f 7867 626f 6f73 745f 666c 6167 3a0a  k_xgboost_flag:.
+00013430: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00013440: 7072 696e 7428 2744 6173 6b20 5847 426f  print('Dask XGBo
+00013450: 6f73 7420 6973 2063 7261 7368 696e 6720  ost is crashing 
+00013460: 6475 6520 746f 2025 732e 2052 6574 7572  due to %s. Retur
+00013470: 6e69 6e67 2077 6974 6820 6375 7272 656e  ning with curren
+00013480: 746c 7920 7365 6c65 6374 6564 2066 6561  tly selected fea
+00013490: 7475 7265 732e 2e2e 2720 2565 290a 2020  tures...' %e).  
+000134a0: 2020 2020 2020 2020 2020 656c 7365 3a0a            else:.
+000134b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000134c0: 7072 696e 7428 2752 6567 756c 6172 2058  print('Regular X
+000134d0: 4742 6f6f 7374 2069 7320 6372 6173 6869  GBoost is crashi
+000134e0: 6e67 2064 7565 2074 6f20 2573 2e20 5265  ng due to %s. Re
+000134f0: 7475 726e 696e 6720 7769 7468 2063 7572  turning with cur
+00013500: 7265 6e74 6c79 2073 656c 6563 7465 6420  rently selected 
+00013510: 6665 6174 7572 6573 2e2e 2e27 2025 6529  features...' %e)
+00013520: 0a20 2020 2020 2020 2020 2020 2069 6d70  .            imp
+00013530: 6f72 7461 6e74 5f66 6561 7475 7265 7320  ortant_features 
+00013540: 3d20 636f 7079 2e64 6565 7063 6f70 7928  = copy.deepcopy(
+00013550: 7072 6564 7329 0a20 2020 2020 2020 2023  preds).        #
+00013560: 2323 2323 2320 2020 2045 2020 2020 4e20  #####    E    N 
+00013570: 2020 2020 4420 2020 2020 204f 2020 4620      D      O  F 
+00013580: 2020 2020 2058 2020 4720 2042 2020 4f20       X  G  B  O 
+00013590: 204f 2020 5320 2054 2020 2020 5320 4520   O  S  T    S E 
+000135a0: 4c20 4520 4320 5420 4920 4f20 4e20 2323  L E C T I O N ##
+000135b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000135c0: 2323 0a20 2020 2020 2020 2070 7269 6e74  ##.        print
+000135d0: 2827 2020 2020 436f 6d70 6c65 7465 6420  ('    Completed 
+000135e0: 5847 426f 6f73 7420 6665 6174 7572 6520  XGBoost feature 
+000135f0: 7365 6c65 6374 696f 6e20 696e 2025 302e  selection in %0.
+00013600: 3066 2073 6563 6f6e 6473 2720 2528 7469  0f seconds' %(ti
+00013610: 6d65 2e74 696d 6528 292d 7374 6172 745f  me.time()-start_
+00013620: 7469 6d65 3229 290a 2020 2020 2020 2020  time2)).        
+00013630: 6966 206c 656e 2869 6463 6f6c 7329 203e  if len(idcols) >
+00013640: 2030 3a0a 2020 2020 2020 2020 2020 2020   0:.            
+00013650: 7072 696e 7428 2720 2020 2041 6c65 7274  print('    Alert
+00013660: 3a20 4e6f 2049 4420 7661 7269 6162 6c65  : No ID variable
+00013670: 7320 2573 2061 7265 2069 6e63 6c75 6465  s %s are include
+00013680: 6420 696e 2073 656c 6563 7465 6420 6665  d in selected fe
+00013690: 6174 7572 6573 2720 2569 6463 6f6c 7329  atures' %idcols)
+000136a0: 0a20 2020 2020 200a 2020 2020 656c 7365  .      .    else
+000136b0: 3a0a 2020 2020 2020 2020 7072 696e 7428  :.        print(
+000136c0: 2753 6b69 7070 696e 6720 5265 6375 7273  'Skipping Recurs
+000136d0: 6976 6520 5847 426f 6f73 7420 6d65 7468  ive XGBoost meth
+000136e0: 6f64 2e20 436f 6e74 696e 7569 6e67 202e  od. Continuing .
+000136f0: 2e2e 2729 0a20 2020 2020 2020 2069 6d70  ..').        imp
+00013700: 6f72 7461 6e74 5f66 6561 7475 7265 7320  ortant_features 
+00013710: 3d20 636f 7079 2e64 6565 7063 6f70 7928  = copy.deepcopy(
+00013720: 7072 6564 7329 0a0a 2020 2020 6966 2076  preds)..    if v
+00013730: 6572 626f 7365 3a0a 2020 2020 2020 2020  erbose:.        
+00013740: 7072 696e 7428 2223 2323 2323 2323 2323  print("#########
+00013750: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00013760: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 00013770: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 00013780: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00013790: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000137a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000137b0: 2323 2323 2323 230a 2020 2020 2323 2320  #######.    ### 
-000137c0: 596f 7520 7365 6c65 6374 2074 6865 2066  You select the f
-000137d0: 6561 7475 7265 7320 7769 7468 2074 6865  eatures with the
-000137e0: 2073 616d 6520 6f6c 6420 6e61 6d65 7320   same old names 
-000137f0: 6173 2062 6566 6f72 6520 6865 7265 2023  as before here #
-00013800: 2323 2323 2323 0a20 2020 2023 2323 2323  ######.    #####
-00013810: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00013790: 2323 2323 2323 2323 2323 2323 2323 2229  ##############")
+000137a0: 0a20 2020 2020 2020 2070 7269 6e74 2822  .        print("
+000137b0: 2323 2323 2320 2020 2020 2020 2020 2046  #####          F
+000137c0: 2045 2041 2054 2055 2052 2045 2020 2053   E A T U R E   S
+000137d0: 2045 204c 2045 2043 2054 2049 204f 204e   E L E C T I O N
+000137e0: 2020 2043 204f 204d 2050 204c 2045 2054     C O M P L E T
+000137f0: 2045 2044 2020 2020 2020 2020 2020 2020   E D            
+00013800: 2323 2323 2323 2322 290a 2020 2020 2020  #######").      
+00013810: 2020 7072 696e 7428 2223 2323 2323 2323    print("#######
 00013820: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 00013830: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 00013840: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00013850: 2323 2323 230a 2020 2020 2323 2049 6e20  #####.    ## In 
-00013860: 6f6e 6520 6361 7365 2c20 636f 6c75 6d6e  one case, column
-00013870: 206e 616d 6573 2067 6574 2063 6861 6e67   names get chang
-00013880: 6564 2069 6e20 7472 6169 6e20 6275 7420  ed in train but 
-00013890: 6e6f 7420 696e 2074 6573 7420 7369 6e63  not in test sinc
-000138a0: 6520 6974 2074 6573 7420 6973 206e 6f74  e it test is not
-000138b0: 2061 7661 696c 6162 6c65 2e0a 2020 2020   available..    
-000138c0: 6966 2069 7369 6e73 7461 6e63 6528 7465  if isinstance(te
-000138d0: 7374 5f64 6174 612c 2073 7472 2920 6f72  st_data, str) or
-000138e0: 2074 6573 745f 6461 7461 2069 7320 4e6f   test_data is No
-000138f0: 6e65 3a0a 2020 2020 2020 2020 7072 696e  ne:.        prin
-00013900: 7428 274f 7574 7075 7420 636f 6e74 6169  t('Output contai
-00013910: 6e73 2061 206c 6973 7420 6f66 2025 7320  ns a list of %s 
-00013920: 696d 706f 7274 616e 7420 6665 6174 7572  important featur
-00013930: 6573 2061 6e64 2061 2074 7261 696e 2064  es and a train d
-00013940: 6174 6166 7261 6d65 2720 256c 656e 2869  ataframe' %len(i
-00013950: 6d70 6f72 7461 6e74 5f66 6561 7475 7265  mportant_feature
-00013960: 7329 290a 2020 2020 656c 7365 3a0a 2020  s)).    else:.  
-00013970: 2020 2020 2020 7072 696e 7428 274f 7574        print('Out
-00013980: 7075 7420 636f 6e74 6169 6e73 2074 776f  put contains two
-00013990: 2064 6174 6166 7261 6d65 733a 2074 7261   dataframes: tra
-000139a0: 696e 2061 6e64 2074 6573 7420 7769 7468  in and test with
-000139b0: 2025 6420 696d 706f 7274 616e 7420 6665   %d important fe
-000139c0: 6174 7572 6573 2e27 2025 6c65 6e28 696d  atures.' %len(im
-000139d0: 706f 7274 616e 745f 6665 6174 7572 6573  portant_features
-000139e0: 2929 0a20 2020 2069 6620 6665 6174 7572  )).    if featur
-000139f0: 655f 6765 6e20 6f72 2066 6561 7475 7265  e_gen or feature
-00013a00: 5f74 7970 653a 0a20 2020 2020 2020 2069  _type:.        i
-00013a10: 6620 6973 696e 7374 616e 6365 2874 6573  f isinstance(tes
-00013a20: 745f 6461 7461 2c20 7374 7229 206f 7220  t_data, str) or 
-00013a30: 7465 7374 5f64 6174 6120 6973 204e 6f6e  test_data is Non
-00013a40: 653a 0a20 2020 2020 2020 2020 2020 2023  e:.            #
-00013a50: 2323 2069 6620 6665 6174 7572 6520 656e  ## if feature en
-00013a60: 6767 2069 7320 7065 7266 6f72 6d65 642c  gg is performed,
-00013a70: 2069 6420 636f 6c75 6d6e 7320 6172 6520   id columns are 
-00013a80: 6472 6f70 7065 642e 2048 656e 6365 2074  dropped. Hence t
-00013a90: 6865 7920 6d75 7374 2072 656a 6f69 6e20  hey must rejoin 
-00013aa0: 6865 7265 2e0a 2020 2020 2020 2020 2020  here..          
-00013ab0: 2020 6461 7461 6e61 6d65 203d 2070 642e    dataname = pd.
-00013ac0: 636f 6e63 6174 285b 7472 6169 6e5f 6964  concat([train_id
-00013ad0: 732c 2064 6174 616e 616d 655d 2c20 6178  s, dataname], ax
-00013ae0: 6973 3d31 290a 2020 2020 2020 2020 2020  is=1).          
-00013af0: 2020 6966 2069 7369 6e73 7461 6e63 6528    if isinstance(
-00013b00: 7461 7267 6574 2c20 7374 7229 3a0a 2020  target, str):.  
-00013b10: 2020 2020 2020 2020 2020 2020 2020 7265                re
-00013b20: 7475 726e 2069 6d70 6f72 7461 6e74 5f66  turn important_f
-00013b30: 6561 7475 7265 732c 2064 6174 616e 616d  eatures, datanam
-00013b40: 655b 696d 706f 7274 616e 745f 6665 6174  e[important_feat
-00013b50: 7572 6573 2b5b 7461 7267 6574 5d5d 0a20  ures+[target]]. 
-00013b60: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
-00013b70: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00013b80: 2072 6574 7572 6e20 696d 706f 7274 616e   return importan
-00013b90: 745f 6665 6174 7572 6573 2c20 6461 7461  t_features, data
-00013ba0: 6e61 6d65 5b69 6d70 6f72 7461 6e74 5f66  name[important_f
-00013bb0: 6561 7475 7265 732b 7461 7267 6574 5d0a  eatures+target].
-00013bc0: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
-00013bd0: 2020 2020 2020 2020 2020 2323 2320 6966            ### if
-00013be0: 2066 6561 7475 7265 2065 6e67 6720 6973   feature engg is
-00013bf0: 2070 6572 666f 726d 6564 2c20 6964 2063   performed, id c
-00013c00: 6f6c 756d 6e73 2061 7265 2064 726f 7070  olumns are dropp
-00013c10: 6564 2e20 4865 6e63 6520 7468 6579 206d  ed. Hence they m
-00013c20: 7573 7420 7265 6a6f 696e 2068 6572 652e  ust rejoin here.
-00013c30: 0a20 2020 2020 2020 2020 2020 2064 6174  .            dat
-00013c40: 616e 616d 6520 3d20 7064 2e63 6f6e 6361  aname = pd.conca
-00013c50: 7428 5b74 7261 696e 5f69 6473 2c20 6461  t([train_ids, da
-00013c60: 7461 6e61 6d65 5d2c 2061 7869 733d 3129  taname], axis=1)
-00013c70: 0a20 2020 2020 2020 2020 2020 2074 6573  .            tes
-00013c80: 745f 6461 7461 203d 2070 642e 636f 6e63  t_data = pd.conc
-00013c90: 6174 285b 7465 7374 5f69 6473 2c20 7465  at([test_ids, te
-00013ca0: 7374 5f64 6174 615d 2c20 6178 6973 3d31  st_data], axis=1
-00013cb0: 290a 2020 2020 2020 2020 2020 2020 6966  ).            if
-00013cc0: 2069 7369 6e73 7461 6e63 6528 7461 7267   isinstance(targ
-00013cd0: 6574 2c20 7374 7229 3a0a 2020 2020 2020  et, str):.      
-00013ce0: 2020 2020 2020 2020 2020 7265 7475 726e            return
-00013cf0: 2064 6174 616e 616d 655b 696d 706f 7274   dataname[import
-00013d00: 616e 745f 6665 6174 7572 6573 2b5b 7461  ant_features+[ta
-00013d10: 7267 6574 5d5d 2c20 7465 7374 5f64 6174  rget]], test_dat
-00013d20: 615b 696d 706f 7274 616e 745f 6665 6174  a[important_feat
-00013d30: 7572 6573 5d0a 2020 2020 2020 2020 2020  ures].          
-00013d40: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
-00013d50: 2020 2020 2020 2020 7265 7475 726e 2064          return d
-00013d60: 6174 616e 616d 655b 696d 706f 7274 616e  ataname[importan
-00013d70: 745f 6665 6174 7572 6573 2b74 6172 6765  t_features+targe
-00013d80: 745d 2c20 7465 7374 5f64 6174 615b 696d  t], test_data[im
-00013d90: 706f 7274 616e 745f 6665 6174 7572 6573  portant_features
-00013da0: 5d0a 2020 2020 656c 7365 3a0a 2020 2020  ].    else:.    
-00013db0: 2020 2020 2323 2320 596f 7520 7365 6c65      ### You sele
-00013dc0: 6374 2074 6865 2066 6561 7475 7265 7320  ct the features 
-00013dd0: 7769 7468 2074 6865 2073 616d 6520 6f6c  with the same ol
-00013de0: 6420 6e61 6d65 7320 6173 2062 6566 6f72  d names as befor
-00013df0: 6520 2323 2323 2323 230a 2020 2020 2020  e #######.      
-00013e00: 2020 6f6c 645f 696d 706f 7274 616e 745f    old_important_
-00013e10: 6665 6174 7572 6573 203d 2063 6f70 792e  features = copy.
-00013e20: 6465 6570 636f 7079 2869 6d70 6f72 7461  deepcopy(importa
-00013e30: 6e74 5f66 6561 7475 7265 7329 0a20 2020  nt_features).   
-00013e40: 2020 2020 2069 6620 6c65 6e28 6461 7465       if len(date
-00013e50: 5f63 6f6c 7329 203e 2030 3a0a 2020 2020  _cols) > 0:.    
-00013e60: 2020 2020 2020 2020 6461 7465 5f72 6570          date_rep
-00013e70: 6c61 6365 7220 3d20 6461 7465 5f63 6f6c  lacer = date_col
-00013e80: 5f6d 6170 7065 7273 2e67 6574 2020 2320  _mappers.get  # 
-00013e90: 466f 7220 6661 7374 6572 2067 6574 732e  For faster gets.
-00013ea0: 0a20 2020 2020 2020 2020 2020 2069 6d70  .            imp
-00013eb0: 6f72 7461 6e74 5f66 6561 7475 7265 7331  ortant_features1
-00013ec0: 203d 205b 6461 7465 5f72 6570 6c61 6365   = [date_replace
-00013ed0: 7228 6e2c 206e 2920 666f 7220 6e20 696e  r(n, n) for n in
-00013ee0: 2069 6d70 6f72 7461 6e74 5f66 6561 7475   important_featu
-00013ef0: 7265 735d 0a20 2020 2020 2020 2065 6c73  res].        els
-00013f00: 653a 0a20 2020 2020 2020 2020 2020 2069  e:.            i
-00013f10: 6d70 6f72 7461 6e74 5f66 6561 7475 7265  mportant_feature
-00013f20: 7331 203d 205b 6974 656d 5f72 6570 6c61  s1 = [item_repla
-00013f30: 6365 7228 6e2c 206e 2920 666f 7220 6e20  cer(n, n) for n 
-00013f40: 696e 2069 6d70 6f72 7461 6e74 5f66 6561  in important_fea
-00013f50: 7475 7265 735d 0a20 2020 2020 2020 2069  tures].        i
-00013f60: 6d70 6f72 7461 6e74 5f66 6561 7475 7265  mportant_feature
-00013f70: 7320 3d20 6669 6e64 5f72 656d 6f76 655f  s = find_remove_
-00013f80: 6475 706c 6963 6174 6573 2869 6d70 6f72  duplicates(impor
-00013f90: 7461 6e74 5f66 6561 7475 7265 7331 290a  tant_features1).
-00013fa0: 2020 2020 2020 2020 6966 206f 6c64 5f69          if old_i
-00013fb0: 6d70 6f72 7461 6e74 5f66 6561 7475 7265  mportant_feature
-00013fc0: 7320 3d3d 2069 6d70 6f72 7461 6e74 5f66  s == important_f
-00013fd0: 6561 7475 7265 733a 0a20 2020 2020 2020  eatures:.       
-00013fe0: 2020 2020 2023 2320 446f 6e27 7420 6472       ## Don't dr
-00013ff0: 6f70 2074 6865 206f 6c64 2074 6172 6765  op the old targe
-00014000: 7420 7369 6e63 6520 7468 6572 6520 6973  t since there is
-00014010: 206f 6e6c 7920 6f6e 6520 7461 7267 6574   only one target
-00014020: 2068 6572 6520 2323 230a 2020 2020 2020   here ###.      
-00014030: 2020 2020 2020 7061 7373 0a20 2020 2020        pass.     
-00014040: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
-00014050: 2020 2020 2069 6620 6c65 6e28 6f6c 645f       if len(old_
-00014060: 696d 706f 7274 616e 745f 6665 6174 7572  important_featur
-00014070: 6573 2920 3d3d 206c 656e 2869 6d70 6f72  es) == len(impor
-00014080: 7461 6e74 5f66 6561 7475 7265 7329 3a0a  tant_features):.
-00014090: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000140a0: 2323 2320 596f 7520 6a75 7374 206d 6f76  ### You just mov
-000140b0: 6520 7468 6520 7661 6c75 6573 2066 726f  e the values fro
-000140c0: 6d20 7468 6520 6e65 7720 6e61 6d65 7320  m the new names 
-000140d0: 746f 2074 6865 206f 6c64 2066 6561 7475  to the old featu
-000140e0: 7265 206e 616d 6573 2023 230a 2020 2020  re names ##.    
-000140f0: 2020 2020 2020 2020 2020 2020 6461 7461              data
-00014100: 6e61 6d65 5b69 6d70 6f72 7461 6e74 5f66  name[important_f
-00014110: 6561 7475 7265 735d 203d 2064 6174 616e  eatures] = datan
-00014120: 616d 655b 6f6c 645f 696d 706f 7274 616e  ame[old_importan
-00014130: 745f 6665 6174 7572 6573 5d0a 2020 2020  t_features].    
-00014140: 2020 2020 2020 2020 2020 2020 6966 2069              if i
-00014150: 7369 6e73 7461 6e63 6528 7465 7374 5f64  sinstance(test_d
-00014160: 6174 612c 2073 7472 2920 6f72 2074 6573  ata, str) or tes
-00014170: 745f 6461 7461 2069 7320 4e6f 6e65 3a0a  t_data is None:.
-00014180: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014190: 2020 2020 7061 7373 0a20 2020 2020 2020      pass.       
-000141a0: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
-000141b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000141c0: 2020 2023 2323 2320 6966 2074 6865 7265     #### if there
-000141d0: 2069 7320 7465 7374 2064 6174 6120 7472   is test data tr
-000141e0: 616e 7366 6572 2076 616c 7565 7320 746f  ansfer values to
-000141f0: 2069 7420 2323 230a 2020 2020 2020 2020   it ###.        
-00014200: 2020 2020 2020 2020 2020 2020 7465 7374              test
-00014210: 5f64 6174 615b 696d 706f 7274 616e 745f  _data[important_
-00014220: 6665 6174 7572 6573 5d20 3d20 7465 7374  features] = test
-00014230: 5f64 6174 615b 6f6c 645f 696d 706f 7274  _data[old_import
-00014240: 616e 745f 6665 6174 7572 6573 5d0a 2020  ant_features].  
-00014250: 2020 2020 2020 2020 2020 656c 7365 3a0a            else:.
-00014260: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014270: 2323 2320 6669 7273 7420 7472 7920 746f  ### first try to
-00014280: 2072 6574 7572 6e20 7769 7468 2074 6865   return with the
-00014290: 206e 6577 2069 6d70 6f72 7461 6e74 2066   new important f
-000142a0: 6561 7475 7265 732c 2069 6620 7468 6174  eatures, if that
-000142b0: 2066 6169 6c73 2072 6574 7572 6e20 7769   fails return wi
-000142c0: 7468 206f 6c64 2066 6561 7475 7265 730a  th old features.
-000142d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000142e0: 7472 793a 0a20 2020 2020 2020 2020 2020  try:.           
-000142f0: 2020 2020 2020 2020 2070 7269 6e74 2827           print('
-00014300: 5468 6572 6520 6172 6520 7370 6563 6961  There are specia
-00014310: 6c20 6368 6172 7320 696e 2063 6f6c 756d  l chars in colum
-00014320: 6e20 6e61 6d65 732e 2050 6c65 6173 6520  n names. Please 
-00014330: 7265 6d6f 7665 2074 6865 6d20 616e 6420  remove them and 
-00014340: 7472 7920 6167 6169 6e2e 2729 0a20 2020  try again.').   
-00014350: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014360: 2069 6620 6973 696e 7374 616e 6365 2874   if isinstance(t
-00014370: 6573 745f 6461 7461 2c20 7374 7229 206f  est_data, str) o
-00014380: 7220 7465 7374 5f64 6174 6120 6973 204e  r test_data is N
-00014390: 6f6e 653a 0a20 2020 2020 2020 2020 2020  one:.           
-000143a0: 2020 2020 2020 2020 2020 2020 2072 6574               ret
-000143b0: 7572 6e20 696d 706f 7274 616e 745f 6665  urn important_fe
-000143c0: 6174 7572 6573 2c20 6461 7461 6e61 6d65  atures, dataname
-000143d0: 5b69 6d70 6f72 7461 6e74 5f66 6561 7475  [important_featu
-000143e0: 7265 735d 0a20 2020 2020 2020 2020 2020  res].           
-000143f0: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
-00014400: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014410: 2020 2020 2020 2072 6574 7572 6e20 6461         return da
-00014420: 7461 6e61 6d65 5b69 6d70 6f72 7461 6e74  taname[important
-00014430: 5f66 6561 7475 7265 735d 2c20 7465 7374  _features], test
-00014440: 5f64 6174 615b 696d 706f 7274 616e 745f  _data[important_
-00014450: 6665 6174 7572 6573 5d0a 2020 2020 2020  features].      
-00014460: 2020 2020 2020 2020 2020 6578 6365 7074            except
-00014470: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
-00014480: 2020 2020 2020 7072 696e 7428 2754 6865        print('The
-00014490: 7265 2061 7265 2073 7065 6369 616c 2063  re are special c
-000144a0: 6861 7273 2069 6e20 636f 6c75 6d6e 206e  hars in column n
-000144b0: 616d 6573 2e20 5265 7475 726e 696e 6720  ames. Returning 
-000144c0: 7769 7468 2069 6d70 6f72 7461 6e74 2066  with important f
-000144d0: 6561 7475 7265 7320 616e 6420 7472 6169  eatures and trai
-000144e0: 6e2e 2729 0a20 2020 2020 2020 2020 2020  n.').           
-000144f0: 2020 2020 2020 2020 2069 6620 6973 696e           if isin
-00014500: 7374 616e 6365 2874 6573 745f 6461 7461  stance(test_data
-00014510: 2c20 7374 7229 206f 7220 7465 7374 5f64  , str) or test_d
-00014520: 6174 6120 6973 204e 6f6e 653a 0a20 2020  ata is None:.   
-00014530: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00014540: 2020 2020 2072 6574 7572 6e20 6f6c 645f       return old_
-00014550: 696d 706f 7274 616e 745f 6665 6174 7572  important_featur
-00014560: 6573 2c20 6461 7461 6e61 6d65 5b6f 6c64  es, dataname[old
-00014570: 5f69 6d70 6f72 7461 6e74 5f66 6561 7475  _important_featu
-00014580: 7265 735d 0a20 2020 2020 2020 2020 2020  res].           
-00014590: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
-000145a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000145b0: 2020 2020 2020 2072 6574 7572 6e20 6461         return da
-000145c0: 7461 6e61 6d65 5b6f 6c64 5f69 6d70 6f72  taname[old_impor
-000145d0: 7461 6e74 5f66 6561 7475 7265 735d 2c20  tant_features], 
-000145e0: 7465 7374 5f64 6174 615b 6f6c 645f 696d  test_data[old_im
-000145f0: 706f 7274 616e 745f 6665 6174 7572 6573  portant_features
-00014600: 5d20 2020 0a20 2020 2020 2020 200a 2020  ]   .        .  
-00014610: 2020 2020 2020 6f6c 645f 7461 7267 6574        old_target
-00014620: 203d 2063 6f70 792e 6465 6570 636f 7079   = copy.deepcopy
-00014630: 2874 6172 6765 7429 0a20 2020 2020 2020  (target).       
-00014640: 2069 6620 6973 696e 7374 616e 6365 2874   if isinstance(t
-00014650: 6172 6765 742c 2073 7472 293a 0a20 2020  arget, str):.   
-00014660: 2020 2020 2020 2020 2074 6172 6765 7420           target 
-00014670: 3d20 6974 656d 5f72 6570 6c61 6365 7228  = item_replacer(
-00014680: 7461 7267 6574 2c20 7461 7267 6574 290a  target, target).
-00014690: 2020 2020 2020 2020 2020 2020 7461 7267              targ
-000146a0: 6574 7320 3d20 5b74 6172 6765 745d 0a20  ets = [target]. 
-000146b0: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
-000146c0: 2020 2020 2020 2020 2074 6172 6765 7420           target 
-000146d0: 3d20 5b69 7465 6d5f 7265 706c 6163 6572  = [item_replacer
-000146e0: 286e 2c20 6e29 2066 6f72 206e 2069 6e20  (n, n) for n in 
-000146f0: 7461 7267 6574 5d0a 2020 2020 2020 2020  target].        
-00014700: 2020 2020 7461 7267 6574 7320 3d20 636f      targets = co
-00014710: 7079 2e64 6565 7063 6f70 7928 7461 7267  py.deepcopy(targ
-00014720: 6574 290a 0a20 2020 2020 2020 2069 6620  et)..        if 
-00014730: 6f6c 645f 7461 7267 6574 203d 3d20 7461  old_target == ta
-00014740: 7267 6574 3a0a 2020 2020 2020 2020 2020  rget:.          
-00014750: 2020 2323 2044 6f6e 2774 2064 726f 7020    ## Don't drop 
-00014760: 7468 6520 6f6c 6420 7461 7267 6574 2073  the old target s
-00014770: 696e 6365 2074 6865 7265 2069 7320 6f6e  ince there is on
-00014780: 6c79 206f 6e65 2074 6172 6765 7420 6865  ly one target he
-00014790: 7265 2023 2323 0a20 2020 2020 2020 2020  re ###.         
-000147a0: 2020 2070 6173 730a 2020 2020 2020 2020     pass.        
-000147b0: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
-000147c0: 2020 2323 2320 796f 7520 646f 6e27 7420    ### you don't 
-000147d0: 6e65 6564 2064 726f 7020 7468 6520 636f  need drop the co
-000147e0: 6c73 2074 6861 7420 6861 7665 2063 6861  ls that have cha
-000147f0: 6e67 6564 2073 696e 6365 206f 6e6c 7920  nged since only 
-00014800: 6120 6665 7720 6172 6520 7365 6c65 6374  a few are select
-00014810: 6564 2023 2323 2323 2323 0a20 2020 2020  ed #######.     
-00014820: 2020 2020 2020 2069 6620 6973 696e 7374         if isinst
-00014830: 616e 6365 2874 6172 6765 742c 2073 7472  ance(target, str
-00014840: 293a 0a20 2020 2020 2020 2020 2020 2020  ):.             
-00014850: 2020 2064 6174 616e 616d 655b 7461 7267     dataname[targ
-00014860: 6574 5d20 3d20 6461 7461 6e61 6d65 5b6f  et] = dataname[o
-00014870: 6c64 5f74 6172 6765 745d 0a20 2020 2020  ld_target].     
-00014880: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
-00014890: 2020 2020 2020 2020 2020 2020 2063 6f70               cop
-000148a0: 795f 7461 7267 6574 7320 3d20 636f 7079  y_targets = copy
-000148b0: 2e64 6565 7063 6f70 7928 7461 7267 6574  .deepcopy(target
-000148c0: 7329 0a20 2020 2020 2020 2020 2020 2020  s).             
-000148d0: 2020 2063 6f70 795f 6f6c 6420 3d20 636f     copy_old = co
-000148e0: 7079 2e64 6565 7063 6f70 7928 6f6c 645f  py.deepcopy(old_
-000148f0: 7461 7267 6574 290a 2020 2020 2020 2020  target).        
-00014900: 2020 2020 2020 2020 666f 7220 6561 6368          for each
-00014910: 5f74 6172 6765 742c 2065 6163 685f 6f6c  _target, each_ol
-00014920: 645f 7461 7267 6574 2069 6e20 7a69 7028  d_target in zip(
-00014930: 636f 7079 5f74 6172 6765 7473 2c20 636f  copy_targets, co
-00014940: 7079 5f6f 6c64 293a 0a20 2020 2020 2020  py_old):.       
-00014950: 2020 2020 2020 2020 2020 2020 2064 6174               dat
-00014960: 616e 616d 655b 6561 6368 5f74 6172 6765  aname[each_targe
-00014970: 745d 203d 2064 6174 616e 616d 655b 6561  t] = dataname[ea
-00014980: 6368 5f6f 6c64 5f74 6172 6765 745d 0a0a  ch_old_target]..
-00014990: 2020 2020 2020 2020 2323 2323 2054 6869          #### Thi
-000149a0: 7320 6973 2077 6865 7265 2077 6520 6368  s is where we ch
-000149b0: 6563 6b20 7768 6574 6865 7220 746f 2072  eck whether to r
-000149c0: 6574 7572 6e20 7465 7374 2064 6174 6120  eturn test data 
-000149d0: 6f72 206e 6f74 2023 2323 2323 230a 2020  or not ######.  
-000149e0: 2020 2020 2020 7472 793a 0a20 2020 2020        try:.     
-000149f0: 2020 2020 2020 2069 6620 6973 696e 7374         if isinst
-00014a00: 616e 6365 2874 6573 745f 6461 7461 2c20  ance(test_data, 
-00014a10: 7374 7229 206f 7220 7465 7374 5f64 6174  str) or test_dat
-00014a20: 6120 6973 204e 6f6e 653a 0a20 2020 2020  a is None:.     
-00014a30: 2020 2020 2020 2020 2020 2069 6620 6665             if fe
-00014a40: 6174 7572 655f 6765 6e20 6f72 2066 6561  ature_gen or fea
-00014a50: 7475 7265 5f74 7970 653a 0a20 2020 2020  ture_type:.     
-00014a60: 2020 2020 2020 2020 2020 2020 2020 2023                 #
-00014a70: 2323 2069 6620 6665 6174 7572 6520 656e  ## if feature en
-00014a80: 6767 2069 7320 7065 7266 6f72 6d65 642c  gg is performed,
-00014a90: 2069 6420 636f 6c75 6d6e 7320 6172 6520   id columns are 
-00014aa0: 6472 6f70 7065 642e 2048 656e 6365 2074  dropped. Hence t
-00014ab0: 6865 7920 6d75 7374 2072 656a 6f69 6e20  hey must rejoin 
-00014ac0: 6865 7265 2e0a 2020 2020 2020 2020 2020  here..          
-00014ad0: 2020 2020 2020 2020 2020 6461 7461 6e61            datana
-00014ae0: 6d65 203d 2070 642e 636f 6e63 6174 285b  me = pd.concat([
-00014af0: 7472 6169 6e5f 6964 732c 2064 6174 616e  train_ids, datan
-00014b00: 616d 655d 2c20 6178 6973 3d31 290a 2020  ame], axis=1).  
-00014b10: 2020 2020 2020 2020 2020 2020 2020 7265                re
-00014b20: 7475 726e 2069 6d70 6f72 7461 6e74 5f66  turn important_f
-00014b30: 6561 7475 7265 732c 2064 6174 616e 616d  eatures, datanam
-00014b40: 655b 696d 706f 7274 616e 745f 6665 6174  e[important_feat
-00014b50: 7572 6573 2b74 6172 6765 745d 0a20 2020  ures+target].   
-00014b60: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
-00014b70: 2020 2020 2020 2020 2020 2020 2020 2023                 #
-00014b80: 2320 5468 6973 2069 7320 666f 7220 7465  # This is for te
-00014b90: 7374 2064 6174 6120 6578 6973 7469 6e67  st data existing
-00014ba0: 2023 2323 230a 2020 2020 2020 2020 2020   ####.          
-00014bb0: 2020 2020 2020 6966 2066 6561 7475 7265        if feature
-00014bc0: 5f67 656e 206f 7220 6665 6174 7572 655f  _gen or feature_
-00014bd0: 7479 7065 3a0a 2020 2020 2020 2020 2020  type:.          
-00014be0: 2020 2020 2020 2020 2020 2323 2320 6966            ### if
-00014bf0: 2066 6561 7475 7265 2065 6e67 6720 6973   feature engg is
-00014c00: 2070 6572 666f 726d 6564 2c20 6964 2063   performed, id c
-00014c10: 6f6c 756d 6e73 2061 7265 2064 726f 7070  olumns are dropp
-00014c20: 6564 2e20 4865 6e63 6520 7468 6579 206d  ed. Hence they m
-00014c30: 7573 7420 7265 6a6f 696e 2068 6572 652e  ust rejoin here.
-00014c40: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00014c50: 2020 2020 2064 6174 616e 616d 6520 3d20       dataname = 
-00014c60: 7064 2e63 6f6e 6361 7428 5b74 7261 696e  pd.concat([train
-00014c70: 5f69 6473 2c20 6461 7461 6e61 6d65 5d2c  _ids, dataname],
-00014c80: 2061 7869 733d 3129 0a20 2020 2020 2020   axis=1).       
-00014c90: 2020 2020 2020 2020 2020 2020 2074 6573               tes
-00014ca0: 745f 6461 7461 203d 2070 642e 636f 6e63  t_data = pd.conc
-00014cb0: 6174 285b 7465 7374 5f69 6473 2c20 7465  at([test_ids, te
-00014cc0: 7374 5f64 6174 615d 2c20 6178 6973 3d31  st_data], axis=1
-00014cd0: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-00014ce0: 2020 2323 2320 596f 7520 7365 6c65 6374    ### You select
-00014cf0: 2074 6865 2066 6561 7475 7265 7320 7769   the features wi
-00014d00: 7468 2074 6865 2073 616d 6520 6f6c 6420  th the same old 
-00014d10: 6e61 6d65 7320 6173 2062 6566 6f72 6520  names as before 
-00014d20: 2323 2323 2323 230a 2020 2020 2020 2020  #######.        
-00014d30: 2020 2020 2020 2020 7265 7475 726e 2064          return d
-00014d40: 6174 616e 616d 655b 696d 706f 7274 616e  ataname[importan
-00014d50: 745f 6665 6174 7572 6573 2b74 6172 6765  t_features+targe
-00014d60: 7473 5d2c 2074 6573 745f 6461 7461 5b69  ts], test_data[i
-00014d70: 6d70 6f72 7461 6e74 5f66 6561 7475 7265  mportant_feature
-00014d80: 735d 0a20 2020 2020 2020 2065 7863 6570  s].        excep
-00014d90: 743a 0a20 2020 2020 2020 2020 2020 2070  t:.            p
-00014da0: 7269 6e74 2827 5761 726e 696e 673a 2052  rint('Warning: R
-00014db0: 6574 7572 6e69 6e67 2077 6974 6820 696d  eturning with im
-00014dc0: 706f 7274 616e 7420 6665 6174 7572 6573  portant features
-00014dd0: 2061 6e64 2074 7261 696e 2e20 506c 6561   and train. Plea
-00014de0: 7365 2072 652d 6368 6563 6b20 796f 7572  se re-check your
-00014df0: 206f 7574 7075 7473 2e27 290a 2020 2020   outputs.').    
-00014e00: 2020 2020 2020 2020 7265 7475 726e 2069          return i
-00014e10: 6d70 6f72 7461 6e74 5f66 6561 7475 7265  mportant_feature
-00014e20: 732c 2064 6174 616e 616d 655b 696d 706f  s, dataname[impo
-00014e30: 7274 616e 745f 6665 6174 7572 6573 2b74  rtant_features+t
-00014e40: 6172 6765 7473 5d0a 2323 2323 2323 2323  argets].########
-00014e50: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00014e60: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00014e70: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00014e80: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00014e90: 2323 2323 2323 2323 0a64 6566 2072 656d  ########.def rem
-00014ea0: 6f76 655f 6869 6768 6c79 5f63 6f72 7265  ove_highly_corre
-00014eb0: 6c61 7465 645f 7661 7273 5f66 6173 7428  lated_vars_fast(
-00014ec0: 6466 2c20 636f 7272 5f6c 696d 6974 3d30  df, corr_limit=0
-00014ed0: 2e37 3029 3a0a 2020 2020 2222 220a 2020  .70):.    """.  
-00014ee0: 2020 5468 6973 2069 7320 6120 7369 6d70    This is a simp
-00014ef0: 6c65 206d 6574 686f 6420 746f 2072 656d  le method to rem
-00014f00: 6f76 6520 6869 6768 6c79 2063 6f72 7265  ove highly corre
-00014f10: 6c61 7465 6420 6665 6174 7572 6573 2066  lated features f
-00014f20: 6173 7420 7573 696e 6720 5065 6172 736f  ast using Pearso
-00014f30: 6e27 7320 436f 7272 656c 6174 696f 6e2e  n's Correlation.
-00014f40: 0a20 2020 2055 7365 2074 6869 7320 6f6e  .    Use this on
-00014f50: 6c79 2066 6f72 2066 6c6f 6174 2061 6e64  ly for float and
-00014f60: 2069 6e74 6567 6572 2076 6172 6961 626c   integer variabl
-00014f70: 6573 2e20 4974 2077 696c 6c20 6175 746f  es. It will auto
-00014f80: 6d61 7469 6361 6c6c 7920 7365 6c65 6374  matically select
-00014f90: 2074 686f 7365 206f 6e6c 792e 0a20 2020   those only..   
-00014fa0: 2049 7420 6361 6e20 6265 2075 7365 6420   It can be used 
-00014fb0: 666f 7220 7665 7279 206c 6172 6765 2064  for very large d
-00014fc0: 6174 6120 7365 7473 2077 6865 7265 2066  ata sets where f
-00014fd0: 6561 7475 7265 7769 7a20 6861 7320 7472  eaturewiz has tr
-00014fe0: 6f75 626c 6520 7769 7468 206d 656d 6f72  ouble with memor
-00014ff0: 790a 2020 2020 2222 220a 2020 2020 2320  y.    """.    # 
-00015000: 4372 6561 7469 6e67 2063 6f72 7265 6c61  Creating correla
-00015010: 7469 6f6e 206d 6174 7269 780a 2020 2020  tion matrix.    
-00015020: 636f 7272 656c 6174 696f 6e5f 6461 7461  correlation_data
-00015030: 6672 616d 6520 3d20 6466 2e63 6f72 7228  frame = df.corr(
-00015040: 292e 6162 7328 292e 6173 7479 7065 286e  ).abs().astype(n
-00015050: 702e 666c 6f61 7431 3629 0a20 2020 2023  p.float16).    #
-00015060: 2053 656c 6563 7469 6e67 2075 7070 6572   Selecting upper
-00015070: 2074 7269 616e 676c 6520 6f66 2063 6f72   triangle of cor
-00015080: 7265 6c61 7469 6f6e 206d 6174 7269 780a  relation matrix.
-00015090: 2020 2020 7570 7065 725f 7472 6920 3d20      upper_tri = 
-000150a0: 636f 7272 656c 6174 696f 6e5f 6461 7461  correlation_data
-000150b0: 6672 616d 652e 7768 6572 6528 6e70 2e74  frame.where(np.t
-000150c0: 7269 7528 6e70 2e6f 6e65 7328 636f 7272  riu(np.ones(corr
-000150d0: 656c 6174 696f 6e5f 6461 7461 6672 616d  elation_datafram
-000150e0: 652e 7368 6170 6529 2c0a 2020 2020 2020  e.shape),.      
-000150f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015100: 2020 2020 2020 2020 2020 2020 6b3d 3129              k=1)
-00015110: 2e61 7374 7970 6528 6e70 2e62 6f6f 6c29  .astype(np.bool)
-00015120: 290a 2020 2020 2320 4669 6e64 696e 6720  ).    # Finding 
-00015130: 696e 6465 7820 6f66 2066 6561 7475 7265  index of feature
-00015140: 2063 6f6c 756d 6e73 2077 6974 6820 636f   columns with co
-00015150: 7272 656c 6174 696f 6e20 6772 6561 7465  rrelation greate
-00015160: 7220 7468 616e 2030 2e39 350a 2020 2020  r than 0.95.    
-00015170: 746f 5f64 726f 7020 3d20 5b63 6f6c 756d  to_drop = [colum
-00015180: 6e20 666f 7220 636f 6c75 6d6e 2069 6e20  n for column in 
-00015190: 7570 7065 725f 7472 692e 636f 6c75 6d6e  upper_tri.column
-000151a0: 7320 6966 2061 6e79 2875 7070 6572 5f74  s if any(upper_t
-000151b0: 7269 5b63 6f6c 756d 6e5d 203e 2063 6f72  ri[column] > cor
-000151c0: 725f 6c69 6d69 7429 5d0a 2020 2020 7072  r_limit)].    pr
-000151d0: 696e 7428 293b 0a20 2020 2070 7269 6e74  int();.    print
-000151e0: 2827 4869 6768 6c79 2063 6f72 7265 6c61  ('Highly correla
-000151f0: 7465 6420 636f 6c75 6d6e 7320 746f 2072  ted columns to r
-00015200: 656d 6f76 653a 2025 7327 2025 746f 5f64  emove: %s' %to_d
-00015210: 726f 7029 0a20 2020 2072 6574 7572 6e20  rop).    return 
-00015220: 746f 5f64 726f 700a 2323 2323 2323 2323  to_drop.########
-00015230: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00015240: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00015250: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00015260: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00015270: 2323 2323 2323 2323 2323 2323 230a 696d  #############.im
-00015280: 706f 7274 206d 756c 7469 7072 6f63 6573  port multiproces
-00015290: 7369 6e67 0a64 6566 2067 6574 5f63 7075  sing.def get_cpu
-000152a0: 5f77 6f72 6b65 725f 636f 756e 7428 293a  _worker_count():
-000152b0: 0a20 2020 2072 6574 7572 6e20 6d75 6c74  .    return mult
-000152c0: 6970 726f 6365 7373 696e 672e 6370 755f  iprocessing.cpu_
-000152d0: 636f 756e 7428 290a 2323 2323 2323 2323  count().########
-000152e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000152f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00015300: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00015310: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00015320: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00015330: 2323 2323 230a 6672 6f6d 2069 7465 7274  #####.from itert
-00015340: 6f6f 6c73 2069 6d70 6f72 7420 636f 6d62  ools import comb
-00015350: 696e 6174 696f 6e73 0a69 6d70 6f72 7420  inations.import 
-00015360: 6d61 7470 6c6f 746c 6962 2e70 6174 6368  matplotlib.patch
-00015370: 6573 2061 7320 6d70 6174 6368 6573 0a69  es as mpatches.i
-00015380: 6d70 6f72 7420 6d61 7470 6c6f 746c 6962  mport matplotlib
-00015390: 2e70 7970 6c6f 7420 6173 2070 6c74 0a66  .pyplot as plt.f
-000153a0: 726f 6d20 736b 6c65 6172 6e2e 6665 6174  rom sklearn.feat
-000153b0: 7572 655f 7365 6c65 6374 696f 6e20 696d  ure_selection im
-000153c0: 706f 7274 2063 6869 322c 206d 7574 7561  port chi2, mutua
-000153d0: 6c5f 696e 666f 5f72 6567 7265 7373 696f  l_info_regressio
-000153e0: 6e2c 206d 7574 7561 6c5f 696e 666f 5f63  n, mutual_info_c
-000153f0: 6c61 7373 6966 0a66 726f 6d20 736b 6c65  lassif.from skle
-00015400: 6172 6e2e 6665 6174 7572 655f 7365 6c65  arn.feature_sele
-00015410: 6374 696f 6e20 696d 706f 7274 2053 656c  ction import Sel
-00015420: 6563 744b 4265 7374 0a69 6d70 6f72 7420  ectKBest.import 
-00015430: 7867 626f 6f73 740a 6465 6620 6472 6177  xgboost.def draw
-00015440: 5f66 6561 7475 7265 5f69 6d70 6f72 7461  _feature_importa
-00015450: 6e63 6573 5f6d 756c 7469 5f6c 6162 656c  nces_multi_label
-00015460: 2862 7374 5f6d 6f64 656c 732c 2064 6173  (bst_models, das
-00015470: 6b5f 7867 626f 6f73 745f 666c 6167 3d46  k_xgboost_flag=F
-00015480: 616c 7365 293a 0a20 2020 2072 6f77 7320  alse):.    rows 
-00015490: 3d20 696e 7428 6c65 6e28 6273 745f 6d6f  = int(len(bst_mo
-000154a0: 6465 6c73 292f 3220 2b20 302e 3529 0a20  dels)/2 + 0.5). 
-000154b0: 2020 2063 6f6c 7573 203d 2032 0a20 2020     colus = 2.   
-000154c0: 2066 6967 2c20 6178 203d 2070 6c74 2e73   fig, ax = plt.s
-000154d0: 7562 706c 6f74 7328 726f 7773 2c20 636f  ubplots(rows, co
-000154e0: 6c75 7329 0a20 2020 2066 6967 2e73 6574  lus).    fig.set
-000154f0: 5f73 697a 655f 696e 6368 6573 286d 696e  _size_inches(min
-00015500: 2863 6f6c 7573 2a35 2c32 3029 2c72 6f77  (colus*5,20),row
-00015510: 732a 3529 0a20 2020 2066 6967 2e73 7562  s*5).    fig.sub
-00015520: 706c 6f74 735f 6164 6a75 7374 2868 7370  plots_adjust(hsp
-00015530: 6163 653d 302e 3529 2023 2323 2054 6869  ace=0.5) ### Thi
-00015540: 7320 636f 6e74 726f 6c73 2074 6865 2073  s controls the s
-00015550: 7061 6365 2062 6574 7765 6e20 726f 7773  pace betwen rows
-00015560: 0a20 2020 2066 6967 2e73 7562 706c 6f74  .    fig.subplot
-00015570: 735f 6164 6a75 7374 2877 7370 6163 653d  s_adjust(wspace=
-00015580: 302e 3529 2023 2323 2054 6869 7320 636f  0.5) ### This co
-00015590: 6e74 726f 6c73 2074 6865 2073 7061 6365  ntrols the space
-000155a0: 2062 6574 7765 656e 2063 6f6c 756d 6e73   between columns
-000155b0: 0a20 2020 2063 6f75 6e74 6572 203d 2030  .    counter = 0
-000155c0: 0a20 2020 2069 6620 726f 7773 203d 3d20  .    if rows == 
-000155d0: 313a 0a20 2020 2020 2020 2061 7820 3d20  1:.        ax = 
-000155e0: 6178 2e72 6573 6861 7065 282d 312c 3129  ax.reshape(-1,1)
-000155f0: 2e54 0a20 2020 2066 6f72 206b 2069 6e20  .T.    for k in 
-00015600: 6e70 2e61 7261 6e67 6528 726f 7773 293a  np.arange(rows):
-00015610: 0a20 2020 2020 2020 2066 6f72 206c 2069  .        for l i
-00015620: 6e20 6e70 2e61 7261 6e67 6528 636f 6c75  n np.arange(colu
-00015630: 7329 3a0a 2020 2020 2020 2020 2020 2020  s):.            
-00015640: 6966 2063 6f75 6e74 6572 203c 206c 656e  if counter < len
-00015650: 2862 7374 5f6d 6f64 656c 7329 3a0a 2020  (bst_models):.  
-00015660: 2020 2020 2020 2020 2020 2020 2020 7472                tr
-00015670: 793a 0a20 2020 2020 2020 2020 2020 2020  y:.             
-00015680: 2020 2020 2020 2062 7374 5f62 6f6f 7374         bst_boost
-00015690: 6572 203d 2062 7374 5f6d 6f64 656c 735b  er = bst_models[
-000156a0: 636f 756e 7465 725d 2e65 7374 696d 6174  counter].estimat
-000156b0: 6f72 735f 5b30 5d0a 2020 2020 2020 2020  ors_[0].        
-000156c0: 2020 2020 2020 2020 2020 2020 6178 3120              ax1 
-000156d0: 3d20 7867 626f 6f73 742e 706c 6f74 5f69  = xgboost.plot_i
-000156e0: 6d70 6f72 7461 6e63 6528 6273 745f 626f  mportance(bst_bo
-000156f0: 6f73 7465 722c 2068 6569 6768 743d 302e  oster, height=0.
-00015700: 382c 2073 686f 775f 7661 6c75 6573 3d46  8, show_values=F
-00015710: 616c 7365 2c0a 2020 2020 2020 2020 2020  alse,.          
-00015720: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015730: 2020 696d 706f 7274 616e 6365 5f74 7970    importance_typ
-00015740: 653d 2767 6169 6e27 2c20 6d61 785f 6e75  e='gain', max_nu
-00015750: 6d5f 6665 6174 7572 6573 3d31 302c 2061  m_features=10, a
-00015760: 783d 6178 5b6b 5d5b 6c5d 290a 2020 2020  x=ax[k][l]).    
-00015770: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015780: 6178 312e 7365 745f 7469 746c 6528 274d  ax1.set_title('M
-00015790: 756c 7469 5f6c 6162 656c 3a20 546f 7020  ulti_label: Top 
-000157a0: 3130 2066 6561 7475 7265 7320 666f 7220  10 features for 
-000157b0: 6669 7273 7420 6c61 6265 6c3a 2072 6f75  first label: rou
-000157c0: 6e64 2025 7327 2025 2863 6f75 6e74 6572  nd %s' %(counter
-000157d0: 2b31 2929 0a20 2020 2020 2020 2020 2020  +1)).           
-000157e0: 2020 2020 2065 7863 6570 743a 0a20 2020       except:.   
-000157f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015800: 2070 6173 730a 2020 2020 2020 2020 2020   pass.          
-00015810: 2020 636f 756e 7465 7220 2b3d 2031 0a20    counter += 1. 
-00015820: 2020 2070 6c74 2e73 686f 7728 293b 0a23     plt.show();.#
+00013850: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00013860: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00013870: 2229 0a20 2020 2064 6963 746f 203d 207b  ").    dicto = {
+00013880: 7d0a 2020 2020 6d69 7373 696e 675f 666c  }.    missing_fl
+00013890: 6167 7331 203d 205b 7b78 3a78 5b3a 2d31  ags1 = [{x:x[:-1
+000138a0: 335d 7d20 666f 7220 7820 696e 2069 6d70  3]} for x in imp
+000138b0: 6f72 7461 6e74 5f66 6561 7475 7265 7320  ortant_features 
+000138c0: 6966 2027 4d69 7373 696e 675f 466c 6167  if 'Missing_Flag
+000138d0: 2720 696e 2078 5d0a 2020 2020 666f 7220  ' in x].    for 
+000138e0: 6561 6368 5f66 6c61 6720 696e 206d 6973  each_flag in mis
+000138f0: 7369 6e67 5f66 6c61 6773 313a 0a20 2020  sing_flags1:.   
+00013900: 2020 2020 2070 7269 6e74 2827 416c 6572       print('Aler
+00013910: 743a 2044 6f6e 7420 666f 7267 6574 2074  t: Dont forget t
+00013920: 6f20 6164 6420 6120 6d69 7373 696e 6720  o add a missing 
+00013930: 666c 6167 2074 6f20 2573 2074 6f20 6372  flag to %s to cr
+00013940: 6561 7465 2025 7320 636f 6c75 6d6e 2720  eate %s column' 
+00013950: 2528 6c69 7374 2865 6163 685f 666c 6167  %(list(each_flag
+00013960: 2e76 616c 7565 7328 2929 5b30 5d2c 206c  .values())[0], l
+00013970: 6973 7428 6561 6368 5f66 6c61 672e 6b65  ist(each_flag.ke
+00013980: 7973 2829 295b 305d 2929 0a20 2020 2020  ys())[0])).     
+00013990: 2020 2064 6963 746f 2e75 7064 6174 6528     dicto.update(
+000139a0: 6561 6368 5f66 6c61 6729 0a20 2020 2069  each_flag).    i
+000139b0: 6620 6c65 6e28 6469 6374 6f29 203e 2030  f len(dicto) > 0
+000139c0: 3a0a 2020 2020 2020 2020 696d 706f 7274  :.        import
+000139d0: 616e 745f 6665 6174 7572 6573 203d 205b  ant_features = [
+000139e0: 6469 6374 6f2e 6765 7428 6974 656d 2c69  dicto.get(item,i
+000139f0: 7465 6d29 2020 666f 7220 6974 656d 2069  tem)  for item i
+00013a00: 6e20 696d 706f 7274 616e 745f 6665 6174  n important_feat
+00013a10: 7572 6573 5d0a 2020 2020 2020 2020 696d  ures].        im
+00013a20: 706f 7274 616e 745f 6665 6174 7572 6573  portant_features
+00013a30: 203d 206c 6973 7428 7365 7428 696d 706f   = list(set(impo
+00013a40: 7274 616e 745f 6665 6174 7572 6573 2929  rtant_features))
+00013a50: 0a20 2020 2069 6620 6c65 6e28 696d 706f  .    if len(impo
+00013a60: 7274 616e 745f 6665 6174 7572 6573 2920  rtant_features) 
+00013a70: 3c3d 2033 303a 0a20 2020 2020 2020 2070  <= 30:.        p
+00013a80: 7269 6e74 2827 5365 6c65 6374 6564 2025  rint('Selected %
+00013a90: 6420 696d 706f 7274 616e 7420 6665 6174  d important feat
+00013aa0: 7572 6573 3a5c 6e25 7327 2025 286c 656e  ures:\n%s' %(len
+00013ab0: 2869 6d70 6f72 7461 6e74 5f66 6561 7475  (important_featu
+00013ac0: 7265 7329 2c20 696d 706f 7274 616e 745f  res), important_
+00013ad0: 6665 6174 7572 6573 2929 0a20 2020 2065  features)).    e
+00013ae0: 6c73 653a 0a20 2020 2020 2020 2070 7269  lse:.        pri
+00013af0: 6e74 2827 5365 6c65 6374 6564 2025 6420  nt('Selected %d 
+00013b00: 696d 706f 7274 616e 7420 6665 6174 7572  important featur
+00013b10: 6573 2e20 546f 6f20 6d61 6e79 2074 6f20  es. Too many to 
+00013b20: 7072 696e 742e 2e2e 2720 256c 656e 2869  print...' %len(i
+00013b30: 6d70 6f72 7461 6e74 5f66 6561 7475 7265  mportant_feature
+00013b40: 7329 290a 2020 2020 6e75 6d76 6172 7320  s)).    numvars 
+00013b50: 3d20 5b78 2066 6f72 2078 2069 6e20 6e75  = [x for x in nu
+00013b60: 6d76 6172 7320 6966 2078 2069 6e20 696d  mvars if x in im
+00013b70: 706f 7274 616e 745f 6665 6174 7572 6573  portant_features
+00013b80: 5d0a 2020 2020 696d 706f 7274 616e 745f  ].    important_
+00013b90: 6361 7473 203d 205b 7820 666f 7220 7820  cats = [x for x 
+00013ba0: 696e 2069 6d70 6f72 7461 6e74 5f63 6174  in important_cat
+00013bb0: 7320 6966 2078 2069 6e20 696d 706f 7274  s if x in import
+00013bc0: 616e 745f 6665 6174 7572 6573 5d0a 2020  ant_features].  
+00013bd0: 2020 7072 696e 7428 2754 6f74 616c 2054    print('Total T
+00013be0: 696d 6520 7461 6b65 6e20 666f 7220 6665  ime taken for fe
+00013bf0: 6174 7572 6577 697a 2073 656c 6563 7469  aturewiz selecti
+00013c00: 6f6e 203d 2025 302e 3066 2073 6563 6f6e  on = %0.0f secon
+00013c10: 6473 2720 2528 7469 6d65 2e74 696d 6528  ds' %(time.time(
+00013c20: 292d 7374 6172 745f 7469 6d65 2929 0a20  )-start_time)). 
+00013c30: 2020 2023 2323 2320 4e6f 7720 6368 616e     #### Now chan
+00013c40: 6765 2074 6865 2066 6561 7475 7265 206e  ge the feature n
+00013c50: 616d 6573 2062 6163 6b20 746f 206f 7269  ames back to ori
+00013c60: 6769 6e61 6c20 6665 6174 7572 6520 6e61  ginal feature na
+00013c70: 6d65 7320 2323 2323 2323 2323 2323 2323  mes ############
+00013c80: 2323 2323 0a20 2020 2069 7465 6d5f 7265  ####.    item_re
+00013c90: 706c 6163 6572 203d 2063 6f6c 5f6e 616d  placer = col_nam
+00013ca0: 655f 6d61 7070 6572 2e67 6574 2020 2320  e_mapper.get  # 
+00013cb0: 466f 7220 6661 7374 6572 2067 6574 732e  For faster gets.
+00013cc0: 0a20 2020 2023 2323 2323 2323 2323 2323  .    ###########
+00013cd0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00013ce0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00013cf0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00013d00: 2323 2323 2323 2323 2323 2323 2323 230a  ###############.
+00013d10: 2020 2020 2323 2320 596f 7520 7365 6c65      ### You sele
+00013d20: 6374 2074 6865 2066 6561 7475 7265 7320  ct the features 
+00013d30: 7769 7468 2074 6865 2073 616d 6520 6f6c  with the same ol
+00013d40: 6420 6e61 6d65 7320 6173 2062 6566 6f72  d names as befor
+00013d50: 6520 6865 7265 2023 2323 2323 2323 0a20  e here #######. 
+00013d60: 2020 2023 2323 2323 2323 2323 2323 2323     #############
+00013d70: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00013d80: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00013d90: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00013da0: 2323 2323 2323 2323 2323 2323 230a 2020  #############.  
+00013db0: 2020 2323 2049 6e20 6f6e 6520 6361 7365    ## In one case
+00013dc0: 2c20 636f 6c75 6d6e 206e 616d 6573 2067  , column names g
+00013dd0: 6574 2063 6861 6e67 6564 2069 6e20 7472  et changed in tr
+00013de0: 6169 6e20 6275 7420 6e6f 7420 696e 2074  ain but not in t
+00013df0: 6573 7420 7369 6e63 6520 6974 2074 6573  est since it tes
+00013e00: 7420 6973 206e 6f74 2061 7661 696c 6162  t is not availab
+00013e10: 6c65 2e0a 2020 2020 6966 2069 7369 6e73  le..    if isins
+00013e20: 7461 6e63 6528 7465 7374 5f64 6174 612c  tance(test_data,
+00013e30: 2073 7472 2920 6f72 2074 6573 745f 6461   str) or test_da
+00013e40: 7461 2069 7320 4e6f 6e65 3a0a 2020 2020  ta is None:.    
+00013e50: 2020 2020 7072 696e 7428 274f 7574 7075      print('Outpu
+00013e60: 7420 636f 6e74 6169 6e73 2061 206c 6973  t contains a lis
+00013e70: 7420 6f66 2025 7320 696d 706f 7274 616e  t of %s importan
+00013e80: 7420 6665 6174 7572 6573 2061 6e64 2061  t features and a
+00013e90: 2074 7261 696e 2064 6174 6166 7261 6d65   train dataframe
+00013ea0: 2720 256c 656e 2869 6d70 6f72 7461 6e74  ' %len(important
+00013eb0: 5f66 6561 7475 7265 7329 290a 2020 2020  _features)).    
+00013ec0: 656c 7365 3a0a 2020 2020 2020 2020 7072  else:.        pr
+00013ed0: 696e 7428 274f 7574 7075 7420 636f 6e74  int('Output cont
+00013ee0: 6169 6e73 2074 776f 2064 6174 6166 7261  ains two datafra
+00013ef0: 6d65 733a 2074 7261 696e 2061 6e64 2074  mes: train and t
+00013f00: 6573 7420 7769 7468 2025 6420 696d 706f  est with %d impo
+00013f10: 7274 616e 7420 6665 6174 7572 6573 2e27  rtant features.'
+00013f20: 2025 6c65 6e28 696d 706f 7274 616e 745f   %len(important_
+00013f30: 6665 6174 7572 6573 2929 0a20 2020 2069  features)).    i
+00013f40: 6620 6665 6174 7572 655f 6765 6e20 6f72  f feature_gen or
+00013f50: 2066 6561 7475 7265 5f74 7970 653a 0a20   feature_type:. 
+00013f60: 2020 2020 2020 2069 6620 6973 696e 7374         if isinst
+00013f70: 616e 6365 2874 6573 745f 6461 7461 2c20  ance(test_data, 
+00013f80: 7374 7229 206f 7220 7465 7374 5f64 6174  str) or test_dat
+00013f90: 6120 6973 204e 6f6e 653a 0a20 2020 2020  a is None:.     
+00013fa0: 2020 2020 2020 2023 2323 2069 6620 6665         ### if fe
+00013fb0: 6174 7572 6520 656e 6767 2069 7320 7065  ature engg is pe
+00013fc0: 7266 6f72 6d65 642c 2069 6420 636f 6c75  rformed, id colu
+00013fd0: 6d6e 7320 6172 6520 6472 6f70 7065 642e  mns are dropped.
+00013fe0: 2048 656e 6365 2074 6865 7920 6d75 7374   Hence they must
+00013ff0: 2072 656a 6f69 6e20 6865 7265 2e0a 2020   rejoin here..  
+00014000: 2020 2020 2020 2020 2020 6461 7461 6e61            datana
+00014010: 6d65 203d 2070 642e 636f 6e63 6174 285b  me = pd.concat([
+00014020: 7472 6169 6e5f 6964 732c 2064 6174 616e  train_ids, datan
+00014030: 616d 655d 2c20 6178 6973 3d31 290a 2020  ame], axis=1).  
+00014040: 2020 2020 2020 2020 2020 6966 2069 7369            if isi
+00014050: 6e73 7461 6e63 6528 7461 7267 6574 2c20  nstance(target, 
+00014060: 7374 7229 3a0a 2020 2020 2020 2020 2020  str):.          
+00014070: 2020 2020 2020 7265 7475 726e 2069 6d70        return imp
+00014080: 6f72 7461 6e74 5f66 6561 7475 7265 732c  ortant_features,
+00014090: 2064 6174 616e 616d 655b 696d 706f 7274   dataname[import
+000140a0: 616e 745f 6665 6174 7572 6573 2b5b 7461  ant_features+[ta
+000140b0: 7267 6574 5d5d 0a20 2020 2020 2020 2020  rget]].         
+000140c0: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+000140d0: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+000140e0: 696d 706f 7274 616e 745f 6665 6174 7572  important_featur
+000140f0: 6573 2c20 6461 7461 6e61 6d65 5b69 6d70  es, dataname[imp
+00014100: 6f72 7461 6e74 5f66 6561 7475 7265 732b  ortant_features+
+00014110: 7461 7267 6574 5d0a 2020 2020 2020 2020  target].        
+00014120: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
+00014130: 2020 2323 2320 6966 2066 6561 7475 7265    ### if feature
+00014140: 2065 6e67 6720 6973 2070 6572 666f 726d   engg is perform
+00014150: 6564 2c20 6964 2063 6f6c 756d 6e73 2061  ed, id columns a
+00014160: 7265 2064 726f 7070 6564 2e20 4865 6e63  re dropped. Henc
+00014170: 6520 7468 6579 206d 7573 7420 7265 6a6f  e they must rejo
+00014180: 696e 2068 6572 652e 0a20 2020 2020 2020  in here..       
+00014190: 2020 2020 2064 6174 616e 616d 6520 3d20       dataname = 
+000141a0: 7064 2e63 6f6e 6361 7428 5b74 7261 696e  pd.concat([train
+000141b0: 5f69 6473 2c20 6461 7461 6e61 6d65 5d2c  _ids, dataname],
+000141c0: 2061 7869 733d 3129 0a20 2020 2020 2020   axis=1).       
+000141d0: 2020 2020 2074 6573 745f 6461 7461 203d       test_data =
+000141e0: 2070 642e 636f 6e63 6174 285b 7465 7374   pd.concat([test
+000141f0: 5f69 6473 2c20 7465 7374 5f64 6174 615d  _ids, test_data]
+00014200: 2c20 6178 6973 3d31 290a 2020 2020 2020  , axis=1).      
+00014210: 2020 2020 2020 6966 2069 7369 6e73 7461        if isinsta
+00014220: 6e63 6528 7461 7267 6574 2c20 7374 7229  nce(target, str)
+00014230: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00014240: 2020 7265 7475 726e 2064 6174 616e 616d    return datanam
+00014250: 655b 696d 706f 7274 616e 745f 6665 6174  e[important_feat
+00014260: 7572 6573 2b5b 7461 7267 6574 5d5d 2c20  ures+[target]], 
+00014270: 7465 7374 5f64 6174 615b 696d 706f 7274  test_data[import
+00014280: 616e 745f 6665 6174 7572 6573 5d0a 2020  ant_features].  
+00014290: 2020 2020 2020 2020 2020 656c 7365 3a0a            else:.
+000142a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000142b0: 7265 7475 726e 2064 6174 616e 616d 655b  return dataname[
+000142c0: 696d 706f 7274 616e 745f 6665 6174 7572  important_featur
+000142d0: 6573 2b74 6172 6765 745d 2c20 7465 7374  es+target], test
+000142e0: 5f64 6174 615b 696d 706f 7274 616e 745f  _data[important_
+000142f0: 6665 6174 7572 6573 5d0a 2020 2020 656c  features].    el
+00014300: 7365 3a0a 2020 2020 2020 2020 2323 2320  se:.        ### 
+00014310: 596f 7520 7365 6c65 6374 2074 6865 2066  You select the f
+00014320: 6561 7475 7265 7320 7769 7468 2074 6865  eatures with the
+00014330: 2073 616d 6520 6f6c 6420 6e61 6d65 7320   same old names 
+00014340: 6173 2062 6566 6f72 6520 2323 2323 2323  as before ######
+00014350: 230a 2020 2020 2020 2020 6f6c 645f 696d  #.        old_im
+00014360: 706f 7274 616e 745f 6665 6174 7572 6573  portant_features
+00014370: 203d 2063 6f70 792e 6465 6570 636f 7079   = copy.deepcopy
+00014380: 2869 6d70 6f72 7461 6e74 5f66 6561 7475  (important_featu
+00014390: 7265 7329 0a20 2020 2020 2020 2069 6620  res).        if 
+000143a0: 6c65 6e28 6461 7465 5f63 6f6c 7329 203e  len(date_cols) >
+000143b0: 2030 3a0a 2020 2020 2020 2020 2020 2020   0:.            
+000143c0: 6461 7465 5f72 6570 6c61 6365 7220 3d20  date_replacer = 
+000143d0: 6461 7465 5f63 6f6c 5f6d 6170 7065 7273  date_col_mappers
+000143e0: 2e67 6574 2020 2320 466f 7220 6661 7374  .get  # For fast
+000143f0: 6572 2067 6574 732e 0a20 2020 2020 2020  er gets..       
+00014400: 2020 2020 2069 6d70 6f72 7461 6e74 5f66       important_f
+00014410: 6561 7475 7265 7331 203d 205b 6461 7465  eatures1 = [date
+00014420: 5f72 6570 6c61 6365 7228 6e2c 206e 2920  _replacer(n, n) 
+00014430: 666f 7220 6e20 696e 2069 6d70 6f72 7461  for n in importa
+00014440: 6e74 5f66 6561 7475 7265 735d 0a20 2020  nt_features].   
+00014450: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
+00014460: 2020 2020 2020 2069 6d70 6f72 7461 6e74         important
+00014470: 5f66 6561 7475 7265 7331 203d 205b 6974  _features1 = [it
+00014480: 656d 5f72 6570 6c61 6365 7228 6e2c 206e  em_replacer(n, n
+00014490: 2920 666f 7220 6e20 696e 2069 6d70 6f72  ) for n in impor
+000144a0: 7461 6e74 5f66 6561 7475 7265 735d 0a20  tant_features]. 
+000144b0: 2020 2020 2020 2069 6d70 6f72 7461 6e74         important
+000144c0: 5f66 6561 7475 7265 7320 3d20 6669 6e64  _features = find
+000144d0: 5f72 656d 6f76 655f 6475 706c 6963 6174  _remove_duplicat
+000144e0: 6573 2869 6d70 6f72 7461 6e74 5f66 6561  es(important_fea
+000144f0: 7475 7265 7331 290a 2020 2020 2020 2020  tures1).        
+00014500: 6966 206f 6c64 5f69 6d70 6f72 7461 6e74  if old_important
+00014510: 5f66 6561 7475 7265 7320 3d3d 2069 6d70  _features == imp
+00014520: 6f72 7461 6e74 5f66 6561 7475 7265 733a  ortant_features:
+00014530: 0a20 2020 2020 2020 2020 2020 2023 2320  .            ## 
+00014540: 446f 6e27 7420 6472 6f70 2074 6865 206f  Don't drop the o
+00014550: 6c64 2074 6172 6765 7420 7369 6e63 6520  ld target since 
+00014560: 7468 6572 6520 6973 206f 6e6c 7920 6f6e  there is only on
+00014570: 6520 7461 7267 6574 2068 6572 6520 2323  e target here ##
+00014580: 230a 2020 2020 2020 2020 2020 2020 7061  #.            pa
+00014590: 7373 0a20 2020 2020 2020 2065 6c73 653a  ss.        else:
+000145a0: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+000145b0: 6c65 6e28 6f6c 645f 696d 706f 7274 616e  len(old_importan
+000145c0: 745f 6665 6174 7572 6573 2920 3d3d 206c  t_features) == l
+000145d0: 656e 2869 6d70 6f72 7461 6e74 5f66 6561  en(important_fea
+000145e0: 7475 7265 7329 3a0a 2020 2020 2020 2020  tures):.        
+000145f0: 2020 2020 2020 2020 2323 2320 596f 7520          ### You 
+00014600: 6a75 7374 206d 6f76 6520 7468 6520 7661  just move the va
+00014610: 6c75 6573 2066 726f 6d20 7468 6520 6e65  lues from the ne
+00014620: 7720 6e61 6d65 7320 746f 2074 6865 206f  w names to the o
+00014630: 6c64 2066 6561 7475 7265 206e 616d 6573  ld feature names
+00014640: 2023 230a 2020 2020 2020 2020 2020 2020   ##.            
+00014650: 2020 2020 6461 7461 6e61 6d65 5b69 6d70      dataname[imp
+00014660: 6f72 7461 6e74 5f66 6561 7475 7265 735d  ortant_features]
+00014670: 203d 2064 6174 616e 616d 655b 6f6c 645f   = dataname[old_
+00014680: 696d 706f 7274 616e 745f 6665 6174 7572  important_featur
+00014690: 6573 5d0a 2020 2020 2020 2020 2020 2020  es].            
+000146a0: 2020 2020 6966 2069 7369 6e73 7461 6e63      if isinstanc
+000146b0: 6528 7465 7374 5f64 6174 612c 2073 7472  e(test_data, str
+000146c0: 2920 6f72 2074 6573 745f 6461 7461 2069  ) or test_data i
+000146d0: 7320 4e6f 6e65 3a0a 2020 2020 2020 2020  s None:.        
+000146e0: 2020 2020 2020 2020 2020 2020 7061 7373              pass
+000146f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00014700: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+00014710: 2020 2020 2020 2020 2020 2023 2323 2320             #### 
+00014720: 6966 2074 6865 7265 2069 7320 7465 7374  if there is test
+00014730: 2064 6174 6120 7472 616e 7366 6572 2076   data transfer v
+00014740: 616c 7565 7320 746f 2069 7420 2323 230a  alues to it ###.
+00014750: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014760: 2020 2020 7465 7374 5f64 6174 615b 696d      test_data[im
+00014770: 706f 7274 616e 745f 6665 6174 7572 6573  portant_features
+00014780: 5d20 3d20 7465 7374 5f64 6174 615b 6f6c  ] = test_data[ol
+00014790: 645f 696d 706f 7274 616e 745f 6665 6174  d_important_feat
+000147a0: 7572 6573 5d0a 2020 2020 2020 2020 2020  ures].          
+000147b0: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+000147c0: 2020 2020 2020 2020 2323 2320 6669 7273          ### firs
+000147d0: 7420 7472 7920 746f 2072 6574 7572 6e20  t try to return 
+000147e0: 7769 7468 2074 6865 206e 6577 2069 6d70  with the new imp
+000147f0: 6f72 7461 6e74 2066 6561 7475 7265 732c  ortant features,
+00014800: 2069 6620 7468 6174 2066 6169 6c73 2072   if that fails r
+00014810: 6574 7572 6e20 7769 7468 206f 6c64 2066  eturn with old f
+00014820: 6561 7475 7265 730a 2020 2020 2020 2020  eatures.        
+00014830: 2020 2020 2020 2020 7472 793a 0a20 2020          try:.   
+00014840: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014850: 2070 7269 6e74 2827 5468 6572 6520 6172   print('There ar
+00014860: 6520 7370 6563 6961 6c20 6368 6172 7320  e special chars 
+00014870: 696e 2063 6f6c 756d 6e20 6e61 6d65 732e  in column names.
+00014880: 2050 6c65 6173 6520 7265 6d6f 7665 2074   Please remove t
+00014890: 6865 6d20 616e 6420 7472 7920 6167 6169  hem and try agai
+000148a0: 6e2e 2729 0a20 2020 2020 2020 2020 2020  n.').           
+000148b0: 2020 2020 2020 2020 2069 6620 6973 696e           if isin
+000148c0: 7374 616e 6365 2874 6573 745f 6461 7461  stance(test_data
+000148d0: 2c20 7374 7229 206f 7220 7465 7374 5f64  , str) or test_d
+000148e0: 6174 6120 6973 204e 6f6e 653a 0a20 2020  ata is None:.   
+000148f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014900: 2020 2020 2072 6574 7572 6e20 696d 706f       return impo
+00014910: 7274 616e 745f 6665 6174 7572 6573 2c20  rtant_features, 
+00014920: 6461 7461 6e61 6d65 5b69 6d70 6f72 7461  dataname[importa
+00014930: 6e74 5f66 6561 7475 7265 735d 0a20 2020  nt_features].   
+00014940: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014950: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+00014960: 2020 2020 2020 2020 2020 2020 2020 2072                 r
+00014970: 6574 7572 6e20 6461 7461 6e61 6d65 5b69  eturn dataname[i
+00014980: 6d70 6f72 7461 6e74 5f66 6561 7475 7265  mportant_feature
+00014990: 735d 2c20 7465 7374 5f64 6174 615b 696d  s], test_data[im
+000149a0: 706f 7274 616e 745f 6665 6174 7572 6573  portant_features
+000149b0: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
+000149c0: 2020 6578 6365 7074 3a0a 2020 2020 2020    except:.      
+000149d0: 2020 2020 2020 2020 2020 2020 2020 7072                pr
+000149e0: 696e 7428 2754 6865 7265 2061 7265 2073  int('There are s
+000149f0: 7065 6369 616c 2063 6861 7273 2069 6e20  pecial chars in 
+00014a00: 636f 6c75 6d6e 206e 616d 6573 2e20 5265  column names. Re
+00014a10: 7475 726e 696e 6720 7769 7468 2069 6d70  turning with imp
+00014a20: 6f72 7461 6e74 2066 6561 7475 7265 7320  ortant features 
+00014a30: 616e 6420 7472 6169 6e2e 2729 0a20 2020  and train.').   
+00014a40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014a50: 2069 6620 6973 696e 7374 616e 6365 2874   if isinstance(t
+00014a60: 6573 745f 6461 7461 2c20 7374 7229 206f  est_data, str) o
+00014a70: 7220 7465 7374 5f64 6174 6120 6973 204e  r test_data is N
+00014a80: 6f6e 653a 0a20 2020 2020 2020 2020 2020  one:.           
+00014a90: 2020 2020 2020 2020 2020 2020 2072 6574               ret
+00014aa0: 7572 6e20 6f6c 645f 696d 706f 7274 616e  urn old_importan
+00014ab0: 745f 6665 6174 7572 6573 2c20 6461 7461  t_features, data
+00014ac0: 6e61 6d65 5b6f 6c64 5f69 6d70 6f72 7461  name[old_importa
+00014ad0: 6e74 5f66 6561 7475 7265 735d 0a20 2020  nt_features].   
+00014ae0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014af0: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+00014b00: 2020 2020 2020 2020 2020 2020 2020 2072                 r
+00014b10: 6574 7572 6e20 6461 7461 6e61 6d65 5b6f  eturn dataname[o
+00014b20: 6c64 5f69 6d70 6f72 7461 6e74 5f66 6561  ld_important_fea
+00014b30: 7475 7265 735d 2c20 7465 7374 5f64 6174  tures], test_dat
+00014b40: 615b 6f6c 645f 696d 706f 7274 616e 745f  a[old_important_
+00014b50: 6665 6174 7572 6573 5d20 2020 0a20 2020  features]   .   
+00014b60: 2020 2020 200a 2020 2020 2020 2020 6f6c       .        ol
+00014b70: 645f 7461 7267 6574 203d 2063 6f70 792e  d_target = copy.
+00014b80: 6465 6570 636f 7079 2874 6172 6765 7429  deepcopy(target)
+00014b90: 0a20 2020 2020 2020 2069 6620 6973 696e  .        if isin
+00014ba0: 7374 616e 6365 2874 6172 6765 742c 2073  stance(target, s
+00014bb0: 7472 293a 0a20 2020 2020 2020 2020 2020  tr):.           
+00014bc0: 2074 6172 6765 7420 3d20 6974 656d 5f72   target = item_r
+00014bd0: 6570 6c61 6365 7228 7461 7267 6574 2c20  eplacer(target, 
+00014be0: 7461 7267 6574 290a 2020 2020 2020 2020  target).        
+00014bf0: 2020 2020 7461 7267 6574 7320 3d20 5b74      targets = [t
+00014c00: 6172 6765 745d 0a20 2020 2020 2020 2065  arget].        e
+00014c10: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+00014c20: 2074 6172 6765 7420 3d20 5b69 7465 6d5f   target = [item_
+00014c30: 7265 706c 6163 6572 286e 2c20 6e29 2066  replacer(n, n) f
+00014c40: 6f72 206e 2069 6e20 7461 7267 6574 5d0a  or n in target].
+00014c50: 2020 2020 2020 2020 2020 2020 7461 7267              targ
+00014c60: 6574 7320 3d20 636f 7079 2e64 6565 7063  ets = copy.deepc
+00014c70: 6f70 7928 7461 7267 6574 290a 0a20 2020  opy(target)..   
+00014c80: 2020 2020 2069 6620 6f6c 645f 7461 7267       if old_targ
+00014c90: 6574 203d 3d20 7461 7267 6574 3a0a 2020  et == target:.  
+00014ca0: 2020 2020 2020 2020 2020 2323 2044 6f6e            ## Don
+00014cb0: 2774 2064 726f 7020 7468 6520 6f6c 6420  't drop the old 
+00014cc0: 7461 7267 6574 2073 696e 6365 2074 6865  target since the
+00014cd0: 7265 2069 7320 6f6e 6c79 206f 6e65 2074  re is only one t
+00014ce0: 6172 6765 7420 6865 7265 2023 2323 0a20  arget here ###. 
+00014cf0: 2020 2020 2020 2020 2020 2070 6173 730a             pass.
+00014d00: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
+00014d10: 2020 2020 2020 2020 2020 2323 2320 796f            ### yo
+00014d20: 7520 646f 6e27 7420 6e65 6564 2064 726f  u don't need dro
+00014d30: 7020 7468 6520 636f 6c73 2074 6861 7420  p the cols that 
+00014d40: 6861 7665 2063 6861 6e67 6564 2073 696e  have changed sin
+00014d50: 6365 206f 6e6c 7920 6120 6665 7720 6172  ce only a few ar
+00014d60: 6520 7365 6c65 6374 6564 2023 2323 2323  e selected #####
+00014d70: 2323 0a20 2020 2020 2020 2020 2020 2069  ##.            i
+00014d80: 6620 6973 696e 7374 616e 6365 2874 6172  f isinstance(tar
+00014d90: 6765 742c 2073 7472 293a 0a20 2020 2020  get, str):.     
+00014da0: 2020 2020 2020 2020 2020 2064 6174 616e             datan
+00014db0: 616d 655b 7461 7267 6574 5d20 3d20 6461  ame[target] = da
+00014dc0: 7461 6e61 6d65 5b6f 6c64 5f74 6172 6765  taname[old_targe
+00014dd0: 745d 0a20 2020 2020 2020 2020 2020 2065  t].            e
+00014de0: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+00014df0: 2020 2020 2063 6f70 795f 7461 7267 6574       copy_target
+00014e00: 7320 3d20 636f 7079 2e64 6565 7063 6f70  s = copy.deepcop
+00014e10: 7928 7461 7267 6574 7329 0a20 2020 2020  y(targets).     
+00014e20: 2020 2020 2020 2020 2020 2063 6f70 795f             copy_
+00014e30: 6f6c 6420 3d20 636f 7079 2e64 6565 7063  old = copy.deepc
+00014e40: 6f70 7928 6f6c 645f 7461 7267 6574 290a  opy(old_target).
+00014e50: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00014e60: 666f 7220 6561 6368 5f74 6172 6765 742c  for each_target,
+00014e70: 2065 6163 685f 6f6c 645f 7461 7267 6574   each_old_target
+00014e80: 2069 6e20 7a69 7028 636f 7079 5f74 6172   in zip(copy_tar
+00014e90: 6765 7473 2c20 636f 7079 5f6f 6c64 293a  gets, copy_old):
+00014ea0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00014eb0: 2020 2020 2064 6174 616e 616d 655b 6561       dataname[ea
+00014ec0: 6368 5f74 6172 6765 745d 203d 2064 6174  ch_target] = dat
+00014ed0: 616e 616d 655b 6561 6368 5f6f 6c64 5f74  aname[each_old_t
+00014ee0: 6172 6765 745d 0a0a 2020 2020 2020 2020  arget]..        
+00014ef0: 2323 2323 2054 6869 7320 6973 2077 6865  #### This is whe
+00014f00: 7265 2077 6520 6368 6563 6b20 7768 6574  re we check whet
+00014f10: 6865 7220 746f 2072 6574 7572 6e20 7465  her to return te
+00014f20: 7374 2064 6174 6120 6f72 206e 6f74 2023  st data or not #
+00014f30: 2323 2323 230a 2020 2020 2020 2020 7472  #####.        tr
+00014f40: 793a 0a20 2020 2020 2020 2020 2020 2069  y:.            i
+00014f50: 6620 6973 696e 7374 616e 6365 2874 6573  f isinstance(tes
+00014f60: 745f 6461 7461 2c20 7374 7229 206f 7220  t_data, str) or 
+00014f70: 7465 7374 5f64 6174 6120 6973 204e 6f6e  test_data is Non
+00014f80: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+00014f90: 2020 2069 6620 6665 6174 7572 655f 6765     if feature_ge
+00014fa0: 6e20 6f72 2066 6561 7475 7265 5f74 7970  n or feature_typ
+00014fb0: 653a 0a20 2020 2020 2020 2020 2020 2020  e:.             
+00014fc0: 2020 2020 2020 2023 2323 2069 6620 6665         ### if fe
+00014fd0: 6174 7572 6520 656e 6767 2069 7320 7065  ature engg is pe
+00014fe0: 7266 6f72 6d65 642c 2069 6420 636f 6c75  rformed, id colu
+00014ff0: 6d6e 7320 6172 6520 6472 6f70 7065 642e  mns are dropped.
+00015000: 2048 656e 6365 2074 6865 7920 6d75 7374   Hence they must
+00015010: 2072 656a 6f69 6e20 6865 7265 2e0a 2020   rejoin here..  
+00015020: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015030: 2020 6461 7461 6e61 6d65 203d 2070 642e    dataname = pd.
+00015040: 636f 6e63 6174 285b 7472 6169 6e5f 6964  concat([train_id
+00015050: 732c 2064 6174 616e 616d 655d 2c20 6178  s, dataname], ax
+00015060: 6973 3d31 290a 2020 2020 2020 2020 2020  is=1).          
+00015070: 2020 2020 2020 7265 7475 726e 2069 6d70        return imp
+00015080: 6f72 7461 6e74 5f66 6561 7475 7265 732c  ortant_features,
+00015090: 2064 6174 616e 616d 655b 696d 706f 7274   dataname[import
+000150a0: 616e 745f 6665 6174 7572 6573 2b74 6172  ant_features+tar
+000150b0: 6765 745d 0a20 2020 2020 2020 2020 2020  get].           
+000150c0: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+000150d0: 2020 2020 2020 2023 2320 5468 6973 2069         ## This i
+000150e0: 7320 666f 7220 7465 7374 2064 6174 6120  s for test data 
+000150f0: 6578 6973 7469 6e67 2023 2323 230a 2020  existing ####.  
+00015100: 2020 2020 2020 2020 2020 2020 2020 6966                if
+00015110: 2066 6561 7475 7265 5f67 656e 206f 7220   feature_gen or 
+00015120: 6665 6174 7572 655f 7479 7065 3a0a 2020  feature_type:.  
+00015130: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015140: 2020 2323 2320 6966 2066 6561 7475 7265    ### if feature
+00015150: 2065 6e67 6720 6973 2070 6572 666f 726d   engg is perform
+00015160: 6564 2c20 6964 2063 6f6c 756d 6e73 2061  ed, id columns a
+00015170: 7265 2064 726f 7070 6564 2e20 4865 6e63  re dropped. Henc
+00015180: 6520 7468 6579 206d 7573 7420 7265 6a6f  e they must rejo
+00015190: 696e 2068 6572 652e 0a20 2020 2020 2020  in here..       
+000151a0: 2020 2020 2020 2020 2020 2020 2064 6174               dat
+000151b0: 616e 616d 6520 3d20 7064 2e63 6f6e 6361  aname = pd.conca
+000151c0: 7428 5b74 7261 696e 5f69 6473 2c20 6461  t([train_ids, da
+000151d0: 7461 6e61 6d65 5d2c 2061 7869 733d 3129  taname], axis=1)
+000151e0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000151f0: 2020 2020 2074 6573 745f 6461 7461 203d       test_data =
+00015200: 2070 642e 636f 6e63 6174 285b 7465 7374   pd.concat([test
+00015210: 5f69 6473 2c20 7465 7374 5f64 6174 615d  _ids, test_data]
+00015220: 2c20 6178 6973 3d31 290a 2020 2020 2020  , axis=1).      
+00015230: 2020 2020 2020 2020 2020 2323 2320 596f            ### Yo
+00015240: 7520 7365 6c65 6374 2074 6865 2066 6561  u select the fea
+00015250: 7475 7265 7320 7769 7468 2074 6865 2073  tures with the s
+00015260: 616d 6520 6f6c 6420 6e61 6d65 7320 6173  ame old names as
+00015270: 2062 6566 6f72 6520 2323 2323 2323 230a   before #######.
+00015280: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015290: 7265 7475 726e 2064 6174 616e 616d 655b  return dataname[
+000152a0: 696d 706f 7274 616e 745f 6665 6174 7572  important_featur
+000152b0: 6573 2b74 6172 6765 7473 5d2c 2074 6573  es+targets], tes
+000152c0: 745f 6461 7461 5b69 6d70 6f72 7461 6e74  t_data[important
+000152d0: 5f66 6561 7475 7265 735d 0a20 2020 2020  _features].     
+000152e0: 2020 2065 7863 6570 743a 0a20 2020 2020     except:.     
+000152f0: 2020 2020 2020 2070 7269 6e74 2827 5761         print('Wa
+00015300: 726e 696e 673a 2052 6574 7572 6e69 6e67  rning: Returning
+00015310: 2077 6974 6820 696d 706f 7274 616e 7420   with important 
+00015320: 6665 6174 7572 6573 2061 6e64 2074 7261  features and tra
+00015330: 696e 2e20 506c 6561 7365 2072 652d 6368  in. Please re-ch
+00015340: 6563 6b20 796f 7572 206f 7574 7075 7473  eck your outputs
+00015350: 2e27 290a 2020 2020 2020 2020 2020 2020  .').            
+00015360: 7265 7475 726e 2069 6d70 6f72 7461 6e74  return important
+00015370: 5f66 6561 7475 7265 732c 2064 6174 616e  _features, datan
+00015380: 616d 655b 696d 706f 7274 616e 745f 6665  ame[important_fe
+00015390: 6174 7572 6573 2b74 6172 6765 7473 5d0a  atures+targets].
+000153a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000153b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000153c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000153d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000153e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000153f0: 0a64 6566 2072 656d 6f76 655f 6869 6768  .def remove_high
+00015400: 6c79 5f63 6f72 7265 6c61 7465 645f 7661  ly_correlated_va
+00015410: 7273 5f66 6173 7428 6466 2c20 636f 7272  rs_fast(df, corr
+00015420: 5f6c 696d 6974 3d30 2e37 3029 3a0a 2020  _limit=0.70):.  
+00015430: 2020 2222 220a 2020 2020 5468 6973 2069    """.    This i
+00015440: 7320 6120 7369 6d70 6c65 206d 6574 686f  s a simple metho
+00015450: 6420 746f 2072 656d 6f76 6520 6869 6768  d to remove high
+00015460: 6c79 2063 6f72 7265 6c61 7465 6420 6665  ly correlated fe
+00015470: 6174 7572 6573 2066 6173 7420 7573 696e  atures fast usin
+00015480: 6720 5065 6172 736f 6e27 7320 436f 7272  g Pearson's Corr
+00015490: 656c 6174 696f 6e2e 0a20 2020 2055 7365  elation..    Use
+000154a0: 2074 6869 7320 6f6e 6c79 2066 6f72 2066   this only for f
+000154b0: 6c6f 6174 2061 6e64 2069 6e74 6567 6572  loat and integer
+000154c0: 2076 6172 6961 626c 6573 2e20 4974 2077   variables. It w
+000154d0: 696c 6c20 6175 746f 6d61 7469 6361 6c6c  ill automaticall
+000154e0: 7920 7365 6c65 6374 2074 686f 7365 206f  y select those o
+000154f0: 6e6c 792e 0a20 2020 2049 7420 6361 6e20  nly..    It can 
+00015500: 6265 2075 7365 6420 666f 7220 7665 7279  be used for very
+00015510: 206c 6172 6765 2064 6174 6120 7365 7473   large data sets
+00015520: 2077 6865 7265 2066 6561 7475 7265 7769   where featurewi
+00015530: 7a20 6861 7320 7472 6f75 626c 6520 7769  z has trouble wi
+00015540: 7468 206d 656d 6f72 790a 2020 2020 2222  th memory.    ""
+00015550: 220a 2020 2020 2320 4372 6561 7469 6e67  ".    # Creating
+00015560: 2063 6f72 7265 6c61 7469 6f6e 206d 6174   correlation mat
+00015570: 7269 780a 2020 2020 636f 7272 656c 6174  rix.    correlat
+00015580: 696f 6e5f 6461 7461 6672 616d 6520 3d20  ion_dataframe = 
+00015590: 6466 2e63 6f72 7228 292e 6162 7328 292e  df.corr().abs().
+000155a0: 6173 7479 7065 286e 702e 666c 6f61 7431  astype(np.float1
+000155b0: 3629 0a20 2020 2023 2053 656c 6563 7469  6).    # Selecti
+000155c0: 6e67 2075 7070 6572 2074 7269 616e 676c  ng upper triangl
+000155d0: 6520 6f66 2063 6f72 7265 6c61 7469 6f6e  e of correlation
+000155e0: 206d 6174 7269 780a 2020 2020 7570 7065   matrix.    uppe
+000155f0: 725f 7472 6920 3d20 636f 7272 656c 6174  r_tri = correlat
+00015600: 696f 6e5f 6461 7461 6672 616d 652e 7768  ion_dataframe.wh
+00015610: 6572 6528 6e70 2e74 7269 7528 6e70 2e6f  ere(np.triu(np.o
+00015620: 6e65 7328 636f 7272 656c 6174 696f 6e5f  nes(correlation_
+00015630: 6461 7461 6672 616d 652e 7368 6170 6529  dataframe.shape)
+00015640: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
+00015650: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015660: 2020 2020 6b3d 3129 2e61 7374 7970 6528      k=1).astype(
+00015670: 6e70 2e62 6f6f 6c29 290a 2020 2020 2320  np.bool)).    # 
+00015680: 4669 6e64 696e 6720 696e 6465 7820 6f66  Finding index of
+00015690: 2066 6561 7475 7265 2063 6f6c 756d 6e73   feature columns
+000156a0: 2077 6974 6820 636f 7272 656c 6174 696f   with correlatio
+000156b0: 6e20 6772 6561 7465 7220 7468 616e 2030  n greater than 0
+000156c0: 2e39 350a 2020 2020 746f 5f64 726f 7020  .95.    to_drop 
+000156d0: 3d20 5b63 6f6c 756d 6e20 666f 7220 636f  = [column for co
+000156e0: 6c75 6d6e 2069 6e20 7570 7065 725f 7472  lumn in upper_tr
+000156f0: 692e 636f 6c75 6d6e 7320 6966 2061 6e79  i.columns if any
+00015700: 2875 7070 6572 5f74 7269 5b63 6f6c 756d  (upper_tri[colum
+00015710: 6e5d 203e 2063 6f72 725f 6c69 6d69 7429  n] > corr_limit)
+00015720: 5d0a 2020 2020 7072 696e 7428 293b 0a20  ].    print();. 
+00015730: 2020 2070 7269 6e74 2827 4869 6768 6c79     print('Highly
+00015740: 2063 6f72 7265 6c61 7465 6420 636f 6c75   correlated colu
+00015750: 6d6e 7320 746f 2072 656d 6f76 653a 2025  mns to remove: %
+00015760: 7327 2025 746f 5f64 726f 7029 0a20 2020  s' %to_drop).   
+00015770: 2072 6574 7572 6e20 746f 5f64 726f 700a   return to_drop.
+00015780: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00015790: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000157a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000157b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000157c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000157d0: 2323 2323 230a 696d 706f 7274 206d 756c  #####.import mul
+000157e0: 7469 7072 6f63 6573 7369 6e67 0a64 6566  tiprocessing.def
+000157f0: 2067 6574 5f63 7075 5f77 6f72 6b65 725f   get_cpu_worker_
+00015800: 636f 756e 7428 293a 0a20 2020 2072 6574  count():.    ret
+00015810: 7572 6e20 6d75 6c74 6970 726f 6365 7373  urn multiprocess
+00015820: 696e 672e 6370 755f 636f 756e 7428 290a  ing.cpu_count().
 00015830: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 00015840: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 00015850: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 00015860: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 00015870: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00015880: 2323 2323 2323 230a 6465 6620 6472 6177  #######.def draw
-00015890: 5f66 6561 7475 7265 5f69 6d70 6f72 7461  _feature_importa
-000158a0: 6e63 6573 5f73 696e 676c 655f 6c61 6265  nces_single_labe
-000158b0: 6c28 6273 745f 6d6f 6465 6c73 2c20 6461  l(bst_models, da
-000158c0: 736b 5f78 6762 6f6f 7374 5f66 6c61 673d  sk_xgboost_flag=
-000158d0: 4661 6c73 6529 3a0a 2020 2020 726f 7773  False):.    rows
-000158e0: 203d 2069 6e74 286c 656e 2862 7374 5f6d   = int(len(bst_m
-000158f0: 6f64 656c 7329 2f32 202b 2030 2e35 290a  odels)/2 + 0.5).
-00015900: 2020 2020 636f 6c75 7320 3d20 320a 2020      colus = 2.  
-00015910: 2020 6669 672c 2061 7820 3d20 706c 742e    fig, ax = plt.
-00015920: 7375 6270 6c6f 7473 2872 6f77 732c 2063  subplots(rows, c
-00015930: 6f6c 7573 290a 2020 2020 6669 672e 7365  olus).    fig.se
-00015940: 745f 7369 7a65 5f69 6e63 6865 7328 6d69  t_size_inches(mi
-00015950: 6e28 636f 6c75 732a 352c 3230 292c 726f  n(colus*5,20),ro
-00015960: 7773 2a35 290a 2020 2020 6669 672e 7375  ws*5).    fig.su
-00015970: 6270 6c6f 7473 5f61 646a 7573 7428 6873  bplots_adjust(hs
-00015980: 7061 6365 3d30 2e35 2920 2323 2320 5468  pace=0.5) ### Th
-00015990: 6973 2063 6f6e 7472 6f6c 7320 7468 6520  is controls the 
-000159a0: 7370 6163 6520 6265 7477 656e 2072 6f77  space betwen row
-000159b0: 730a 2020 2020 6669 672e 7375 6270 6c6f  s.    fig.subplo
-000159c0: 7473 5f61 646a 7573 7428 7773 7061 6365  ts_adjust(wspace
-000159d0: 3d30 2e35 2920 2323 2320 5468 6973 2063  =0.5) ### This c
-000159e0: 6f6e 7472 6f6c 7320 7468 6520 7370 6163  ontrols the spac
-000159f0: 6520 6265 7477 6565 6e20 636f 6c75 6d6e  e between column
-00015a00: 730a 2020 2020 636f 756e 7465 7220 3d20  s.    counter = 
-00015a10: 300a 2020 2020 6966 2072 6f77 7320 3d3d  0.    if rows ==
-00015a20: 2031 3a0a 2020 2020 2020 2020 6178 203d   1:.        ax =
-00015a30: 2061 782e 7265 7368 6170 6528 2d31 2c31   ax.reshape(-1,1
-00015a40: 292e 540a 2020 2020 666f 7220 6b20 696e  ).T.    for k in
-00015a50: 206e 702e 6172 616e 6765 2872 6f77 7329   np.arange(rows)
-00015a60: 3a0a 2020 2020 2020 2020 666f 7220 6c20  :.        for l 
-00015a70: 696e 206e 702e 6172 616e 6765 2863 6f6c  in np.arange(col
-00015a80: 7573 293a 0a20 2020 2020 2020 2020 2020  us):.           
-00015a90: 2069 6620 636f 756e 7465 7220 3c20 6c65   if counter < le
-00015aa0: 6e28 6273 745f 6d6f 6465 6c73 293a 0a20  n(bst_models):. 
-00015ab0: 2020 2020 2020 2020 2020 2020 2020 2074                 t
-00015ac0: 7279 3a0a 2020 2020 2020 2020 2020 2020  ry:.            
-00015ad0: 2020 2020 2020 2020 6273 745f 626f 6f73          bst_boos
-00015ae0: 7465 7220 3d20 6273 745f 6d6f 6465 6c73  ter = bst_models
-00015af0: 5b63 6f75 6e74 6572 5d0a 2020 2020 2020  [counter].      
-00015b00: 2020 2020 2020 2020 2020 2020 2020 6178                ax
-00015b10: 3120 3d20 7867 626f 6f73 742e 706c 6f74  1 = xgboost.plot
-00015b20: 5f69 6d70 6f72 7461 6e63 6528 6273 745f  _importance(bst_
-00015b30: 626f 6f73 7465 722c 2068 6569 6768 743d  booster, height=
-00015b40: 302e 382c 2073 686f 775f 7661 6c75 6573  0.8, show_values
-00015b50: 3d46 616c 7365 2c0a 2020 2020 2020 2020  =False,.        
-00015b60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015b70: 2020 2020 696d 706f 7274 616e 6365 5f74      importance_t
-00015b80: 7970 653d 2767 6169 6e27 2c20 6d61 785f  ype='gain', max_
-00015b90: 6e75 6d5f 6665 6174 7572 6573 3d31 302c  num_features=10,
-00015ba0: 2061 783d 6178 5b6b 5d5b 6c5d 290a 2020   ax=ax[k][l]).  
-00015bb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00015bc0: 2020 6178 312e 7365 745f 7469 746c 6528    ax1.set_title(
-00015bd0: 2754 6f70 2031 3020 6665 6174 7572 6573  'Top 10 features
-00015be0: 2077 6974 6820 5847 4220 6d6f 6465 6c20   with XGB model 
-00015bf0: 2573 2720 2528 636f 756e 7465 722b 3129  %s' %(counter+1)
-00015c00: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
-00015c10: 2020 6578 6365 7074 3a0a 2020 2020 2020    except:.      
-00015c20: 2020 2020 2020 2020 2020 2020 2020 7061                pa
-00015c30: 7373 0a20 2020 2020 2020 2020 2020 2063  ss.            c
-00015c40: 6f75 6e74 6572 202b 3d20 310a 2020 2020  ounter += 1.    
-00015c50: 706c 742e 7368 6f77 2829 3b0a 2323 2323  plt.show();.####
-00015c60: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00015c70: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00015c80: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00015c90: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00015ca0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00015cb0: 2323 0a64 6566 2072 6564 7563 655f 6d65  ##.def reduce_me
-00015cc0: 6d5f 7573 6167 6528 6466 293a 0a20 2020  m_usage(df):.   
-00015cd0: 2022 2222 0a20 2020 2023 2323 2323 2323   """.    #######
-00015ce0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00015cf0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00015d00: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00015d10: 2323 2323 2323 2323 2323 2323 2323 0a20  ##############. 
-00015d20: 2020 2047 7265 6174 6c79 2069 6e64 6562     Greatly indeb
-00015d30: 7465 6420 746f 203a 0a20 2020 2068 7474  ted to :.    htt
-00015d40: 7073 3a2f 2f77 7777 2e6b 6167 676c 652e  ps://www.kaggle.
-00015d50: 636f 6d2f 6172 6a61 6e73 6f2f 7265 6475  com/arjanso/redu
-00015d60: 6369 6e67 2d64 6174 6166 7261 6d65 2d6d  cing-dataframe-m
-00015d70: 656d 6f72 792d 7369 7a65 2d62 792d 3635  emory-size-by-65
-00015d80: 0a20 2020 2020 2020 2066 6f72 2074 6869  .        for thi
-00015d90: 7320 6675 6e63 7469 6f6e 2074 6f20 7265  s function to re
-00015da0: 6475 6365 206d 656d 6f72 7920 7573 6167  duce memory usag
-00015db0: 652e 0a20 2020 2023 2323 2323 2323 2323  e..    #########
+00015880: 2323 2323 2323 2323 2323 2323 230a 6672  #############.fr
+00015890: 6f6d 2069 7465 7274 6f6f 6c73 2069 6d70  om itertools imp
+000158a0: 6f72 7420 636f 6d62 696e 6174 696f 6e73  ort combinations
+000158b0: 0a69 6d70 6f72 7420 6d61 7470 6c6f 746c  .import matplotl
+000158c0: 6962 2e70 6174 6368 6573 2061 7320 6d70  ib.patches as mp
+000158d0: 6174 6368 6573 0a69 6d70 6f72 7420 6d61  atches.import ma
+000158e0: 7470 6c6f 746c 6962 2e70 7970 6c6f 7420  tplotlib.pyplot 
+000158f0: 6173 2070 6c74 0a66 726f 6d20 736b 6c65  as plt.from skle
+00015900: 6172 6e2e 6665 6174 7572 655f 7365 6c65  arn.feature_sele
+00015910: 6374 696f 6e20 696d 706f 7274 2063 6869  ction import chi
+00015920: 322c 206d 7574 7561 6c5f 696e 666f 5f72  2, mutual_info_r
+00015930: 6567 7265 7373 696f 6e2c 206d 7574 7561  egression, mutua
+00015940: 6c5f 696e 666f 5f63 6c61 7373 6966 0a66  l_info_classif.f
+00015950: 726f 6d20 736b 6c65 6172 6e2e 6665 6174  rom sklearn.feat
+00015960: 7572 655f 7365 6c65 6374 696f 6e20 696d  ure_selection im
+00015970: 706f 7274 2053 656c 6563 744b 4265 7374  port SelectKBest
+00015980: 0a69 6d70 6f72 7420 7867 626f 6f73 740a  .import xgboost.
+00015990: 6465 6620 6472 6177 5f66 6561 7475 7265  def draw_feature
+000159a0: 5f69 6d70 6f72 7461 6e63 6573 5f6d 756c  _importances_mul
+000159b0: 7469 5f6c 6162 656c 2862 7374 5f6d 6f64  ti_label(bst_mod
+000159c0: 656c 732c 2064 6173 6b5f 7867 626f 6f73  els, dask_xgboos
+000159d0: 745f 666c 6167 3d46 616c 7365 293a 0a20  t_flag=False):. 
+000159e0: 2020 2072 6f77 7320 3d20 696e 7428 6c65     rows = int(le
+000159f0: 6e28 6273 745f 6d6f 6465 6c73 292f 3220  n(bst_models)/2 
+00015a00: 2b20 302e 3529 0a20 2020 2063 6f6c 7573  + 0.5).    colus
+00015a10: 203d 2032 0a20 2020 2066 6967 2c20 6178   = 2.    fig, ax
+00015a20: 203d 2070 6c74 2e73 7562 706c 6f74 7328   = plt.subplots(
+00015a30: 726f 7773 2c20 636f 6c75 7329 0a20 2020  rows, colus).   
+00015a40: 2066 6967 2e73 6574 5f73 697a 655f 696e   fig.set_size_in
+00015a50: 6368 6573 286d 696e 2863 6f6c 7573 2a35  ches(min(colus*5
+00015a60: 2c32 3029 2c72 6f77 732a 3529 0a20 2020  ,20),rows*5).   
+00015a70: 2066 6967 2e73 7562 706c 6f74 735f 6164   fig.subplots_ad
+00015a80: 6a75 7374 2868 7370 6163 653d 302e 3529  just(hspace=0.5)
+00015a90: 2023 2323 2054 6869 7320 636f 6e74 726f   ### This contro
+00015aa0: 6c73 2074 6865 2073 7061 6365 2062 6574  ls the space bet
+00015ab0: 7765 6e20 726f 7773 0a20 2020 2066 6967  wen rows.    fig
+00015ac0: 2e73 7562 706c 6f74 735f 6164 6a75 7374  .subplots_adjust
+00015ad0: 2877 7370 6163 653d 302e 3529 2023 2323  (wspace=0.5) ###
+00015ae0: 2054 6869 7320 636f 6e74 726f 6c73 2074   This controls t
+00015af0: 6865 2073 7061 6365 2062 6574 7765 656e  he space between
+00015b00: 2063 6f6c 756d 6e73 0a20 2020 2063 6f75   columns.    cou
+00015b10: 6e74 6572 203d 2030 0a20 2020 2069 6620  nter = 0.    if 
+00015b20: 726f 7773 203d 3d20 313a 0a20 2020 2020  rows == 1:.     
+00015b30: 2020 2061 7820 3d20 6178 2e72 6573 6861     ax = ax.resha
+00015b40: 7065 282d 312c 3129 2e54 0a20 2020 2066  pe(-1,1).T.    f
+00015b50: 6f72 206b 2069 6e20 6e70 2e61 7261 6e67  or k in np.arang
+00015b60: 6528 726f 7773 293a 0a20 2020 2020 2020  e(rows):.       
+00015b70: 2066 6f72 206c 2069 6e20 6e70 2e61 7261   for l in np.ara
+00015b80: 6e67 6528 636f 6c75 7329 3a0a 2020 2020  nge(colus):.    
+00015b90: 2020 2020 2020 2020 6966 2063 6f75 6e74          if count
+00015ba0: 6572 203c 206c 656e 2862 7374 5f6d 6f64  er < len(bst_mod
+00015bb0: 656c 7329 3a0a 2020 2020 2020 2020 2020  els):.          
+00015bc0: 2020 2020 2020 7472 793a 0a20 2020 2020        try:.     
+00015bd0: 2020 2020 2020 2020 2020 2020 2020 2062                 b
+00015be0: 7374 5f62 6f6f 7374 6572 203d 2062 7374  st_booster = bst
+00015bf0: 5f6d 6f64 656c 735b 636f 756e 7465 725d  _models[counter]
+00015c00: 2e65 7374 696d 6174 6f72 735f 5b30 5d0a  .estimators_[0].
+00015c10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015c20: 2020 2020 6178 3120 3d20 7867 626f 6f73      ax1 = xgboos
+00015c30: 742e 706c 6f74 5f69 6d70 6f72 7461 6e63  t.plot_importanc
+00015c40: 6528 6273 745f 626f 6f73 7465 722c 2068  e(bst_booster, h
+00015c50: 6569 6768 743d 302e 382c 2073 686f 775f  eight=0.8, show_
+00015c60: 7661 6c75 6573 3d46 616c 7365 2c0a 2020  values=False,.  
+00015c70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00015c80: 2020 2020 2020 2020 2020 696d 706f 7274            import
+00015c90: 616e 6365 5f74 7970 653d 2767 6169 6e27  ance_type='gain'
+00015ca0: 2c20 6d61 785f 6e75 6d5f 6665 6174 7572  , max_num_featur
+00015cb0: 6573 3d31 302c 2061 783d 6178 5b6b 5d5b  es=10, ax=ax[k][
+00015cc0: 6c5d 290a 2020 2020 2020 2020 2020 2020  l]).            
+00015cd0: 2020 2020 2020 2020 6178 312e 7365 745f          ax1.set_
+00015ce0: 7469 746c 6528 274d 756c 7469 5f6c 6162  title('Multi_lab
+00015cf0: 656c 3a20 546f 7020 3130 2066 6561 7475  el: Top 10 featu
+00015d00: 7265 7320 666f 7220 6669 7273 7420 6c61  res for first la
+00015d10: 6265 6c3a 2072 6f75 6e64 2025 7327 2025  bel: round %s' %
+00015d20: 2863 6f75 6e74 6572 2b31 2929 0a20 2020  (counter+1)).   
+00015d30: 2020 2020 2020 2020 2020 2020 2065 7863               exc
+00015d40: 6570 743a 0a20 2020 2020 2020 2020 2020  ept:.           
+00015d50: 2020 2020 2020 2020 2070 6173 730a 2020           pass.  
+00015d60: 2020 2020 2020 2020 2020 636f 756e 7465            counte
+00015d70: 7220 2b3d 2031 0a20 2020 2070 6c74 2e73  r += 1.    plt.s
+00015d80: 686f 7728 293b 0a23 2323 2323 2323 2323  how();.#########
+00015d90: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00015da0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00015db0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 00015dc0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00015dd0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00015de0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00015df0: 2323 2323 2323 2323 2323 2323 0a20 2020  ############.   
-00015e00: 2049 7420 6973 2061 2062 6974 2073 6c6f   It is a bit slo
-00015e10: 7720 6173 2069 7420 6974 6572 6174 6573  w as it iterates
-00015e20: 2074 6872 6f75 6768 2061 6c6c 2074 6865   through all the
-00015e30: 2063 6f6c 756d 6e73 206f 6620 6120 6461   columns of a da
-00015e40: 7461 6672 616d 6520 616e 6420 6d6f 6469  taframe and modi
-00015e50: 6669 6573 2064 6174 6120 7479 7065 730a  fies data types.
-00015e60: 2020 2020 2020 2020 746f 2072 6564 7563          to reduc
-00015e70: 6520 6d65 6d6f 7279 2075 7361 6765 2e20  e memory usage. 
-00015e80: 4275 7420 6974 2068 6173 2062 6565 6e20  But it has been 
-00015e90: 7368 6f77 6e20 746f 2072 6564 7563 6520  shown to reduce 
-00015ea0: 6d65 6d6f 7279 2075 7361 6765 2062 7920  memory usage by 
-00015eb0: 3635 2520 6f72 2073 6f2e 2020 2020 2020  65% or so.      
-00015ec0: 200a 2020 2020 2222 220a 2020 2020 7374   .    """.    st
-00015ed0: 6172 745f 6d65 6d20 3d20 6466 2e6d 656d  art_mem = df.mem
-00015ee0: 6f72 795f 7573 6167 6528 292e 7375 6d28  ory_usage().sum(
-00015ef0: 2920 2f20 3130 3234 2a2a 320a 2020 2020  ) / 1024**2.    
-00015f00: 6966 2074 7970 6528 6466 2920 3d3d 2064  if type(df) == d
-00015f10: 6173 6b2e 6461 7461 6672 616d 652e 636f  ask.dataframe.co
-00015f20: 7265 2e44 6174 6146 7261 6d65 3a0a 2020  re.DataFrame:.  
-00015f30: 2020 2020 2020 7374 6172 745f 6d65 6d20        start_mem 
-00015f40: 3d20 7374 6172 745f 6d65 6d2e 636f 6d70  = start_mem.comp
-00015f50: 7574 6528 290a 2020 2020 7072 696e 7428  ute().    print(
-00015f60: 2720 2020 2043 6175 7469 6f6e 3a20 5765  '    Caution: We
-00015f70: 2077 696c 6c20 7472 7920 746f 2072 6564   will try to red
-00015f80: 7563 6520 7468 6520 6d65 6d6f 7279 2075  uce the memory u
-00015f90: 7361 6765 206f 6620 6461 7461 6672 616d  sage of datafram
-00015fa0: 6520 6672 6f6d 207b 3a2e 3266 7d20 4d42  e from {:.2f} MB
-00015fb0: 272e 666f 726d 6174 2873 7461 7274 5f6d  '.format(start_m
-00015fc0: 656d 2929 0a20 2020 2063 6f6c 7320 3d20  em)).    cols = 
-00015fd0: 6466 2e63 6f6c 756d 6e73 0a20 2020 2069  df.columns.    i
-00015fe0: 6620 7479 7065 2864 6629 203d 3d20 6461  f type(df) == da
-00015ff0: 736b 2e64 6174 6166 7261 6d65 2e63 6f72  sk.dataframe.cor
-00016000: 652e 4461 7461 4672 616d 653a 0a20 2020  e.DataFrame:.   
-00016010: 2020 2020 2063 6f6c 7320 3d20 636f 6c73       cols = cols
-00016020: 2e74 6f6c 6973 7428 290a 0a20 2020 2066  .tolist()..    f
-00016030: 6f72 2063 6f6c 2069 6e20 636f 6c73 3a0a  or col in cols:.
-00016040: 2020 2020 2020 2020 636f 6c5f 7479 7065          col_type
-00016050: 203d 2064 665b 636f 6c5d 2e64 7479 7065   = df[col].dtype
-00016060: 0a20 2020 2020 2020 2069 6620 636f 6c5f  .        if col_
-00016070: 7479 7065 2021 3d20 6f62 6a65 6374 3a0a  type != object:.
-00016080: 2020 2020 2020 2020 2020 2020 7472 793a              try:
-00016090: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000160a0: 2063 5f6d 696e 203d 2064 665b 636f 6c5d   c_min = df[col]
-000160b0: 2e6d 696e 2829 0a20 2020 2020 2020 2020  .min().         
-000160c0: 2020 2020 2020 2063 5f6d 6178 203d 2064         c_max = d
-000160d0: 665b 636f 6c5d 2e6d 6178 2829 0a20 2020  f[col].max().   
-000160e0: 2020 2020 2020 2020 2065 7863 6570 743a           except:
-000160f0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00016100: 2063 6f6e 7469 6e75 650a 2020 2020 2020   continue.      
-00016110: 2020 2020 2020 6966 2074 7970 6528 6466        if type(df
-00016120: 2920 3d3d 2064 6173 6b2e 6461 7461 6672  ) == dask.datafr
-00016130: 616d 652e 636f 7265 2e44 6174 6146 7261  ame.core.DataFra
-00016140: 6d65 3a0a 2020 2020 2020 2020 2020 2020  me:.            
-00016150: 2020 2020 635f 6d69 6e20 3d20 635f 6d69      c_min = c_mi
-00016160: 6e2e 636f 6d70 7574 6528 290a 2020 2020  n.compute().    
-00016170: 2020 2020 2020 2020 2020 2020 635f 6d61              c_ma
-00016180: 7820 3d20 635f 6d61 782e 636f 6d70 7574  x = c_max.comput
-00016190: 6528 290a 2020 2020 2020 2020 2020 2020  e().            
-000161a0: 6966 2073 7472 2863 6f6c 5f74 7970 6529  if str(col_type)
-000161b0: 5b3a 335d 203d 3d20 2769 6e74 273a 0a20  [:3] == 'int':. 
-000161c0: 2020 2020 2020 2020 2020 2020 2020 2069                 i
-000161d0: 6620 635f 6d69 6e20 3e20 6e70 2e69 696e  f c_min > np.iin
-000161e0: 666f 286e 702e 696e 7438 292e 6d69 6e20  fo(np.int8).min 
-000161f0: 616e 6420 635f 6d61 7820 3c20 6e70 2e69  and c_max < np.i
-00016200: 696e 666f 286e 702e 696e 7438 292e 6d61  info(np.int8).ma
-00016210: 783a 0a20 2020 2020 2020 2020 2020 2020  x:.             
-00016220: 2020 2020 2020 2064 665b 636f 6c5d 203d         df[col] =
-00016230: 2064 665b 636f 6c5d 2e61 7374 7970 6528   df[col].astype(
-00016240: 6e70 2e69 6e74 3829 0a20 2020 2020 2020  np.int8).       
-00016250: 2020 2020 2020 2020 2065 6c69 6620 635f           elif c_
-00016260: 6d69 6e20 3e20 6e70 2e69 696e 666f 286e  min > np.iinfo(n
-00016270: 702e 696e 7431 3629 2e6d 696e 2061 6e64  p.int16).min and
-00016280: 2063 5f6d 6178 203c 206e 702e 6969 6e66   c_max < np.iinf
-00016290: 6f28 6e70 2e69 6e74 3136 292e 6d61 783a  o(np.int16).max:
-000162a0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-000162b0: 2020 2020 2064 665b 636f 6c5d 203d 2064       df[col] = d
-000162c0: 665b 636f 6c5d 2e61 7374 7970 6528 6e70  f[col].astype(np
-000162d0: 2e69 6e74 3136 290a 2020 2020 2020 2020  .int16).        
-000162e0: 2020 2020 2020 2020 656c 6966 2063 5f6d          elif c_m
-000162f0: 696e 203e 206e 702e 6969 6e66 6f28 6e70  in > np.iinfo(np
-00016300: 2e69 6e74 3332 292e 6d69 6e20 616e 6420  .int32).min and 
-00016310: 635f 6d61 7820 3c20 6e70 2e69 696e 666f  c_max < np.iinfo
-00016320: 286e 702e 696e 7433 3229 2e6d 6178 3a0a  (np.int32).max:.
-00016330: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016340: 2020 2020 6466 5b63 6f6c 5d20 3d20 6466      df[col] = df
-00016350: 5b63 6f6c 5d2e 6173 7479 7065 286e 702e  [col].astype(np.
-00016360: 696e 7433 3229 0a20 2020 2020 2020 2020  int32).         
-00016370: 2020 2020 2020 2065 6c69 6620 635f 6d69         elif c_mi
-00016380: 6e20 3e20 6e70 2e69 696e 666f 286e 702e  n > np.iinfo(np.
-00016390: 696e 7436 3429 2e6d 696e 2061 6e64 2063  int64).min and c
-000163a0: 5f6d 6178 203c 206e 702e 6969 6e66 6f28  _max < np.iinfo(
-000163b0: 6e70 2e69 6e74 3634 292e 6d61 783a 0a20  np.int64).max:. 
-000163c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000163d0: 2020 2064 665b 636f 6c5d 203d 2064 665b     df[col] = df[
-000163e0: 636f 6c5d 2e61 7374 7970 6528 6e70 2e69  col].astype(np.i
-000163f0: 6e74 3634 2920 200a 2020 2020 2020 2020  nt64)  .        
-00016400: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
-00016410: 2020 2020 2020 2020 2020 7472 793a 0a20            try:. 
-00016420: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016430: 2020 2069 6620 635f 6d69 6e20 3e20 6e70     if c_min > np
-00016440: 2e66 696e 666f 286e 702e 666c 6f61 7431  .finfo(np.float1
-00016450: 3629 2e6d 696e 2061 6e64 2063 5f6d 6178  6).min and c_max
-00016460: 203c 206e 702e 6669 6e66 6f28 6e70 2e66   < np.finfo(np.f
-00016470: 6c6f 6174 3136 292e 6d61 783a 0a20 2020  loat16).max:.   
-00016480: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016490: 2020 2020 2064 665b 636f 6c5d 203d 2064       df[col] = d
-000164a0: 665b 636f 6c5d 2e61 7374 7970 6528 6e70  f[col].astype(np
-000164b0: 2e66 6c6f 6174 3136 290a 2020 2020 2020  .float16).      
-000164c0: 2020 2020 2020 2020 2020 2020 2020 656c                el
-000164d0: 6966 2063 5f6d 696e 203e 206e 702e 6669  if c_min > np.fi
-000164e0: 6e66 6f28 6e70 2e66 6c6f 6174 3332 292e  nfo(np.float32).
-000164f0: 6d69 6e20 616e 6420 635f 6d61 7820 3c20  min and c_max < 
-00016500: 6e70 2e66 696e 666f 286e 702e 666c 6f61  np.finfo(np.floa
-00016510: 7433 3229 2e6d 6178 3a0a 2020 2020 2020  t32).max:.      
-00016520: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00016530: 2020 6466 5b63 6f6c 5d20 3d20 6466 5b63    df[col] = df[c
-00016540: 6f6c 5d2e 6173 7479 7065 286e 702e 666c  ol].astype(np.fl
-00016550: 6f61 7433 3229 0a20 2020 2020 2020 2020  oat32).         
-00016560: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
-00016570: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
-00016580: 2020 2020 2020 2020 2064 665b 636f 6c5d           df[col]
-00016590: 203d 2064 665b 636f 6c5d 2e61 7374 7970   = df[col].astyp
-000165a0: 6528 6e70 2e66 6c6f 6174 3634 290a 2020  e(np.float64).  
-000165b0: 2020 2020 2020 2020 2020 2020 2020 6578                ex
-000165c0: 6365 7074 3a0a 2020 2020 2020 2020 2020  cept:.          
-000165d0: 2020 2020 2020 2020 2020 636f 6e74 696e            contin
-000165e0: 7565 0a20 2020 2020 2020 2065 6c73 653a  ue.        else:
-000165f0: 0a20 2020 2020 2020 2020 2020 2064 665b  .            df[
-00016600: 636f 6c5d 203d 2064 665b 636f 6c5d 2e61  col] = df[col].a
-00016610: 7374 7970 6528 2763 6174 6567 6f72 7927  stype('category'
-00016620: 290a 0a20 2020 2023 2323 2323 2323 2020  )..    #######  
-00016630: 5265 7375 6c74 7320 6166 7465 7220 6d65  Results after me
-00016640: 6d6f 7279 2075 7361 6765 2066 756e 6374  mory usage funct
-00016650: 696f 6e20 2323 2323 2323 2323 2323 2323  ion ############
-00016660: 2323 2323 2323 230a 2020 2020 656e 645f  #######.    end_
-00016670: 6d65 6d20 3d20 6466 2e6d 656d 6f72 795f  mem = df.memory_
-00016680: 7573 6167 6528 292e 7375 6d28 2920 2f20  usage().sum() / 
-00016690: 3130 3234 2a2a 320a 2020 2020 6966 2074  1024**2.    if t
-000166a0: 7970 6528 6466 2920 3d3d 2064 6173 6b2e  ype(df) == dask.
-000166b0: 6461 7461 6672 616d 652e 636f 7265 2e44  dataframe.core.D
-000166c0: 6174 6146 7261 6d65 3a0a 2020 2020 2020  ataFrame:.      
-000166d0: 2020 656e 645f 6d65 6d20 3d20 656e 645f    end_mem = end_
-000166e0: 6d65 6d2e 636f 6d70 7574 6528 290a 2020  mem.compute().  
-000166f0: 2020 7072 696e 7428 6627 2020 2020 2020    print(f'      
-00016700: 2020 6279 207b 2831 3030 202a 2028 7374    by {(100 * (st
-00016710: 6172 745f 6d65 6d20 2d20 656e 645f 6d65  art_mem - end_me
-00016720: 6d29 202f 2073 7461 7274 5f6d 656d 293a  m) / start_mem):
-00016730: 2e31 667d 252e 204d 656d 6f72 7920 7573  .1f}%. Memory us
-00016740: 6167 6520 6166 7465 7220 6973 3a20 7b65  age after is: {e
-00016750: 6e64 5f6d 656d 3a2e 3266 7d20 4d42 2729  nd_mem:.2f} MB')
-00016760: 2020 2020 0a20 2020 2072 6574 7572 6e20      .    return 
-00016770: 6466 0a23 2323 2323 2323 2323 2323 2323  df.#############
-00016780: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00016790: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000167a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000167b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000167c0: 2323 2323 230a 6465 6620 4645 5f73 7461  #####.def FE_sta
-000167d0: 7274 5f65 6e64 5f64 6174 655f 7469 6d65  rt_end_date_time
-000167e0: 5f66 6561 7475 7265 7328 736d 616c 6c64  _features(smalld
-000167f0: 662c 2073 7461 7274 5469 6d65 2c20 656e  f, startTime, en
-00016800: 6454 696d 652c 2073 706c 6974 7465 725f  dTime, splitter_
-00016810: 6461 7465 5f73 7472 696e 673d 222f 222c  date_string="/",
-00016820: 7370 6c69 7474 6572 5f68 6f75 725f 7374  splitter_hour_st
-00016830: 7269 6e67 3d22 3a22 293a 0a20 2020 2022  ring=":"):.    "
-00016840: 2222 0a20 2020 2046 4520 7374 616e 6473  "".    FE stands
-00016850: 2066 6f72 2046 6561 7475 7265 2045 6e67   for Feature Eng
-00016860: 696e 6565 7269 6e67 202d 2069 7420 6d65  ineering - it me
-00016870: 616e 7320 7468 6973 2066 756e 6374 696f  ans this functio
-00016880: 6e20 7065 7266 6f72 6d73 2066 6561 7475  n performs featu
-00016890: 7265 2065 6e67 696e 6565 7269 6e67 0a20  re engineering. 
-000168a0: 2020 2023 2323 2323 2323 2323 2323 2323     #############
-000168b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000168c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000168d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000168e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000168f0: 2323 2323 2323 2323 230a 2020 2020 5468  #########.    Th
-00016900: 6973 2066 756e 6374 696f 6e20 6973 2075  is function is u
-00016910: 7365 6420 7768 656e 2079 6f75 2068 6176  sed when you hav
-00016920: 6520 7374 6172 7420 616e 6420 656e 6420  e start and end 
-00016930: 6461 7465 2074 696d 6520 7374 616d 7073  date time stamps
-00016940: 2069 6e20 796f 7572 2064 6174 6173 6574   in your dataset
-00016950: 2e0a 2020 2020 2020 2020 2d20 4966 2074  ..        - If t
-00016960: 6865 7265 2069 7320 6e6f 2073 7461 7274  here is no start
-00016970: 2061 6e64 2065 6e64 2074 696d 6520 6665   and end time fe
-00016980: 6174 7572 6573 2c20 646f 6e27 7420 7573  atures, don't us
-00016990: 6520 6974 2e20 426f 7468 206d 7573 7420  e it. Both must 
-000169a0: 6265 2070 7265 7365 6e74 210a 2020 2020  be present!.    
-000169b0: 2020 2020 2d20 7468 6973 206d 6f64 756c      - this modul
-000169c0: 6520 7769 6c6c 2063 7265 6174 6520 6164  e will create ad
-000169d0: 6469 7469 6f6e 616c 2066 6561 7475 7265  ditional feature
-000169e0: 7320 666f 7220 7375 6368 2066 6965 6c64  s for such field
-000169f0: 732e 0a20 2020 2020 2020 202d 2079 6f75  s..        - you
-00016a00: 206d 7573 7420 7072 6f76 6964 6520 6120   must provide a 
-00016a10: 7374 6172 7420 6461 7465 2074 696d 6520  start date time 
-00016a20: 7374 616d 7020 6669 656c 6420 616e 6420  stamp field and 
-00016a30: 616e 2065 6e64 2064 6174 6520 7469 6d65  an end date time
-00016a40: 2073 7461 6d70 2066 6965 6c64 0a20 2020   stamp field.   
-00016a50: 204f 7468 6572 7769 7365 2c20 796f 7520   Otherwise, you 
-00016a60: 6172 6520 6265 7474 6572 206f 6666 2075  are better off u
-00016a70: 7369 6e67 2074 6865 2046 455f 6372 6561  sing the FE_crea
-00016a80: 7465 5f64 6174 655f 7469 6d65 5f66 6561  te_date_time_fea
-00016a90: 7475 7265 7328 2920 6d6f 6475 6c65 2069  tures() module i
-00016aa0: 6e20 7468 6973 206c 6962 7261 7279 2e0a  n this library..
-00016ab0: 0a20 2020 2049 6e70 7574 733a 0a20 2020  .    Inputs:.   
-00016ac0: 2073 6d61 6c6c 6466 3a20 4461 7461 6672   smalldf: Datafr
-00016ad0: 616d 6520 636f 6e74 6169 6e69 6e67 2079  ame containing y
-00016ae0: 6f75 7220 6461 7465 2074 696d 6520 6669  our date time fi
-00016af0: 656c 6473 0a20 2020 2073 7461 7274 5469  elds.    startTi
-00016b00: 6d65 3a20 7468 6973 2069 7320 686f 7065  me: this is hope
-00016b10: 6675 6c6c 7920 6120 7374 7269 6e67 2066  fully a string f
-00016b20: 6965 6c64 2077 6869 6368 2063 6f6e 7665  ield which conve
-00016b30: 7274 7320 746f 2061 2064 6174 6520 7469  rts to a date ti
-00016b40: 6d65 2073 7461 6d70 2065 6173 696c 792e  me stamp easily.
-00016b50: 204d 616b 6520 7375 7265 2069 7420 6973   Make sure it is
-00016b60: 2061 2073 7472 696e 672e 0a20 2020 2065   a string..    e
-00016b70: 6e64 5469 6d65 3a20 7468 6973 2061 6c73  ndTime: this als
-00016b80: 6f20 6d75 7374 2062 6520 6120 7374 7269  o must be a stri
-00016b90: 6e67 2066 6965 6c64 2077 6869 6368 2063  ng field which c
-00016ba0: 6f6e 7665 7274 7320 746f 2061 2064 6174  onverts to a dat
-00016bb0: 6520 7469 6d65 2073 7461 6d70 2065 6173  e time stamp eas
-00016bc0: 696c 792e 204d 616b 6520 7375 7265 2069  ily. Make sure i
-00016bd0: 7420 6973 2061 2073 7472 696e 672e 0a20  t is a string.. 
-00016be0: 2020 2073 706c 6974 7465 725f 6461 7465     splitter_date
-00016bf0: 5f73 7472 696e 673a 2075 7375 616c 6c79  _string: usually
-00016c00: 2074 6865 7265 2069 7320 6120 7374 7269   there is a stri
-00016c10: 6e67 2073 7563 6820 6173 2027 2f27 206f  ng such as '/' o
-00016c20: 7220 272e 2720 6265 7477 6565 6e20 6461  r '.' between da
-00016c30: 792f 6d6f 6e74 682f 7965 6172 2065 7463  y/month/year etc
-00016c40: 2e20 4465 6661 756c 7420 6973 2061 7373  . Default is ass
-00016c50: 756d 6564 202f 2068 6572 652e 0a20 2020  umed / here..   
-00016c60: 2073 706c 6974 7465 725f 686f 7572 5f73   splitter_hour_s
-00016c70: 7472 696e 673a 2075 7375 616c 6c79 2074  tring: usually t
-00016c80: 6865 7265 2069 7320 6120 7374 7269 6e67  here is a string
-00016c90: 2073 7563 6820 6173 2027 3a27 206f 7220   such as ':' or 
-00016ca0: 272e 2720 6265 7477 6565 6e20 686f 7572  '.' between hour
-00016cb0: 3a6d 696e 3a73 6563 2065 7463 2e20 4465  :min:sec etc. De
-00016cc0: 6661 756c 7420 6973 2061 7373 756d 6564  fault is assumed
-00016cd0: 203a 2068 6572 652e 0a0a 2020 2020 4f75   : here...    Ou
-00016ce0: 7470 7574 733a 0a20 2020 2054 6865 206f  tputs:.    The o
-00016cf0: 7269 6769 6e61 6c20 7061 6e64 6173 2064  riginal pandas d
-00016d00: 6174 6166 7261 6d65 2077 6974 6820 6164  ataframe with ad
-00016d10: 6469 7469 6f6e 616c 2066 6965 6c64 7320  ditional fields 
-00016d20: 6372 6561 7465 6420 6279 2073 706c 6974  created by split
-00016d30: 7469 6e67 2074 6865 2073 7461 7274 2061  ting the start a
-00016d40: 6e64 2065 6e64 2074 696d 6520 6669 656c  nd end time fiel
-00016d50: 6473 0a20 2020 2023 2323 2323 2323 2323  ds.    #########
-00016d60: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00016d70: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00016d80: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00016d90: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00016da0: 2323 2323 2323 2323 2323 2323 230a 2020  #############.  
-00016db0: 2020 2222 220a 2020 2020 736d 616c 6c64    """.    smalld
-00016dc0: 6620 3d20 736d 616c 6c64 662e 636f 7079  f = smalldf.copy
-00016dd0: 2829 0a20 2020 2061 6464 5f63 6f6c 7320  ().    add_cols 
-00016de0: 3d20 5b5d 0a20 2020 2064 6174 655f 7469  = [].    date_ti
-00016df0: 6d65 5f76 6172 6961 626c 655f 666c 6167  me_variable_flag
-00016e00: 203d 2046 616c 7365 0a20 2020 2069 6620   = False.    if 
-00016e10: 736d 616c 6c64 665b 7374 6172 7454 696d  smalldf[startTim
-00016e20: 655d 2e64 7479 7065 2069 6e20 5b27 6461  e].dtype in ['da
-00016e30: 7465 7469 6d65 3634 5b6e 735d 272c 2764  tetime64[ns]','d
-00016e40: 6174 6574 696d 6531 365b 6e73 5d27 2c27  atetime16[ns]','
-00016e50: 6461 7465 7469 6d65 3332 5b6e 735d 275d  datetime32[ns]']
-00016e60: 3a0a 2020 2020 2020 2020 7072 696e 7428  :.        print(
-00016e70: 2725 7320 7661 7269 6162 6c65 2069 7320  '%s variable is 
-00016e80: 6120 6461 7465 2d74 696d 6520 7661 7269  a date-time vari
-00016e90: 6162 6c65 2720 2573 7461 7274 5469 6d65  able' %startTime
-00016ea0: 290a 2020 2020 2020 2020 6461 7465 5f74  ).        date_t
-00016eb0: 696d 655f 7661 7269 6162 6c65 5f66 6c61  ime_variable_fla
-00016ec0: 6720 3d20 5472 7565 0a20 2020 2069 6620  g = True.    if 
-00016ed0: 6461 7465 5f74 696d 655f 7661 7269 6162  date_time_variab
-00016ee0: 6c65 5f66 6c61 673a 0a20 2020 2020 2020  le_flag:.       
-00016ef0: 2076 6965 775f 6461 7973 203d 2027 7072   view_days = 'pr
-00016f00: 6f63 6573 7369 6e67 272b 7374 6172 7454  ocessing'+startT
-00016f10: 696d 652b 275f 656c 6170 7365 645f 6461  ime+'_elapsed_da
-00016f20: 7973 270a 2020 2020 2020 2020 736d 616c  ys'.        smal
-00016f30: 6c64 665b 7669 6577 5f64 6179 735d 203d  ldf[view_days] =
-00016f40: 2028 736d 616c 6c64 665b 656e 6454 696d   (smalldf[endTim
-00016f50: 655d 202d 2073 6d61 6c6c 6466 5b73 7461  e] - smalldf[sta
-00016f60: 7274 5469 6d65 5d29 2e61 7374 7970 6528  rtTime]).astype(
-00016f70: 2774 696d 6564 656c 7461 3634 5b73 5d27  'timedelta64[s]'
-00016f80: 292f 2836 302a 3630 2a32 3429 0a20 2020  )/(60*60*24).   
-00016f90: 2020 2020 2073 6d61 6c6c 6466 5b76 6965       smalldf[vie
-00016fa0: 775f 6461 7973 5d20 3d20 736d 616c 6c64  w_days] = smalld
-00016fb0: 665b 7669 6577 5f64 6179 735d 2e61 7374  f[view_days].ast
-00016fc0: 7970 6528 696e 7429 0a20 2020 2020 2020  ype(int).       
-00016fd0: 2061 6464 5f63 6f6c 732e 6170 7065 6e64   add_cols.append
-00016fe0: 2876 6965 775f 6461 7973 290a 2020 2020  (view_days).    
-00016ff0: 2020 2020 7669 6577 5f74 696d 6520 3d20      view_time = 
-00017000: 2770 726f 6365 7373 696e 6727 2b73 7461  'processing'+sta
-00017010: 7274 5469 6d65 2b27 5f65 6c61 7073 6564  rtTime+'_elapsed
-00017020: 5f74 696d 6527 0a20 2020 2020 2020 2073  _time'.        s
-00017030: 6d61 6c6c 6466 5b76 6965 775f 7469 6d65  malldf[view_time
-00017040: 5d20 3d20 2873 6d61 6c6c 6466 5b65 6e64  ] = (smalldf[end
-00017050: 5469 6d65 5d20 2d20 736d 616c 6c64 665b  Time] - smalldf[
-00017060: 7374 6172 7454 696d 655d 292e 6173 7479  startTime]).asty
-00017070: 7065 2827 7469 6d65 6465 6c74 6136 345b  pe('timedelta64[
-00017080: 735d 2729 2e76 616c 7565 730a 2020 2020  s]').values.    
-00017090: 2020 2020 6164 645f 636f 6c73 2e61 7070      add_cols.app
-000170a0: 656e 6428 7669 6577 5f74 696d 6529 0a20  end(view_time). 
-000170b0: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
-000170c0: 2073 7461 7274 5f64 6174 6520 3d20 2770   start_date = 'p
-000170d0: 726f 6365 7373 696e 6727 2b73 7461 7274  rocessing'+start
-000170e0: 5469 6d65 2b27 5f73 7461 7274 5f64 6174  Time+'_start_dat
-000170f0: 6527 0a20 2020 2020 2020 2073 6d61 6c6c  e'.        small
-00017100: 6466 5b73 7461 7274 5f64 6174 655d 203d  df[start_date] =
-00017110: 2073 6d61 6c6c 6466 5b73 7461 7274 5469   smalldf[startTi
-00017120: 6d65 5d2e 6d61 7028 6c61 6d62 6461 2078  me].map(lambda x
-00017130: 3a20 782e 7370 6c69 7428 2220 2229 5b30  : x.split(" ")[0
-00017140: 5d29 0a20 2020 2020 2020 2061 6464 5f63  ]).        add_c
-00017150: 6f6c 732e 6170 7065 6e64 2873 7461 7274  ols.append(start
-00017160: 5f64 6174 6529 0a20 2020 2020 2020 2074  _date).        t
-00017170: 7279 3a0a 2020 2020 2020 2020 2020 2020  ry:.            
-00017180: 7374 6172 745f 7469 6d65 203d 2027 7072  start_time = 'pr
-00017190: 6f63 6573 7369 6e67 272b 7374 6172 7454  ocessing'+startT
-000171a0: 696d 652b 275f 7374 6172 745f 7469 6d65  ime+'_start_time
-000171b0: 270a 2020 2020 2020 2020 2020 2020 736d  '.            sm
-000171c0: 616c 6c64 665b 7374 6172 745f 7469 6d65  alldf[start_time
-000171d0: 5d20 3d20 736d 616c 6c64 665b 7374 6172  ] = smalldf[star
-000171e0: 7454 696d 655d 2e6d 6170 286c 616d 6264  tTime].map(lambd
-000171f0: 6120 783a 2078 2e73 706c 6974 2822 2022  a x: x.split(" "
-00017200: 295b 315d 290a 2020 2020 2020 2020 2020  )[1]).          
-00017210: 2020 6164 645f 636f 6c73 2e61 7070 656e    add_cols.appen
-00017220: 6428 7374 6172 745f 7469 6d65 290a 2020  d(start_time).  
-00017230: 2020 2020 2020 6578 6365 7074 3a0a 2020        except:.  
-00017240: 2020 2020 2020 2020 2020 2323 2320 7468            ### th
-00017250: 6572 6520 6973 206e 6f20 686f 7572 2d6d  ere is no hour-m
-00017260: 696e 7574 6573 2070 6172 7420 6f66 2074  inutes part of t
-00017270: 6869 7320 6461 7465 2074 696d 6520 7374  his date time st
-00017280: 616d 7020 6669 656c 642e 2059 6f75 2063  amp field. You c
-00017290: 616e 206a 7573 7420 736b 6970 2069 7420  an just skip it 
-000172a0: 6966 2069 7420 6973 206e 6f74 2074 6865  if it is not the
-000172b0: 7265 0a20 2020 2020 2020 2020 2020 2070  re.            p
-000172c0: 6173 730a 2020 2020 2020 2020 656e 645f  ass.        end_
-000172d0: 6461 7465 203d 2027 7072 6f63 6573 7369  date = 'processi
-000172e0: 6e67 272b 656e 6454 696d 652b 275f 656e  ng'+endTime+'_en
-000172f0: 645f 6461 7465 270a 2020 2020 2020 2020  d_date'.        
-00017300: 736d 616c 6c64 665b 656e 645f 6461 7465  smalldf[end_date
-00017310: 5d20 3d20 736d 616c 6c64 665b 656e 6454  ] = smalldf[endT
-00017320: 696d 655d 2e6d 6170 286c 616d 6264 6120  ime].map(lambda 
-00017330: 783a 2078 2e73 706c 6974 2822 2022 295b  x: x.split(" ")[
-00017340: 305d 290a 2020 2020 2020 2020 6164 645f  0]).        add_
-00017350: 636f 6c73 2e61 7070 656e 6428 656e 645f  cols.append(end_
-00017360: 6461 7465 290a 2020 2020 2020 2020 7472  date).        tr
-00017370: 793a 0a20 2020 2020 2020 2020 2020 2065  y:.            e
-00017380: 6e64 5f74 696d 6520 3d20 2770 726f 6365  nd_time = 'proce
-00017390: 7373 696e 6727 2b65 6e64 5469 6d65 2b27  ssing'+endTime+'
-000173a0: 5f65 6e64 5f74 696d 6527 0a20 2020 2020  _end_time'.     
-000173b0: 2020 2020 2020 2073 6d61 6c6c 6466 5b65         smalldf[e
-000173c0: 6e64 5f74 696d 655d 203d 2073 6d61 6c6c  nd_time] = small
-000173d0: 6466 5b65 6e64 5469 6d65 5d2e 6d61 7028  df[endTime].map(
-000173e0: 6c61 6d62 6461 2078 3a20 782e 7370 6c69  lambda x: x.spli
-000173f0: 7428 2220 2229 5b31 5d29 0a20 2020 2020  t(" ")[1]).     
-00017400: 2020 2020 2020 2061 6464 5f63 6f6c 732e         add_cols.
-00017410: 6170 7065 6e64 2865 6e64 5f74 696d 6529  append(end_time)
-00017420: 0a20 2020 2020 2020 2065 7863 6570 743a  .        except:
-00017430: 0a20 2020 2020 2020 2020 2020 2023 2323  .            ###
-00017440: 2074 6865 7265 2069 7320 6e6f 2068 6f75   there is no hou
-00017450: 722d 6d69 6e75 7465 7320 7061 7274 206f  r-minutes part o
-00017460: 6620 7468 6973 2064 6174 6520 7469 6d65  f this date time
-00017470: 2073 7461 6d70 2066 6965 6c64 2e20 596f   stamp field. Yo
-00017480: 7520 6361 6e20 6a75 7374 2073 6b69 7020  u can just skip 
-00017490: 6974 2069 6620 6974 2069 7320 6e6f 7420  it if it is not 
-000174a0: 7468 6572 650a 2020 2020 2020 2020 2020  there.          
-000174b0: 2020 7061 7373 0a20 2020 2020 2020 2076    pass.        v
-000174c0: 6965 775f 6461 7973 203d 2027 7072 6f63  iew_days = 'proc
-000174d0: 6573 7369 6e67 272b 7374 6172 7454 696d  essing'+startTim
-000174e0: 652b 275f 656c 6170 7365 645f 6461 7973  e+'_elapsed_days
-000174f0: 270a 2020 2020 2020 2020 736d 616c 6c64  '.        smalld
-00017500: 665b 7669 6577 5f64 6179 735d 203d 2028  f[view_days] = (
-00017510: 7064 2e74 6f5f 6461 7465 7469 6d65 2873  pd.to_datetime(s
-00017520: 6d61 6c6c 6466 5b65 6e64 5f64 6174 655d  malldf[end_date]
-00017530: 2920 2d20 7064 2e74 6f5f 6461 7465 7469  ) - pd.to_dateti
-00017540: 6d65 2873 6d61 6c6c 6466 5b73 7461 7274  me(smalldf[start
-00017550: 5f64 6174 655d 2929 2e76 616c 7565 732e  _date])).values.
-00017560: 6173 7479 7065 2869 6e74 290a 2020 2020  astype(int).    
-00017570: 2020 2020 6164 645f 636f 6c73 2e61 7070      add_cols.app
-00017580: 656e 6428 7669 6577 5f64 6179 7329 0a20  end(view_days). 
-00017590: 2020 2020 2020 2074 7279 3a0a 2020 2020         try:.    
-000175a0: 2020 2020 2020 2020 7669 6577 5f74 696d          view_tim
-000175b0: 6520 3d20 2770 726f 6365 7373 696e 6727  e = 'processing'
-000175c0: 2b73 7461 7274 5469 6d65 2b27 5f65 6c61  +startTime+'_ela
-000175d0: 7073 6564 5f74 696d 6527 0a20 2020 2020  psed_time'.     
-000175e0: 2020 2020 2020 2073 6d61 6c6c 6466 5b76         smalldf[v
-000175f0: 6965 775f 7469 6d65 5d20 3d20 2870 642e  iew_time] = (pd.
-00017600: 746f 5f64 6174 6574 696d 6528 736d 616c  to_datetime(smal
-00017610: 6c64 665b 656e 645f 7469 6d65 5d29 202d  ldf[end_time]) -
-00017620: 2070 642e 746f 5f64 6174 6574 696d 6528   pd.to_datetime(
-00017630: 736d 616c 6c64 665b 7374 6172 745f 7469  smalldf[start_ti
-00017640: 6d65 5d29 292e 6173 7479 7065 2827 7469  me])).astype('ti
-00017650: 6d65 6465 6c74 6136 345b 735d 2729 2e76  medelta64[s]').v
-00017660: 616c 7565 730a 2020 2020 2020 2020 2020  alues.          
-00017670: 2020 6164 645f 636f 6c73 2e61 7070 656e    add_cols.appen
-00017680: 6428 7669 6577 5f74 696d 6529 0a20 2020  d(view_time).   
-00017690: 2020 2020 2065 7863 6570 743a 0a20 2020       except:.   
-000176a0: 2020 2020 2020 2020 2023 2323 2049 6e20           ### In 
-000176b0: 736f 6d65 2064 6174 6520 7469 6d65 2066  some date time f
-000176c0: 6965 6c64 7320 7468 6973 2067 6976 6573  ields this gives
-000176d0: 2061 6e20 6572 726f 7220 736f 2073 6b69   an error so ski
-000176e0: 7020 6974 2069 6e20 7468 6174 2063 6173  p it in that cas
-000176f0: 650a 2020 2020 2020 2020 2020 2020 7061  e.            pa
-00017700: 7373 0a20 2020 2020 2020 2023 2323 2320  ss.        #### 
-00017710: 5468 6520 7265 6173 6f6e 2077 6520 6368  The reason we ch
-00017720: 6f73 6520 656e 6454 696d 6520 6865 7265  ose endTime here
-00017730: 2069 7320 7468 6174 2073 7461 7274 5469   is that startTi
-00017740: 6d65 2069 7320 7573 7561 6c6c 7920 7461  me is usually ta
-00017750: 6b65 6e20 6361 7265 206f 6620 6279 2061  ken care of by a
-00017760: 6e6f 7468 6572 206c 6962 7261 7279 2e20  nother library. 
-00017770: 536f 2062 6574 7465 7220 746f 2064 6f20  So better to do 
-00017780: 7468 6973 2061 6c6f 6e65 2e0a 2020 2020  this alone..    
-00017790: 2020 2020 7965 6172 203d 2027 7072 6f63      year = 'proc
-000177a0: 6573 7369 6e67 272b 656e 6454 696d 652b  essing'+endTime+
-000177b0: 275f 656e 645f 7965 6172 270a 2020 2020  '_end_year'.    
-000177c0: 2020 2020 736d 616c 6c64 665b 7965 6172      smalldf[year
-000177d0: 5d20 3d20 736d 616c 6c64 665b 656e 645f  ] = smalldf[end_
-000177e0: 6461 7465 5d2e 6d61 7028 6c61 6d62 6461  date].map(lambda
-000177f0: 2078 3a20 7374 7228 7829 2e73 706c 6974   x: str(x).split
-00017800: 2873 706c 6974 7465 725f 6461 7465 5f73  (splitter_date_s
-00017810: 7472 696e 6729 5b30 5d29 2e76 616c 7565  tring)[0]).value
-00017820: 730a 2020 2020 2020 2020 6164 645f 636f  s.        add_co
-00017830: 6c73 2e61 7070 656e 6428 7965 6172 290a  ls.append(year).
-00017840: 2020 2020 2020 2020 2323 2323 2054 6865          #### The
-00017850: 2072 6561 736f 6e20 7765 2063 686f 7365   reason we chose
-00017860: 2065 6e64 5469 6d65 2068 6572 6520 6973   endTime here is
-00017870: 2074 6861 7420 7374 6172 7454 696d 6520   that startTime 
-00017880: 6973 2075 7375 616c 6c79 2074 616b 656e  is usually taken
-00017890: 2063 6172 6520 6f66 2062 7920 616e 6f74   care of by anot
-000178a0: 6865 7220 6c69 6272 6172 792e 2053 6f20  her library. So 
-000178b0: 6265 7474 6572 2074 6f20 646f 2074 6869  better to do thi
-000178c0: 7320 616c 6f6e 652e 0a20 2020 2020 2020  s alone..       
-000178d0: 206d 6f6e 7468 203d 2027 7072 6f63 6573   month = 'proces
-000178e0: 7369 6e67 272b 656e 6454 696d 652b 275f  sing'+endTime+'_
-000178f0: 656e 645f 6d6f 6e74 6827 0a20 2020 2020  end_month'.     
-00017900: 2020 2073 6d61 6c6c 6466 5b6d 6f6e 7468     smalldf[month
-00017910: 5d20 3d20 736d 616c 6c64 665b 656e 645f  ] = smalldf[end_
-00017920: 6461 7465 5d2e 6d61 7028 6c61 6d62 6461  date].map(lambda
-00017930: 2078 3a20 7374 7228 7829 2e73 706c 6974   x: str(x).split
-00017940: 2873 706c 6974 7465 725f 6461 7465 5f73  (splitter_date_s
-00017950: 7472 696e 6729 5b31 5d29 2e76 616c 7565  tring)[1]).value
-00017960: 730a 2020 2020 2020 2020 6164 645f 636f  s.        add_co
-00017970: 6c73 2e61 7070 656e 6428 6d6f 6e74 6829  ls.append(month)
-00017980: 0a20 2020 2020 2020 2074 7279 3a0a 2020  .        try:.  
-00017990: 2020 2020 2020 2020 2020 2323 2323 2054            #### T
-000179a0: 6865 2072 6561 736f 6e20 7765 2063 686f  he reason we cho
-000179b0: 7365 2065 6e64 5469 6d65 2068 6572 6520  se endTime here 
-000179c0: 6973 2074 6861 7420 7374 6172 7454 696d  is that startTim
-000179d0: 6520 6973 2075 7375 616c 6c79 2074 616b  e is usually tak
-000179e0: 656e 2063 6172 6520 6f66 2062 7920 616e  en care of by an
-000179f0: 6f74 6865 7220 6c69 6272 6172 792e 2053  other library. S
-00017a00: 6f20 6265 7474 6572 2074 6f20 646f 2074  o better to do t
-00017a10: 6869 7320 616c 6f6e 652e 0a20 2020 2020  his alone..     
-00017a20: 2020 2020 2020 2064 6179 6e75 6d20 3d20         daynum = 
-00017a30: 2770 726f 6365 7373 696e 6727 2b65 6e64  'processing'+end
-00017a40: 5469 6d65 2b27 5f65 6e64 5f64 6179 5f6e  Time+'_end_day_n
-00017a50: 756d 6265 7227 0a20 2020 2020 2020 2020  umber'.         
-00017a60: 2020 2073 6d61 6c6c 6466 5b64 6179 6e75     smalldf[daynu
-00017a70: 6d5d 203d 2073 6d61 6c6c 6466 5b65 6e64  m] = smalldf[end
-00017a80: 5f64 6174 655d 2e6d 6170 286c 616d 6264  _date].map(lambd
-00017a90: 6120 783a 2073 7472 2878 292e 7370 6c69  a x: str(x).spli
-00017aa0: 7428 7370 6c69 7474 6572 5f64 6174 655f  t(splitter_date_
-00017ab0: 7374 7269 6e67 295b 325d 292e 7661 6c75  string)[2]).valu
-00017ac0: 6573 0a20 2020 2020 2020 2020 2020 2061  es.            a
-00017ad0: 6464 5f63 6f6c 732e 6170 7065 6e64 2864  dd_cols.append(d
-00017ae0: 6179 6e75 6d29 0a20 2020 2020 2020 2065  aynum).        e
-00017af0: 7863 6570 743a 0a20 2020 2020 2020 2020  xcept:.         
-00017b00: 2020 2023 2323 2049 6e20 736f 6d65 2064     ### In some d
-00017b10: 6174 6520 7469 6d65 2066 6965 6c64 7320  ate time fields 
-00017b20: 7468 6520 6461 7920 6e75 6d62 6572 2069  the day number i
-00017b30: 7320 6e6f 7420 7468 6572 652e 2049 6620  s not there. If 
-00017b40: 6e6f 742c 206a 7573 7420 736b 6970 2069  not, just skip i
-00017b50: 7420 2323 2323 0a20 2020 2020 2020 2020  t ####.         
-00017b60: 2020 2070 6173 730a 2020 2020 2020 2020     pass.        
-00017b70: 2323 2323 2049 6e20 736f 6d65 2064 6174  #### In some dat
-00017b80: 6520 7469 6d65 2066 6965 6c64 732c 2074  e time fields, t
-00017b90: 6865 2068 6f75 7220 616e 6420 6d69 6e75  he hour and minu
-00017ba0: 7465 2069 7320 6e6f 7420 7468 6572 652c  te is not there,
-00017bb0: 2073 6f20 736b 6970 2069 7420 696e 2074   so skip it in t
-00017bc0: 6861 7420 6361 7365 2069 6620 6974 2065  hat case if it e
-00017bd0: 7272 6f72 7321 0a20 2020 2020 2020 2074  rrors!.        t
-00017be0: 7279 3a0a 2020 2020 2020 2020 2020 2020  ry:.            
-00017bf0: 7374 6172 745f 686f 7572 203d 2027 7072  start_hour = 'pr
-00017c00: 6f63 6573 7369 6e67 272b 7374 6172 7454  ocessing'+startT
-00017c10: 696d 652b 275f 7374 6172 745f 686f 7572  ime+'_start_hour
-00017c20: 270a 2020 2020 2020 2020 2020 2020 736d  '.            sm
-00017c30: 616c 6c64 665b 7374 6172 745f 686f 7572  alldf[start_hour
-00017c40: 5d20 3d20 736d 616c 6c64 665b 7374 6172  ] = smalldf[star
-00017c50: 745f 7469 6d65 5d2e 6d61 7028 6c61 6d62  t_time].map(lamb
-00017c60: 6461 2078 3a20 7374 7228 7829 2e73 706c  da x: str(x).spl
-00017c70: 6974 2873 706c 6974 7465 725f 686f 7572  it(splitter_hour
-00017c80: 5f73 7472 696e 6729 5b30 5d29 2e76 616c  _string)[0]).val
-00017c90: 7565 730a 2020 2020 2020 2020 2020 2020  ues.            
-00017ca0: 6164 645f 636f 6c73 2e61 7070 656e 6428  add_cols.append(
-00017cb0: 7374 6172 745f 686f 7572 290a 2020 2020  start_hour).    
-00017cc0: 2020 2020 2020 2020 7374 6172 745f 6d69          start_mi
-00017cd0: 6e20 3d20 2770 726f 6365 7373 696e 6727  n = 'processing'
-00017ce0: 2b73 7461 7274 5469 6d65 2b27 5f73 7461  +startTime+'_sta
-00017cf0: 7274 5f68 6f75 7227 0a20 2020 2020 2020  rt_hour'.       
-00017d00: 2020 2020 2073 6d61 6c6c 6466 5b73 7461       smalldf[sta
-00017d10: 7274 5f6d 696e 5d20 3d20 736d 616c 6c64  rt_min] = smalld
-00017d20: 665b 7374 6172 745f 7469 6d65 5d2e 6d61  f[start_time].ma
-00017d30: 7028 6c61 6d62 6461 2078 3a20 7374 7228  p(lambda x: str(
-00017d40: 7829 2e73 706c 6974 2873 706c 6974 7465  x).split(splitte
-00017d50: 725f 686f 7572 5f73 7472 696e 6729 5b31  r_hour_string)[1
-00017d60: 5d29 2e76 616c 7565 730a 2020 2020 2020  ]).values.      
-00017d70: 2020 2020 2020 6164 645f 636f 6c73 2e61        add_cols.a
-00017d80: 7070 656e 6428 7374 6172 745f 6d69 6e29  ppend(start_min)
-00017d90: 0a20 2020 2020 2020 2065 7863 6570 743a  .        except:
-00017da0: 0a20 2020 2020 2020 2020 2020 2023 2323  .            ###
-00017db0: 2049 6620 6974 2065 7272 6f72 732c 2073   If it errors, s
-00017dc0: 6b69 7020 6974 0a20 2020 2020 2020 2020  kip it.         
-00017dd0: 2020 2070 6173 730a 2020 2020 2020 2020     pass.        
-00017de0: 2323 2323 2043 6865 636b 2069 6620 7468  #### Check if th
-00017df0: 6572 6520 6973 2061 2077 6565 6b64 6179  ere is a weekday
-00017e00: 2061 6e64 2077 6565 6b65 6e64 7320 696e   and weekends in
-00017e10: 2064 6174 6520 7469 6d65 2063 6f6c 756d   date time colum
-00017e20: 6e73 2075 7369 6e67 2065 6e64 5469 6d65  ns using endTime
-00017e30: 206f 6e6c 790a 2020 2020 2020 2020 7765   only.        we
-00017e40: 656b 6461 795f 6e75 6d20 3d20 2770 726f  ekday_num = 'pro
-00017e50: 6365 7373 696e 6727 2b65 6e64 5469 6d65  cessing'+endTime
-00017e60: 2b27 5f65 6e64 5f77 6565 6b64 6179 5f6e  +'_end_weekday_n
-00017e70: 756d 6265 7227 0a20 2020 2020 2020 2073  umber'.        s
-00017e80: 6d61 6c6c 6466 5b77 6565 6b64 6179 5f6e  malldf[weekday_n
-00017e90: 756d 5d20 3d20 7064 2e74 6f5f 6461 7465  um] = pd.to_date
-00017ea0: 7469 6d65 2873 6d61 6c6c 6466 5b65 6e64  time(smalldf[end
-00017eb0: 5f64 6174 655d 292e 6474 2e77 6565 6b64  _date]).dt.weekd
-00017ec0: 6179 2e76 616c 7565 730a 2020 2020 2020  ay.values.      
-00017ed0: 2020 6164 645f 636f 6c73 2e61 7070 656e    add_cols.appen
-00017ee0: 6428 7765 656b 6461 795f 6e75 6d29 0a20  d(weekday_num). 
-00017ef0: 2020 2020 2020 2077 6565 6b65 6e64 203d         weekend =
-00017f00: 2027 7072 6f63 6573 7369 6e67 272b 656e   'processing'+en
-00017f10: 6454 696d 652b 275f 656e 645f 7765 656b  dTime+'_end_week
-00017f20: 656e 645f 666c 6167 270a 2020 2020 2020  end_flag'.      
-00017f30: 2020 736d 616c 6c64 665b 7765 656b 656e    smalldf[weeken
-00017f40: 645d 203d 2073 6d61 6c6c 6466 5b77 6565  d] = smalldf[wee
-00017f50: 6b64 6179 5f6e 756d 5d2e 6d61 7028 6c61  kday_num].map(la
-00017f60: 6d62 6461 2078 3a20 3120 6966 2078 2069  mbda x: 1 if x i
-00017f70: 6e5b 352c 365d 2065 6c73 6520 3029 0a20  n[5,6] else 0). 
-00017f80: 2020 2020 2020 2061 6464 5f63 6f6c 732e         add_cols.
-00017f90: 6170 7065 6e64 2877 6565 6b65 6e64 290a  append(weekend).
-00017fa0: 2020 2020 2323 2323 2049 6620 6576 6572      #### If ever
-00017fb0: 7974 6869 6e67 2077 6f72 6b73 2077 656c  ything works wel
-00017fc0: 6c2c 2074 6865 7265 2073 686f 756c 6420  l, there should 
-00017fd0: 6265 2031 3320 6e65 7720 636f 6c75 6d6e  be 13 new column
-00017fe0: 7320 6164 6465 6420 6279 206d 6f64 756c  s added by modul
-00017ff0: 652e 2041 6c6c 2074 6865 2062 6573 7421  e. All the best!
-00018000: 0a20 2020 2070 7269 6e74 2827 2564 2063  .    print('%d c
-00018010: 6f6c 756d 6e73 2061 6464 6564 2075 7369  olumns added usi
-00018020: 6e67 2073 7461 7274 2064 6174 653d 2573  ng start date=%s
-00018030: 2061 6e64 2065 6e64 2064 6174 653d 2573   and end date=%s
-00018040: 2070 726f 6365 7373 696e 672e 2e2e 2720   processing...' 
-00018050: 2528 6c65 6e28 6164 645f 636f 6c73 292c  %(len(add_cols),
-00018060: 7374 6172 7454 696d 652c 656e 6454 696d  startTime,endTim
-00018070: 6529 290a 2020 2020 7265 7475 726e 2073  e)).    return s
-00018080: 6d61 6c6c 6466 0a23 2323 2323 2323 2323  malldf.#########
-00018090: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000180a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000180b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000180c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000180d0: 2323 0a64 6566 2046 455f 7370 6c69 745f  ##.def FE_split_
-000180e0: 6f6e 655f 6669 656c 645f 696e 746f 5f6d  one_field_into_m
-000180f0: 616e 7928 6466 5f69 6e2c 2066 6965 6c64  any(df_in, field
-00018100: 2c20 7370 6c69 7474 6572 2c20 6669 6c6c  , splitter, fill
-00018110: 6572 2c20 6e65 775f 6e61 6d65 735f 6c69  er, new_names_li
-00018120: 7374 3d27 272c 2061 6464 5f63 6f75 6e74  st='', add_count
-00018130: 5f66 6965 6c64 3d46 616c 7365 293a 0a20  _field=False):. 
-00018140: 2020 2022 2222 0a20 2020 2046 4520 7374     """.    FE st
-00018150: 616e 6473 2066 6f72 2046 6561 7475 7265  ands for Feature
-00018160: 2045 6e67 696e 6565 7269 6e67 202d 2069   Engineering - i
-00018170: 7420 6d65 616e 7320 7468 6973 2066 756e  t means this fun
-00018180: 6374 696f 6e20 7065 7266 6f72 6d73 2066  ction performs f
-00018190: 6561 7475 7265 2065 6e67 696e 6565 7269  eature engineeri
-000181a0: 6e67 0a20 2020 2023 2323 2323 2323 2323  ng.    #########
-000181b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000181c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000181d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000181e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000181f0: 2323 2323 2323 2323 2323 2323 230a 2020  #############.  
-00018200: 2020 5468 6973 2066 756e 6374 696f 6e20    This function 
-00018210: 7461 6b65 7320 616e 7920 6461 7461 2066  takes any data f
-00018220: 7261 6d65 2066 6965 6c64 2028 7374 7269  rame field (stri
-00018230: 6e67 2076 6172 6961 626c 6573 206f 6e6c  ng variables onl
-00018240: 7929 2061 6e64 2073 706c 6974 730a 2020  y) and splits.  
-00018250: 2020 6974 2069 6e74 6f20 6173 206d 616e    it into as man
-00018260: 7920 6669 656c 6473 2061 7320 796f 7520  y fields as you 
-00018270: 7761 6e74 2069 6e20 7468 6520 6e65 775f  want in the new_
-00018280: 6e61 6d65 735f 6c69 7374 2e0a 0a20 2020  names_list...   
-00018290: 2049 6e70 7574 733a 0a20 2020 2020 2020   Inputs:.       
-000182a0: 2064 6674 3a20 7061 6e64 6173 2044 6174   dft: pandas Dat
-000182b0: 6146 7261 6d65 0a20 2020 2020 2020 2066  aFrame.        f
-000182c0: 6965 6c64 3a20 6e61 6d65 206f 6620 7374  ield: name of st
-000182d0: 7269 6e67 2063 6f6c 756d 6e20 7468 6174  ring column that
-000182e0: 2079 6f75 2077 616e 7420 746f 2073 706c   you want to spl
-000182f0: 6974 2075 7369 6e67 2074 6865 2073 706c  it using the spl
-00018300: 6974 7465 7220 7374 7269 6e67 2073 7065  itter string spe
-00018310: 6369 6669 6564 0a20 2020 2020 2020 2073  cified.        s
-00018320: 706c 6974 7465 723a 2073 7065 6369 6679  plitter: specify
-00018330: 2077 6861 7420 7374 7269 6e67 2074 6f20   what string to 
-00018340: 7370 6c69 7420 6f6e 2075 7369 6e67 2074  split on using t
-00018350: 6865 2073 706c 6974 7465 7220 6172 6775  he splitter argu
-00018360: 6d65 6e74 2e0a 2020 2020 2020 2020 6669  ment..        fi
-00018370: 6c6c 6572 3a20 596f 7520 6361 6e20 616c  ller: You can al
-00018380: 736f 2066 696c 6c20 4e75 6c6c 2076 616c  so fill Null val
-00018390: 7565 7320 7468 6174 206d 6179 2068 6170  ues that may hap
-000183a0: 7065 6e20 6475 6520 746f 2079 6f75 7220  pen due to your 
-000183b0: 7370 6c69 7474 696e 6720 6279 2073 7065  splitting by spe
-000183c0: 6369 6679 696e 6720 6120 6669 6c6c 6572  cifying a filler
-000183d0: 2e0a 2020 2020 2020 2020 6e65 775f 6e61  ..        new_na
-000183e0: 6d65 735f 6c69 7374 3a20 4966 206e 6f20  mes_list: If no 
-000183f0: 6e65 775f 6e61 6d65 735f 6c69 7374 2069  new_names_list i
-00018400: 7320 6769 7665 6e2c 2074 6865 6e20 7765  s given, then we
-00018410: 2075 7365 2074 6865 206e 616d 6520 6f66   use the name of
-00018420: 2074 6865 2066 6965 6c64 2069 7473 656c   the field itsel
-00018430: 6620 746f 2063 7265 6174 6520 6e65 7720  f to create new 
-00018440: 636f 6c75 6d6e 732e 0a20 2020 2020 2020  columns..       
-00018450: 2061 6464 5f63 6f75 6e74 5f66 6965 6c64   add_count_field
-00018460: 3a20 4661 6c73 6520 2864 6566 6175 6c74  : False (default
-00018470: 292e 2049 6620 5472 7565 2c20 6974 2077  ). If True, it w
-00018480: 696c 6c20 636f 756e 7420 7468 6520 6e75  ill count the nu
-00018490: 6d62 6572 206f 6620 6974 656d 7320 696e  mber of items in
-000184a0: 0a20 2020 2020 2020 2020 2020 2074 6865  .            the
-000184b0: 2022 6669 656c 6422 2063 6f6c 756d 6e20   "field" column 
-000184c0: 6265 666f 7265 2074 6865 2073 706c 6974  before the split
-000184d0: 2e20 5468 6973 206d 6179 2062 6520 6e65  . This may be ne
-000184e0: 6564 6564 2069 6e20 6e65 7374 6564 2064  eded in nested d
-000184f0: 6963 7469 6f6e 6172 7920 6669 656c 6473  ictionary fields
-00018500: 2e0a 0a20 2020 204f 7574 7075 7473 3a0a  ...    Outputs:.
-00018510: 2020 2020 2020 2020 6466 743a 206f 7269          dft: ori
-00018520: 6769 6e61 6c20 6461 7461 6672 616d 6520  ginal dataframe 
-00018530: 7769 7468 2061 6464 6974 696f 6e61 6c20  with additional 
-00018540: 636f 6c75 6d6e 7320 6372 6561 7465 6420  columns created 
-00018550: 6279 2073 706c 6974 7469 6e67 2074 6865  by splitting the
-00018560: 2066 6965 6c64 2e0a 2020 2020 2020 2020   field..        
-00018570: 6e65 775f 6e61 6d65 735f 6c69 7374 3a20  new_names_list: 
-00018580: 7468 6520 6c69 7374 206f 6620 6e65 7720  the list of new 
-00018590: 636f 6c75 6d6e 7320 6372 6561 7465 6420  columns created 
-000185a0: 6279 2074 6869 7320 6675 6e63 7469 6f6e  by this function
-000185b0: 0a20 2020 2023 2323 2323 2323 2323 2323  .    ###########
-000185c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000185d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00015dd0: 2323 2323 2323 2323 2323 2323 2323 230a  ###############.
+00015de0: 6465 6620 6472 6177 5f66 6561 7475 7265  def draw_feature
+00015df0: 5f69 6d70 6f72 7461 6e63 6573 5f73 696e  _importances_sin
+00015e00: 676c 655f 6c61 6265 6c28 6273 745f 6d6f  gle_label(bst_mo
+00015e10: 6465 6c73 2c20 6461 736b 5f78 6762 6f6f  dels, dask_xgboo
+00015e20: 7374 5f66 6c61 673d 4661 6c73 6529 3a0a  st_flag=False):.
+00015e30: 2020 2020 726f 7773 203d 2069 6e74 286c      rows = int(l
+00015e40: 656e 2862 7374 5f6d 6f64 656c 7329 2f32  en(bst_models)/2
+00015e50: 202b 2030 2e35 290a 2020 2020 636f 6c75   + 0.5).    colu
+00015e60: 7320 3d20 320a 2020 2020 6669 672c 2061  s = 2.    fig, a
+00015e70: 7820 3d20 706c 742e 7375 6270 6c6f 7473  x = plt.subplots
+00015e80: 2872 6f77 732c 2063 6f6c 7573 290a 2020  (rows, colus).  
+00015e90: 2020 6669 672e 7365 745f 7369 7a65 5f69    fig.set_size_i
+00015ea0: 6e63 6865 7328 6d69 6e28 636f 6c75 732a  nches(min(colus*
+00015eb0: 352c 3230 292c 726f 7773 2a35 290a 2020  5,20),rows*5).  
+00015ec0: 2020 6669 672e 7375 6270 6c6f 7473 5f61    fig.subplots_a
+00015ed0: 646a 7573 7428 6873 7061 6365 3d30 2e35  djust(hspace=0.5
+00015ee0: 2920 2323 2320 5468 6973 2063 6f6e 7472  ) ### This contr
+00015ef0: 6f6c 7320 7468 6520 7370 6163 6520 6265  ols the space be
+00015f00: 7477 656e 2072 6f77 730a 2020 2020 6669  twen rows.    fi
+00015f10: 672e 7375 6270 6c6f 7473 5f61 646a 7573  g.subplots_adjus
+00015f20: 7428 7773 7061 6365 3d30 2e35 2920 2323  t(wspace=0.5) ##
+00015f30: 2320 5468 6973 2063 6f6e 7472 6f6c 7320  # This controls 
+00015f40: 7468 6520 7370 6163 6520 6265 7477 6565  the space betwee
+00015f50: 6e20 636f 6c75 6d6e 730a 2020 2020 636f  n columns.    co
+00015f60: 756e 7465 7220 3d20 300a 2020 2020 6966  unter = 0.    if
+00015f70: 2072 6f77 7320 3d3d 2031 3a0a 2020 2020   rows == 1:.    
+00015f80: 2020 2020 6178 203d 2061 782e 7265 7368      ax = ax.resh
+00015f90: 6170 6528 2d31 2c31 292e 540a 2020 2020  ape(-1,1).T.    
+00015fa0: 666f 7220 6b20 696e 206e 702e 6172 616e  for k in np.aran
+00015fb0: 6765 2872 6f77 7329 3a0a 2020 2020 2020  ge(rows):.      
+00015fc0: 2020 666f 7220 6c20 696e 206e 702e 6172    for l in np.ar
+00015fd0: 616e 6765 2863 6f6c 7573 293a 0a20 2020  ange(colus):.   
+00015fe0: 2020 2020 2020 2020 2069 6620 636f 756e           if coun
+00015ff0: 7465 7220 3c20 6c65 6e28 6273 745f 6d6f  ter < len(bst_mo
+00016000: 6465 6c73 293a 0a20 2020 2020 2020 2020  dels):.         
+00016010: 2020 2020 2020 2074 7279 3a0a 2020 2020         try:.    
+00016020: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00016030: 6273 745f 626f 6f73 7465 7220 3d20 6273  bst_booster = bs
+00016040: 745f 6d6f 6465 6c73 5b63 6f75 6e74 6572  t_models[counter
+00016050: 5d0a 2020 2020 2020 2020 2020 2020 2020  ].              
+00016060: 2020 2020 2020 6178 3120 3d20 7867 626f        ax1 = xgbo
+00016070: 6f73 742e 706c 6f74 5f69 6d70 6f72 7461  ost.plot_importa
+00016080: 6e63 6528 6273 745f 626f 6f73 7465 722c  nce(bst_booster,
+00016090: 2068 6569 6768 743d 302e 382c 2073 686f   height=0.8, sho
+000160a0: 775f 7661 6c75 6573 3d46 616c 7365 2c0a  w_values=False,.
+000160b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000160c0: 2020 2020 2020 2020 2020 2020 696d 706f              impo
+000160d0: 7274 616e 6365 5f74 7970 653d 2767 6169  rtance_type='gai
+000160e0: 6e27 2c20 6d61 785f 6e75 6d5f 6665 6174  n', max_num_feat
+000160f0: 7572 6573 3d31 302c 2061 783d 6178 5b6b  ures=10, ax=ax[k
+00016100: 5d5b 6c5d 290a 2020 2020 2020 2020 2020  ][l]).          
+00016110: 2020 2020 2020 2020 2020 6178 312e 7365            ax1.se
+00016120: 745f 7469 746c 6528 2754 6f70 2031 3020  t_title('Top 10 
+00016130: 6665 6174 7572 6573 2077 6974 6820 5847  features with XG
+00016140: 4220 6d6f 6465 6c20 2573 2720 2528 636f  B model %s' %(co
+00016150: 756e 7465 722b 3129 290a 2020 2020 2020  unter+1)).      
+00016160: 2020 2020 2020 2020 2020 6578 6365 7074            except
+00016170: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00016180: 2020 2020 2020 7061 7373 0a20 2020 2020        pass.     
+00016190: 2020 2020 2020 2063 6f75 6e74 6572 202b         counter +
+000161a0: 3d20 310a 2020 2020 706c 742e 7368 6f77  = 1.    plt.show
+000161b0: 2829 3b0a 2323 2323 2323 2323 2323 2323  ();.############
+000161c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000161d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000161e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000161f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00016200: 2323 2323 2323 2323 2323 0a64 6566 2072  ##########.def r
+00016210: 6564 7563 655f 6d65 6d5f 7573 6167 6528  educe_mem_usage(
+00016220: 6466 293a 0a20 2020 2022 2222 0a20 2020  df):.    """.   
+00016230: 2023 2323 2323 2323 2323 2323 2323 2323   ###############
+00016240: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00016250: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00016260: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00016270: 2323 2323 2323 0a20 2020 2047 7265 6174  ######.    Great
+00016280: 6c79 2069 6e64 6562 7465 6420 746f 203a  ly indebted to :
+00016290: 0a20 2020 2068 7474 7073 3a2f 2f77 7777  .    https://www
+000162a0: 2e6b 6167 676c 652e 636f 6d2f 6172 6a61  .kaggle.com/arja
+000162b0: 6e73 6f2f 7265 6475 6369 6e67 2d64 6174  nso/reducing-dat
+000162c0: 6166 7261 6d65 2d6d 656d 6f72 792d 7369  aframe-memory-si
+000162d0: 7a65 2d62 792d 3635 0a20 2020 2020 2020  ze-by-65.       
+000162e0: 2066 6f72 2074 6869 7320 6675 6e63 7469   for this functi
+000162f0: 6f6e 2074 6f20 7265 6475 6365 206d 656d  on to reduce mem
+00016300: 6f72 7920 7573 6167 652e 0a20 2020 2023  ory usage..    #
+00016310: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00016320: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00016330: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00016340: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00016350: 2323 2323 0a20 2020 2049 7420 6973 2061  ####.    It is a
+00016360: 2062 6974 2073 6c6f 7720 6173 2069 7420   bit slow as it 
+00016370: 6974 6572 6174 6573 2074 6872 6f75 6768  iterates through
+00016380: 2061 6c6c 2074 6865 2063 6f6c 756d 6e73   all the columns
+00016390: 206f 6620 6120 6461 7461 6672 616d 6520   of a dataframe 
+000163a0: 616e 6420 6d6f 6469 6669 6573 2064 6174  and modifies dat
+000163b0: 6120 7479 7065 730a 2020 2020 2020 2020  a types.        
+000163c0: 746f 2072 6564 7563 6520 6d65 6d6f 7279  to reduce memory
+000163d0: 2075 7361 6765 2e20 4275 7420 6974 2068   usage. But it h
+000163e0: 6173 2062 6565 6e20 7368 6f77 6e20 746f  as been shown to
+000163f0: 2072 6564 7563 6520 6d65 6d6f 7279 2075   reduce memory u
+00016400: 7361 6765 2062 7920 3635 2520 6f72 2073  sage by 65% or s
+00016410: 6f2e 2020 2020 2020 200a 2020 2020 2222  o.       .    ""
+00016420: 220a 2020 2020 7374 6172 745f 6d65 6d20  ".    start_mem 
+00016430: 3d20 6466 2e6d 656d 6f72 795f 7573 6167  = df.memory_usag
+00016440: 6528 292e 7375 6d28 2920 2f20 3130 3234  e().sum() / 1024
+00016450: 2a2a 320a 2020 2020 6966 2074 7970 6528  **2.    if type(
+00016460: 6466 2920 3d3d 2064 6173 6b2e 6461 7461  df) == dask.data
+00016470: 6672 616d 652e 636f 7265 2e44 6174 6146  frame.core.DataF
+00016480: 7261 6d65 3a0a 2020 2020 2020 2020 7374  rame:.        st
+00016490: 6172 745f 6d65 6d20 3d20 7374 6172 745f  art_mem = start_
+000164a0: 6d65 6d2e 636f 6d70 7574 6528 290a 2020  mem.compute().  
+000164b0: 2020 7072 696e 7428 2720 2020 2043 6175    print('    Cau
+000164c0: 7469 6f6e 3a20 5765 2077 696c 6c20 7472  tion: We will tr
+000164d0: 7920 746f 2072 6564 7563 6520 7468 6520  y to reduce the 
+000164e0: 6d65 6d6f 7279 2075 7361 6765 206f 6620  memory usage of 
+000164f0: 6461 7461 6672 616d 6520 6672 6f6d 207b  dataframe from {
+00016500: 3a2e 3266 7d20 4d42 272e 666f 726d 6174  :.2f} MB'.format
+00016510: 2873 7461 7274 5f6d 656d 2929 0a20 2020  (start_mem)).   
+00016520: 2063 6f6c 7320 3d20 6466 2e63 6f6c 756d   cols = df.colum
+00016530: 6e73 0a20 2020 2069 6620 7479 7065 2864  ns.    if type(d
+00016540: 6629 203d 3d20 6461 736b 2e64 6174 6166  f) == dask.dataf
+00016550: 7261 6d65 2e63 6f72 652e 4461 7461 4672  rame.core.DataFr
+00016560: 616d 653a 0a20 2020 2020 2020 2063 6f6c  ame:.        col
+00016570: 7320 3d20 636f 6c73 2e74 6f6c 6973 7428  s = cols.tolist(
+00016580: 290a 0a20 2020 2066 6f72 2063 6f6c 2069  )..    for col i
+00016590: 6e20 636f 6c73 3a0a 2020 2020 2020 2020  n cols:.        
+000165a0: 636f 6c5f 7479 7065 203d 2064 665b 636f  col_type = df[co
+000165b0: 6c5d 2e64 7479 7065 0a20 2020 2020 2020  l].dtype.       
+000165c0: 2069 6620 636f 6c5f 7479 7065 2021 3d20   if col_type != 
+000165d0: 6f62 6a65 6374 3a0a 2020 2020 2020 2020  object:.        
+000165e0: 2020 2020 7472 793a 0a20 2020 2020 2020      try:.       
+000165f0: 2020 2020 2020 2020 2063 5f6d 696e 203d           c_min =
+00016600: 2064 665b 636f 6c5d 2e6d 696e 2829 0a20   df[col].min(). 
+00016610: 2020 2020 2020 2020 2020 2020 2020 2063                 c
+00016620: 5f6d 6178 203d 2064 665b 636f 6c5d 2e6d  _max = df[col].m
+00016630: 6178 2829 0a20 2020 2020 2020 2020 2020  ax().           
+00016640: 2065 7863 6570 743a 0a20 2020 2020 2020   except:.       
+00016650: 2020 2020 2020 2020 2063 6f6e 7469 6e75           continu
+00016660: 650a 2020 2020 2020 2020 2020 2020 6966  e.            if
+00016670: 2074 7970 6528 6466 2920 3d3d 2064 6173   type(df) == das
+00016680: 6b2e 6461 7461 6672 616d 652e 636f 7265  k.dataframe.core
+00016690: 2e44 6174 6146 7261 6d65 3a0a 2020 2020  .DataFrame:.    
+000166a0: 2020 2020 2020 2020 2020 2020 635f 6d69              c_mi
+000166b0: 6e20 3d20 635f 6d69 6e2e 636f 6d70 7574  n = c_min.comput
+000166c0: 6528 290a 2020 2020 2020 2020 2020 2020  e().            
+000166d0: 2020 2020 635f 6d61 7820 3d20 635f 6d61      c_max = c_ma
+000166e0: 782e 636f 6d70 7574 6528 290a 2020 2020  x.compute().    
+000166f0: 2020 2020 2020 2020 6966 2073 7472 2863          if str(c
+00016700: 6f6c 5f74 7970 6529 5b3a 335d 203d 3d20  ol_type)[:3] == 
+00016710: 2769 6e74 273a 0a20 2020 2020 2020 2020  'int':.         
+00016720: 2020 2020 2020 2069 6620 635f 6d69 6e20         if c_min 
+00016730: 3e20 6e70 2e69 696e 666f 286e 702e 696e  > np.iinfo(np.in
+00016740: 7438 292e 6d69 6e20 616e 6420 635f 6d61  t8).min and c_ma
+00016750: 7820 3c20 6e70 2e69 696e 666f 286e 702e  x < np.iinfo(np.
+00016760: 696e 7438 292e 6d61 783a 0a20 2020 2020  int8).max:.     
+00016770: 2020 2020 2020 2020 2020 2020 2020 2064                 d
+00016780: 665b 636f 6c5d 203d 2064 665b 636f 6c5d  f[col] = df[col]
+00016790: 2e61 7374 7970 6528 6e70 2e69 6e74 3829  .astype(np.int8)
+000167a0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+000167b0: 2065 6c69 6620 635f 6d69 6e20 3e20 6e70   elif c_min > np
+000167c0: 2e69 696e 666f 286e 702e 696e 7431 3629  .iinfo(np.int16)
+000167d0: 2e6d 696e 2061 6e64 2063 5f6d 6178 203c  .min and c_max <
+000167e0: 206e 702e 6969 6e66 6f28 6e70 2e69 6e74   np.iinfo(np.int
+000167f0: 3136 292e 6d61 783a 0a20 2020 2020 2020  16).max:.       
+00016800: 2020 2020 2020 2020 2020 2020 2064 665b               df[
+00016810: 636f 6c5d 203d 2064 665b 636f 6c5d 2e61  col] = df[col].a
+00016820: 7374 7970 6528 6e70 2e69 6e74 3136 290a  stype(np.int16).
+00016830: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00016840: 656c 6966 2063 5f6d 696e 203e 206e 702e  elif c_min > np.
+00016850: 6969 6e66 6f28 6e70 2e69 6e74 3332 292e  iinfo(np.int32).
+00016860: 6d69 6e20 616e 6420 635f 6d61 7820 3c20  min and c_max < 
+00016870: 6e70 2e69 696e 666f 286e 702e 696e 7433  np.iinfo(np.int3
+00016880: 3229 2e6d 6178 3a0a 2020 2020 2020 2020  2).max:.        
+00016890: 2020 2020 2020 2020 2020 2020 6466 5b63              df[c
+000168a0: 6f6c 5d20 3d20 6466 5b63 6f6c 5d2e 6173  ol] = df[col].as
+000168b0: 7479 7065 286e 702e 696e 7433 3229 0a20  type(np.int32). 
+000168c0: 2020 2020 2020 2020 2020 2020 2020 2065                 e
+000168d0: 6c69 6620 635f 6d69 6e20 3e20 6e70 2e69  lif c_min > np.i
+000168e0: 696e 666f 286e 702e 696e 7436 3429 2e6d  info(np.int64).m
+000168f0: 696e 2061 6e64 2063 5f6d 6178 203c 206e  in and c_max < n
+00016900: 702e 6969 6e66 6f28 6e70 2e69 6e74 3634  p.iinfo(np.int64
+00016910: 292e 6d61 783a 0a20 2020 2020 2020 2020  ).max:.         
+00016920: 2020 2020 2020 2020 2020 2064 665b 636f             df[co
+00016930: 6c5d 203d 2064 665b 636f 6c5d 2e61 7374  l] = df[col].ast
+00016940: 7970 6528 6e70 2e69 6e74 3634 2920 200a  ype(np.int64)  .
+00016950: 2020 2020 2020 2020 2020 2020 656c 7365              else
+00016960: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00016970: 2020 7472 793a 0a20 2020 2020 2020 2020    try:.         
+00016980: 2020 2020 2020 2020 2020 2069 6620 635f             if c_
+00016990: 6d69 6e20 3e20 6e70 2e66 696e 666f 286e  min > np.finfo(n
+000169a0: 702e 666c 6f61 7431 3629 2e6d 696e 2061  p.float16).min a
+000169b0: 6e64 2063 5f6d 6178 203c 206e 702e 6669  nd c_max < np.fi
+000169c0: 6e66 6f28 6e70 2e66 6c6f 6174 3136 292e  nfo(np.float16).
+000169d0: 6d61 783a 0a20 2020 2020 2020 2020 2020  max:.           
+000169e0: 2020 2020 2020 2020 2020 2020 2064 665b               df[
+000169f0: 636f 6c5d 203d 2064 665b 636f 6c5d 2e61  col] = df[col].a
+00016a00: 7374 7970 6528 6e70 2e66 6c6f 6174 3136  stype(np.float16
+00016a10: 290a 2020 2020 2020 2020 2020 2020 2020  ).              
+00016a20: 2020 2020 2020 656c 6966 2063 5f6d 696e        elif c_min
+00016a30: 203e 206e 702e 6669 6e66 6f28 6e70 2e66   > np.finfo(np.f
+00016a40: 6c6f 6174 3332 292e 6d69 6e20 616e 6420  loat32).min and 
+00016a50: 635f 6d61 7820 3c20 6e70 2e66 696e 666f  c_max < np.finfo
+00016a60: 286e 702e 666c 6f61 7433 3229 2e6d 6178  (np.float32).max
+00016a70: 3a0a 2020 2020 2020 2020 2020 2020 2020  :.              
+00016a80: 2020 2020 2020 2020 2020 6466 5b63 6f6c            df[col
+00016a90: 5d20 3d20 6466 5b63 6f6c 5d2e 6173 7479  ] = df[col].asty
+00016aa0: 7065 286e 702e 666c 6f61 7433 3229 0a20  pe(np.float32). 
+00016ab0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00016ac0: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+00016ad0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00016ae0: 2064 665b 636f 6c5d 203d 2064 665b 636f   df[col] = df[co
+00016af0: 6c5d 2e61 7374 7970 6528 6e70 2e66 6c6f  l].astype(np.flo
+00016b00: 6174 3634 290a 2020 2020 2020 2020 2020  at64).          
+00016b10: 2020 2020 2020 6578 6365 7074 3a0a 2020        except:.  
+00016b20: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00016b30: 2020 636f 6e74 696e 7565 0a20 2020 2020    continue.     
+00016b40: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
+00016b50: 2020 2020 2064 665b 636f 6c5d 203d 2064       df[col] = d
+00016b60: 665b 636f 6c5d 2e61 7374 7970 6528 2763  f[col].astype('c
+00016b70: 6174 6567 6f72 7927 290a 0a20 2020 2023  ategory')..    #
+00016b80: 2323 2323 2323 2020 5265 7375 6c74 7320  ######  Results 
+00016b90: 6166 7465 7220 6d65 6d6f 7279 2075 7361  after memory usa
+00016ba0: 6765 2066 756e 6374 696f 6e20 2323 2323  ge function ####
+00016bb0: 2323 2323 2323 2323 2323 2323 2323 230a  ###############.
+00016bc0: 2020 2020 656e 645f 6d65 6d20 3d20 6466      end_mem = df
+00016bd0: 2e6d 656d 6f72 795f 7573 6167 6528 292e  .memory_usage().
+00016be0: 7375 6d28 2920 2f20 3130 3234 2a2a 320a  sum() / 1024**2.
+00016bf0: 2020 2020 6966 2074 7970 6528 6466 2920      if type(df) 
+00016c00: 3d3d 2064 6173 6b2e 6461 7461 6672 616d  == dask.datafram
+00016c10: 652e 636f 7265 2e44 6174 6146 7261 6d65  e.core.DataFrame
+00016c20: 3a0a 2020 2020 2020 2020 656e 645f 6d65  :.        end_me
+00016c30: 6d20 3d20 656e 645f 6d65 6d2e 636f 6d70  m = end_mem.comp
+00016c40: 7574 6528 290a 2020 2020 7072 696e 7428  ute().    print(
+00016c50: 6627 2020 2020 2020 2020 6279 207b 2831  f'        by {(1
+00016c60: 3030 202a 2028 7374 6172 745f 6d65 6d20  00 * (start_mem 
+00016c70: 2d20 656e 645f 6d65 6d29 202f 2073 7461  - end_mem) / sta
+00016c80: 7274 5f6d 656d 293a 2e31 667d 252e 204d  rt_mem):.1f}%. M
+00016c90: 656d 6f72 7920 7573 6167 6520 6166 7465  emory usage afte
+00016ca0: 7220 6973 3a20 7b65 6e64 5f6d 656d 3a2e  r is: {end_mem:.
+00016cb0: 3266 7d20 4d42 2729 2020 2020 0a20 2020  2f} MB')    .   
+00016cc0: 2072 6574 7572 6e20 6466 0a23 2323 2323   return df.#####
+00016cd0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00016ce0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00016cf0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00016d00: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00016d10: 2323 2323 2323 2323 2323 2323 230a 6465  #############.de
+00016d20: 6620 4645 5f73 7461 7274 5f65 6e64 5f64  f FE_start_end_d
+00016d30: 6174 655f 7469 6d65 5f66 6561 7475 7265  ate_time_feature
+00016d40: 7328 736d 616c 6c64 662c 2073 7461 7274  s(smalldf, start
+00016d50: 5469 6d65 2c20 656e 6454 696d 652c 2073  Time, endTime, s
+00016d60: 706c 6974 7465 725f 6461 7465 5f73 7472  plitter_date_str
+00016d70: 696e 673d 222f 222c 7370 6c69 7474 6572  ing="/",splitter
+00016d80: 5f68 6f75 725f 7374 7269 6e67 3d22 3a22  _hour_string=":"
+00016d90: 293a 0a20 2020 2022 2222 0a20 2020 2046  ):.    """.    F
+00016da0: 4520 7374 616e 6473 2066 6f72 2046 6561  E stands for Fea
+00016db0: 7475 7265 2045 6e67 696e 6565 7269 6e67  ture Engineering
+00016dc0: 202d 2069 7420 6d65 616e 7320 7468 6973   - it means this
+00016dd0: 2066 756e 6374 696f 6e20 7065 7266 6f72   function perfor
+00016de0: 6d73 2066 6561 7475 7265 2065 6e67 696e  ms feature engin
+00016df0: 6565 7269 6e67 0a20 2020 2023 2323 2323  eering.    #####
+00016e00: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00016e10: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00016e20: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00016e30: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00016e40: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00016e50: 230a 2020 2020 5468 6973 2066 756e 6374  #.    This funct
+00016e60: 696f 6e20 6973 2075 7365 6420 7768 656e  ion is used when
+00016e70: 2079 6f75 2068 6176 6520 7374 6172 7420   you have start 
+00016e80: 616e 6420 656e 6420 6461 7465 2074 696d  and end date tim
+00016e90: 6520 7374 616d 7073 2069 6e20 796f 7572  e stamps in your
+00016ea0: 2064 6174 6173 6574 2e0a 2020 2020 2020   dataset..      
+00016eb0: 2020 2d20 4966 2074 6865 7265 2069 7320    - If there is 
+00016ec0: 6e6f 2073 7461 7274 2061 6e64 2065 6e64  no start and end
+00016ed0: 2074 696d 6520 6665 6174 7572 6573 2c20   time features, 
+00016ee0: 646f 6e27 7420 7573 6520 6974 2e20 426f  don't use it. Bo
+00016ef0: 7468 206d 7573 7420 6265 2070 7265 7365  th must be prese
+00016f00: 6e74 210a 2020 2020 2020 2020 2d20 7468  nt!.        - th
+00016f10: 6973 206d 6f64 756c 6520 7769 6c6c 2063  is module will c
+00016f20: 7265 6174 6520 6164 6469 7469 6f6e 616c  reate additional
+00016f30: 2066 6561 7475 7265 7320 666f 7220 7375   features for su
+00016f40: 6368 2066 6965 6c64 732e 0a20 2020 2020  ch fields..     
+00016f50: 2020 202d 2079 6f75 206d 7573 7420 7072     - you must pr
+00016f60: 6f76 6964 6520 6120 7374 6172 7420 6461  ovide a start da
+00016f70: 7465 2074 696d 6520 7374 616d 7020 6669  te time stamp fi
+00016f80: 656c 6420 616e 6420 616e 2065 6e64 2064  eld and an end d
+00016f90: 6174 6520 7469 6d65 2073 7461 6d70 2066  ate time stamp f
+00016fa0: 6965 6c64 0a20 2020 204f 7468 6572 7769  ield.    Otherwi
+00016fb0: 7365 2c20 796f 7520 6172 6520 6265 7474  se, you are bett
+00016fc0: 6572 206f 6666 2075 7369 6e67 2074 6865  er off using the
+00016fd0: 2046 455f 6372 6561 7465 5f64 6174 655f   FE_create_date_
+00016fe0: 7469 6d65 5f66 6561 7475 7265 7328 2920  time_features() 
+00016ff0: 6d6f 6475 6c65 2069 6e20 7468 6973 206c  module in this l
+00017000: 6962 7261 7279 2e0a 0a20 2020 2049 6e70  ibrary...    Inp
+00017010: 7574 733a 0a20 2020 2073 6d61 6c6c 6466  uts:.    smalldf
+00017020: 3a20 4461 7461 6672 616d 6520 636f 6e74  : Dataframe cont
+00017030: 6169 6e69 6e67 2079 6f75 7220 6461 7465  aining your date
+00017040: 2074 696d 6520 6669 656c 6473 0a20 2020   time fields.   
+00017050: 2073 7461 7274 5469 6d65 3a20 7468 6973   startTime: this
+00017060: 2069 7320 686f 7065 6675 6c6c 7920 6120   is hopefully a 
+00017070: 7374 7269 6e67 2066 6965 6c64 2077 6869  string field whi
+00017080: 6368 2063 6f6e 7665 7274 7320 746f 2061  ch converts to a
+00017090: 2064 6174 6520 7469 6d65 2073 7461 6d70   date time stamp
+000170a0: 2065 6173 696c 792e 204d 616b 6520 7375   easily. Make su
+000170b0: 7265 2069 7420 6973 2061 2073 7472 696e  re it is a strin
+000170c0: 672e 0a20 2020 2065 6e64 5469 6d65 3a20  g..    endTime: 
+000170d0: 7468 6973 2061 6c73 6f20 6d75 7374 2062  this also must b
+000170e0: 6520 6120 7374 7269 6e67 2066 6965 6c64  e a string field
+000170f0: 2077 6869 6368 2063 6f6e 7665 7274 7320   which converts 
+00017100: 746f 2061 2064 6174 6520 7469 6d65 2073  to a date time s
+00017110: 7461 6d70 2065 6173 696c 792e 204d 616b  tamp easily. Mak
+00017120: 6520 7375 7265 2069 7420 6973 2061 2073  e sure it is a s
+00017130: 7472 696e 672e 0a20 2020 2073 706c 6974  tring..    split
+00017140: 7465 725f 6461 7465 5f73 7472 696e 673a  ter_date_string:
+00017150: 2075 7375 616c 6c79 2074 6865 7265 2069   usually there i
+00017160: 7320 6120 7374 7269 6e67 2073 7563 6820  s a string such 
+00017170: 6173 2027 2f27 206f 7220 272e 2720 6265  as '/' or '.' be
+00017180: 7477 6565 6e20 6461 792f 6d6f 6e74 682f  tween day/month/
+00017190: 7965 6172 2065 7463 2e20 4465 6661 756c  year etc. Defaul
+000171a0: 7420 6973 2061 7373 756d 6564 202f 2068  t is assumed / h
+000171b0: 6572 652e 0a20 2020 2073 706c 6974 7465  ere..    splitte
+000171c0: 725f 686f 7572 5f73 7472 696e 673a 2075  r_hour_string: u
+000171d0: 7375 616c 6c79 2074 6865 7265 2069 7320  sually there is 
+000171e0: 6120 7374 7269 6e67 2073 7563 6820 6173  a string such as
+000171f0: 2027 3a27 206f 7220 272e 2720 6265 7477   ':' or '.' betw
+00017200: 6565 6e20 686f 7572 3a6d 696e 3a73 6563  een hour:min:sec
+00017210: 2065 7463 2e20 4465 6661 756c 7420 6973   etc. Default is
+00017220: 2061 7373 756d 6564 203a 2068 6572 652e   assumed : here.
+00017230: 0a0a 2020 2020 4f75 7470 7574 733a 0a20  ..    Outputs:. 
+00017240: 2020 2054 6865 206f 7269 6769 6e61 6c20     The original 
+00017250: 7061 6e64 6173 2064 6174 6166 7261 6d65  pandas dataframe
+00017260: 2077 6974 6820 6164 6469 7469 6f6e 616c   with additional
+00017270: 2066 6965 6c64 7320 6372 6561 7465 6420   fields created 
+00017280: 6279 2073 706c 6974 7469 6e67 2074 6865  by splitting the
+00017290: 2073 7461 7274 2061 6e64 2065 6e64 2074   start and end t
+000172a0: 696d 6520 6669 656c 6473 0a20 2020 2023  ime fields.    #
+000172b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000172c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000172d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000172e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000172f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00017300: 2323 2323 230a 2020 2020 2222 220a 2020  #####.    """.  
+00017310: 2020 736d 616c 6c64 6620 3d20 736d 616c    smalldf = smal
+00017320: 6c64 662e 636f 7079 2829 0a20 2020 2061  ldf.copy().    a
+00017330: 6464 5f63 6f6c 7320 3d20 5b5d 0a20 2020  dd_cols = [].   
+00017340: 2064 6174 655f 7469 6d65 5f76 6172 6961   date_time_varia
+00017350: 626c 655f 666c 6167 203d 2046 616c 7365  ble_flag = False
+00017360: 0a20 2020 2069 6620 736d 616c 6c64 665b  .    if smalldf[
+00017370: 7374 6172 7454 696d 655d 2e64 7479 7065  startTime].dtype
+00017380: 2069 6e20 5b27 6461 7465 7469 6d65 3634   in ['datetime64
+00017390: 5b6e 735d 272c 2764 6174 6574 696d 6531  [ns]','datetime1
+000173a0: 365b 6e73 5d27 2c27 6461 7465 7469 6d65  6[ns]','datetime
+000173b0: 3332 5b6e 735d 275d 3a0a 2020 2020 2020  32[ns]']:.      
+000173c0: 2020 7072 696e 7428 2725 7320 7661 7269    print('%s vari
+000173d0: 6162 6c65 2069 7320 6120 6461 7465 2d74  able is a date-t
+000173e0: 696d 6520 7661 7269 6162 6c65 2720 2573  ime variable' %s
+000173f0: 7461 7274 5469 6d65 290a 2020 2020 2020  tartTime).      
+00017400: 2020 6461 7465 5f74 696d 655f 7661 7269    date_time_vari
+00017410: 6162 6c65 5f66 6c61 6720 3d20 5472 7565  able_flag = True
+00017420: 0a20 2020 2069 6620 6461 7465 5f74 696d  .    if date_tim
+00017430: 655f 7661 7269 6162 6c65 5f66 6c61 673a  e_variable_flag:
+00017440: 0a20 2020 2020 2020 2076 6965 775f 6461  .        view_da
+00017450: 7973 203d 2027 7072 6f63 6573 7369 6e67  ys = 'processing
+00017460: 272b 7374 6172 7454 696d 652b 275f 656c  '+startTime+'_el
+00017470: 6170 7365 645f 6461 7973 270a 2020 2020  apsed_days'.    
+00017480: 2020 2020 736d 616c 6c64 665b 7669 6577      smalldf[view
+00017490: 5f64 6179 735d 203d 2028 736d 616c 6c64  _days] = (smalld
+000174a0: 665b 656e 6454 696d 655d 202d 2073 6d61  f[endTime] - sma
+000174b0: 6c6c 6466 5b73 7461 7274 5469 6d65 5d29  lldf[startTime])
+000174c0: 2e61 7374 7970 6528 2774 696d 6564 656c  .astype('timedel
+000174d0: 7461 3634 5b73 5d27 292f 2836 302a 3630  ta64[s]')/(60*60
+000174e0: 2a32 3429 0a20 2020 2020 2020 2073 6d61  *24).        sma
+000174f0: 6c6c 6466 5b76 6965 775f 6461 7973 5d20  lldf[view_days] 
+00017500: 3d20 736d 616c 6c64 665b 7669 6577 5f64  = smalldf[view_d
+00017510: 6179 735d 2e61 7374 7970 6528 696e 7429  ays].astype(int)
+00017520: 0a20 2020 2020 2020 2061 6464 5f63 6f6c  .        add_col
+00017530: 732e 6170 7065 6e64 2876 6965 775f 6461  s.append(view_da
+00017540: 7973 290a 2020 2020 2020 2020 7669 6577  ys).        view
+00017550: 5f74 696d 6520 3d20 2770 726f 6365 7373  _time = 'process
+00017560: 696e 6727 2b73 7461 7274 5469 6d65 2b27  ing'+startTime+'
+00017570: 5f65 6c61 7073 6564 5f74 696d 6527 0a20  _elapsed_time'. 
+00017580: 2020 2020 2020 2073 6d61 6c6c 6466 5b76         smalldf[v
+00017590: 6965 775f 7469 6d65 5d20 3d20 2873 6d61  iew_time] = (sma
+000175a0: 6c6c 6466 5b65 6e64 5469 6d65 5d20 2d20  lldf[endTime] - 
+000175b0: 736d 616c 6c64 665b 7374 6172 7454 696d  smalldf[startTim
+000175c0: 655d 292e 6173 7479 7065 2827 7469 6d65  e]).astype('time
+000175d0: 6465 6c74 6136 345b 735d 2729 2e76 616c  delta64[s]').val
+000175e0: 7565 730a 2020 2020 2020 2020 6164 645f  ues.        add_
+000175f0: 636f 6c73 2e61 7070 656e 6428 7669 6577  cols.append(view
+00017600: 5f74 696d 6529 0a20 2020 2065 6c73 653a  _time).    else:
+00017610: 0a20 2020 2020 2020 2073 7461 7274 5f64  .        start_d
+00017620: 6174 6520 3d20 2770 726f 6365 7373 696e  ate = 'processin
+00017630: 6727 2b73 7461 7274 5469 6d65 2b27 5f73  g'+startTime+'_s
+00017640: 7461 7274 5f64 6174 6527 0a20 2020 2020  tart_date'.     
+00017650: 2020 2073 6d61 6c6c 6466 5b73 7461 7274     smalldf[start
+00017660: 5f64 6174 655d 203d 2073 6d61 6c6c 6466  _date] = smalldf
+00017670: 5b73 7461 7274 5469 6d65 5d2e 6d61 7028  [startTime].map(
+00017680: 6c61 6d62 6461 2078 3a20 782e 7370 6c69  lambda x: x.spli
+00017690: 7428 2220 2229 5b30 5d29 0a20 2020 2020  t(" ")[0]).     
+000176a0: 2020 2061 6464 5f63 6f6c 732e 6170 7065     add_cols.appe
+000176b0: 6e64 2873 7461 7274 5f64 6174 6529 0a20  nd(start_date). 
+000176c0: 2020 2020 2020 2074 7279 3a0a 2020 2020         try:.    
+000176d0: 2020 2020 2020 2020 7374 6172 745f 7469          start_ti
+000176e0: 6d65 203d 2027 7072 6f63 6573 7369 6e67  me = 'processing
+000176f0: 272b 7374 6172 7454 696d 652b 275f 7374  '+startTime+'_st
+00017700: 6172 745f 7469 6d65 270a 2020 2020 2020  art_time'.      
+00017710: 2020 2020 2020 736d 616c 6c64 665b 7374        smalldf[st
+00017720: 6172 745f 7469 6d65 5d20 3d20 736d 616c  art_time] = smal
+00017730: 6c64 665b 7374 6172 7454 696d 655d 2e6d  ldf[startTime].m
+00017740: 6170 286c 616d 6264 6120 783a 2078 2e73  ap(lambda x: x.s
+00017750: 706c 6974 2822 2022 295b 315d 290a 2020  plit(" ")[1]).  
+00017760: 2020 2020 2020 2020 2020 6164 645f 636f            add_co
+00017770: 6c73 2e61 7070 656e 6428 7374 6172 745f  ls.append(start_
+00017780: 7469 6d65 290a 2020 2020 2020 2020 6578  time).        ex
+00017790: 6365 7074 3a0a 2020 2020 2020 2020 2020  cept:.          
+000177a0: 2020 2323 2320 7468 6572 6520 6973 206e    ### there is n
+000177b0: 6f20 686f 7572 2d6d 696e 7574 6573 2070  o hour-minutes p
+000177c0: 6172 7420 6f66 2074 6869 7320 6461 7465  art of this date
+000177d0: 2074 696d 6520 7374 616d 7020 6669 656c   time stamp fiel
+000177e0: 642e 2059 6f75 2063 616e 206a 7573 7420  d. You can just 
+000177f0: 736b 6970 2069 7420 6966 2069 7420 6973  skip it if it is
+00017800: 206e 6f74 2074 6865 7265 0a20 2020 2020   not there.     
+00017810: 2020 2020 2020 2070 6173 730a 2020 2020         pass.    
+00017820: 2020 2020 656e 645f 6461 7465 203d 2027      end_date = '
+00017830: 7072 6f63 6573 7369 6e67 272b 656e 6454  processing'+endT
+00017840: 696d 652b 275f 656e 645f 6461 7465 270a  ime+'_end_date'.
+00017850: 2020 2020 2020 2020 736d 616c 6c64 665b          smalldf[
+00017860: 656e 645f 6461 7465 5d20 3d20 736d 616c  end_date] = smal
+00017870: 6c64 665b 656e 6454 696d 655d 2e6d 6170  ldf[endTime].map
+00017880: 286c 616d 6264 6120 783a 2078 2e73 706c  (lambda x: x.spl
+00017890: 6974 2822 2022 295b 305d 290a 2020 2020  it(" ")[0]).    
+000178a0: 2020 2020 6164 645f 636f 6c73 2e61 7070      add_cols.app
+000178b0: 656e 6428 656e 645f 6461 7465 290a 2020  end(end_date).  
+000178c0: 2020 2020 2020 7472 793a 0a20 2020 2020        try:.     
+000178d0: 2020 2020 2020 2065 6e64 5f74 696d 6520         end_time 
+000178e0: 3d20 2770 726f 6365 7373 696e 6727 2b65  = 'processing'+e
+000178f0: 6e64 5469 6d65 2b27 5f65 6e64 5f74 696d  ndTime+'_end_tim
+00017900: 6527 0a20 2020 2020 2020 2020 2020 2073  e'.            s
+00017910: 6d61 6c6c 6466 5b65 6e64 5f74 696d 655d  malldf[end_time]
+00017920: 203d 2073 6d61 6c6c 6466 5b65 6e64 5469   = smalldf[endTi
+00017930: 6d65 5d2e 6d61 7028 6c61 6d62 6461 2078  me].map(lambda x
+00017940: 3a20 782e 7370 6c69 7428 2220 2229 5b31  : x.split(" ")[1
+00017950: 5d29 0a20 2020 2020 2020 2020 2020 2061  ]).            a
+00017960: 6464 5f63 6f6c 732e 6170 7065 6e64 2865  dd_cols.append(e
+00017970: 6e64 5f74 696d 6529 0a20 2020 2020 2020  nd_time).       
+00017980: 2065 7863 6570 743a 0a20 2020 2020 2020   except:.       
+00017990: 2020 2020 2023 2323 2074 6865 7265 2069       ### there i
+000179a0: 7320 6e6f 2068 6f75 722d 6d69 6e75 7465  s no hour-minute
+000179b0: 7320 7061 7274 206f 6620 7468 6973 2064  s part of this d
+000179c0: 6174 6520 7469 6d65 2073 7461 6d70 2066  ate time stamp f
+000179d0: 6965 6c64 2e20 596f 7520 6361 6e20 6a75  ield. You can ju
+000179e0: 7374 2073 6b69 7020 6974 2069 6620 6974  st skip it if it
+000179f0: 2069 7320 6e6f 7420 7468 6572 650a 2020   is not there.  
+00017a00: 2020 2020 2020 2020 2020 7061 7373 0a20            pass. 
+00017a10: 2020 2020 2020 2076 6965 775f 6461 7973         view_days
+00017a20: 203d 2027 7072 6f63 6573 7369 6e67 272b   = 'processing'+
+00017a30: 7374 6172 7454 696d 652b 275f 656c 6170  startTime+'_elap
+00017a40: 7365 645f 6461 7973 270a 2020 2020 2020  sed_days'.      
+00017a50: 2020 736d 616c 6c64 665b 7669 6577 5f64    smalldf[view_d
+00017a60: 6179 735d 203d 2028 7064 2e74 6f5f 6461  ays] = (pd.to_da
+00017a70: 7465 7469 6d65 2873 6d61 6c6c 6466 5b65  tetime(smalldf[e
+00017a80: 6e64 5f64 6174 655d 2920 2d20 7064 2e74  nd_date]) - pd.t
+00017a90: 6f5f 6461 7465 7469 6d65 2873 6d61 6c6c  o_datetime(small
+00017aa0: 6466 5b73 7461 7274 5f64 6174 655d 2929  df[start_date]))
+00017ab0: 2e76 616c 7565 732e 6173 7479 7065 2869  .values.astype(i
+00017ac0: 6e74 290a 2020 2020 2020 2020 6164 645f  nt).        add_
+00017ad0: 636f 6c73 2e61 7070 656e 6428 7669 6577  cols.append(view
+00017ae0: 5f64 6179 7329 0a20 2020 2020 2020 2074  _days).        t
+00017af0: 7279 3a0a 2020 2020 2020 2020 2020 2020  ry:.            
+00017b00: 7669 6577 5f74 696d 6520 3d20 2770 726f  view_time = 'pro
+00017b10: 6365 7373 696e 6727 2b73 7461 7274 5469  cessing'+startTi
+00017b20: 6d65 2b27 5f65 6c61 7073 6564 5f74 696d  me+'_elapsed_tim
+00017b30: 6527 0a20 2020 2020 2020 2020 2020 2073  e'.            s
+00017b40: 6d61 6c6c 6466 5b76 6965 775f 7469 6d65  malldf[view_time
+00017b50: 5d20 3d20 2870 642e 746f 5f64 6174 6574  ] = (pd.to_datet
+00017b60: 696d 6528 736d 616c 6c64 665b 656e 645f  ime(smalldf[end_
+00017b70: 7469 6d65 5d29 202d 2070 642e 746f 5f64  time]) - pd.to_d
+00017b80: 6174 6574 696d 6528 736d 616c 6c64 665b  atetime(smalldf[
+00017b90: 7374 6172 745f 7469 6d65 5d29 292e 6173  start_time])).as
+00017ba0: 7479 7065 2827 7469 6d65 6465 6c74 6136  type('timedelta6
+00017bb0: 345b 735d 2729 2e76 616c 7565 730a 2020  4[s]').values.  
+00017bc0: 2020 2020 2020 2020 2020 6164 645f 636f            add_co
+00017bd0: 6c73 2e61 7070 656e 6428 7669 6577 5f74  ls.append(view_t
+00017be0: 696d 6529 0a20 2020 2020 2020 2065 7863  ime).        exc
+00017bf0: 6570 743a 0a20 2020 2020 2020 2020 2020  ept:.           
+00017c00: 2023 2323 2049 6e20 736f 6d65 2064 6174   ### In some dat
+00017c10: 6520 7469 6d65 2066 6965 6c64 7320 7468  e time fields th
+00017c20: 6973 2067 6976 6573 2061 6e20 6572 726f  is gives an erro
+00017c30: 7220 736f 2073 6b69 7020 6974 2069 6e20  r so skip it in 
+00017c40: 7468 6174 2063 6173 650a 2020 2020 2020  that case.      
+00017c50: 2020 2020 2020 7061 7373 0a20 2020 2020        pass.     
+00017c60: 2020 2023 2323 2320 5468 6520 7265 6173     #### The reas
+00017c70: 6f6e 2077 6520 6368 6f73 6520 656e 6454  on we chose endT
+00017c80: 696d 6520 6865 7265 2069 7320 7468 6174  ime here is that
+00017c90: 2073 7461 7274 5469 6d65 2069 7320 7573   startTime is us
+00017ca0: 7561 6c6c 7920 7461 6b65 6e20 6361 7265  ually taken care
+00017cb0: 206f 6620 6279 2061 6e6f 7468 6572 206c   of by another l
+00017cc0: 6962 7261 7279 2e20 536f 2062 6574 7465  ibrary. So bette
+00017cd0: 7220 746f 2064 6f20 7468 6973 2061 6c6f  r to do this alo
+00017ce0: 6e65 2e0a 2020 2020 2020 2020 7965 6172  ne..        year
+00017cf0: 203d 2027 7072 6f63 6573 7369 6e67 272b   = 'processing'+
+00017d00: 656e 6454 696d 652b 275f 656e 645f 7965  endTime+'_end_ye
+00017d10: 6172 270a 2020 2020 2020 2020 736d 616c  ar'.        smal
+00017d20: 6c64 665b 7965 6172 5d20 3d20 736d 616c  ldf[year] = smal
+00017d30: 6c64 665b 656e 645f 6461 7465 5d2e 6d61  ldf[end_date].ma
+00017d40: 7028 6c61 6d62 6461 2078 3a20 7374 7228  p(lambda x: str(
+00017d50: 7829 2e73 706c 6974 2873 706c 6974 7465  x).split(splitte
+00017d60: 725f 6461 7465 5f73 7472 696e 6729 5b30  r_date_string)[0
+00017d70: 5d29 2e76 616c 7565 730a 2020 2020 2020  ]).values.      
+00017d80: 2020 6164 645f 636f 6c73 2e61 7070 656e    add_cols.appen
+00017d90: 6428 7965 6172 290a 2020 2020 2020 2020  d(year).        
+00017da0: 2323 2323 2054 6865 2072 6561 736f 6e20  #### The reason 
+00017db0: 7765 2063 686f 7365 2065 6e64 5469 6d65  we chose endTime
+00017dc0: 2068 6572 6520 6973 2074 6861 7420 7374   here is that st
+00017dd0: 6172 7454 696d 6520 6973 2075 7375 616c  artTime is usual
+00017de0: 6c79 2074 616b 656e 2063 6172 6520 6f66  ly taken care of
+00017df0: 2062 7920 616e 6f74 6865 7220 6c69 6272   by another libr
+00017e00: 6172 792e 2053 6f20 6265 7474 6572 2074  ary. So better t
+00017e10: 6f20 646f 2074 6869 7320 616c 6f6e 652e  o do this alone.
+00017e20: 0a20 2020 2020 2020 206d 6f6e 7468 203d  .        month =
+00017e30: 2027 7072 6f63 6573 7369 6e67 272b 656e   'processing'+en
+00017e40: 6454 696d 652b 275f 656e 645f 6d6f 6e74  dTime+'_end_mont
+00017e50: 6827 0a20 2020 2020 2020 2073 6d61 6c6c  h'.        small
+00017e60: 6466 5b6d 6f6e 7468 5d20 3d20 736d 616c  df[month] = smal
+00017e70: 6c64 665b 656e 645f 6461 7465 5d2e 6d61  ldf[end_date].ma
+00017e80: 7028 6c61 6d62 6461 2078 3a20 7374 7228  p(lambda x: str(
+00017e90: 7829 2e73 706c 6974 2873 706c 6974 7465  x).split(splitte
+00017ea0: 725f 6461 7465 5f73 7472 696e 6729 5b31  r_date_string)[1
+00017eb0: 5d29 2e76 616c 7565 730a 2020 2020 2020  ]).values.      
+00017ec0: 2020 6164 645f 636f 6c73 2e61 7070 656e    add_cols.appen
+00017ed0: 6428 6d6f 6e74 6829 0a20 2020 2020 2020  d(month).       
+00017ee0: 2074 7279 3a0a 2020 2020 2020 2020 2020   try:.          
+00017ef0: 2020 2323 2323 2054 6865 2072 6561 736f    #### The reaso
+00017f00: 6e20 7765 2063 686f 7365 2065 6e64 5469  n we chose endTi
+00017f10: 6d65 2068 6572 6520 6973 2074 6861 7420  me here is that 
+00017f20: 7374 6172 7454 696d 6520 6973 2075 7375  startTime is usu
+00017f30: 616c 6c79 2074 616b 656e 2063 6172 6520  ally taken care 
+00017f40: 6f66 2062 7920 616e 6f74 6865 7220 6c69  of by another li
+00017f50: 6272 6172 792e 2053 6f20 6265 7474 6572  brary. So better
+00017f60: 2074 6f20 646f 2074 6869 7320 616c 6f6e   to do this alon
+00017f70: 652e 0a20 2020 2020 2020 2020 2020 2064  e..            d
+00017f80: 6179 6e75 6d20 3d20 2770 726f 6365 7373  aynum = 'process
+00017f90: 696e 6727 2b65 6e64 5469 6d65 2b27 5f65  ing'+endTime+'_e
+00017fa0: 6e64 5f64 6179 5f6e 756d 6265 7227 0a20  nd_day_number'. 
+00017fb0: 2020 2020 2020 2020 2020 2073 6d61 6c6c             small
+00017fc0: 6466 5b64 6179 6e75 6d5d 203d 2073 6d61  df[daynum] = sma
+00017fd0: 6c6c 6466 5b65 6e64 5f64 6174 655d 2e6d  lldf[end_date].m
+00017fe0: 6170 286c 616d 6264 6120 783a 2073 7472  ap(lambda x: str
+00017ff0: 2878 292e 7370 6c69 7428 7370 6c69 7474  (x).split(splitt
+00018000: 6572 5f64 6174 655f 7374 7269 6e67 295b  er_date_string)[
+00018010: 325d 292e 7661 6c75 6573 0a20 2020 2020  2]).values.     
+00018020: 2020 2020 2020 2061 6464 5f63 6f6c 732e         add_cols.
+00018030: 6170 7065 6e64 2864 6179 6e75 6d29 0a20  append(daynum). 
+00018040: 2020 2020 2020 2065 7863 6570 743a 0a20         except:. 
+00018050: 2020 2020 2020 2020 2020 2023 2323 2049             ### I
+00018060: 6e20 736f 6d65 2064 6174 6520 7469 6d65  n some date time
+00018070: 2066 6965 6c64 7320 7468 6520 6461 7920   fields the day 
+00018080: 6e75 6d62 6572 2069 7320 6e6f 7420 7468  number is not th
+00018090: 6572 652e 2049 6620 6e6f 742c 206a 7573  ere. If not, jus
+000180a0: 7420 736b 6970 2069 7420 2323 2323 0a20  t skip it ####. 
+000180b0: 2020 2020 2020 2020 2020 2070 6173 730a             pass.
+000180c0: 2020 2020 2020 2020 2323 2323 2049 6e20          #### In 
+000180d0: 736f 6d65 2064 6174 6520 7469 6d65 2066  some date time f
+000180e0: 6965 6c64 732c 2074 6865 2068 6f75 7220  ields, the hour 
+000180f0: 616e 6420 6d69 6e75 7465 2069 7320 6e6f  and minute is no
+00018100: 7420 7468 6572 652c 2073 6f20 736b 6970  t there, so skip
+00018110: 2069 7420 696e 2074 6861 7420 6361 7365   it in that case
+00018120: 2069 6620 6974 2065 7272 6f72 7321 0a20   if it errors!. 
+00018130: 2020 2020 2020 2074 7279 3a0a 2020 2020         try:.    
+00018140: 2020 2020 2020 2020 7374 6172 745f 686f          start_ho
+00018150: 7572 203d 2027 7072 6f63 6573 7369 6e67  ur = 'processing
+00018160: 272b 7374 6172 7454 696d 652b 275f 7374  '+startTime+'_st
+00018170: 6172 745f 686f 7572 270a 2020 2020 2020  art_hour'.      
+00018180: 2020 2020 2020 736d 616c 6c64 665b 7374        smalldf[st
+00018190: 6172 745f 686f 7572 5d20 3d20 736d 616c  art_hour] = smal
+000181a0: 6c64 665b 7374 6172 745f 7469 6d65 5d2e  ldf[start_time].
+000181b0: 6d61 7028 6c61 6d62 6461 2078 3a20 7374  map(lambda x: st
+000181c0: 7228 7829 2e73 706c 6974 2873 706c 6974  r(x).split(split
+000181d0: 7465 725f 686f 7572 5f73 7472 696e 6729  ter_hour_string)
+000181e0: 5b30 5d29 2e76 616c 7565 730a 2020 2020  [0]).values.    
+000181f0: 2020 2020 2020 2020 6164 645f 636f 6c73          add_cols
+00018200: 2e61 7070 656e 6428 7374 6172 745f 686f  .append(start_ho
+00018210: 7572 290a 2020 2020 2020 2020 2020 2020  ur).            
+00018220: 7374 6172 745f 6d69 6e20 3d20 2770 726f  start_min = 'pro
+00018230: 6365 7373 696e 6727 2b73 7461 7274 5469  cessing'+startTi
+00018240: 6d65 2b27 5f73 7461 7274 5f68 6f75 7227  me+'_start_hour'
+00018250: 0a20 2020 2020 2020 2020 2020 2073 6d61  .            sma
+00018260: 6c6c 6466 5b73 7461 7274 5f6d 696e 5d20  lldf[start_min] 
+00018270: 3d20 736d 616c 6c64 665b 7374 6172 745f  = smalldf[start_
+00018280: 7469 6d65 5d2e 6d61 7028 6c61 6d62 6461  time].map(lambda
+00018290: 2078 3a20 7374 7228 7829 2e73 706c 6974   x: str(x).split
+000182a0: 2873 706c 6974 7465 725f 686f 7572 5f73  (splitter_hour_s
+000182b0: 7472 696e 6729 5b31 5d29 2e76 616c 7565  tring)[1]).value
+000182c0: 730a 2020 2020 2020 2020 2020 2020 6164  s.            ad
+000182d0: 645f 636f 6c73 2e61 7070 656e 6428 7374  d_cols.append(st
+000182e0: 6172 745f 6d69 6e29 0a20 2020 2020 2020  art_min).       
+000182f0: 2065 7863 6570 743a 0a20 2020 2020 2020   except:.       
+00018300: 2020 2020 2023 2323 2049 6620 6974 2065       ### If it e
+00018310: 7272 6f72 732c 2073 6b69 7020 6974 0a20  rrors, skip it. 
+00018320: 2020 2020 2020 2020 2020 2070 6173 730a             pass.
+00018330: 2020 2020 2020 2020 2323 2323 2043 6865          #### Che
+00018340: 636b 2069 6620 7468 6572 6520 6973 2061  ck if there is a
+00018350: 2077 6565 6b64 6179 2061 6e64 2077 6565   weekday and wee
+00018360: 6b65 6e64 7320 696e 2064 6174 6520 7469  kends in date ti
+00018370: 6d65 2063 6f6c 756d 6e73 2075 7369 6e67  me columns using
+00018380: 2065 6e64 5469 6d65 206f 6e6c 790a 2020   endTime only.  
+00018390: 2020 2020 2020 7765 656b 6461 795f 6e75        weekday_nu
+000183a0: 6d20 3d20 2770 726f 6365 7373 696e 6727  m = 'processing'
+000183b0: 2b65 6e64 5469 6d65 2b27 5f65 6e64 5f77  +endTime+'_end_w
+000183c0: 6565 6b64 6179 5f6e 756d 6265 7227 0a20  eekday_number'. 
+000183d0: 2020 2020 2020 2073 6d61 6c6c 6466 5b77         smalldf[w
+000183e0: 6565 6b64 6179 5f6e 756d 5d20 3d20 7064  eekday_num] = pd
+000183f0: 2e74 6f5f 6461 7465 7469 6d65 2873 6d61  .to_datetime(sma
+00018400: 6c6c 6466 5b65 6e64 5f64 6174 655d 292e  lldf[end_date]).
+00018410: 6474 2e77 6565 6b64 6179 2e76 616c 7565  dt.weekday.value
+00018420: 730a 2020 2020 2020 2020 6164 645f 636f  s.        add_co
+00018430: 6c73 2e61 7070 656e 6428 7765 656b 6461  ls.append(weekda
+00018440: 795f 6e75 6d29 0a20 2020 2020 2020 2077  y_num).        w
+00018450: 6565 6b65 6e64 203d 2027 7072 6f63 6573  eekend = 'proces
+00018460: 7369 6e67 272b 656e 6454 696d 652b 275f  sing'+endTime+'_
+00018470: 656e 645f 7765 656b 656e 645f 666c 6167  end_weekend_flag
+00018480: 270a 2020 2020 2020 2020 736d 616c 6c64  '.        smalld
+00018490: 665b 7765 656b 656e 645d 203d 2073 6d61  f[weekend] = sma
+000184a0: 6c6c 6466 5b77 6565 6b64 6179 5f6e 756d  lldf[weekday_num
+000184b0: 5d2e 6d61 7028 6c61 6d62 6461 2078 3a20  ].map(lambda x: 
+000184c0: 3120 6966 2078 2069 6e5b 352c 365d 2065  1 if x in[5,6] e
+000184d0: 6c73 6520 3029 0a20 2020 2020 2020 2061  lse 0).        a
+000184e0: 6464 5f63 6f6c 732e 6170 7065 6e64 2877  dd_cols.append(w
+000184f0: 6565 6b65 6e64 290a 2020 2020 2323 2323  eekend).    ####
+00018500: 2049 6620 6576 6572 7974 6869 6e67 2077   If everything w
+00018510: 6f72 6b73 2077 656c 6c2c 2074 6865 7265  orks well, there
+00018520: 2073 686f 756c 6420 6265 2031 3320 6e65   should be 13 ne
+00018530: 7720 636f 6c75 6d6e 7320 6164 6465 6420  w columns added 
+00018540: 6279 206d 6f64 756c 652e 2041 6c6c 2074  by module. All t
+00018550: 6865 2062 6573 7421 0a20 2020 2070 7269  he best!.    pri
+00018560: 6e74 2827 2564 2063 6f6c 756d 6e73 2061  nt('%d columns a
+00018570: 6464 6564 2075 7369 6e67 2073 7461 7274  dded using start
+00018580: 2064 6174 653d 2573 2061 6e64 2065 6e64   date=%s and end
+00018590: 2064 6174 653d 2573 2070 726f 6365 7373   date=%s process
+000185a0: 696e 672e 2e2e 2720 2528 6c65 6e28 6164  ing...' %(len(ad
+000185b0: 645f 636f 6c73 292c 7374 6172 7454 696d  d_cols),startTim
+000185c0: 652c 656e 6454 696d 6529 290a 2020 2020  e,endTime)).    
+000185d0: 7265 7475 726e 2073 6d61 6c6c 6466 0a23  return smalldf.#
 000185e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 000185f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00018600: 2323 2323 2323 2323 2323 230a 2020 2020  ###########.    
-00018610: 2222 220a 2020 2020 6466 5f66 6965 6c64  """.    df_field
-00018620: 203d 2064 665f 696e 5b66 6965 6c64 5d2e   = df_in[field].
-00018630: 7661 6c75 6573 0a20 2020 2064 6620 3d20  values.    df = 
-00018640: 636f 7079 2e64 6565 7063 6f70 7928 6466  copy.deepcopy(df
-00018650: 5f69 6e29 0a20 2020 2023 2323 2046 6972  _in).    ### Fir
-00018660: 7374 2063 6f70 7920 2077 6861 7465 7665  st copy  whateve
-00018670: 7220 6973 2069 6e20 7468 6174 2066 6965  r is in that fie
-00018680: 6c64 2073 6f20 7765 2063 616e 2073 6176  ld so we can sav
-00018690: 6520 6974 2066 6f72 206c 6174 6572 2023  e it for later #
-000186a0: 2323 0a20 2020 2023 2323 2052 656d 656d  ##.    ### Remem
-000186b0: 6265 7220 7468 6174 2066 696c 6c6e 6120  ber that fillna 
-000186c0: 6f6e 6c79 2077 6f72 6b73 2061 7420 6461  only works at da
-000186d0: 7461 6672 616d 6520 6c65 7665 6c21 2023  taframe level! #
-000186e0: 2323 0a20 2020 2064 665b 5b66 6965 6c64  ##.    df[[field
-000186f0: 5d5d 203d 2064 665b 5b66 6965 6c64 5d5d  ]] = df[[field]]
-00018700: 2e66 696c 6c6e 6128 6669 6c6c 6572 290a  .fillna(filler).
-00018710: 2020 2020 6966 2061 6464 5f63 6f75 6e74      if add_count
-00018720: 5f66 6965 6c64 3a0a 2020 2020 2020 2020  _field:.        
-00018730: 2323 2320 7468 6572 6520 7769 6c6c 2062  ### there will b
-00018740: 6520 6f6e 6520 6578 7472 6120 6669 656c  e one extra fiel
-00018750: 6420 6372 6561 7465 6420 7768 656e 2077  d created when w
-00018760: 6520 636f 756e 7420 7468 6520 6e75 6d62  e count the numb
-00018770: 6572 206f 6620 636f 6e74 656e 7473 2069  er of contents i
-00018780: 6e20 6561 6368 2066 6965 6c64 2023 2323  n each field ###
-00018790: 0a20 2020 2020 2020 206d 6178 5f74 6869  .        max_thi
-000187a0: 6e67 7320 3d20 6466 5b66 6965 6c64 5d2e  ngs = df[field].
-000187b0: 6d61 7028 6c61 6d62 6461 2078 3a20 6c65  map(lambda x: le
-000187c0: 6e28 782e 7370 6c69 7428 7370 6c69 7474  n(x.split(splitt
-000187d0: 6572 2929 292e 6d61 7828 2920 2b20 310a  er))).max() + 1.
-000187e0: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
-000187f0: 2020 6d61 785f 7468 696e 6773 203d 2064    max_things = d
-00018800: 665b 6669 656c 645d 2e6d 6170 286c 616d  f[field].map(lam
-00018810: 6264 6120 783a 206c 656e 2878 2e73 706c  bda x: len(x.spl
-00018820: 6974 2873 706c 6974 7465 7229 2929 2e6d  it(splitter))).m
-00018830: 6178 2829 0a20 2020 2069 6620 6c65 6e28  ax().    if len(
-00018840: 6e65 775f 6e61 6d65 735f 6c69 7374 2920  new_names_list) 
-00018850: 3d3d 2030 3a0a 2020 2020 2020 2020 7072  == 0:.        pr
-00018860: 696e 7428 2720 2020 204d 6178 2e20 636f  int('    Max. co
-00018870: 6c75 6d6e 7320 6372 6561 7465 6420 6279  lumns created by
-00018880: 2073 706c 6974 7469 6e67 2025 7320 6669   splitting %s fi
-00018890: 656c 6420 6973 2025 642e 2720 2528 0a20  eld is %d.' %(. 
-000188a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000188b0: 2020 2020 2020 2020 2020 2066 6965 6c64             field
-000188c0: 2c6d 6178 5f74 6869 6e67 7329 290a 2020  ,max_things)).  
-000188d0: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
-000188e0: 6966 206e 6f74 206d 6178 5f74 6869 6e67  if not max_thing
-000188f0: 7320 3d3d 206c 656e 286e 6577 5f6e 616d  s == len(new_nam
-00018900: 6573 5f6c 6973 7429 3a0a 2020 2020 2020  es_list):.      
-00018910: 2020 2020 2020 7072 696e 7428 2222 2220        print(""" 
-00018920: 2020 204d 6178 2e20 636f 6c75 6d6e 7320     Max. columns 
-00018930: 6372 6561 7465 6420 6279 2073 706c 6974  created by split
-00018940: 7469 6e67 2025 7320 6669 656c 6420 6973  ting %s field is
-00018950: 2025 6420 6275 7420 796f 7520 6861 7665   %d but you have
-00018960: 2067 6976 656e 2025 640a 2020 2020 2020   given %d.      
-00018970: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018980: 2020 2020 2020 7661 7269 6162 6c65 206e        variable n
-00018990: 616d 6573 206f 6e6c 792e 2053 656c 6563  ames only. Selec
-000189a0: 7469 6e67 2066 6972 7374 2025 6422 2222  ting first %d"""
-000189b0: 2025 280a 2020 2020 2020 2020 2020 2020   %(.            
-000189c0: 2020 2020 2020 2020 2020 2020 6669 656c              fiel
-000189d0: 642c 6d61 785f 7468 696e 6773 2c6c 656e  d,max_things,len
-000189e0: 286e 6577 5f6e 616d 6573 5f6c 6973 7429  (new_names_list)
-000189f0: 2c6c 656e 286e 6577 5f6e 616d 6573 5f6c  ,len(new_names_l
-00018a00: 6973 7429 2929 0a20 2020 2023 2323 2054  ist))).    ### T
-00018a10: 6869 7320 6372 6561 7465 7320 6120 6e65  his creates a ne
-00018a20: 7720 6669 656c 6420 7468 6174 2063 6f75  w field that cou
-00018a30: 6e74 7320 7468 6520 6e75 6d62 6572 206f  nts the number o
-00018a40: 6620 7468 696e 6773 2074 6861 7420 6172  f things that ar
-00018a50: 6520 696e 2074 6861 7420 6669 656c 642e  e in that field.
-00018a60: 0a20 2020 2069 6620 6164 645f 636f 756e  .    if add_coun
-00018a70: 745f 6669 656c 643a 0a20 2020 2020 2020  t_field:.       
-00018a80: 2023 2323 2320 7468 6973 2063 6f75 6e74   #### this count
-00018a90: 7320 7468 6520 6e75 6d62 6572 206f 6620  s the number of 
-00018aa0: 636f 6e74 656e 7473 2061 6674 6572 2073  contents after s
-00018ab0: 706c 6974 7469 6e67 2065 6163 6820 726f  plitting each ro
-00018ac0: 7720 7768 6963 6820 7661 7269 6573 2e20  w which varies. 
-00018ad0: 4865 6e63 6520 6974 2068 656c 7073 2e0a  Hence it helps..
-00018ae0: 2020 2020 2020 2020 6e75 6d5f 7072 6f64          num_prod
-00018af0: 7563 7473 5f76 6965 7765 6420 3d20 2743  ucts_viewed = 'C
-00018b00: 6f6e 7465 6e74 5f43 6f75 6e74 5f69 6e5f  ontent_Count_in_
-00018b10: 272b 6669 656c 640a 2020 2020 2020 2020  '+field.        
-00018b20: 6466 5b6e 756d 5f70 726f 6475 6374 735f  df[num_products_
-00018b30: 7669 6577 6564 5d20 3d20 6466 5b66 6965  viewed] = df[fie
-00018b40: 6c64 5d2e 6d61 7028 6c61 6d62 6461 2078  ld].map(lambda x
-00018b50: 3a20 6c65 6e28 782e 7370 6c69 7428 7370  : len(x.split(sp
-00018b60: 6c69 7474 6572 2929 292e 7661 6c75 6573  litter))).values
-00018b70: 0a20 2020 2023 2323 2043 6c65 616e 2075  .    ### Clean u
-00018b80: 7020 7468 6520 6669 656c 6420 7375 6368  p the field such
-00018b90: 2074 6861 7420 6974 2068 6173 2074 6865   that it has the
-00018ba0: 2072 6967 6874 206e 756d 6265 7220 6f66   right number of
-00018bb0: 2073 706c 6974 2063 6861 7273 206f 7468   split chars oth
-00018bc0: 6572 7769 7365 2061 6464 2074 6f20 6974  erwise add to it
-00018bd0: 0a20 2020 2023 2323 2054 6869 7320 6669  .    ### This fi
-00018be0: 6c6c 7320 7570 2074 6865 2066 6965 6c64  lls up the field
-00018bf0: 2077 6974 6820 656d 7074 7920 7374 7269   with empty stri
-00018c00: 6e67 7320 6265 7477 6565 6e20 6561 6368  ngs between each
-00018c10: 2073 706c 6974 7465 722e 2059 6f75 2063   splitter. You c
-00018c20: 616e 2774 2064 6f20 6d75 6368 2061 626f  an't do much abo
-00018c30: 7574 2069 742e 0a20 2020 2023 2323 2320  ut it..    #### 
-00018c40: 4c65 6176 6520 7468 6973 2061 7320 6974  Leave this as it
-00018c50: 2069 732e 2049 7420 6973 206e 6f74 2073   is. It is not s
-00018c60: 6f6d 6574 6869 6e67 2079 6f75 2063 616e  omething you can
-00018c70: 2064 6f20 7269 6768 7420 6e6f 772e 2049   do right now. I
-00018c80: 7420 776f 726b 732e 0a20 2020 2066 696c  t works..    fil
-00018c90: 6c5f 7374 7269 6e67 203d 2073 706c 6974  l_string = split
-00018ca0: 7465 7220 2b20 6669 6c6c 6572 0a20 2020  ter + filler.   
-00018cb0: 2064 665b 6669 656c 645d 203d 2064 665b   df[field] = df[
-00018cc0: 6669 656c 645d 2e6d 6170 286c 616d 6264  field].map(lambd
-00018cd0: 6120 783a 2078 2b66 696c 6c5f 7374 7269  a x: x+fill_stri
-00018ce0: 6e67 2a28 6d61 785f 7468 696e 6773 2d6c  ng*(max_things-l
-00018cf0: 656e 2878 2e73 706c 6974 2873 706c 6974  en(x.split(split
-00018d00: 7465 7229 2929 2069 6620 6c65 6e28 0a20  ter))) if len(. 
-00018d10: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018d20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018d30: 2020 2078 2e73 706c 6974 2873 706c 6974     x.split(split
-00018d40: 7465 7229 2920 3c20 6d61 785f 7468 696e  ter)) < max_thin
-00018d50: 6773 2065 6c73 6520 7829 0a20 2020 2023  gs else x).    #
-00018d60: 2323 2323 2320 4e6f 7720 796f 7520 6372  ##### Now you cr
-00018d70: 6561 7465 206e 6577 2066 6965 6c64 7320  eate new fields 
-00018d80: 6279 2073 706c 6974 2074 6865 206f 6e65  by split the one
-00018d90: 206c 6172 6765 2066 6965 6c64 2023 2323   large field ###
-00018da0: 2323 2323 230a 2020 2020 6966 2069 7369  #####.    if isi
-00018db0: 6e73 7461 6e63 6528 6e65 775f 6e61 6d65  nstance(new_name
-00018dc0: 735f 6c69 7374 2c20 7374 7229 3a0a 2020  s_list, str):.  
-00018dd0: 2020 2020 2020 6966 206e 6577 5f6e 616d        if new_nam
-00018de0: 6573 5f6c 6973 7420 3d3d 2027 273a 0a20  es_list == '':. 
-00018df0: 2020 2020 2020 2020 2020 206e 6577 5f6e             new_n
-00018e00: 616d 6573 5f6c 6973 7420 3d20 5b66 6965  ames_list = [fie
-00018e10: 6c64 2b27 5f27 2b73 7472 2869 2920 666f  ld+'_'+str(i) fo
-00018e20: 7220 6920 696e 2072 616e 6765 2831 2c6d  r i in range(1,m
-00018e30: 6178 5f74 6869 6e67 732b 3129 5d0a 2020  ax_things+1)].  
-00018e40: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
-00018e50: 2020 2020 2020 2020 6e65 775f 6e61 6d65          new_name
-00018e60: 735f 6c69 7374 203d 205b 6e65 775f 6e61  s_list = [new_na
-00018e70: 6d65 735f 6c69 7374 5d0a 2020 2020 2323  mes_list].    ##
-00018e80: 2320 4669 7273 7420 6669 6c6c 2065 6d70  # First fill emp
-00018e90: 7479 2073 7061 6365 7320 6f72 204e 614e  ty spaces or NaN
-00018ea0: 7320 7769 7468 2066 696c 6c65 7220 2323  s with filler ##
-00018eb0: 230a 2020 2020 6466 2e6c 6f63 5b64 665b  #.    df.loc[df[
-00018ec0: 6669 656c 645d 203d 3d20 7370 6c69 7474  field] == splitt
-00018ed0: 6572 2c20 6669 656c 645d 203d 2066 696c  er, field] = fil
-00018ee0: 6c65 720a 2020 2020 666f 7220 6920 696e  ler.    for i in
-00018ef0: 2072 616e 6765 286c 656e 286e 6577 5f6e   range(len(new_n
-00018f00: 616d 6573 5f6c 6973 7429 293a 0a20 2020  ames_list)):.   
-00018f10: 2020 2020 2074 7279 3a0a 2020 2020 2020       try:.      
-00018f20: 2020 2020 2020 6466 5b6e 6577 5f6e 616d        df[new_nam
-00018f30: 6573 5f6c 6973 745b 695d 5d20 3d20 6466  es_list[i]] = df
-00018f40: 5b66 6965 6c64 5d2e 6d61 7028 6c61 6d62  [field].map(lamb
-00018f50: 6461 2078 3a20 782e 7370 6c69 7428 7370  da x: x.split(sp
-00018f60: 6c69 7474 6572 295b 695d 0a20 2020 2020  litter)[i].     
-00018f70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018f80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00018f90: 2020 2020 2069 6620 7370 6c69 7474 6572       if splitter
-00018fa0: 2069 6e20 7820 656c 7365 2066 696c 6c65   in x else fille
-00018fb0: 7229 0a20 2020 2020 2020 2065 7863 6570  r).        excep
-00018fc0: 743a 0a20 2020 2020 2020 2020 2020 2064  t:.            d
-00018fd0: 665b 6e65 775f 6e61 6d65 735f 6c69 7374  f[new_names_list
-00018fe0: 5b69 5d5d 203d 2066 696c 6c65 720a 2020  [i]] = filler.  
-00018ff0: 2020 2020 2020 2020 2020 636f 6e74 696e            contin
-00019000: 7565 0a20 2020 2023 2323 2074 6865 7265  ue.    ### there
-00019010: 2069 7320 7265 616c 6c79 206e 6f74 6869   is really nothi
-00019020: 6e67 2079 6f75 2063 616e 2064 6f20 746f  ng you can do to
-00019030: 2066 696c 6c20 7570 2073 696e 6365 2074   fill up since t
-00019040: 6865 7920 6172 6520 6669 6c6c 6564 2077  hey are filled w
-00019050: 6974 6820 656d 7074 7920 7374 7269 6e67  ith empty string
-00019060: 732e 0a20 2020 2023 2323 2320 4c65 6176  s..    #### Leav
-00019070: 6520 7468 6973 2061 7320 6974 2069 732e  e this as it is.
-00019080: 2049 7420 6973 206e 6f74 2073 6f6d 6574   It is not somet
-00019090: 6869 6e67 2079 6f75 2063 616e 2064 6f20  hing you can do 
-000190a0: 7269 6768 7420 6e6f 772e 2049 7420 776f  right now. It wo
-000190b0: 726b 732e 0a20 2020 2064 665b 6669 656c  rks..    df[fiel
-000190c0: 645d 203d 2064 665f 6669 656c 640a 2020  d] = df_field.  
-000190d0: 2020 7265 7475 726e 2064 662c 206e 6577    return df, new
-000190e0: 5f6e 616d 6573 5f6c 6973 740a 2323 2323  _names_list.####
-000190f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00019100: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00019110: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00019120: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00019130: 2323 2323 2323 230a 6465 6620 4645 5f61  #######.def FE_a
-00019140: 6464 5f67 726f 7570 6279 5f66 6561 7475  dd_groupby_featu
-00019150: 7265 735f 6167 6772 6567 6174 6564 5f74  res_aggregated_t
-00019160: 6f5f 6461 7461 6672 616d 6528 7472 6169  o_dataframe(trai
-00019170: 6e2c 0a20 2020 2020 2020 2020 2020 2020  n,.             
-00019180: 2020 2020 2020 2061 6767 5f74 7970 6573         agg_types
-00019190: 2c20 2067 726f 7570 6279 5f63 6f6c 756d  ,  groupby_colum
-000191a0: 6e73 2c20 6967 6e6f 7265 5f76 6172 6961  ns, ignore_varia
-000191b0: 626c 6573 2c20 7465 7374 3d22 2229 3a0a  bles, test=""):.
-000191c0: 2020 2020 2222 220a 2020 2020 4645 2073      """.    FE s
-000191d0: 7461 6e64 7320 666f 7220 4665 6174 7572  tands for Featur
-000191e0: 6520 456e 6769 6e65 6572 696e 672e 2054  e Engineering. T
-000191f0: 6869 7320 6675 6e63 7469 6f6e 2070 6572  his function per
-00019200: 666f 726d 7320 6665 6174 7572 6520 656e  forms feature en
-00019210: 6769 6e65 6572 696e 6720 6f6e 2064 6174  gineering on dat
-00019220: 612e 0a20 2020 2023 2323 2323 2323 2323  a..    #########
-00019230: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00019240: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00019250: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00019260: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00019270: 2323 2323 2323 2323 2323 2323 230a 2020  #############.  
-00019280: 2020 2323 2320 2020 5468 6973 2066 756e    ###   This fun
-00019290: 6374 696f 6e20 6973 2061 2076 6572 7920  ction is a very 
-000192a0: 6661 7374 2066 756e 6374 696f 6e20 7468  fast function th
-000192b0: 6174 2077 696c 6c20 636f 6d70 7574 6520  at will compute 
-000192c0: 6167 6772 6567 6174 6573 2066 6f72 206e  aggregates for n
-000192d0: 756d 6572 6963 730a 2020 2020 2323 2320  umerics.    ### 
-000192e0: 2020 4974 2072 6574 7572 6e73 206f 7269    It returns ori
-000192f0: 6769 6e61 6c20 6461 7461 6672 616d 6520  ginal dataframe 
-00019300: 7769 7468 2061 6464 6564 2066 6561 7475  with added featu
-00019310: 7265 7320 6672 6f6d 206e 756d 6572 6963  res from numeric
-00019320: 2076 6172 6961 626c 6573 2061 6767 7265   variables aggre
-00019330: 6761 7465 640a 2020 2020 2323 2320 2020  gated.    ###   
-00019340: 5768 6174 2064 6f20 796f 7520 6d65 616e  What do you mean
-00019350: 2061 6767 7265 6761 7465 3f20 6167 6772   aggregate? aggr
-00019360: 6567 6174 6573 2063 616e 2062 6520 2263  egates can be "c
-00019370: 6f75 6e74 2c20 226d 6561 6e22 2c20 226d  ount, "mean", "m
-00019380: 6564 6961 6e22 2c20 6574 632e 0a20 2020  edian", etc..   
-00019390: 2023 2323 2020 2057 6861 7420 646f 2079   ###   What do y
-000193a0: 6f75 2061 6767 7265 6772 6174 653f 2061  ou aggregrate? a
-000193b0: 6c6c 206e 756d 6572 6963 2063 6f6c 756d  ll numeric colum
-000193c0: 6e73 2069 6e20 796f 7572 2064 6174 610a  ns in your data.
-000193d0: 2020 2020 2323 2320 2020 5768 6174 2064      ###   What d
-000193e0: 6f20 796f 7520 6772 6f75 7062 793f 206f  o you groupby? o
-000193f0: 6e65 2067 726f 7570 6279 2063 6f6c 756d  ne groupby colum
-00019400: 6e20 6174 2061 2074 696d 6520 6f72 206d  n at a time or m
-00019410: 756c 7469 706c 6520 636f 6c75 6d6e 7320  ultiple columns 
-00019420: 6f6e 6520 6279 206f 6e65 0a20 2020 2023  one by one.    #
-00019430: 2323 2020 2020 202d 2d20 6966 2079 6f75  ##     -- if you
-00019440: 2067 6976 6520 6974 2061 206c 6973 7420   give it a list 
-00019450: 6f66 2063 6f6c 756d 6e73 2c20 6974 2077  of columns, it w
-00019460: 696c 6c20 6578 6563 7574 6520 7468 6520  ill execute the 
-00019470: 6772 6f75 7069 6e67 206f 6e65 2062 7920  grouping one by 
-00019480: 6f6e 650a 2020 2020 2323 2320 2020 5768  one.    ###   Wh
-00019490: 6174 2069 7320 7468 6520 6967 6e6f 7265  at is the ignore
-000194a0: 5f76 6172 6961 626c 6573 2066 6f72 3f20  _variables for? 
-000194b0: 6974 2077 696c 6c20 6967 6e6f 7265 2074  it will ignore t
-000194c0: 6865 7365 2076 6172 6961 626c 6573 2066  hese variables f
-000194d0: 726f 6d20 6772 6f75 7069 6e67 2e0a 2020  rom grouping..  
-000194e0: 2020 2323 2320 2020 4d61 6b65 2073 7572    ###   Make sur
-000194f0: 6520 746f 2072 6564 7563 6520 636f 7272  e to reduce corr
-00019500: 656c 6174 6564 2066 6561 7475 7265 7320  elated features 
-00019510: 7573 696e 6720 4645 5f72 656d 6f76 655f  using FE_remove_
-00019520: 7661 7269 6162 6c65 735f 7573 696e 675f  variables_using_
-00019530: 5355 4c4f 565f 6d65 7468 6f64 2829 0a20  SULOV_method(). 
-00019540: 2020 2023 2323 2323 2323 2323 2323 2323     #############
-00019550: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00019560: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00019570: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00019580: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00019590: 2323 2323 2323 2323 230a 2020 2020 2323  #########.    ##
-000195a0: 2320 496e 7075 7473 3a0a 2020 2020 2323  # Inputs:.    ##
-000195b0: 2320 2020 7472 6169 6e3a 204a 7573 7420  #   train: Just 
-000195c0: 7365 6e74 2069 6e20 7468 6520 6461 7461  sent in the data
-000195d0: 2066 7261 6d65 2077 6865 7265 2079 6f75   frame where you
-000195e0: 2077 616e 7420 6167 6772 6567 6174 6564   want aggregated
-000195f0: 2066 6561 7475 7265 7320 666f 722e 0a20   features for.. 
-00019600: 2020 2023 2323 2020 2061 6767 5f74 7970     ###   agg_typ
-00019610: 6573 3a20 6c69 7374 206f 6620 636f 6d70  es: list of comp
-00019620: 7574 6174 696f 6e61 6c20 7479 7065 733a  utational types:
-00019630: 2027 6d65 616e 272c 276d 6564 6961 6e27   'mean','median'
-00019640: 2c27 636f 756e 7427 2c20 0a20 2020 2023  ,'count', .    #
-00019650: 2323 2020 2020 2020 2020 2020 2020 2020  ##              
-00019660: 2020 2020 2020 2027 6d61 7827 2c20 276d         'max', 'm
-00019670: 696e 272c 2027 7375 6d27 2c20 6574 632e  in', 'sum', etc.
-00019680: 0a20 2020 2023 2323 2020 2020 2020 2020  .    ###        
-00019690: 204f 6e65 2063 6176 6561 743a 2074 6865   One caveat: the
-000196a0: 7365 2061 6767 5f74 7970 6573 206d 7573  se agg_types mus
-000196b0: 7420 6265 2066 6f75 6e64 2069 6e20 7468  t be found in th
-000196c0: 6520 666f 6c6c 6f77 696e 6720 6167 675f  e following agg_
-000196d0: 6675 6e63 206f 6620 0a20 2020 2023 2323  func of .    ###
-000196e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000196f0: 2020 206e 756d 7079 206f 7220 7061 6e64     numpy or pand
-00019700: 6173 2067 726f 7570 6279 2073 7461 7465  as groupby state
-00019710: 6d65 6e74 2e0a 2020 2020 2323 2320 2020  ment..    ###   
-00019720: 2020 2020 2020 4c69 7374 206f 6620 6167        List of ag
-00019730: 6772 6567 6174 6573 2061 7661 696c 6162  gregates availab
-00019740: 6c65 3a20 7b27 636f 756e 7427 2c27 7375  le: {'count','su
-00019750: 6d27 2c27 6d65 616e 272c 276d 6164 272c  m','mean','mad',
-00019760: 276d 6564 6961 6e27 2c27 6d69 6e27 2c27  'median','min','
-00019770: 6d61 7827 2c0a 2020 2020 2323 2320 2020  max',.    ###   
-00019780: 2020 2020 2020 2020 2020 2020 276d 6f64              'mod
-00019790: 6527 2c27 6162 7327 2c20 2770 726f 6427  e','abs', 'prod'
-000197a0: 2c27 7374 6427 2c27 7661 7227 2c27 7365  ,'std','var','se
-000197b0: 6d27 2c27 736b 6577 272c 276b 7572 7427  m','skew','kurt'
-000197c0: 2c0a 2020 2020 2323 2320 2020 2020 2020  ,.    ###       
-000197d0: 2020 2020 2020 2020 2027 7175 616e 7469           'quanti
-000197e0: 6c65 272c 2763 756d 7375 6d27 2c27 6375  le','cumsum','cu
-000197f0: 6d70 726f 6427 2c27 6375 6d6d 6178 272c  mprod','cummax',
-00019800: 2763 756d 6d69 6e27 7d0a 2020 2020 2323  'cummin'}.    ##
-00019810: 2320 2020 6772 6f75 7062 795f 636f 6c75  #   groupby_colu
-00019820: 6d6e 733a 2063 616e 2062 6520 6120 7374  mns: can be a st
-00019830: 7269 6e67 2072 6570 7265 7365 6e74 696e  ring representin
-00019840: 6720 6120 7369 6e67 6c65 2063 6f6c 756d  g a single colum
-00019850: 6e20 6f72 2061 206c 6973 7420 6f66 200a  n or a list of .
-00019860: 2020 2020 2323 2320 2020 2020 2020 2020      ###         
-00019870: 2020 2020 2020 2020 2020 2020 6d75 6c74              mult
-00019880: 6970 6c65 2063 6f6c 756d 6e73 0a20 2020  iple columns.   
-00019890: 2023 2323 2020 2020 2020 2020 2020 2020   ###            
-000198a0: 2020 202d 2069 7420 7769 6c6c 2067 726f     - it will gro
-000198b0: 7570 6279 2061 6c6c 2074 6865 206e 756d  upby all the num
-000198c0: 6572 6963 2066 6561 7475 7265 7320 7573  eric features us
-000198d0: 696e 6720 6f6e 6520 6772 6f75 7062 7920  ing one groupby 
-000198e0: 636f 6c75 6d6e 200a 2020 2020 2323 2320  column .    ### 
-000198f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00019900: 2020 2061 7420 6120 7469 6d65 2069 6e20     at a time in 
-00019910: 6120 6c6f 6f70 2e0a 2020 2020 2323 2320  a loop..    ### 
-00019920: 2020 6967 6e6f 7265 5f76 6172 6961 626c    ignore_variabl
-00019930: 6573 3a20 6c69 7374 206f 6620 7661 7269  es: list of vari
-00019940: 6162 6c65 7320 746f 2069 676e 6f72 6520  ables to ignore 
-00019950: 616d 6f6e 6720 6e75 6d65 7269 6320 7661  among numeric va
-00019960: 7269 6162 6c65 7320 696e 0a20 2020 2023  riables in.    #
-00019970: 2323 2020 2020 2020 2020 2020 2020 2020  ##              
-00019980: 2020 6461 7461 2073 696e 6365 2074 6865    data since the
-00019990: 7920 6d61 7920 6265 2049 4420 7661 7269  y may be ID vari
-000199a0: 6162 6c65 732e 0a20 2020 2023 2323 204f  ables..    ### O
-000199b0: 7574 7075 7473 3a0a 2020 2020 2323 2320  utputs:.    ### 
-000199c0: 2020 2020 5265 7475 726e 7320 7468 6520      Returns the 
-000199d0: 6f72 6967 696e 616c 2064 6174 6166 7261  original datafra
-000199e0: 6d65 2077 6974 6820 6164 6469 7469 6f6e  me with addition
-000199f0: 616c 2066 6561 7475 7265 7320 6372 6561  al features crea
-00019a00: 7465 6420 6279 2074 6869 7320 6675 6e63  ted by this func
-00019a10: 7469 6f6e 2e0a 2020 2020 2323 2323 2323  tion..    ######
-00019a20: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00019a30: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00019a40: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00019a50: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00019a60: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00019a70: 0a20 2020 2022 2222 0a20 2020 2074 7261  .    """.    tra
-00019a80: 696e 7820 3d20 636f 7079 2e64 6565 7063  inx = copy.deepc
-00019a90: 6f70 7928 7472 6169 6e29 0a20 2020 2074  opy(train).    t
-00019aa0: 6573 7478 203d 2063 6f70 792e 6465 6570  estx = copy.deep
-00019ab0: 636f 7079 2874 6573 7429 0a20 2020 2069  copy(test).    i
-00019ac0: 6620 6973 696e 7374 616e 6365 2867 726f  f isinstance(gro
-00019ad0: 7570 6279 5f63 6f6c 756d 6e73 2c20 7374  upby_columns, st
-00019ae0: 7229 3a0a 2020 2020 2020 2020 6772 6f75  r):.        grou
-00019af0: 7062 795f 636f 6c75 6d6e 7320 3d20 5b67  pby_columns = [g
-00019b00: 726f 7570 6279 5f63 6f6c 756d 6e73 5d0a  roupby_columns].
-00019b10: 2020 2020 6e75 6d65 7269 6373 203d 2074      numerics = t
-00019b20: 7261 696e 782e 7365 6c65 6374 5f64 7479  rainx.select_dty
-00019b30: 7065 7328 696e 636c 7564 653d 276e 756d  pes(include='num
-00019b40: 6265 7227 292e 636f 6c75 6d6e 732e 746f  ber').columns.to
-00019b50: 6c69 7374 2829 0a20 2020 206e 756d 6572  list().    numer
-00019b60: 6963 7320 3d20 5b78 2066 6f72 2078 2069  ics = [x for x i
-00019b70: 6e20 6e75 6d65 7269 6373 2069 6620 7820  n numerics if x 
-00019b80: 6e6f 7420 696e 2069 676e 6f72 655f 7661  not in ignore_va
-00019b90: 7269 6162 6c65 735d 0a20 2020 204d 4742  riables].    MGB
-00019ba0: 203d 2047 726f 7570 6279 5f41 6767 7265   = Groupby_Aggre
-00019bb0: 6761 746f 7228 6361 7465 676f 7269 6361  gator(categorica
-00019bc0: 6c73 3d67 726f 7570 6279 5f63 6f6c 756d  ls=groupby_colum
-00019bd0: 6e73 2c0a 2020 2020 2020 2020 2020 2020  ns,.            
-00019be0: 6167 6772 6567 6174 6573 3d61 6767 5f74  aggregates=agg_t
-00019bf0: 7970 6573 2c20 6e75 6d65 7269 6373 3d6e  ypes, numerics=n
-00019c00: 756d 6572 6963 7329 0a20 2020 2074 7261  umerics).    tra
-00019c10: 696e 5f63 6f70 7920 3d20 4d47 422e 6669  in_copy = MGB.fi
-00019c20: 745f 7472 616e 7366 6f72 6d28 7472 6169  t_transform(trai
-00019c30: 6e78 290a 2020 2020 6966 2069 7369 6e73  nx).    if isins
-00019c40: 7461 6e63 6528 7465 7374 782c 2073 7472  tance(testx, str
-00019c50: 2920 6f72 2074 6573 7478 2069 7320 4e6f  ) or testx is No
-00019c60: 6e65 3a0a 2020 2020 2020 2020 7465 7374  ne:.        test
-00019c70: 5f63 6f70 7920 3d20 7465 7374 780a 2020  _copy = testx.  
-00019c80: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
-00019c90: 7465 7374 5f63 6f70 7920 3d20 4d47 422e  test_copy = MGB.
-00019ca0: 7472 616e 7366 6f72 6d28 7465 7374 7829  transform(testx)
-00019cb0: 0a20 2020 2023 2323 2072 6574 7572 6e20  .    ### return 
-00019cc0: 7468 6520 6461 7461 6672 616d 6573 2023  the dataframes #
-00019cd0: 2323 2323 2323 2323 2323 0a20 2020 2072  ##########.    r
-00019ce0: 6574 7572 6e20 7472 6169 6e5f 636f 7079  eturn train_copy
-00019cf0: 2c20 7465 7374 5f63 6f70 790a 2323 2323  , test_copy.####
-00019d00: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00019d10: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00019d20: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00019d30: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00019d40: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00019d50: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00019d60: 230a 6465 6620 4645 5f63 6f6d 6269 6e65  #.def FE_combine
-00019d70: 5f72 6172 655f 6361 7465 676f 7269 6573  _rare_categories
-00019d80: 2874 7261 696e 5f64 662c 2063 6174 6567  (train_df, categ
-00019d90: 6f72 6963 616c 5f66 6561 7475 7265 732c  orical_features,
-00019da0: 2074 6573 745f 6466 3d22 2229 3a0a 2020   test_df=""):.  
-00019db0: 2020 2222 220a 2020 2020 496e 2074 6869    """.    In thi
-00019dc0: 7320 6675 6e63 7469 6f6e 2c20 7765 2077  s function, we w
-00019dd0: 696c 6c20 7365 6c65 6374 2061 6c6c 2072  ill select all r
-00019de0: 6172 6520 636c 6173 7365 7320 6861 7669  are classes havi
-00019df0: 6e67 2072 6570 7265 7365 6e74 6174 696f  ng representatio
-00019e00: 6e20 3c31 2520 6f66 2070 6f70 756c 6174  n <1% of populat
-00019e10: 696f 6e20 616e 640a 2020 2020 6772 6f75  ion and.    grou
-00019e20: 7020 7468 656d 2074 6f67 6574 6865 7220  p them together 
-00019e30: 756e 6465 7220 6120 6e65 7720 6c61 6265  under a new labe
-00019e40: 6c20 6361 6c6c 6564 2027 5241 5245 272e  l called 'RARE'.
-00019e50: 2057 6520 7769 6c6c 2061 7070 6c79 2074   We will apply t
-00019e60: 6869 7320 6f6e 2074 7261 696e 2061 6e64  his on train and
-00019e70: 2074 6573 7420 286f 7074 696f 6e61 6c29   test (optional)
-00019e80: 0a20 2020 2022 2222 0a20 2020 2074 7261  .    """.    tra
-00019e90: 696e 5f64 6620 3d20 636f 7079 2e64 6565  in_df = copy.dee
-00019ea0: 7063 6f70 7928 7472 6169 6e5f 6466 290a  pcopy(train_df).
-00019eb0: 2020 2020 7465 7374 5f64 6620 3d20 636f      test_df = co
-00019ec0: 7079 2e64 6565 7063 6f70 7928 7465 7374  py.deepcopy(test
-00019ed0: 5f64 6629 0a20 2020 2074 7261 696e 5f64  _df).    train_d
-00019ee0: 665b 6361 7465 676f 7269 6361 6c5f 6665  f[categorical_fe
-00019ef0: 6174 7572 6573 5d20 3d20 7472 6169 6e5f  atures] = train_
-00019f00: 6466 5b63 6174 6567 6f72 6963 616c 5f66  df[categorical_f
-00019f10: 6561 7475 7265 735d 2e61 7070 6c79 280a  eatures].apply(.
-00019f20: 2020 2020 2020 2020 2020 2020 6c61 6d62              lamb
-00019f30: 6461 2078 3a20 782e 6d61 736b 2878 2e6d  da x: x.mask(x.m
-00019f40: 6170 2878 2e76 616c 7565 5f63 6f75 6e74  ap(x.value_count
-00019f50: 7328 2929 3c20 2830 2e30 312a 7472 6169  s())< (0.01*trai
-00019f60: 6e5f 6466 2e73 6861 7065 5b30 5d29 2c20  n_df.shape[0]), 
-00019f70: 2752 4152 4527 2929 0a20 2020 2066 6f72  'RARE')).    for
-00019f80: 2063 6f6c 2069 6e20 6361 7465 676f 7269   col in categori
-00019f90: 6361 6c5f 6665 6174 7572 6573 3a0a 2020  cal_features:.  
-00019fa0: 2020 2020 2020 7661 6c73 203d 206c 6973        vals = lis
-00019fb0: 7428 7472 6169 6e5f 6466 5b63 6f6c 5d2e  t(train_df[col].
-00019fc0: 756e 6971 7565 2829 290a 2020 2020 2020  unique()).      
-00019fd0: 2020 6966 2069 7369 6e73 7461 6e63 6528    if isinstance(
-00019fe0: 7465 7374 5f64 662c 2073 7472 2920 6f72  test_df, str) or
-00019ff0: 2074 6573 745f 6466 2069 7320 4e6f 6e65   test_df is None
-0001a000: 3a0a 2020 2020 2020 2020 2020 2020 7265  :.            re
-0001a010: 7475 726e 2074 7261 696e 5f64 662c 2074  turn train_df, t
-0001a020: 6573 745f 6466 0a20 2020 2020 2020 2065  est_df.        e
-0001a030: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
-0001a040: 2074 6573 745f 6466 5b63 6f6c 5d20 3d20   test_df[col] = 
-0001a050: 7465 7374 5f64 665b 636f 6c5d 2e61 7070  test_df[col].app
-0001a060: 6c79 286c 616d 6264 6120 783a 2027 5241  ly(lambda x: 'RA
-0001a070: 5245 2720 6966 2078 206e 6f74 2069 6e20  RE' if x not in 
-0001a080: 7661 6c73 2065 6c73 6520 7829 0a20 2020  vals else x).   
-0001a090: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-0001a0a0: 7472 6169 6e5f 6466 2c20 7465 7374 5f64  train_df, test_d
-0001a0b0: 660a 0a23 2323 2323 2323 2323 2323 2323  f..#############
-0001a0c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001a0d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001a0e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001a0f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001a100: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001a110: 2323 2323 2323 2323 0a64 6566 2046 455f  ########.def FE_
-0001a120: 6765 745f 6c61 7465 7374 5f76 616c 7565  get_latest_value
-0001a130: 735f 6261 7365 645f 6f6e 5f64 6174 655f  s_based_on_date_
-0001a140: 636f 6c75 6d6e 2864 6674 2c20 6964 5f63  column(dft, id_c
-0001a150: 6f6c 2c20 6461 7465 5f63 6f6c 2c20 636f  ol, date_col, co
-0001a160: 6c73 2c20 6173 6365 6e64 696e 673d 4661  ls, ascending=Fa
-0001a170: 6c73 6529 3a0a 2020 2020 2222 220a 2020  lse):.    """.  
-0001a180: 2020 4645 206d 6561 6e73 2046 4541 5455    FE means FEATU
-0001a190: 5245 2045 4e47 494e 4545 5249 4e47 202d  RE ENGINEERING -
-0001a1a0: 2054 6861 7420 6d65 616e 7320 7468 6973   That means this
-0001a1b0: 2066 756e 6374 696f 6e20 7769 6c6c 2063   function will c
-0001a1c0: 7265 6174 6520 6e65 7720 6665 6174 7572  reate new featur
-0001a1d0: 6573 0a20 2020 2023 2323 2323 2323 2323  es.    #########
-0001a1e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001a1f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001a200: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001a210: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001a220: 2323 2323 2323 2323 2323 2323 230a 2020  #############.  
-0001a230: 2020 5468 6973 2066 756e 6374 696f 6e20    This function 
-0001a240: 6765 7473 2079 6f75 2074 6865 206c 6174  gets you the lat
-0001a250: 6573 7420 7661 6c75 6573 206f 6620 7468  est values of th
-0001a260: 6520 636f 6c75 6d6e 7320 696e 2063 6f6c  e columns in col
-0001a270: 7320 6672 6f6d 2061 2064 6174 6520 636f  s from a date co
-0001a280: 6c75 6d6e 2064 6174 655f 636f 6c2e 0a0a  lumn date_col...
-0001a290: 2020 2020 496e 7075 7473 3a0a 2020 2020      Inputs:.    
-0001a2a0: 6466 743a 2064 6174 6166 7261 6d65 2c20  dft: dataframe, 
-0001a2b0: 7061 6e64 6173 0a20 2020 2069 645f 636f  pandas.    id_co
-0001a2c0: 6c3a 2079 6f75 206e 6565 6420 746f 2070  l: you need to p
-0001a2d0: 726f 7669 6465 2061 6e20 4944 2063 6f6c  rovide an ID col
-0001a2e0: 756d 6e20 746f 2067 726f 7570 6279 2074  umn to groupby t
-0001a2f0: 6865 2063 6f6c 7320 616e 6420 7468 656e  he cols and then
-0001a300: 2073 6f72 7420 7468 656d 2062 7920 6461   sort them by da
-0001a310: 7465 5f63 6f6c 2e0a 2020 2020 6461 7465  te_col..    date
-0001a320: 5f63 6f6c 3a20 7468 6973 206d 7573 7420  _col: this must 
-0001a330: 6265 2061 2076 616c 6964 2070 616e 6461  be a valid panda
-0001a340: 7320 6461 7465 2d74 696d 6520 636f 6c75  s date-time colu
-0001a350: 6d6e 2e20 4966 2069 7420 6973 2061 2073  mn. If it is a s
-0001a360: 7472 696e 6720 636f 6c75 6d6e 2c0a 2020  tring column,.  
-0001a370: 2020 2020 2020 2020 206d 616b 6520 7375           make su
-0001a380: 7265 2079 6f75 2063 6861 6e67 6520 6974  re you change it
-0001a390: 2074 6f20 6120 6461 7465 2d74 696d 6520   to a date-time 
-0001a3a0: 636f 6c75 6d6e 2e0a 2020 2020 2020 2020  column..        
-0001a3b0: 2020 4974 2073 6f72 7473 2065 6163 6820    It sorts each 
-0001a3c0: 6772 6f75 7020 6279 2074 6865 206c 6174  group by the lat
-0001a3d0: 6573 7420 6461 7465 2028 6465 7363 656e  est date (descen
-0001a3e0: 6469 6e67 2920 616e 6420 7365 6c65 6374  ding) and select
-0001a3f0: 7320 7468 6174 2074 6f70 2072 6f77 2e0a  s that top row..
-0001a400: 2020 2020 636f 6c73 3a20 7468 6573 6520      cols: these 
-0001a410: 6172 6520 7468 6520 6c69 7374 206f 6620  are the list of 
-0001a420: 636f 6c75 6d6e 7320 796f 7520 7761 6e74  columns you want
-0001a430: 2074 6865 6972 206c 6174 6573 7420 7661   their latest va
-0001a440: 6c75 6520 6261 7365 6420 6f6e 2074 6865  lue based on the
-0001a450: 2064 6174 652d 636f 6c20 796f 7520 7370   date-col you sp
-0001a460: 6563 6966 792e 0a20 2020 2020 2020 2020  ecify..         
-0001a470: 5468 6573 6520 636f 6c73 2063 616e 2062  These cols can b
-0001a480: 6520 616e 7920 7479 7065 206f 6620 636f  e any type of co
-0001a490: 6c75 6d6e 3a20 6e75 6d65 7269 6320 6f72  lumn: numeric or
-0001a4a0: 2073 7472 696e 672e 0a20 2020 2061 7363   string..    asc
-0001a4b0: 656e 6469 6e67 3a20 5365 7420 7468 6973  ending: Set this
-0001a4c0: 2061 7320 5472 7565 206f 7220 4661 6c73   as True or Fals
-0001a4d0: 6520 6465 7065 6e64 696e 6720 6f6e 2077  e depending on w
-0001a4e0: 6865 7468 6572 2079 6f75 2077 616e 7420  hether you want 
-0001a4f0: 736d 616c 6c65 7374 206f 7220 6269 6767  smallest or bigg
-0001a500: 6573 7420 6f6e 2074 6f70 2e0a 0a20 2020  est on top...   
-0001a510: 204f 7574 7075 7473 3a0a 2020 2020 5265   Outputs:.    Re
-0001a520: 7475 726e 7320 6120 6461 7461 6672 616d  turns a datafram
-0001a530: 6520 7468 6174 2069 7320 736d 616c 6c65  e that is smalle
-0001a540: 7220 7468 616e 2069 6e70 7574 2064 6174  r than input dat
-0001a550: 6166 7261 6d65 2073 696e 6365 2069 7420  aframe since it 
-0001a560: 6772 6f75 7073 2063 6f6c 7320 6279 2049  groups cols by I
-0001a570: 445f 636f 6c75 6d6e 2e0a 2020 2020 2323  D_column..    ##
-0001a580: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001a590: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001a5a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001a5b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001a5c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001a5d0: 2323 2323 0a20 2020 2042 6577 6172 6521  ####.    Beware!
-0001a5e0: 2059 6f75 2077 696c 6c20 6765 7420 6120   You will get a 
-0001a5f0: 6461 7461 6672 616d 6520 7468 6174 2068  dataframe that h
-0001a600: 6173 2066 6577 6572 2063 6f6c 7320 7468  as fewer cols th
-0001a610: 616e 2079 6f75 7220 696e 7075 7420 7769  an your input wi
-0001a620: 7468 2066 6577 6572 2072 6f77 7320 7468  th fewer rows th
-0001a630: 616e 2069 6e70 7574 2e0a 2020 2020 2222  an input..    ""
-0001a640: 220a 2020 2020 6466 7420 3d20 636f 7079  ".    dft = copy
-0001a650: 2e64 6565 7063 6f70 7928 6466 7429 0a20  .deepcopy(dft). 
-0001a660: 2020 2074 7279 3a0a 2020 2020 2020 2020     try:.        
-0001a670: 6966 2069 7369 6e73 7461 6e63 6528 636f  if isinstance(co
-0001a680: 6c73 2c20 7374 7229 3a0a 2020 2020 2020  ls, str):.      
-0001a690: 2020 2020 2020 636f 6c73 203d 205b 636f        cols = [co
-0001a6a0: 6c73 5d0a 2020 2020 2020 2020 7472 6169  ls].        trai
-0001a6b0: 6e5f 6164 6420 3d20 6466 742e 6772 6f75  n_add = dft.grou
-0001a6c0: 7062 7928 5b69 645f 636f 6c5d 2c20 736f  pby([id_col], so
-0001a6d0: 7274 3d46 616c 7365 292e 6170 706c 7928  rt=False).apply(
-0001a6e0: 6c61 6d62 6461 2078 3a20 782e 736f 7274  lambda x: x.sort
-0001a6f0: 5f76 616c 7565 7328 5b64 6174 655f 636f  _values([date_co
-0001a700: 6c5d 2c0a 2020 2020 2020 2020 2020 2020  l],.            
-0001a710: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001a720: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001a730: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001a740: 2020 2020 2020 2020 2020 2020 6173 6365              asce
-0001a750: 6e64 696e 673d 6173 6365 6e64 696e 6729  nding=ascending)
-0001a760: 290a 2020 2020 2020 2020 7472 6169 6e5f  ).        train_
-0001a770: 6164 6420 3d20 7472 6169 6e5f 6164 645b  add = train_add[
-0001a780: 636f 6c73 5d2e 7265 7365 745f 696e 6465  cols].reset_inde
-0001a790: 7828 290a 2020 2020 2020 2020 7472 6169  x().        trai
-0001a7a0: 6e5f 6164 6420 3d20 7472 6169 6e5f 6164  n_add = train_ad
-0001a7b0: 642e 6772 6f75 7062 7928 6964 5f63 6f6c  d.groupby(id_col
-0001a7c0: 292e 6865 6164 2831 292e 7265 7365 745f  ).head(1).reset_
-0001a7d0: 696e 6465 7828 6472 6f70 3d54 7275 6529  index(drop=True)
-0001a7e0: 2e64 726f 7028 276c 6576 656c 5f31 272c  .drop('level_1',
-0001a7f0: 6178 6973 3d31 290a 2020 2020 6578 6365  axis=1).    exce
-0001a800: 7074 3a0a 2020 2020 2020 2020 7072 696e  pt:.        prin
-0001a810: 7428 2720 2020 2045 7272 6f72 2069 6e20  t('    Error in 
-0001a820: 6765 7474 696e 6720 6c61 7465 7374 2073  getting latest s
-0001a830: 7461 7475 7320 6f66 2063 6f6c 756d 6e73  tatus of columns
-0001a840: 2062 6173 6564 206f 6e20 2573 2e20 5265   based on %s. Re
-0001a850: 7475 726e 696e 672e 2e2e 2720 2564 6174  turning...' %dat
-0001a860: 655f 636f 6c29 0a20 2020 2020 2020 2072  e_col).        r
-0001a870: 6574 7572 6e20 6466 740a 2020 2020 7265  eturn dft.    re
-0001a880: 7475 726e 2074 7261 696e 5f61 6464 0a23  turn train_add.#
-0001a890: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001a8a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001a8b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001a8c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001a8d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001a8e0: 0a66 726f 6d20 6675 6e63 746f 6f6c 7320  .from functools 
-0001a8f0: 696d 706f 7274 2072 6564 7563 650a 6465  import reduce.de
-0001a900: 6620 4645 5f73 706c 6974 5f61 6464 5f63  f FE_split_add_c
-0001a910: 6f6c 756d 6e28 6466 742c 2063 6f6c 2c20  olumn(dft, col, 
-0001a920: 7370 6c69 7474 6572 3d27 2c27 2c20 6163  splitter=',', ac
-0001a930: 7469 6f6e 3d27 6164 6427 293a 0a20 2020  tion='add'):.   
-0001a940: 2022 2222 0a20 2020 2046 4520 6d65 616e   """.    FE mean
-0001a950: 7320 4645 4154 5552 4520 454e 4749 4e45  s FEATURE ENGINE
-0001a960: 4552 494e 4720 2d20 5468 6174 206d 6561  ERING - That mea
-0001a970: 6e73 2074 6869 7320 6675 6e63 7469 6f6e  ns this function
-0001a980: 2077 696c 6c20 6372 6561 7465 206e 6577   will create new
-0001a990: 2066 6561 7475 7265 730a 2020 2020 2323   features.    ##
-0001a9a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001a9b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001a9c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001a9d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001a9e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001a9f0: 2323 2323 0a20 2020 2054 6869 7320 6675  ####.    This fu
-0001aa00: 6e63 7469 6f6e 2077 696c 6c20 7370 6c69  nction will spli
-0001aa10: 7420 6120 636f 6c75 6d6e 2773 2076 616c  t a column's val
-0001aa20: 7565 7320 6261 7365 6420 6f6e 2061 2073  ues based on a s
-0001aa30: 706c 6974 7465 7220 796f 7520 7370 6563  plitter you spec
-0001aa40: 6966 7920 616e 640a 2020 2020 7769 6c6c  ify and.    will
-0001aa50: 2065 6974 6865 7220 6164 6420 7468 656d   either add them
-0001aa60: 206f 7220 636f 6e63 6174 656e 6174 6520   or concatenate 
-0001aa70: 7468 656d 2061 7320 796f 7520 7370 6563  them as you spec
-0001aa80: 6966 7920 696e 2074 6865 2061 6374 696f  ify in the actio
-0001aa90: 6e20 6172 6775 6d65 6e74 2e0a 0a20 2020  n argument...   
-0001aaa0: 2049 6e70 7574 733a 0a20 2020 2064 6674   Inputs:.    dft
-0001aab0: 3a20 7061 6e64 6173 2044 6174 6146 7261  : pandas DataFra
-0001aac0: 6d65 0a20 2020 2063 6f6c 3a20 6e61 6d65  me.    col: name
-0001aad0: 206f 6620 636f 6c75 6d6e 2074 6861 7420   of column that 
-0001aae0: 796f 7520 7761 6e74 2074 6f20 7370 6c69  you want to spli
-0001aaf0: 7420 696e 746f 2069 7473 2063 6f6e 7374  t into its const
-0001ab00: 6974 7565 6e74 2070 6172 7473 2e20 4974  ituent parts. It
-0001ab10: 206d 7573 7420 6265 2061 2073 7472 696e   must be a strin
-0001ab20: 6720 636f 6c75 6d6e 2e0a 2020 2020 7370  g column..    sp
-0001ab30: 6c69 7474 6572 3a20 7370 6c69 7474 6572  litter: splitter
-0001ab40: 2063 616e 2062 6520 616e 7920 7374 7269   can be any stri
-0001ab50: 6e67 2074 6861 7420 6973 2066 6f75 6e64  ng that is found
-0001ab60: 2069 6e20 796f 7572 2063 6f6c 756d 6e20   in your column 
-0001ab70: 616e 6420 7468 6174 2079 6f75 2077 616e  and that you wan
-0001ab80: 7420 746f 2073 706c 6974 2062 792e 0a20  t to split by.. 
-0001ab90: 2020 2061 6374 696f 6e3a 2063 616e 2062     action: can b
-0001aba0: 6520 616e 7920 6f6e 6520 6f66 2066 6f6c  e any one of fol
-0001abb0: 6c6f 7769 6e67 3a20 7b27 6164 6427 2c20  lowing: {'add', 
-0001abc0: 2773 7562 7472 6163 7427 2c20 276d 756c  'subtract', 'mul
-0001abd0: 7469 706c 7927 2c20 2764 6976 6964 6527  tiply', 'divide'
-0001abe0: 2c20 2763 6f6e 6361 7427 2c20 2763 6f6e  , 'concat', 'con
-0001abf0: 6361 7465 6e61 7465 277d 0a20 2020 2023  catenate'}.    #
-0001ac00: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001ac10: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001ac20: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001ac30: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001ac40: 2323 2323 2323 2323 2323 2323 2323 230a  ###############.
-0001ac50: 2020 2020 5265 7475 726e 7320 6120 6461      Returns a da
-0001ac60: 7461 6672 616d 6520 7769 7468 2061 206e  taframe with a n
-0001ac70: 6577 2063 6f6c 756d 6e20 7468 6174 2069  ew column that i
-0001ac80: 7320 6120 6d6f 6469 6669 6361 7469 6f6e  s a modification
-0001ac90: 206f 6620 7468 6520 6f6c 6420 636f 6c75   of the old colu
-0001aca0: 6d6e 0a20 2020 2022 2222 0a20 2020 2064  mn.    """.    d
-0001acb0: 6674 203d 2063 6f70 792e 6465 6570 636f  ft = copy.deepco
-0001acc0: 7079 2864 6674 290a 2020 2020 6e65 775f  py(dft).    new_
-0001acd0: 636f 6c20 3d20 636f 6c20 2b20 275f 7370  col = col + '_sp
-0001ace0: 6c69 745f 6170 706c 7927 0a20 2020 2070  lit_apply'.    p
-0001acf0: 7269 6e74 2827 4372 6561 7469 6e67 2063  rint('Creating c
-0001ad00: 6f6c 756d 6e20 3d20 2573 2075 7369 6e67  olumn = %s using
-0001ad10: 2073 706c 6974 5f61 6464 2066 6561 7475   split_add featu
-0001ad20: 7265 2065 6e67 696e 6565 7269 6e67 2e2e  re engineering..
-0001ad30: 2e27 2025 6e65 775f 636f 6c29 0a20 2020  .' %new_col).   
-0001ad40: 2069 6620 6163 7469 6f6e 2069 6e20 5b27   if action in ['
-0001ad50: 2b27 2c27 2d27 2c27 2a27 2c27 2f27 2c27  +','-','*','/','
-0001ad60: 6164 6427 2c27 7375 6274 7261 6374 272c  add','subtract',
-0001ad70: 276d 756c 7469 706c 7927 2c27 6469 7669  'multiply','divi
-0001ad80: 6465 275d 3a0a 2020 2020 2020 2020 6966  de']:.        if
-0001ad90: 2061 6374 696f 6e20 696e 205b 2761 6464   action in ['add
-0001ada0: 272c 272b 275d 3a0a 2020 2020 2020 2020  ','+']:.        
-0001adb0: 2020 2020 7369 676e 203d 2027 2b27 0a20      sign = '+'. 
-0001adc0: 2020 2020 2020 2065 6c69 6620 6163 7469         elif acti
-0001add0: 6f6e 2069 6e20 5b27 2d27 2c20 2773 7562  on in ['-', 'sub
-0001ade0: 7472 6163 7427 5d3a 0a20 2020 2020 2020  tract']:.       
-0001adf0: 2020 2020 2073 6967 6e20 3d20 272d 270a       sign = '-'.
-0001ae00: 2020 2020 2020 2020 656c 6966 2061 6374          elif act
-0001ae10: 696f 6e20 696e 205b 272a 272c 2027 6d75  ion in ['*', 'mu
-0001ae20: 6c74 6970 6c79 275d 3a0a 2020 2020 2020  ltiply']:.      
-0001ae30: 2020 2020 2020 7369 676e 203d 2027 2a27        sign = '*'
-0001ae40: 0a20 2020 2020 2020 2065 6c69 6620 6163  .        elif ac
-0001ae50: 7469 6f6e 2069 6e20 5b27 2f27 2c20 2764  tion in ['/', 'd
-0001ae60: 6976 6964 6527 5d3a 0a20 2020 2020 2020  ivide']:.       
-0001ae70: 2020 2020 2073 6967 6e20 3d20 272f 270a       sign = '/'.
-0001ae80: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
-0001ae90: 2020 2020 2020 2020 2020 7369 676e 203d            sign =
-0001aea0: 2027 2b27 0a20 2020 2020 2020 2023 2075   '+'.        # u
-0001aeb0: 7369 6e67 2072 6564 7563 6520 746f 2063  sing reduce to c
-0001aec0: 6f6d 7075 7465 2073 756d 206f 6620 6c69  ompute sum of li
-0001aed0: 7374 0a20 2020 2020 2020 2074 7279 3a0a  st.        try:.
-0001aee0: 2020 2020 2020 2020 2020 2020 7472 6169              trai
-0001aef0: 6e78 203d 2064 6674 5b63 6f6c 5d2e 6173  nx = dft[col].as
-0001af00: 7479 7065 2873 7472 290a 2020 2020 2020  type(str).      
-0001af10: 2020 2020 2020 7472 6169 6e78 203d 2074        trainx = t
-0001af20: 7261 696e 782e 6d61 7028 6c61 6d62 6461  rainx.map(lambda
-0001af30: 2078 3a20 2030 2069 6620 7820 6973 206e   x:  0 if x is n
-0001af40: 702e 6e61 6e20 656c 7365 2030 2069 6620  p.nan else 0 if 
-0001af50: 7820 3d3d 2027 2720 656c 7365 2078 2e73  x == '' else x.s
-0001af60: 706c 6974 2873 706c 6974 7465 7229 292e  plit(splitter)).
-0001af70: 6d61 7028 0a20 2020 2020 2020 2020 2020  map(.           
-0001af80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001af90: 2020 2020 206c 616d 6264 6120 6c69 7374       lambda list
-0001afa0: 783a 205b 696e 7428 7829 2069 6620 7820  x: [int(x) if x 
-0001afb0: 213d 2027 2720 656c 7365 2030 2066 6f72  != '' else 0 for
-0001afc0: 2078 2069 6e20 6c69 7374 7820 5d20 6966   x in listx ] if
-0001afd0: 2069 7369 6e73 7461 6e63 6528 6c69 7374   isinstance(list
-0001afe0: 782c 6c69 7374 2920 656c 7365 205b 302c  x,list) else [0,
-0001aff0: 305d 290a 2020 2020 2020 2020 2020 2020  0]).            
-0001b000: 6466 745b 6e65 775f 636f 6c5d 203d 2074  dft[new_col] = t
-0001b010: 7261 696e 782e 6d61 7028 6c61 6d62 6461  rainx.map(lambda
-0001b020: 206c 6973 3a20 7265 6475 6365 286c 616d   lis: reduce(lam
-0001b030: 6264 6120 612c 6220 3a20 6576 616c 2827  bda a,b : eval('
-0001b040: 6127 2b73 6967 6e2b 2762 2729 2c20 6c69  a'+sign+'b'), li
-0001b050: 7329 2069 6620 6973 696e 7374 616e 6365  s) if isinstance
-0001b060: 286c 6973 2c6c 6973 7429 2065 6c73 6520  (lis,list) else 
-0001b070: 3029 2e76 616c 7565 730a 2020 2020 2020  0).values.      
-0001b080: 2020 6578 6365 7074 3a0a 2020 2020 2020    except:.      
-0001b090: 2020 2020 2020 7072 696e 7428 2720 2020        print('   
-0001b0a0: 2045 7272 6f72 3a20 7265 7475 726e 696e   Error: returnin
-0001b0b0: 6720 7769 7468 6f75 7420 6372 6561 7469  g without creati
-0001b0c0: 6e67 206e 6577 2063 6f6c 756d 6e27 290a  ng new column').
-0001b0d0: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-0001b0e0: 726e 2064 6674 0a20 2020 2065 6c69 6620  rn dft.    elif 
-0001b0f0: 6163 7469 6f6e 2069 6e20 5b27 636f 6e63  action in ['conc
-0001b100: 6174 272c 2763 6f6e 6361 7465 6e61 7465  at','concatenate
-0001b110: 275d 3a0a 2020 2020 2020 2020 7472 793a  ']:.        try:
-0001b120: 0a20 2020 2020 2020 2020 2020 2064 6674  .            dft
-0001b130: 5b6e 6577 5f63 6f6c 5d20 3d20 6466 745b  [new_col] = dft[
-0001b140: 636f 6c5d 2e6d 6170 286c 616d 6264 6120  col].map(lambda 
-0001b150: 783a 2020 2220 2220 6966 2078 2069 7320  x:  " " if x is 
-0001b160: 6e70 2e6e 616e 2065 6c73 6520 2220 2220  np.nan else " " 
-0001b170: 6966 2078 203d 3d20 2727 2065 6c73 6520  if x == '' else 
-0001b180: 782e 7370 6c69 7428 7370 6c69 7474 6572  x.split(splitter
-0001b190: 2929 2e6d 6170 280a 2020 2020 2020 2020  )).map(.        
-0001b1a0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001b1b0: 2020 2020 6c61 6d62 6461 206c 6973 7478      lambda listx
-0001b1c0: 3a20 6e70 2e63 6f6e 6361 7465 6e61 7465  : np.concatenate
-0001b1d0: 285b 7374 7228 7829 2069 6620 7820 213d  ([str(x) if x !=
-0001b1e0: 2027 2720 656c 7365 2022 2022 2066 6f72   '' else " " for
-0001b1f0: 2078 2069 6e20 6c69 7374 785d 2069 6620   x in listx] if 
-0001b200: 6973 696e 7374 616e 6365 286c 6973 7478  isinstance(listx
-0001b210: 2c6c 6973 7429 2065 6c73 6520 2220 2229  ,list) else " ")
-0001b220: 292e 7661 6c75 6573 0a20 2020 2020 2020  ).values.       
-0001b230: 2065 7863 6570 743a 0a20 2020 2020 2020   except:.       
-0001b240: 2020 2020 2070 7269 6e74 2827 2020 2020       print('    
-0001b250: 4572 726f 723a 2072 6574 7572 6e69 6e67  Error: returning
-0001b260: 2077 6974 686f 7574 2063 7265 6174 696e   without creatin
-0001b270: 6720 6e65 7720 636f 6c75 6d6e 2729 0a20  g new column'). 
-0001b280: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
-0001b290: 2070 7269 6e74 2827 436f 756c 6420 6e6f   print('Could no
-0001b2a0: 7420 7065 7266 6f72 6d20 6163 7469 6f6e  t perform action
-0001b2b0: 2e20 506c 6561 7365 2063 6865 636b 2079  . Please check y
-0001b2c0: 6f75 7220 696e 7075 7473 2061 6e64 2074  our inputs and t
-0001b2d0: 7279 2061 6761 696e 2729 0a20 2020 2020  ry again').     
-0001b2e0: 2020 2072 6574 7572 6e20 6466 740a 2020     return dft.  
-0001b2f0: 2020 7265 7475 726e 2064 6674 0a23 2323    return dft.###
-0001b300: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001b310: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001b320: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001b330: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001b340: 2323 2323 2323 2323 2323 2323 230a 6465  #############.de
-0001b350: 6620 4645 5f61 6464 5f61 6765 5f62 795f  f FE_add_age_by_
-0001b360: 6461 7465 5f63 6f6c 2864 6674 2c20 6461  date_col(dft, da
-0001b370: 7465 5f63 6f6c 2c20 6167 655f 666f 726d  te_col, age_form
-0001b380: 6174 293a 0a20 2020 2022 2222 0a20 2020  at):.    """.   
-0001b390: 2046 4520 6d65 616e 7320 4645 4154 5552   FE means FEATUR
-0001b3a0: 4520 454e 4749 4e45 4552 494e 4720 2d20  E ENGINEERING - 
-0001b3b0: 5468 6174 206d 6561 6e73 2074 6869 7320  That means this 
-0001b3c0: 6675 6e63 7469 6f6e 2077 696c 6c20 6372  function will cr
-0001b3d0: 6561 7465 206e 6577 2066 6561 7475 7265  eate new feature
-0001b3e0: 730a 2020 2020 2323 2323 2323 2323 2323  s.    ##########
-0001b3f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001b400: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001b410: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001b420: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001b430: 2323 2323 2323 2323 2323 2323 0a20 2020  ############.   
-0001b440: 2054 6869 7320 6861 6e64 7920 6675 6e63   This handy func
-0001b450: 7469 6f6e 2067 6574 7320 796f 7520 6167  tion gets you ag
-0001b460: 6520 6672 6f6d 2074 6865 2064 6174 655f  e from the date_
-0001b470: 636f 6c20 746f 2074 6f64 6179 2e20 4974  col to today. It
-0001b480: 2063 616e 2062 6520 636f 756e 7465 6420   can be counted 
-0001b490: 696e 206d 6f6e 7468 7320 6f72 2079 6561  in months or yea
-0001b4a0: 7273 206f 7220 6461 7973 2e0a 2020 2020  rs or days..    
-0001b4b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001b4c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001b4d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001b4e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001b4f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001b500: 2323 2323 2323 0a20 2020 2049 7420 7265  ######.    It re
-0001b510: 7475 726e 7320 7468 6520 7361 6d65 2064  turns the same d
-0001b520: 6174 6166 7261 6d65 2077 6974 6820 616e  ataframe with an
-0001b530: 2065 7874 7261 2063 6f6c 756d 6e20 6164   extra column ad
-0001b540: 6465 6420 7468 6174 2067 6976 6573 2079  ded that gives y
-0001b550: 6f75 2061 6765 0a20 2020 2022 2222 0a20  ou age.    """. 
-0001b560: 2020 2069 6620 6e6f 7420 6167 655f 666f     if not age_fo
-0001b570: 726d 6174 2069 6e20 5b27 4d27 2c27 4427  rmat in ['M','D'
-0001b580: 2c27 5927 5d3a 0a20 2020 2020 2020 2070  ,'Y']:.        p
-0001b590: 7269 6e74 2827 4167 6520 6973 206e 6f74  rint('Age is not
-0001b5a0: 2067 6976 656e 2069 6e20 7269 6768 7420   given in right 
-0001b5b0: 666f 726d 6174 2e20 4d75 7374 2062 6520  format. Must be 
-0001b5c0: 6f6e 6520 6f66 2044 2c20 5920 6f72 204d  one of D, Y or M
-0001b5d0: 2729 0a20 2020 2020 2020 2072 6574 7572  ').        retur
-0001b5e0: 6e20 6466 740a 2020 2020 6e65 775f 6461  n dft.    new_da
-0001b5f0: 7465 5f63 6f6c 203d 2027 6c61 7374 5f27  te_col = 'last_'
-0001b600: 2b64 6174 655f 636f 6c2b 275f 696e 5f6d  +date_col+'_in_m
-0001b610: 6f6e 7468 7327 0a20 2020 2074 7279 3a0a  onths'.    try:.
-0001b620: 2020 2020 2020 2020 6e6f 7720 3d20 7064          now = pd
-0001b630: 2e54 696d 6573 7461 6d70 2827 6e6f 7727  .Timestamp('now'
-0001b640: 290a 2020 2020 2020 2020 6466 745b 6461  ).        dft[da
-0001b650: 7465 5f63 6f6c 5d20 3d20 7064 2e74 6f5f  te_col] = pd.to_
-0001b660: 6461 7465 7469 6d65 2864 6674 5b64 6174  datetime(dft[dat
-0001b670: 655f 636f 6c5d 2c20 666f 726d 6174 3d27  e_col], format='
-0001b680: 2579 2d25 6d2d 2564 2729 0a20 2020 2020  %y-%m-%d').     
-0001b690: 2020 2064 6674 5b64 6174 655f 636f 6c5d     dft[date_col]
-0001b6a0: 203d 2064 6674 5b64 6174 655f 636f 6c5d   = dft[date_col]
-0001b6b0: 2e77 6865 7265 2864 6674 5b64 6174 655f  .where(dft[date_
-0001b6c0: 636f 6c5d 203c 206e 6f77 2c20 6466 745b  col] < now, dft[
-0001b6d0: 6461 7465 5f63 6f6c 5d20 2d20 206e 702e  date_col] -  np.
-0001b6e0: 7469 6d65 6465 6c74 6136 3428 3130 302c  timedelta64(100,
-0001b6f0: 2061 6765 5f66 6f72 6d61 7429 290a 2020   age_format)).  
-0001b700: 2020 2020 2020 6966 2061 6765 5f66 6f72        if age_for
-0001b710: 6d61 7420 3d3d 2027 4d27 3a0a 2020 2020  mat == 'M':.    
-0001b720: 2020 2020 2020 2020 6466 745b 6e65 775f          dft[new_
-0001b730: 6461 7465 5f63 6f6c 5d20 3d20 286e 6f77  date_col] = (now
-0001b740: 202d 2064 6674 5b64 6174 655f 636f 6c5d   - dft[date_col]
-0001b750: 292e 6173 7479 7065 2827 3c6d 385b 4d5d  ).astype('<m8[M]
-0001b760: 2729 0a20 2020 2020 2020 2065 6c69 6620  ').        elif 
-0001b770: 6167 655f 666f 726d 6174 203d 3d20 2759  age_format == 'Y
-0001b780: 273a 0a20 2020 2020 2020 2020 2020 2064  ':.            d
-0001b790: 6674 5b6e 6577 5f64 6174 655f 636f 6c5d  ft[new_date_col]
-0001b7a0: 203d 2028 6e6f 7720 2d20 6466 745b 6461   = (now - dft[da
-0001b7b0: 7465 5f63 6f6c 5d29 2e61 7374 7970 6528  te_col]).astype(
-0001b7c0: 273c 6d38 5b59 5d27 290a 2020 2020 2020  '<m8[Y]').      
-0001b7d0: 2020 656c 6966 2061 6765 5f66 6f72 6d61    elif age_forma
-0001b7e0: 7420 3d3d 2027 4427 3a0a 2020 2020 2020  t == 'D':.      
-0001b7f0: 2020 2020 2020 6466 745b 6e65 775f 6461        dft[new_da
-0001b800: 7465 5f63 6f6c 5d20 3d20 286e 6f77 202d  te_col] = (now -
-0001b810: 2064 6674 5b64 6174 655f 636f 6c5d 292e   dft[date_col]).
-0001b820: 6173 7479 7065 2827 3c6d 385b 445d 2729  astype('<m8[D]')
-0001b830: 0a20 2020 2065 7863 6570 743a 0a20 2020  .    except:.   
-0001b840: 2020 2020 2070 7269 6e74 2827 2020 2020       print('    
-0001b850: 4572 726f 7220 696e 2064 6174 6520 666f  Error in date fo
-0001b860: 726d 6174 7469 6e67 2e20 506c 6561 7365  rmatting. Please
-0001b870: 2063 6865 636b 2079 6f75 7220 696e 7075   check your inpu
-0001b880: 7420 616e 6420 7472 7920 6167 6169 6e27  t and try again'
-0001b890: 290a 2020 2020 7265 7475 726e 2064 6674  ).    return dft
-0001b8a0: 0a23 2323 2323 2323 2323 2323 2323 2323  .###############
-0001b8b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001b8c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001b8d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001b8e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001b8f0: 2323 0a64 6566 2046 455f 636f 756e 745f  ##.def FE_count_
-0001b900: 726f 7773 5f66 6f72 5f61 6c6c 5f63 6f6c  rows_for_all_col
-0001b910: 756d 6e73 5f62 795f 6772 6f75 7028 6466  umns_by_group(df
-0001b920: 742c 2069 645f 636f 6c29 3a0a 2020 2020  t, id_col):.    
-0001b930: 2222 220a 2020 2020 4645 206d 6561 6e73  """.    FE means
-0001b940: 2046 4541 5455 5245 2045 4e47 494e 4545   FEATURE ENGINEE
-0001b950: 5249 4e47 202d 2054 6861 7420 6d65 616e  RING - That mean
-0001b960: 7320 7468 6973 2066 756e 6374 696f 6e20  s this function 
-0001b970: 7769 6c6c 2063 7265 6174 6520 6e65 7720  will create new 
-0001b980: 6665 6174 7572 6573 0a20 2020 2023 2323  features.    ###
-0001b990: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001b9a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001b9b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001b9c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001b9d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001b9e0: 2323 230a 2020 2020 5468 6973 2068 616e  ###.    This han
-0001b9f0: 6479 2066 756e 6374 696f 6e20 6769 7665  dy function give
-0001ba00: 7320 796f 7520 6120 636f 756e 7420 6f66  s you a count of
-0001ba10: 2061 6c6c 2072 6f77 7320 6279 2067 726f   all rows by gro
-0001ba20: 7570 7320 6261 7365 6420 6f6e 2069 645f  ups based on id_
-0001ba30: 636f 6c20 696e 2079 6f75 7220 6461 7461  col in your data
-0001ba40: 6672 616d 652e 0a20 2020 2052 656d 656d  frame..    Remem
-0001ba50: 6265 7220 7468 6174 2069 7420 636f 756e  ber that it coun
-0001ba60: 7473 206f 6e6c 7920 6e6f 6e2d 6e75 6c6c  ts only non-null
-0001ba70: 2072 6f77 732e 2048 656e 6365 2069 7420   rows. Hence it 
-0001ba80: 6973 2061 2064 6966 6665 7265 6e74 2063  is a different c
-0001ba90: 6f75 6e74 2074 6861 6e20 6f74 6865 7220  ount than other 
-0001baa0: 636f 756e 7420 6675 6e63 7469 6f6e 2e0a  count function..
-0001bab0: 2020 2020 2323 2323 2323 2323 2323 2323      ############
-0001bac0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001bad0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001bae0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001baf0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001bb00: 2323 2323 2323 2323 2323 0a20 2020 2049  ##########.    I
-0001bb10: 7420 7265 7475 726e 7320 6120 6461 7461  t returns a data
-0001bb20: 6672 616d 6520 7769 7468 2069 645f 636f  frame with id_co
-0001bb30: 6c20 6173 2074 6865 2069 6e64 6578 2061  l as the index a
-0001bb40: 6e64 2061 2062 756e 6368 206f 6620 6e65  nd a bunch of ne
-0001bb50: 7720 636f 6c75 6d6e 7320 7468 6174 2067  w columns that g
-0001bb60: 6976 6520 796f 7520 636f 756e 7473 206f  ive you counts o
-0001bb70: 6620 6772 6f75 7073 2e0a 2020 2020 2222  f groups..    ""
-0001bb80: 220a 2020 2020 6e65 775f 636f 6c20 3d20  ".    new_col = 
-0001bb90: 2772 6f77 5f63 6f75 6e74 5f27 0a20 2020  'row_count_'.   
-0001bba0: 2069 6620 6973 696e 7374 616e 6365 2869   if isinstance(i
-0001bbb0: 645f 636f 6c2c 2073 7472 293a 0a20 2020  d_col, str):.   
-0001bbc0: 2020 2020 2067 726f 7570 6279 5f63 6f6c       groupby_col
-0001bbd0: 756d 6e73 203d 2020 5b69 645f 636f 6c5d  umns =  [id_col]
-0001bbe0: 0a20 2020 2065 6c73 653a 0a20 2020 2020  .    else:.     
-0001bbf0: 2020 2067 726f 7570 6279 5f63 6f6c 756d     groupby_colum
-0001bc00: 6e73 203d 2063 6f70 792e 6465 6570 636f  ns = copy.deepco
-0001bc10: 7079 2869 645f 636f 6c29 0a20 2020 2067  py(id_col).    g
-0001bc20: 726f 7570 6564 5f63 6f75 6e74 203d 2064  rouped_count = d
-0001bc30: 6674 2e67 726f 7570 6279 2867 726f 7570  ft.groupby(group
-0001bc40: 6279 5f63 6f6c 756d 6e73 292e 636f 756e  by_columns).coun
-0001bc50: 7428 292e 6164 645f 7072 6566 6978 286e  t().add_prefix(n
-0001bc60: 6577 5f63 6f6c 290a 2020 2020 7265 7475  ew_col).    retu
-0001bc70: 726e 2067 726f 7570 6564 5f63 6f75 6e74  rn grouped_count
-0001bc80: 0a23 2323 2323 2323 2323 2323 2323 2323  .###############
-0001bc90: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001bca0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001bcb0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001bcc0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001bcd0: 2323 0a64 6566 2063 6f75 6e74 5f72 6f77  ##.def count_row
-0001bce0: 735f 6279 5f67 726f 7570 5f69 6e63 6c5f  s_by_group_incl_
-0001bcf0: 6e75 6c6c 7328 6466 742c 2069 645f 636f  nulls(dft, id_co
-0001bd00: 6c29 3a0a 2020 2020 2222 220a 2020 2020  l):.    """.    
-0001bd10: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001bd20: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001bd30: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001bd40: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001bd50: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001bd60: 2323 2323 2323 0a20 2020 2054 6869 7320  ######.    This 
-0001bd70: 6675 6e63 7469 6f6e 2067 6976 6573 2079  function gives y
-0001bd80: 6f75 2074 6865 2063 6f75 6e74 206f 6620  ou the count of 
-0001bd90: 616c 6c20 7468 6520 726f 7773 2069 6e63  all the rows inc
-0001bda0: 6c75 6469 6e67 206e 756c 6c20 726f 7773  luding null rows
-0001bdb0: 2069 6e20 796f 7572 2064 6174 612e 0a20   in your data.. 
-0001bdc0: 2020 2049 7420 7265 7475 726e 7320 6120     It returns a 
-0001bdd0: 6461 7461 6672 616d 6520 7769 7468 2069  dataframe with i
-0001bde0: 645f 636f 6c20 6173 2074 6865 2069 6e64  d_col as the ind
-0001bdf0: 6578 2061 6e64 2074 6865 2063 6f75 6e74  ex and the count
-0001be00: 7320 6f66 2072 6f77 7320 2869 6e63 6c20  s of rows (incl 
-0001be10: 6e75 6c6c 2072 6f77 7329 2061 7320 6120  null rows) as a 
-0001be20: 6e65 7720 636f 6c75 6d6e 0a20 2020 2023  new column.    #
+00018600: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00018610: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00018620: 2323 2323 2323 2323 2323 0a64 6566 2046  ##########.def F
+00018630: 455f 7370 6c69 745f 6f6e 655f 6669 656c  E_split_one_fiel
+00018640: 645f 696e 746f 5f6d 616e 7928 6466 5f69  d_into_many(df_i
+00018650: 6e2c 2066 6965 6c64 2c20 7370 6c69 7474  n, field, splitt
+00018660: 6572 2c20 6669 6c6c 6572 2c20 6e65 775f  er, filler, new_
+00018670: 6e61 6d65 735f 6c69 7374 3d27 272c 2061  names_list='', a
+00018680: 6464 5f63 6f75 6e74 5f66 6965 6c64 3d46  dd_count_field=F
+00018690: 616c 7365 293a 0a20 2020 2022 2222 0a20  alse):.    """. 
+000186a0: 2020 2046 4520 7374 616e 6473 2066 6f72     FE stands for
+000186b0: 2046 6561 7475 7265 2045 6e67 696e 6565   Feature Enginee
+000186c0: 7269 6e67 202d 2069 7420 6d65 616e 7320  ring - it means 
+000186d0: 7468 6973 2066 756e 6374 696f 6e20 7065  this function pe
+000186e0: 7266 6f72 6d73 2066 6561 7475 7265 2065  rforms feature e
+000186f0: 6e67 696e 6565 7269 6e67 0a20 2020 2023  ngineering.    #
+00018700: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00018710: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00018720: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00018730: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00018740: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00018750: 2323 2323 230a 2020 2020 5468 6973 2066  #####.    This f
+00018760: 756e 6374 696f 6e20 7461 6b65 7320 616e  unction takes an
+00018770: 7920 6461 7461 2066 7261 6d65 2066 6965  y data frame fie
+00018780: 6c64 2028 7374 7269 6e67 2076 6172 6961  ld (string varia
+00018790: 626c 6573 206f 6e6c 7929 2061 6e64 2073  bles only) and s
+000187a0: 706c 6974 730a 2020 2020 6974 2069 6e74  plits.    it int
+000187b0: 6f20 6173 206d 616e 7920 6669 656c 6473  o as many fields
+000187c0: 2061 7320 796f 7520 7761 6e74 2069 6e20   as you want in 
+000187d0: 7468 6520 6e65 775f 6e61 6d65 735f 6c69  the new_names_li
+000187e0: 7374 2e0a 0a20 2020 2049 6e70 7574 733a  st...    Inputs:
+000187f0: 0a20 2020 2020 2020 2064 6674 3a20 7061  .        dft: pa
+00018800: 6e64 6173 2044 6174 6146 7261 6d65 0a20  ndas DataFrame. 
+00018810: 2020 2020 2020 2066 6965 6c64 3a20 6e61         field: na
+00018820: 6d65 206f 6620 7374 7269 6e67 2063 6f6c  me of string col
+00018830: 756d 6e20 7468 6174 2079 6f75 2077 616e  umn that you wan
+00018840: 7420 746f 2073 706c 6974 2075 7369 6e67  t to split using
+00018850: 2074 6865 2073 706c 6974 7465 7220 7374   the splitter st
+00018860: 7269 6e67 2073 7065 6369 6669 6564 0a20  ring specified. 
+00018870: 2020 2020 2020 2073 706c 6974 7465 723a         splitter:
+00018880: 2073 7065 6369 6679 2077 6861 7420 7374   specify what st
+00018890: 7269 6e67 2074 6f20 7370 6c69 7420 6f6e  ring to split on
+000188a0: 2075 7369 6e67 2074 6865 2073 706c 6974   using the split
+000188b0: 7465 7220 6172 6775 6d65 6e74 2e0a 2020  ter argument..  
+000188c0: 2020 2020 2020 6669 6c6c 6572 3a20 596f        filler: Yo
+000188d0: 7520 6361 6e20 616c 736f 2066 696c 6c20  u can also fill 
+000188e0: 4e75 6c6c 2076 616c 7565 7320 7468 6174  Null values that
+000188f0: 206d 6179 2068 6170 7065 6e20 6475 6520   may happen due 
+00018900: 746f 2079 6f75 7220 7370 6c69 7474 696e  to your splittin
+00018910: 6720 6279 2073 7065 6369 6679 696e 6720  g by specifying 
+00018920: 6120 6669 6c6c 6572 2e0a 2020 2020 2020  a filler..      
+00018930: 2020 6e65 775f 6e61 6d65 735f 6c69 7374    new_names_list
+00018940: 3a20 4966 206e 6f20 6e65 775f 6e61 6d65  : If no new_name
+00018950: 735f 6c69 7374 2069 7320 6769 7665 6e2c  s_list is given,
+00018960: 2074 6865 6e20 7765 2075 7365 2074 6865   then we use the
+00018970: 206e 616d 6520 6f66 2074 6865 2066 6965   name of the fie
+00018980: 6c64 2069 7473 656c 6620 746f 2063 7265  ld itself to cre
+00018990: 6174 6520 6e65 7720 636f 6c75 6d6e 732e  ate new columns.
+000189a0: 0a20 2020 2020 2020 2061 6464 5f63 6f75  .        add_cou
+000189b0: 6e74 5f66 6965 6c64 3a20 4661 6c73 6520  nt_field: False 
+000189c0: 2864 6566 6175 6c74 292e 2049 6620 5472  (default). If Tr
+000189d0: 7565 2c20 6974 2077 696c 6c20 636f 756e  ue, it will coun
+000189e0: 7420 7468 6520 6e75 6d62 6572 206f 6620  t the number of 
+000189f0: 6974 656d 7320 696e 0a20 2020 2020 2020  items in.       
+00018a00: 2020 2020 2074 6865 2022 6669 656c 6422       the "field"
+00018a10: 2063 6f6c 756d 6e20 6265 666f 7265 2074   column before t
+00018a20: 6865 2073 706c 6974 2e20 5468 6973 206d  he split. This m
+00018a30: 6179 2062 6520 6e65 6564 6564 2069 6e20  ay be needed in 
+00018a40: 6e65 7374 6564 2064 6963 7469 6f6e 6172  nested dictionar
+00018a50: 7920 6669 656c 6473 2e0a 0a20 2020 204f  y fields...    O
+00018a60: 7574 7075 7473 3a0a 2020 2020 2020 2020  utputs:.        
+00018a70: 6466 743a 206f 7269 6769 6e61 6c20 6461  dft: original da
+00018a80: 7461 6672 616d 6520 7769 7468 2061 6464  taframe with add
+00018a90: 6974 696f 6e61 6c20 636f 6c75 6d6e 7320  itional columns 
+00018aa0: 6372 6561 7465 6420 6279 2073 706c 6974  created by split
+00018ab0: 7469 6e67 2074 6865 2066 6965 6c64 2e0a  ting the field..
+00018ac0: 2020 2020 2020 2020 6e65 775f 6e61 6d65          new_name
+00018ad0: 735f 6c69 7374 3a20 7468 6520 6c69 7374  s_list: the list
+00018ae0: 206f 6620 6e65 7720 636f 6c75 6d6e 7320   of new columns 
+00018af0: 6372 6561 7465 6420 6279 2074 6869 7320  created by this 
+00018b00: 6675 6e63 7469 6f6e 0a20 2020 2023 2323  function.    ###
+00018b10: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00018b20: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00018b30: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00018b40: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00018b50: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00018b60: 2323 230a 2020 2020 2222 220a 2020 2020  ###.    """.    
+00018b70: 6466 5f66 6965 6c64 203d 2064 665f 696e  df_field = df_in
+00018b80: 5b66 6965 6c64 5d2e 7661 6c75 6573 0a20  [field].values. 
+00018b90: 2020 2064 6620 3d20 636f 7079 2e64 6565     df = copy.dee
+00018ba0: 7063 6f70 7928 6466 5f69 6e29 0a20 2020  pcopy(df_in).   
+00018bb0: 2023 2323 2046 6972 7374 2063 6f70 7920   ### First copy 
+00018bc0: 2077 6861 7465 7665 7220 6973 2069 6e20   whatever is in 
+00018bd0: 7468 6174 2066 6965 6c64 2073 6f20 7765  that field so we
+00018be0: 2063 616e 2073 6176 6520 6974 2066 6f72   can save it for
+00018bf0: 206c 6174 6572 2023 2323 0a20 2020 2023   later ###.    #
+00018c00: 2323 2052 656d 656d 6265 7220 7468 6174  ## Remember that
+00018c10: 2066 696c 6c6e 6120 6f6e 6c79 2077 6f72   fillna only wor
+00018c20: 6b73 2061 7420 6461 7461 6672 616d 6520  ks at dataframe 
+00018c30: 6c65 7665 6c21 2023 2323 0a20 2020 2064  level! ###.    d
+00018c40: 665b 5b66 6965 6c64 5d5d 203d 2064 665b  f[[field]] = df[
+00018c50: 5b66 6965 6c64 5d5d 2e66 696c 6c6e 6128  [field]].fillna(
+00018c60: 6669 6c6c 6572 290a 2020 2020 6966 2061  filler).    if a
+00018c70: 6464 5f63 6f75 6e74 5f66 6965 6c64 3a0a  dd_count_field:.
+00018c80: 2020 2020 2020 2020 2323 2320 7468 6572          ### ther
+00018c90: 6520 7769 6c6c 2062 6520 6f6e 6520 6578  e will be one ex
+00018ca0: 7472 6120 6669 656c 6420 6372 6561 7465  tra field create
+00018cb0: 6420 7768 656e 2077 6520 636f 756e 7420  d when we count 
+00018cc0: 7468 6520 6e75 6d62 6572 206f 6620 636f  the number of co
+00018cd0: 6e74 656e 7473 2069 6e20 6561 6368 2066  ntents in each f
+00018ce0: 6965 6c64 2023 2323 0a20 2020 2020 2020  ield ###.       
+00018cf0: 206d 6178 5f74 6869 6e67 7320 3d20 6466   max_things = df
+00018d00: 5b66 6965 6c64 5d2e 6d61 7028 6c61 6d62  [field].map(lamb
+00018d10: 6461 2078 3a20 6c65 6e28 782e 7370 6c69  da x: len(x.spli
+00018d20: 7428 7370 6c69 7474 6572 2929 292e 6d61  t(splitter))).ma
+00018d30: 7828 2920 2b20 310a 2020 2020 656c 7365  x() + 1.    else
+00018d40: 3a0a 2020 2020 2020 2020 6d61 785f 7468  :.        max_th
+00018d50: 696e 6773 203d 2064 665b 6669 656c 645d  ings = df[field]
+00018d60: 2e6d 6170 286c 616d 6264 6120 783a 206c  .map(lambda x: l
+00018d70: 656e 2878 2e73 706c 6974 2873 706c 6974  en(x.split(split
+00018d80: 7465 7229 2929 2e6d 6178 2829 0a20 2020  ter))).max().   
+00018d90: 2069 6620 6c65 6e28 6e65 775f 6e61 6d65   if len(new_name
+00018da0: 735f 6c69 7374 2920 3d3d 2030 3a0a 2020  s_list) == 0:.  
+00018db0: 2020 2020 2020 7072 696e 7428 2720 2020        print('   
+00018dc0: 204d 6178 2e20 636f 6c75 6d6e 7320 6372   Max. columns cr
+00018dd0: 6561 7465 6420 6279 2073 706c 6974 7469  eated by splitti
+00018de0: 6e67 2025 7320 6669 656c 6420 6973 2025  ng %s field is %
+00018df0: 642e 2720 2528 0a20 2020 2020 2020 2020  d.' %(.         
+00018e00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018e10: 2020 2066 6965 6c64 2c6d 6178 5f74 6869     field,max_thi
+00018e20: 6e67 7329 290a 2020 2020 656c 7365 3a0a  ngs)).    else:.
+00018e30: 2020 2020 2020 2020 6966 206e 6f74 206d          if not m
+00018e40: 6178 5f74 6869 6e67 7320 3d3d 206c 656e  ax_things == len
+00018e50: 286e 6577 5f6e 616d 6573 5f6c 6973 7429  (new_names_list)
+00018e60: 3a0a 2020 2020 2020 2020 2020 2020 7072  :.            pr
+00018e70: 696e 7428 2222 2220 2020 204d 6178 2e20  int("""    Max. 
+00018e80: 636f 6c75 6d6e 7320 6372 6561 7465 6420  columns created 
+00018e90: 6279 2073 706c 6974 7469 6e67 2025 7320  by splitting %s 
+00018ea0: 6669 656c 6420 6973 2025 6420 6275 7420  field is %d but 
+00018eb0: 796f 7520 6861 7665 2067 6976 656e 2025  you have given %
+00018ec0: 640a 2020 2020 2020 2020 2020 2020 2020  d.              
+00018ed0: 2020 2020 2020 2020 2020 2020 2020 7661                va
+00018ee0: 7269 6162 6c65 206e 616d 6573 206f 6e6c  riable names onl
+00018ef0: 792e 2053 656c 6563 7469 6e67 2066 6972  y. Selecting fir
+00018f00: 7374 2025 6422 2222 2025 280a 2020 2020  st %d""" %(.    
+00018f10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00018f20: 2020 2020 6669 656c 642c 6d61 785f 7468      field,max_th
+00018f30: 696e 6773 2c6c 656e 286e 6577 5f6e 616d  ings,len(new_nam
+00018f40: 6573 5f6c 6973 7429 2c6c 656e 286e 6577  es_list),len(new
+00018f50: 5f6e 616d 6573 5f6c 6973 7429 2929 0a20  _names_list))). 
+00018f60: 2020 2023 2323 2054 6869 7320 6372 6561     ### This crea
+00018f70: 7465 7320 6120 6e65 7720 6669 656c 6420  tes a new field 
+00018f80: 7468 6174 2063 6f75 6e74 7320 7468 6520  that counts the 
+00018f90: 6e75 6d62 6572 206f 6620 7468 696e 6773  number of things
+00018fa0: 2074 6861 7420 6172 6520 696e 2074 6861   that are in tha
+00018fb0: 7420 6669 656c 642e 0a20 2020 2069 6620  t field..    if 
+00018fc0: 6164 645f 636f 756e 745f 6669 656c 643a  add_count_field:
+00018fd0: 0a20 2020 2020 2020 2023 2323 2320 7468  .        #### th
+00018fe0: 6973 2063 6f75 6e74 7320 7468 6520 6e75  is counts the nu
+00018ff0: 6d62 6572 206f 6620 636f 6e74 656e 7473  mber of contents
+00019000: 2061 6674 6572 2073 706c 6974 7469 6e67   after splitting
+00019010: 2065 6163 6820 726f 7720 7768 6963 6820   each row which 
+00019020: 7661 7269 6573 2e20 4865 6e63 6520 6974  varies. Hence it
+00019030: 2068 656c 7073 2e0a 2020 2020 2020 2020   helps..        
+00019040: 6e75 6d5f 7072 6f64 7563 7473 5f76 6965  num_products_vie
+00019050: 7765 6420 3d20 2743 6f6e 7465 6e74 5f43  wed = 'Content_C
+00019060: 6f75 6e74 5f69 6e5f 272b 6669 656c 640a  ount_in_'+field.
+00019070: 2020 2020 2020 2020 6466 5b6e 756d 5f70          df[num_p
+00019080: 726f 6475 6374 735f 7669 6577 6564 5d20  roducts_viewed] 
+00019090: 3d20 6466 5b66 6965 6c64 5d2e 6d61 7028  = df[field].map(
+000190a0: 6c61 6d62 6461 2078 3a20 6c65 6e28 782e  lambda x: len(x.
+000190b0: 7370 6c69 7428 7370 6c69 7474 6572 2929  split(splitter))
+000190c0: 292e 7661 6c75 6573 0a20 2020 2023 2323  ).values.    ###
+000190d0: 2043 6c65 616e 2075 7020 7468 6520 6669   Clean up the fi
+000190e0: 656c 6420 7375 6368 2074 6861 7420 6974  eld such that it
+000190f0: 2068 6173 2074 6865 2072 6967 6874 206e   has the right n
+00019100: 756d 6265 7220 6f66 2073 706c 6974 2063  umber of split c
+00019110: 6861 7273 206f 7468 6572 7769 7365 2061  hars otherwise a
+00019120: 6464 2074 6f20 6974 0a20 2020 2023 2323  dd to it.    ###
+00019130: 2054 6869 7320 6669 6c6c 7320 7570 2074   This fills up t
+00019140: 6865 2066 6965 6c64 2077 6974 6820 656d  he field with em
+00019150: 7074 7920 7374 7269 6e67 7320 6265 7477  pty strings betw
+00019160: 6565 6e20 6561 6368 2073 706c 6974 7465  een each splitte
+00019170: 722e 2059 6f75 2063 616e 2774 2064 6f20  r. You can't do 
+00019180: 6d75 6368 2061 626f 7574 2069 742e 0a20  much about it.. 
+00019190: 2020 2023 2323 2320 4c65 6176 6520 7468     #### Leave th
+000191a0: 6973 2061 7320 6974 2069 732e 2049 7420  is as it is. It 
+000191b0: 6973 206e 6f74 2073 6f6d 6574 6869 6e67  is not something
+000191c0: 2079 6f75 2063 616e 2064 6f20 7269 6768   you can do righ
+000191d0: 7420 6e6f 772e 2049 7420 776f 726b 732e  t now. It works.
+000191e0: 0a20 2020 2066 696c 6c5f 7374 7269 6e67  .    fill_string
+000191f0: 203d 2073 706c 6974 7465 7220 2b20 6669   = splitter + fi
+00019200: 6c6c 6572 0a20 2020 2064 665b 6669 656c  ller.    df[fiel
+00019210: 645d 203d 2064 665b 6669 656c 645d 2e6d  d] = df[field].m
+00019220: 6170 286c 616d 6264 6120 783a 2078 2b66  ap(lambda x: x+f
+00019230: 696c 6c5f 7374 7269 6e67 2a28 6d61 785f  ill_string*(max_
+00019240: 7468 696e 6773 2d6c 656e 2878 2e73 706c  things-len(x.spl
+00019250: 6974 2873 706c 6974 7465 7229 2929 2069  it(splitter))) i
+00019260: 6620 6c65 6e28 0a20 2020 2020 2020 2020  f len(.         
+00019270: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00019280: 2020 2020 2020 2020 2020 2078 2e73 706c             x.spl
+00019290: 6974 2873 706c 6974 7465 7229 2920 3c20  it(splitter)) < 
+000192a0: 6d61 785f 7468 696e 6773 2065 6c73 6520  max_things else 
+000192b0: 7829 0a20 2020 2023 2323 2323 2320 4e6f  x).    ###### No
+000192c0: 7720 796f 7520 6372 6561 7465 206e 6577  w you create new
+000192d0: 2066 6965 6c64 7320 6279 2073 706c 6974   fields by split
+000192e0: 2074 6865 206f 6e65 206c 6172 6765 2066   the one large f
+000192f0: 6965 6c64 2023 2323 2323 2323 230a 2020  ield ########.  
+00019300: 2020 6966 2069 7369 6e73 7461 6e63 6528    if isinstance(
+00019310: 6e65 775f 6e61 6d65 735f 6c69 7374 2c20  new_names_list, 
+00019320: 7374 7229 3a0a 2020 2020 2020 2020 6966  str):.        if
+00019330: 206e 6577 5f6e 616d 6573 5f6c 6973 7420   new_names_list 
+00019340: 3d3d 2027 273a 0a20 2020 2020 2020 2020  == '':.         
+00019350: 2020 206e 6577 5f6e 616d 6573 5f6c 6973     new_names_lis
+00019360: 7420 3d20 5b66 6965 6c64 2b27 5f27 2b73  t = [field+'_'+s
+00019370: 7472 2869 2920 666f 7220 6920 696e 2072  tr(i) for i in r
+00019380: 616e 6765 2831 2c6d 6178 5f74 6869 6e67  ange(1,max_thing
+00019390: 732b 3129 5d0a 2020 2020 2020 2020 656c  s+1)].        el
+000193a0: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+000193b0: 6e65 775f 6e61 6d65 735f 6c69 7374 203d  new_names_list =
+000193c0: 205b 6e65 775f 6e61 6d65 735f 6c69 7374   [new_names_list
+000193d0: 5d0a 2020 2020 2323 2320 4669 7273 7420  ].    ### First 
+000193e0: 6669 6c6c 2065 6d70 7479 2073 7061 6365  fill empty space
+000193f0: 7320 6f72 204e 614e 7320 7769 7468 2066  s or NaNs with f
+00019400: 696c 6c65 7220 2323 230a 2020 2020 6466  iller ###.    df
+00019410: 2e6c 6f63 5b64 665b 6669 656c 645d 203d  .loc[df[field] =
+00019420: 3d20 7370 6c69 7474 6572 2c20 6669 656c  = splitter, fiel
+00019430: 645d 203d 2066 696c 6c65 720a 2020 2020  d] = filler.    
+00019440: 666f 7220 6920 696e 2072 616e 6765 286c  for i in range(l
+00019450: 656e 286e 6577 5f6e 616d 6573 5f6c 6973  en(new_names_lis
+00019460: 7429 293a 0a20 2020 2020 2020 2074 7279  t)):.        try
+00019470: 3a0a 2020 2020 2020 2020 2020 2020 6466  :.            df
+00019480: 5b6e 6577 5f6e 616d 6573 5f6c 6973 745b  [new_names_list[
+00019490: 695d 5d20 3d20 6466 5b66 6965 6c64 5d2e  i]] = df[field].
+000194a0: 6d61 7028 6c61 6d62 6461 2078 3a20 782e  map(lambda x: x.
+000194b0: 7370 6c69 7428 7370 6c69 7474 6572 295b  split(splitter)[
+000194c0: 695d 0a20 2020 2020 2020 2020 2020 2020  i].             
+000194d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000194e0: 2020 2020 2020 2020 2020 2020 2069 6620               if 
+000194f0: 7370 6c69 7474 6572 2069 6e20 7820 656c  splitter in x el
+00019500: 7365 2066 696c 6c65 7229 0a20 2020 2020  se filler).     
+00019510: 2020 2065 7863 6570 743a 0a20 2020 2020     except:.     
+00019520: 2020 2020 2020 2064 665b 6e65 775f 6e61         df[new_na
+00019530: 6d65 735f 6c69 7374 5b69 5d5d 203d 2066  mes_list[i]] = f
+00019540: 696c 6c65 720a 2020 2020 2020 2020 2020  iller.          
+00019550: 2020 636f 6e74 696e 7565 0a20 2020 2023    continue.    #
+00019560: 2323 2074 6865 7265 2069 7320 7265 616c  ## there is real
+00019570: 6c79 206e 6f74 6869 6e67 2079 6f75 2063  ly nothing you c
+00019580: 616e 2064 6f20 746f 2066 696c 6c20 7570  an do to fill up
+00019590: 2073 696e 6365 2074 6865 7920 6172 6520   since they are 
+000195a0: 6669 6c6c 6564 2077 6974 6820 656d 7074  filled with empt
+000195b0: 7920 7374 7269 6e67 732e 0a20 2020 2023  y strings..    #
+000195c0: 2323 2320 4c65 6176 6520 7468 6973 2061  ### Leave this a
+000195d0: 7320 6974 2069 732e 2049 7420 6973 206e  s it is. It is n
+000195e0: 6f74 2073 6f6d 6574 6869 6e67 2079 6f75  ot something you
+000195f0: 2063 616e 2064 6f20 7269 6768 7420 6e6f   can do right no
+00019600: 772e 2049 7420 776f 726b 732e 0a20 2020  w. It works..   
+00019610: 2064 665b 6669 656c 645d 203d 2064 665f   df[field] = df_
+00019620: 6669 656c 640a 2020 2020 7265 7475 726e  field.    return
+00019630: 2064 662c 206e 6577 5f6e 616d 6573 5f6c   df, new_names_l
+00019640: 6973 740a 2323 2323 2323 2323 2323 2323  ist.############
+00019650: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00019660: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00019670: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00019680: 2323 2323 2323 2323 2323 2323 2323 230a  ###############.
+00019690: 6465 6620 4645 5f61 6464 5f67 726f 7570  def FE_add_group
+000196a0: 6279 5f66 6561 7475 7265 735f 6167 6772  by_features_aggr
+000196b0: 6567 6174 6564 5f74 6f5f 6461 7461 6672  egated_to_datafr
+000196c0: 616d 6528 7472 6169 6e2c 0a20 2020 2020  ame(train,.     
+000196d0: 2020 2020 2020 2020 2020 2020 2020 2061                 a
+000196e0: 6767 5f74 7970 6573 2c20 2067 726f 7570  gg_types,  group
+000196f0: 6279 5f63 6f6c 756d 6e73 2c20 6967 6e6f  by_columns, igno
+00019700: 7265 5f76 6172 6961 626c 6573 2c20 7465  re_variables, te
+00019710: 7374 3d22 2229 3a0a 2020 2020 2222 220a  st=""):.    """.
+00019720: 2020 2020 4645 2073 7461 6e64 7320 666f      FE stands fo
+00019730: 7220 4665 6174 7572 6520 456e 6769 6e65  r Feature Engine
+00019740: 6572 696e 672e 2054 6869 7320 6675 6e63  ering. This func
+00019750: 7469 6f6e 2070 6572 666f 726d 7320 6665  tion performs fe
+00019760: 6174 7572 6520 656e 6769 6e65 6572 696e  ature engineerin
+00019770: 6720 6f6e 2064 6174 612e 0a20 2020 2023  g on data..    #
+00019780: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00019790: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000197a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000197b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000197c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000197d0: 2323 2323 230a 2020 2020 2323 2320 2020  #####.    ###   
+000197e0: 5468 6973 2066 756e 6374 696f 6e20 6973  This function is
+000197f0: 2061 2076 6572 7920 6661 7374 2066 756e   a very fast fun
+00019800: 6374 696f 6e20 7468 6174 2077 696c 6c20  ction that will 
+00019810: 636f 6d70 7574 6520 6167 6772 6567 6174  compute aggregat
+00019820: 6573 2066 6f72 206e 756d 6572 6963 730a  es for numerics.
+00019830: 2020 2020 2323 2320 2020 4974 2072 6574      ###   It ret
+00019840: 7572 6e73 206f 7269 6769 6e61 6c20 6461  urns original da
+00019850: 7461 6672 616d 6520 7769 7468 2061 6464  taframe with add
+00019860: 6564 2066 6561 7475 7265 7320 6672 6f6d  ed features from
+00019870: 206e 756d 6572 6963 2076 6172 6961 626c   numeric variabl
+00019880: 6573 2061 6767 7265 6761 7465 640a 2020  es aggregated.  
+00019890: 2020 2323 2320 2020 5768 6174 2064 6f20    ###   What do 
+000198a0: 796f 7520 6d65 616e 2061 6767 7265 6761  you mean aggrega
+000198b0: 7465 3f20 6167 6772 6567 6174 6573 2063  te? aggregates c
+000198c0: 616e 2062 6520 2263 6f75 6e74 2c20 226d  an be "count, "m
+000198d0: 6561 6e22 2c20 226d 6564 6961 6e22 2c20  ean", "median", 
+000198e0: 6574 632e 0a20 2020 2023 2323 2020 2057  etc..    ###   W
+000198f0: 6861 7420 646f 2079 6f75 2061 6767 7265  hat do you aggre
+00019900: 6772 6174 653f 2061 6c6c 206e 756d 6572  grate? all numer
+00019910: 6963 2063 6f6c 756d 6e73 2069 6e20 796f  ic columns in yo
+00019920: 7572 2064 6174 610a 2020 2020 2323 2320  ur data.    ### 
+00019930: 2020 5768 6174 2064 6f20 796f 7520 6772    What do you gr
+00019940: 6f75 7062 793f 206f 6e65 2067 726f 7570  oupby? one group
+00019950: 6279 2063 6f6c 756d 6e20 6174 2061 2074  by column at a t
+00019960: 696d 6520 6f72 206d 756c 7469 706c 6520  ime or multiple 
+00019970: 636f 6c75 6d6e 7320 6f6e 6520 6279 206f  columns one by o
+00019980: 6e65 0a20 2020 2023 2323 2020 2020 202d  ne.    ###     -
+00019990: 2d20 6966 2079 6f75 2067 6976 6520 6974  - if you give it
+000199a0: 2061 206c 6973 7420 6f66 2063 6f6c 756d   a list of colum
+000199b0: 6e73 2c20 6974 2077 696c 6c20 6578 6563  ns, it will exec
+000199c0: 7574 6520 7468 6520 6772 6f75 7069 6e67  ute the grouping
+000199d0: 206f 6e65 2062 7920 6f6e 650a 2020 2020   one by one.    
+000199e0: 2323 2320 2020 5768 6174 2069 7320 7468  ###   What is th
+000199f0: 6520 6967 6e6f 7265 5f76 6172 6961 626c  e ignore_variabl
+00019a00: 6573 2066 6f72 3f20 6974 2077 696c 6c20  es for? it will 
+00019a10: 6967 6e6f 7265 2074 6865 7365 2076 6172  ignore these var
+00019a20: 6961 626c 6573 2066 726f 6d20 6772 6f75  iables from grou
+00019a30: 7069 6e67 2e0a 2020 2020 2323 2320 2020  ping..    ###   
+00019a40: 4d61 6b65 2073 7572 6520 746f 2072 6564  Make sure to red
+00019a50: 7563 6520 636f 7272 656c 6174 6564 2066  uce correlated f
+00019a60: 6561 7475 7265 7320 7573 696e 6720 4645  eatures using FE
+00019a70: 5f72 656d 6f76 655f 7661 7269 6162 6c65  _remove_variable
+00019a80: 735f 7573 696e 675f 5355 4c4f 565f 6d65  s_using_SULOV_me
+00019a90: 7468 6f64 2829 0a20 2020 2023 2323 2323  thod().    #####
+00019aa0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00019ab0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00019ac0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00019ad0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00019ae0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00019af0: 230a 2020 2020 2323 2320 496e 7075 7473  #.    ### Inputs
+00019b00: 3a0a 2020 2020 2323 2320 2020 7472 6169  :.    ###   trai
+00019b10: 6e3a 204a 7573 7420 7365 6e74 2069 6e20  n: Just sent in 
+00019b20: 7468 6520 6461 7461 2066 7261 6d65 2077  the data frame w
+00019b30: 6865 7265 2079 6f75 2077 616e 7420 6167  here you want ag
+00019b40: 6772 6567 6174 6564 2066 6561 7475 7265  gregated feature
+00019b50: 7320 666f 722e 0a20 2020 2023 2323 2020  s for..    ###  
+00019b60: 2061 6767 5f74 7970 6573 3a20 6c69 7374   agg_types: list
+00019b70: 206f 6620 636f 6d70 7574 6174 696f 6e61   of computationa
+00019b80: 6c20 7479 7065 733a 2027 6d65 616e 272c  l types: 'mean',
+00019b90: 276d 6564 6961 6e27 2c27 636f 756e 7427  'median','count'
+00019ba0: 2c20 0a20 2020 2023 2323 2020 2020 2020  , .    ###      
+00019bb0: 2020 2020 2020 2020 2020 2020 2020 2027                 '
+00019bc0: 6d61 7827 2c20 276d 696e 272c 2027 7375  max', 'min', 'su
+00019bd0: 6d27 2c20 6574 632e 0a20 2020 2023 2323  m', etc..    ###
+00019be0: 2020 2020 2020 2020 204f 6e65 2063 6176           One cav
+00019bf0: 6561 743a 2074 6865 7365 2061 6767 5f74  eat: these agg_t
+00019c00: 7970 6573 206d 7573 7420 6265 2066 6f75  ypes must be fou
+00019c10: 6e64 2069 6e20 7468 6520 666f 6c6c 6f77  nd in the follow
+00019c20: 696e 6720 6167 675f 6675 6e63 206f 6620  ing agg_func of 
+00019c30: 0a20 2020 2023 2323 2020 2020 2020 2020  .    ###        
+00019c40: 2020 2020 2020 2020 2020 206e 756d 7079             numpy
+00019c50: 206f 7220 7061 6e64 6173 2067 726f 7570   or pandas group
+00019c60: 6279 2073 7461 7465 6d65 6e74 2e0a 2020  by statement..  
+00019c70: 2020 2323 2320 2020 2020 2020 2020 4c69    ###         Li
+00019c80: 7374 206f 6620 6167 6772 6567 6174 6573  st of aggregates
+00019c90: 2061 7661 696c 6162 6c65 3a20 7b27 636f   available: {'co
+00019ca0: 756e 7427 2c27 7375 6d27 2c27 6d65 616e  unt','sum','mean
+00019cb0: 272c 276d 6164 272c 276d 6564 6961 6e27  ','mad','median'
+00019cc0: 2c27 6d69 6e27 2c27 6d61 7827 2c0a 2020  ,'min','max',.  
+00019cd0: 2020 2323 2320 2020 2020 2020 2020 2020    ###           
+00019ce0: 2020 2020 276d 6f64 6527 2c27 6162 7327      'mode','abs'
+00019cf0: 2c20 2770 726f 6427 2c27 7374 6427 2c27  , 'prod','std','
+00019d00: 7661 7227 2c27 7365 6d27 2c27 736b 6577  var','sem','skew
+00019d10: 272c 276b 7572 7427 2c0a 2020 2020 2323  ','kurt',.    ##
+00019d20: 2320 2020 2020 2020 2020 2020 2020 2020  #               
+00019d30: 2027 7175 616e 7469 6c65 272c 2763 756d   'quantile','cum
+00019d40: 7375 6d27 2c27 6375 6d70 726f 6427 2c27  sum','cumprod','
+00019d50: 6375 6d6d 6178 272c 2763 756d 6d69 6e27  cummax','cummin'
+00019d60: 7d0a 2020 2020 2323 2320 2020 6772 6f75  }.    ###   grou
+00019d70: 7062 795f 636f 6c75 6d6e 733a 2063 616e  pby_columns: can
+00019d80: 2062 6520 6120 7374 7269 6e67 2072 6570   be a string rep
+00019d90: 7265 7365 6e74 696e 6720 6120 7369 6e67  resenting a sing
+00019da0: 6c65 2063 6f6c 756d 6e20 6f72 2061 206c  le column or a l
+00019db0: 6973 7420 6f66 200a 2020 2020 2323 2320  ist of .    ### 
+00019dc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00019dd0: 2020 2020 6d75 6c74 6970 6c65 2063 6f6c      multiple col
+00019de0: 756d 6e73 0a20 2020 2023 2323 2020 2020  umns.    ###    
+00019df0: 2020 2020 2020 2020 2020 202d 2069 7420             - it 
+00019e00: 7769 6c6c 2067 726f 7570 6279 2061 6c6c  will groupby all
+00019e10: 2074 6865 206e 756d 6572 6963 2066 6561   the numeric fea
+00019e20: 7475 7265 7320 7573 696e 6720 6f6e 6520  tures using one 
+00019e30: 6772 6f75 7062 7920 636f 6c75 6d6e 200a  groupby column .
+00019e40: 2020 2020 2323 2320 2020 2020 2020 2020      ###         
+00019e50: 2020 2020 2020 2020 2020 2061 7420 6120             at a 
+00019e60: 7469 6d65 2069 6e20 6120 6c6f 6f70 2e0a  time in a loop..
+00019e70: 2020 2020 2323 2320 2020 6967 6e6f 7265      ###   ignore
+00019e80: 5f76 6172 6961 626c 6573 3a20 6c69 7374  _variables: list
+00019e90: 206f 6620 7661 7269 6162 6c65 7320 746f   of variables to
+00019ea0: 2069 676e 6f72 6520 616d 6f6e 6720 6e75   ignore among nu
+00019eb0: 6d65 7269 6320 7661 7269 6162 6c65 7320  meric variables 
+00019ec0: 696e 0a20 2020 2023 2323 2020 2020 2020  in.    ###      
+00019ed0: 2020 2020 2020 2020 2020 6461 7461 2073            data s
+00019ee0: 696e 6365 2074 6865 7920 6d61 7920 6265  ince they may be
+00019ef0: 2049 4420 7661 7269 6162 6c65 732e 0a20   ID variables.. 
+00019f00: 2020 2023 2323 204f 7574 7075 7473 3a0a     ### Outputs:.
+00019f10: 2020 2020 2323 2320 2020 2020 5265 7475      ###     Retu
+00019f20: 726e 7320 7468 6520 6f72 6967 696e 616c  rns the original
+00019f30: 2064 6174 6166 7261 6d65 2077 6974 6820   dataframe with 
+00019f40: 6164 6469 7469 6f6e 616c 2066 6561 7475  additional featu
+00019f50: 7265 7320 6372 6561 7465 6420 6279 2074  res created by t
+00019f60: 6869 7320 6675 6e63 7469 6f6e 2e0a 2020  his function..  
+00019f70: 2020 2323 2323 2323 2323 2323 2323 2323    ##############
+00019f80: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00019f90: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00019fa0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00019fb0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00019fc0: 2323 2323 2323 2323 0a20 2020 2022 2222  ########.    """
+00019fd0: 0a20 2020 2074 7261 696e 7820 3d20 636f  .    trainx = co
+00019fe0: 7079 2e64 6565 7063 6f70 7928 7472 6169  py.deepcopy(trai
+00019ff0: 6e29 0a20 2020 2074 6573 7478 203d 2063  n).    testx = c
+0001a000: 6f70 792e 6465 6570 636f 7079 2874 6573  opy.deepcopy(tes
+0001a010: 7429 0a20 2020 2069 6620 6973 696e 7374  t).    if isinst
+0001a020: 616e 6365 2867 726f 7570 6279 5f63 6f6c  ance(groupby_col
+0001a030: 756d 6e73 2c20 7374 7229 3a0a 2020 2020  umns, str):.    
+0001a040: 2020 2020 6772 6f75 7062 795f 636f 6c75      groupby_colu
+0001a050: 6d6e 7320 3d20 5b67 726f 7570 6279 5f63  mns = [groupby_c
+0001a060: 6f6c 756d 6e73 5d0a 2020 2020 6e75 6d65  olumns].    nume
+0001a070: 7269 6373 203d 2074 7261 696e 782e 7365  rics = trainx.se
+0001a080: 6c65 6374 5f64 7479 7065 7328 696e 636c  lect_dtypes(incl
+0001a090: 7564 653d 276e 756d 6265 7227 292e 636f  ude='number').co
+0001a0a0: 6c75 6d6e 732e 746f 6c69 7374 2829 0a20  lumns.tolist(). 
+0001a0b0: 2020 206e 756d 6572 6963 7320 3d20 5b78     numerics = [x
+0001a0c0: 2066 6f72 2078 2069 6e20 6e75 6d65 7269   for x in numeri
+0001a0d0: 6373 2069 6620 7820 6e6f 7420 696e 2069  cs if x not in i
+0001a0e0: 676e 6f72 655f 7661 7269 6162 6c65 735d  gnore_variables]
+0001a0f0: 0a20 2020 204d 4742 203d 2047 726f 7570  .    MGB = Group
+0001a100: 6279 5f41 6767 7265 6761 746f 7228 6361  by_Aggregator(ca
+0001a110: 7465 676f 7269 6361 6c73 3d67 726f 7570  tegoricals=group
+0001a120: 6279 5f63 6f6c 756d 6e73 2c0a 2020 2020  by_columns,.    
+0001a130: 2020 2020 2020 2020 6167 6772 6567 6174          aggregat
+0001a140: 6573 3d61 6767 5f74 7970 6573 2c20 6e75  es=agg_types, nu
+0001a150: 6d65 7269 6373 3d6e 756d 6572 6963 7329  merics=numerics)
+0001a160: 0a20 2020 2074 7261 696e 5f63 6f70 7920  .    train_copy 
+0001a170: 3d20 4d47 422e 6669 745f 7472 616e 7366  = MGB.fit_transf
+0001a180: 6f72 6d28 7472 6169 6e78 290a 2020 2020  orm(trainx).    
+0001a190: 6966 2069 7369 6e73 7461 6e63 6528 7465  if isinstance(te
+0001a1a0: 7374 782c 2073 7472 2920 6f72 2074 6573  stx, str) or tes
+0001a1b0: 7478 2069 7320 4e6f 6e65 3a0a 2020 2020  tx is None:.    
+0001a1c0: 2020 2020 7465 7374 5f63 6f70 7920 3d20      test_copy = 
+0001a1d0: 7465 7374 780a 2020 2020 656c 7365 3a0a  testx.    else:.
+0001a1e0: 2020 2020 2020 2020 7465 7374 5f63 6f70          test_cop
+0001a1f0: 7920 3d20 4d47 422e 7472 616e 7366 6f72  y = MGB.transfor
+0001a200: 6d28 7465 7374 7829 0a20 2020 2023 2323  m(testx).    ###
+0001a210: 2072 6574 7572 6e20 7468 6520 6461 7461   return the data
+0001a220: 6672 616d 6573 2023 2323 2323 2323 2323  frames #########
+0001a230: 2323 0a20 2020 2072 6574 7572 6e20 7472  ##.    return tr
+0001a240: 6169 6e5f 636f 7079 2c20 7465 7374 5f63  ain_copy, test_c
+0001a250: 6f70 790a 2323 2323 2323 2323 2323 2323  opy.############
+0001a260: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001a270: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001a280: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001a290: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001a2a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001a2b0: 2323 2323 2323 2323 230a 6465 6620 4645  #########.def FE
+0001a2c0: 5f63 6f6d 6269 6e65 5f72 6172 655f 6361  _combine_rare_ca
+0001a2d0: 7465 676f 7269 6573 2874 7261 696e 5f64  tegories(train_d
+0001a2e0: 662c 2063 6174 6567 6f72 6963 616c 5f66  f, categorical_f
+0001a2f0: 6561 7475 7265 732c 2074 6573 745f 6466  eatures, test_df
+0001a300: 3d22 2229 3a0a 2020 2020 2222 220a 2020  =""):.    """.  
+0001a310: 2020 496e 2074 6869 7320 6675 6e63 7469    In this functi
+0001a320: 6f6e 2c20 7765 2077 696c 6c20 7365 6c65  on, we will sele
+0001a330: 6374 2061 6c6c 2072 6172 6520 636c 6173  ct all rare clas
+0001a340: 7365 7320 6861 7669 6e67 2072 6570 7265  ses having repre
+0001a350: 7365 6e74 6174 696f 6e20 3c31 2520 6f66  sentation <1% of
+0001a360: 2070 6f70 756c 6174 696f 6e20 616e 640a   population and.
+0001a370: 2020 2020 6772 6f75 7020 7468 656d 2074      group them t
+0001a380: 6f67 6574 6865 7220 756e 6465 7220 6120  ogether under a 
+0001a390: 6e65 7720 6c61 6265 6c20 6361 6c6c 6564  new label called
+0001a3a0: 2027 5241 5245 272e 2057 6520 7769 6c6c   'RARE'. We will
+0001a3b0: 2061 7070 6c79 2074 6869 7320 6f6e 2074   apply this on t
+0001a3c0: 7261 696e 2061 6e64 2074 6573 7420 286f  rain and test (o
+0001a3d0: 7074 696f 6e61 6c29 0a20 2020 2022 2222  ptional).    """
+0001a3e0: 0a20 2020 2074 7261 696e 5f64 6620 3d20  .    train_df = 
+0001a3f0: 636f 7079 2e64 6565 7063 6f70 7928 7472  copy.deepcopy(tr
+0001a400: 6169 6e5f 6466 290a 2020 2020 7465 7374  ain_df).    test
+0001a410: 5f64 6620 3d20 636f 7079 2e64 6565 7063  _df = copy.deepc
+0001a420: 6f70 7928 7465 7374 5f64 6629 0a20 2020  opy(test_df).   
+0001a430: 2074 7261 696e 5f64 665b 6361 7465 676f   train_df[catego
+0001a440: 7269 6361 6c5f 6665 6174 7572 6573 5d20  rical_features] 
+0001a450: 3d20 7472 6169 6e5f 6466 5b63 6174 6567  = train_df[categ
+0001a460: 6f72 6963 616c 5f66 6561 7475 7265 735d  orical_features]
+0001a470: 2e61 7070 6c79 280a 2020 2020 2020 2020  .apply(.        
+0001a480: 2020 2020 6c61 6d62 6461 2078 3a20 782e      lambda x: x.
+0001a490: 6d61 736b 2878 2e6d 6170 2878 2e76 616c  mask(x.map(x.val
+0001a4a0: 7565 5f63 6f75 6e74 7328 2929 3c20 2830  ue_counts())< (0
+0001a4b0: 2e30 312a 7472 6169 6e5f 6466 2e73 6861  .01*train_df.sha
+0001a4c0: 7065 5b30 5d29 2c20 2752 4152 4527 2929  pe[0]), 'RARE'))
+0001a4d0: 0a20 2020 2066 6f72 2063 6f6c 2069 6e20  .    for col in 
+0001a4e0: 6361 7465 676f 7269 6361 6c5f 6665 6174  categorical_feat
+0001a4f0: 7572 6573 3a0a 2020 2020 2020 2020 7661  ures:.        va
+0001a500: 6c73 203d 206c 6973 7428 7472 6169 6e5f  ls = list(train_
+0001a510: 6466 5b63 6f6c 5d2e 756e 6971 7565 2829  df[col].unique()
+0001a520: 290a 2020 2020 2020 2020 6966 2069 7369  ).        if isi
+0001a530: 6e73 7461 6e63 6528 7465 7374 5f64 662c  nstance(test_df,
+0001a540: 2073 7472 2920 6f72 2074 6573 745f 6466   str) or test_df
+0001a550: 2069 7320 4e6f 6e65 3a0a 2020 2020 2020   is None:.      
+0001a560: 2020 2020 2020 7265 7475 726e 2074 7261        return tra
+0001a570: 696e 5f64 662c 2074 6573 745f 6466 0a20  in_df, test_df. 
+0001a580: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
+0001a590: 2020 2020 2020 2020 2074 6573 745f 6466           test_df
+0001a5a0: 5b63 6f6c 5d20 3d20 7465 7374 5f64 665b  [col] = test_df[
+0001a5b0: 636f 6c5d 2e61 7070 6c79 286c 616d 6264  col].apply(lambd
+0001a5c0: 6120 783a 2027 5241 5245 2720 6966 2078  a x: 'RARE' if x
+0001a5d0: 206e 6f74 2069 6e20 7661 6c73 2065 6c73   not in vals els
+0001a5e0: 6520 7829 0a20 2020 2020 2020 2020 2020  e x).           
+0001a5f0: 2072 6574 7572 6e20 7472 6169 6e5f 6466   return train_df
+0001a600: 2c20 7465 7374 5f64 660a 0a23 2323 2323  , test_df..#####
+0001a610: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001a620: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001a630: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001a640: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001a650: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001a660: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001a670: 0a64 6566 2046 455f 6765 745f 6c61 7465  .def FE_get_late
+0001a680: 7374 5f76 616c 7565 735f 6261 7365 645f  st_values_based_
+0001a690: 6f6e 5f64 6174 655f 636f 6c75 6d6e 2864  on_date_column(d
+0001a6a0: 6674 2c20 6964 5f63 6f6c 2c20 6461 7465  ft, id_col, date
+0001a6b0: 5f63 6f6c 2c20 636f 6c73 2c20 6173 6365  _col, cols, asce
+0001a6c0: 6e64 696e 673d 4661 6c73 6529 3a0a 2020  nding=False):.  
+0001a6d0: 2020 2222 220a 2020 2020 4645 206d 6561    """.    FE mea
+0001a6e0: 6e73 2046 4541 5455 5245 2045 4e47 494e  ns FEATURE ENGIN
+0001a6f0: 4545 5249 4e47 202d 2054 6861 7420 6d65  EERING - That me
+0001a700: 616e 7320 7468 6973 2066 756e 6374 696f  ans this functio
+0001a710: 6e20 7769 6c6c 2063 7265 6174 6520 6e65  n will create ne
+0001a720: 7720 6665 6174 7572 6573 0a20 2020 2023  w features.    #
+0001a730: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001a740: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001a750: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001a760: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001a770: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001a780: 2323 2323 230a 2020 2020 5468 6973 2066  #####.    This f
+0001a790: 756e 6374 696f 6e20 6765 7473 2079 6f75  unction gets you
+0001a7a0: 2074 6865 206c 6174 6573 7420 7661 6c75   the latest valu
+0001a7b0: 6573 206f 6620 7468 6520 636f 6c75 6d6e  es of the column
+0001a7c0: 7320 696e 2063 6f6c 7320 6672 6f6d 2061  s in cols from a
+0001a7d0: 2064 6174 6520 636f 6c75 6d6e 2064 6174   date column dat
+0001a7e0: 655f 636f 6c2e 0a0a 2020 2020 496e 7075  e_col...    Inpu
+0001a7f0: 7473 3a0a 2020 2020 6466 743a 2064 6174  ts:.    dft: dat
+0001a800: 6166 7261 6d65 2c20 7061 6e64 6173 0a20  aframe, pandas. 
+0001a810: 2020 2069 645f 636f 6c3a 2079 6f75 206e     id_col: you n
+0001a820: 6565 6420 746f 2070 726f 7669 6465 2061  eed to provide a
+0001a830: 6e20 4944 2063 6f6c 756d 6e20 746f 2067  n ID column to g
+0001a840: 726f 7570 6279 2074 6865 2063 6f6c 7320  roupby the cols 
+0001a850: 616e 6420 7468 656e 2073 6f72 7420 7468  and then sort th
+0001a860: 656d 2062 7920 6461 7465 5f63 6f6c 2e0a  em by date_col..
+0001a870: 2020 2020 6461 7465 5f63 6f6c 3a20 7468      date_col: th
+0001a880: 6973 206d 7573 7420 6265 2061 2076 616c  is must be a val
+0001a890: 6964 2070 616e 6461 7320 6461 7465 2d74  id pandas date-t
+0001a8a0: 696d 6520 636f 6c75 6d6e 2e20 4966 2069  ime column. If i
+0001a8b0: 7420 6973 2061 2073 7472 696e 6720 636f  t is a string co
+0001a8c0: 6c75 6d6e 2c0a 2020 2020 2020 2020 2020  lumn,.          
+0001a8d0: 206d 616b 6520 7375 7265 2079 6f75 2063   make sure you c
+0001a8e0: 6861 6e67 6520 6974 2074 6f20 6120 6461  hange it to a da
+0001a8f0: 7465 2d74 696d 6520 636f 6c75 6d6e 2e0a  te-time column..
+0001a900: 2020 2020 2020 2020 2020 4974 2073 6f72            It sor
+0001a910: 7473 2065 6163 6820 6772 6f75 7020 6279  ts each group by
+0001a920: 2074 6865 206c 6174 6573 7420 6461 7465   the latest date
+0001a930: 2028 6465 7363 656e 6469 6e67 2920 616e   (descending) an
+0001a940: 6420 7365 6c65 6374 7320 7468 6174 2074  d selects that t
+0001a950: 6f70 2072 6f77 2e0a 2020 2020 636f 6c73  op row..    cols
+0001a960: 3a20 7468 6573 6520 6172 6520 7468 6520  : these are the 
+0001a970: 6c69 7374 206f 6620 636f 6c75 6d6e 7320  list of columns 
+0001a980: 796f 7520 7761 6e74 2074 6865 6972 206c  you want their l
+0001a990: 6174 6573 7420 7661 6c75 6520 6261 7365  atest value base
+0001a9a0: 6420 6f6e 2074 6865 2064 6174 652d 636f  d on the date-co
+0001a9b0: 6c20 796f 7520 7370 6563 6966 792e 0a20  l you specify.. 
+0001a9c0: 2020 2020 2020 2020 5468 6573 6520 636f          These co
+0001a9d0: 6c73 2063 616e 2062 6520 616e 7920 7479  ls can be any ty
+0001a9e0: 7065 206f 6620 636f 6c75 6d6e 3a20 6e75  pe of column: nu
+0001a9f0: 6d65 7269 6320 6f72 2073 7472 696e 672e  meric or string.
+0001aa00: 0a20 2020 2061 7363 656e 6469 6e67 3a20  .    ascending: 
+0001aa10: 5365 7420 7468 6973 2061 7320 5472 7565  Set this as True
+0001aa20: 206f 7220 4661 6c73 6520 6465 7065 6e64   or False depend
+0001aa30: 696e 6720 6f6e 2077 6865 7468 6572 2079  ing on whether y
+0001aa40: 6f75 2077 616e 7420 736d 616c 6c65 7374  ou want smallest
+0001aa50: 206f 7220 6269 6767 6573 7420 6f6e 2074   or biggest on t
+0001aa60: 6f70 2e0a 0a20 2020 204f 7574 7075 7473  op...    Outputs
+0001aa70: 3a0a 2020 2020 5265 7475 726e 7320 6120  :.    Returns a 
+0001aa80: 6461 7461 6672 616d 6520 7468 6174 2069  dataframe that i
+0001aa90: 7320 736d 616c 6c65 7220 7468 616e 2069  s smaller than i
+0001aaa0: 6e70 7574 2064 6174 6166 7261 6d65 2073  nput dataframe s
+0001aab0: 696e 6365 2069 7420 6772 6f75 7073 2063  ince it groups c
+0001aac0: 6f6c 7320 6279 2049 445f 636f 6c75 6d6e  ols by ID_column
+0001aad0: 2e0a 2020 2020 2323 2323 2323 2323 2323  ..    ##########
+0001aae0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001aaf0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001ab00: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001ab10: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001ab20: 2323 2323 2323 2323 2323 2323 0a20 2020  ############.   
+0001ab30: 2042 6577 6172 6521 2059 6f75 2077 696c   Beware! You wil
+0001ab40: 6c20 6765 7420 6120 6461 7461 6672 616d  l get a datafram
+0001ab50: 6520 7468 6174 2068 6173 2066 6577 6572  e that has fewer
+0001ab60: 2063 6f6c 7320 7468 616e 2079 6f75 7220   cols than your 
+0001ab70: 696e 7075 7420 7769 7468 2066 6577 6572  input with fewer
+0001ab80: 2072 6f77 7320 7468 616e 2069 6e70 7574   rows than input
+0001ab90: 2e0a 2020 2020 2222 220a 2020 2020 6466  ..    """.    df
+0001aba0: 7420 3d20 636f 7079 2e64 6565 7063 6f70  t = copy.deepcop
+0001abb0: 7928 6466 7429 0a20 2020 2074 7279 3a0a  y(dft).    try:.
+0001abc0: 2020 2020 2020 2020 6966 2069 7369 6e73          if isins
+0001abd0: 7461 6e63 6528 636f 6c73 2c20 7374 7229  tance(cols, str)
+0001abe0: 3a0a 2020 2020 2020 2020 2020 2020 636f  :.            co
+0001abf0: 6c73 203d 205b 636f 6c73 5d0a 2020 2020  ls = [cols].    
+0001ac00: 2020 2020 7472 6169 6e5f 6164 6420 3d20      train_add = 
+0001ac10: 6466 742e 6772 6f75 7062 7928 5b69 645f  dft.groupby([id_
+0001ac20: 636f 6c5d 2c20 736f 7274 3d46 616c 7365  col], sort=False
+0001ac30: 292e 6170 706c 7928 6c61 6d62 6461 2078  ).apply(lambda x
+0001ac40: 3a20 782e 736f 7274 5f76 616c 7565 7328  : x.sort_values(
+0001ac50: 5b64 6174 655f 636f 6c5d 2c0a 2020 2020  [date_col],.    
+0001ac60: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001ac70: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001ac80: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001ac90: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001aca0: 2020 2020 6173 6365 6e64 696e 673d 6173      ascending=as
+0001acb0: 6365 6e64 696e 6729 290a 2020 2020 2020  cending)).      
+0001acc0: 2020 7472 6169 6e5f 6164 6420 3d20 7472    train_add = tr
+0001acd0: 6169 6e5f 6164 645b 636f 6c73 5d2e 7265  ain_add[cols].re
+0001ace0: 7365 745f 696e 6465 7828 290a 2020 2020  set_index().    
+0001acf0: 2020 2020 7472 6169 6e5f 6164 6420 3d20      train_add = 
+0001ad00: 7472 6169 6e5f 6164 642e 6772 6f75 7062  train_add.groupb
+0001ad10: 7928 6964 5f63 6f6c 292e 6865 6164 2831  y(id_col).head(1
+0001ad20: 292e 7265 7365 745f 696e 6465 7828 6472  ).reset_index(dr
+0001ad30: 6f70 3d54 7275 6529 2e64 726f 7028 276c  op=True).drop('l
+0001ad40: 6576 656c 5f31 272c 6178 6973 3d31 290a  evel_1',axis=1).
+0001ad50: 2020 2020 6578 6365 7074 3a0a 2020 2020      except:.    
+0001ad60: 2020 2020 7072 696e 7428 2720 2020 2045      print('    E
+0001ad70: 7272 6f72 2069 6e20 6765 7474 696e 6720  rror in getting 
+0001ad80: 6c61 7465 7374 2073 7461 7475 7320 6f66  latest status of
+0001ad90: 2063 6f6c 756d 6e73 2062 6173 6564 206f   columns based o
+0001ada0: 6e20 2573 2e20 5265 7475 726e 696e 672e  n %s. Returning.
+0001adb0: 2e2e 2720 2564 6174 655f 636f 6c29 0a20  ..' %date_col). 
+0001adc0: 2020 2020 2020 2072 6574 7572 6e20 6466         return df
+0001add0: 740a 2020 2020 7265 7475 726e 2074 7261  t.    return tra
+0001ade0: 696e 5f61 6464 0a23 2323 2323 2323 2323  in_add.#########
+0001adf0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001ae00: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001ae10: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001ae20: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001ae30: 2323 2323 2323 2323 0a66 726f 6d20 6675  ########.from fu
+0001ae40: 6e63 746f 6f6c 7320 696d 706f 7274 2072  nctools import r
+0001ae50: 6564 7563 650a 6465 6620 4645 5f73 706c  educe.def FE_spl
+0001ae60: 6974 5f61 6464 5f63 6f6c 756d 6e28 6466  it_add_column(df
+0001ae70: 742c 2063 6f6c 2c20 7370 6c69 7474 6572  t, col, splitter
+0001ae80: 3d27 2c27 2c20 6163 7469 6f6e 3d27 6164  =',', action='ad
+0001ae90: 6427 293a 0a20 2020 2022 2222 0a20 2020  d'):.    """.   
+0001aea0: 2046 4520 6d65 616e 7320 4645 4154 5552   FE means FEATUR
+0001aeb0: 4520 454e 4749 4e45 4552 494e 4720 2d20  E ENGINEERING - 
+0001aec0: 5468 6174 206d 6561 6e73 2074 6869 7320  That means this 
+0001aed0: 6675 6e63 7469 6f6e 2077 696c 6c20 6372  function will cr
+0001aee0: 6561 7465 206e 6577 2066 6561 7475 7265  eate new feature
+0001aef0: 730a 2020 2020 2323 2323 2323 2323 2323  s.    ##########
+0001af00: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001af10: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001af20: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001af30: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001af40: 2323 2323 2323 2323 2323 2323 0a20 2020  ############.   
+0001af50: 2054 6869 7320 6675 6e63 7469 6f6e 2077   This function w
+0001af60: 696c 6c20 7370 6c69 7420 6120 636f 6c75  ill split a colu
+0001af70: 6d6e 2773 2076 616c 7565 7320 6261 7365  mn's values base
+0001af80: 6420 6f6e 2061 2073 706c 6974 7465 7220  d on a splitter 
+0001af90: 796f 7520 7370 6563 6966 7920 616e 640a  you specify and.
+0001afa0: 2020 2020 7769 6c6c 2065 6974 6865 7220      will either 
+0001afb0: 6164 6420 7468 656d 206f 7220 636f 6e63  add them or conc
+0001afc0: 6174 656e 6174 6520 7468 656d 2061 7320  atenate them as 
+0001afd0: 796f 7520 7370 6563 6966 7920 696e 2074  you specify in t
+0001afe0: 6865 2061 6374 696f 6e20 6172 6775 6d65  he action argume
+0001aff0: 6e74 2e0a 0a20 2020 2049 6e70 7574 733a  nt...    Inputs:
+0001b000: 0a20 2020 2064 6674 3a20 7061 6e64 6173  .    dft: pandas
+0001b010: 2044 6174 6146 7261 6d65 0a20 2020 2063   DataFrame.    c
+0001b020: 6f6c 3a20 6e61 6d65 206f 6620 636f 6c75  ol: name of colu
+0001b030: 6d6e 2074 6861 7420 796f 7520 7761 6e74  mn that you want
+0001b040: 2074 6f20 7370 6c69 7420 696e 746f 2069   to split into i
+0001b050: 7473 2063 6f6e 7374 6974 7565 6e74 2070  ts constituent p
+0001b060: 6172 7473 2e20 4974 206d 7573 7420 6265  arts. It must be
+0001b070: 2061 2073 7472 696e 6720 636f 6c75 6d6e   a string column
+0001b080: 2e0a 2020 2020 7370 6c69 7474 6572 3a20  ..    splitter: 
+0001b090: 7370 6c69 7474 6572 2063 616e 2062 6520  splitter can be 
+0001b0a0: 616e 7920 7374 7269 6e67 2074 6861 7420  any string that 
+0001b0b0: 6973 2066 6f75 6e64 2069 6e20 796f 7572  is found in your
+0001b0c0: 2063 6f6c 756d 6e20 616e 6420 7468 6174   column and that
+0001b0d0: 2079 6f75 2077 616e 7420 746f 2073 706c   you want to spl
+0001b0e0: 6974 2062 792e 0a20 2020 2061 6374 696f  it by..    actio
+0001b0f0: 6e3a 2063 616e 2062 6520 616e 7920 6f6e  n: can be any on
+0001b100: 6520 6f66 2066 6f6c 6c6f 7769 6e67 3a20  e of following: 
+0001b110: 7b27 6164 6427 2c20 2773 7562 7472 6163  {'add', 'subtrac
+0001b120: 7427 2c20 276d 756c 7469 706c 7927 2c20  t', 'multiply', 
+0001b130: 2764 6976 6964 6527 2c20 2763 6f6e 6361  'divide', 'conca
+0001b140: 7427 2c20 2763 6f6e 6361 7465 6e61 7465  t', 'concatenate
+0001b150: 277d 0a20 2020 2023 2323 2323 2323 2323  '}.    #########
+0001b160: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001b170: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001b180: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001b190: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001b1a0: 2323 2323 2323 230a 2020 2020 5265 7475  #######.    Retu
+0001b1b0: 726e 7320 6120 6461 7461 6672 616d 6520  rns a dataframe 
+0001b1c0: 7769 7468 2061 206e 6577 2063 6f6c 756d  with a new colum
+0001b1d0: 6e20 7468 6174 2069 7320 6120 6d6f 6469  n that is a modi
+0001b1e0: 6669 6361 7469 6f6e 206f 6620 7468 6520  fication of the 
+0001b1f0: 6f6c 6420 636f 6c75 6d6e 0a20 2020 2022  old column.    "
+0001b200: 2222 0a20 2020 2064 6674 203d 2063 6f70  "".    dft = cop
+0001b210: 792e 6465 6570 636f 7079 2864 6674 290a  y.deepcopy(dft).
+0001b220: 2020 2020 6e65 775f 636f 6c20 3d20 636f      new_col = co
+0001b230: 6c20 2b20 275f 7370 6c69 745f 6170 706c  l + '_split_appl
+0001b240: 7927 0a20 2020 2070 7269 6e74 2827 4372  y'.    print('Cr
+0001b250: 6561 7469 6e67 2063 6f6c 756d 6e20 3d20  eating column = 
+0001b260: 2573 2075 7369 6e67 2073 706c 6974 5f61  %s using split_a
+0001b270: 6464 2066 6561 7475 7265 2065 6e67 696e  dd feature engin
+0001b280: 6565 7269 6e67 2e2e 2e27 2025 6e65 775f  eering...' %new_
+0001b290: 636f 6c29 0a20 2020 2069 6620 6163 7469  col).    if acti
+0001b2a0: 6f6e 2069 6e20 5b27 2b27 2c27 2d27 2c27  on in ['+','-','
+0001b2b0: 2a27 2c27 2f27 2c27 6164 6427 2c27 7375  *','/','add','su
+0001b2c0: 6274 7261 6374 272c 276d 756c 7469 706c  btract','multipl
+0001b2d0: 7927 2c27 6469 7669 6465 275d 3a0a 2020  y','divide']:.  
+0001b2e0: 2020 2020 2020 6966 2061 6374 696f 6e20        if action 
+0001b2f0: 696e 205b 2761 6464 272c 272b 275d 3a0a  in ['add','+']:.
+0001b300: 2020 2020 2020 2020 2020 2020 7369 676e              sign
+0001b310: 203d 2027 2b27 0a20 2020 2020 2020 2065   = '+'.        e
+0001b320: 6c69 6620 6163 7469 6f6e 2069 6e20 5b27  lif action in ['
+0001b330: 2d27 2c20 2773 7562 7472 6163 7427 5d3a  -', 'subtract']:
+0001b340: 0a20 2020 2020 2020 2020 2020 2073 6967  .            sig
+0001b350: 6e20 3d20 272d 270a 2020 2020 2020 2020  n = '-'.        
+0001b360: 656c 6966 2061 6374 696f 6e20 696e 205b  elif action in [
+0001b370: 272a 272c 2027 6d75 6c74 6970 6c79 275d  '*', 'multiply']
+0001b380: 3a0a 2020 2020 2020 2020 2020 2020 7369  :.            si
+0001b390: 676e 203d 2027 2a27 0a20 2020 2020 2020  gn = '*'.       
+0001b3a0: 2065 6c69 6620 6163 7469 6f6e 2069 6e20   elif action in 
+0001b3b0: 5b27 2f27 2c20 2764 6976 6964 6527 5d3a  ['/', 'divide']:
+0001b3c0: 0a20 2020 2020 2020 2020 2020 2073 6967  .            sig
+0001b3d0: 6e20 3d20 272f 270a 2020 2020 2020 2020  n = '/'.        
+0001b3e0: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
+0001b3f0: 2020 7369 676e 203d 2027 2b27 0a20 2020    sign = '+'.   
+0001b400: 2020 2020 2023 2075 7369 6e67 2072 6564       # using red
+0001b410: 7563 6520 746f 2063 6f6d 7075 7465 2073  uce to compute s
+0001b420: 756d 206f 6620 6c69 7374 0a20 2020 2020  um of list.     
+0001b430: 2020 2074 7279 3a0a 2020 2020 2020 2020     try:.        
+0001b440: 2020 2020 7472 6169 6e78 203d 2064 6674      trainx = dft
+0001b450: 5b63 6f6c 5d2e 6173 7479 7065 2873 7472  [col].astype(str
+0001b460: 290a 2020 2020 2020 2020 2020 2020 7472  ).            tr
+0001b470: 6169 6e78 203d 2074 7261 696e 782e 6d61  ainx = trainx.ma
+0001b480: 7028 6c61 6d62 6461 2078 3a20 2030 2069  p(lambda x:  0 i
+0001b490: 6620 7820 6973 206e 702e 6e61 6e20 656c  f x is np.nan el
+0001b4a0: 7365 2030 2069 6620 7820 3d3d 2027 2720  se 0 if x == '' 
+0001b4b0: 656c 7365 2078 2e73 706c 6974 2873 706c  else x.split(spl
+0001b4c0: 6974 7465 7229 292e 6d61 7028 0a20 2020  itter)).map(.   
+0001b4d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001b4e0: 2020 2020 2020 2020 2020 2020 206c 616d               lam
+0001b4f0: 6264 6120 6c69 7374 783a 205b 696e 7428  bda listx: [int(
+0001b500: 7829 2069 6620 7820 213d 2027 2720 656c  x) if x != '' el
+0001b510: 7365 2030 2066 6f72 2078 2069 6e20 6c69  se 0 for x in li
+0001b520: 7374 7820 5d20 6966 2069 7369 6e73 7461  stx ] if isinsta
+0001b530: 6e63 6528 6c69 7374 782c 6c69 7374 2920  nce(listx,list) 
+0001b540: 656c 7365 205b 302c 305d 290a 2020 2020  else [0,0]).    
+0001b550: 2020 2020 2020 2020 6466 745b 6e65 775f          dft[new_
+0001b560: 636f 6c5d 203d 2074 7261 696e 782e 6d61  col] = trainx.ma
+0001b570: 7028 6c61 6d62 6461 206c 6973 3a20 7265  p(lambda lis: re
+0001b580: 6475 6365 286c 616d 6264 6120 612c 6220  duce(lambda a,b 
+0001b590: 3a20 6576 616c 2827 6127 2b73 6967 6e2b  : eval('a'+sign+
+0001b5a0: 2762 2729 2c20 6c69 7329 2069 6620 6973  'b'), lis) if is
+0001b5b0: 696e 7374 616e 6365 286c 6973 2c6c 6973  instance(lis,lis
+0001b5c0: 7429 2065 6c73 6520 3029 2e76 616c 7565  t) else 0).value
+0001b5d0: 730a 2020 2020 2020 2020 6578 6365 7074  s.        except
+0001b5e0: 3a0a 2020 2020 2020 2020 2020 2020 7072  :.            pr
+0001b5f0: 696e 7428 2720 2020 2045 7272 6f72 3a20  int('    Error: 
+0001b600: 7265 7475 726e 696e 6720 7769 7468 6f75  returning withou
+0001b610: 7420 6372 6561 7469 6e67 206e 6577 2063  t creating new c
+0001b620: 6f6c 756d 6e27 290a 2020 2020 2020 2020  olumn').        
+0001b630: 2020 2020 7265 7475 726e 2064 6674 0a20      return dft. 
+0001b640: 2020 2065 6c69 6620 6163 7469 6f6e 2069     elif action i
+0001b650: 6e20 5b27 636f 6e63 6174 272c 2763 6f6e  n ['concat','con
+0001b660: 6361 7465 6e61 7465 275d 3a0a 2020 2020  catenate']:.    
+0001b670: 2020 2020 7472 793a 0a20 2020 2020 2020      try:.       
+0001b680: 2020 2020 2064 6674 5b6e 6577 5f63 6f6c       dft[new_col
+0001b690: 5d20 3d20 6466 745b 636f 6c5d 2e6d 6170  ] = dft[col].map
+0001b6a0: 286c 616d 6264 6120 783a 2020 2220 2220  (lambda x:  " " 
+0001b6b0: 6966 2078 2069 7320 6e70 2e6e 616e 2065  if x is np.nan e
+0001b6c0: 6c73 6520 2220 2220 6966 2078 203d 3d20  lse " " if x == 
+0001b6d0: 2727 2065 6c73 6520 782e 7370 6c69 7428  '' else x.split(
+0001b6e0: 7370 6c69 7474 6572 2929 2e6d 6170 280a  splitter)).map(.
+0001b6f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001b700: 2020 2020 2020 2020 2020 2020 6c61 6d62              lamb
+0001b710: 6461 206c 6973 7478 3a20 6e70 2e63 6f6e  da listx: np.con
+0001b720: 6361 7465 6e61 7465 285b 7374 7228 7829  catenate([str(x)
+0001b730: 2069 6620 7820 213d 2027 2720 656c 7365   if x != '' else
+0001b740: 2022 2022 2066 6f72 2078 2069 6e20 6c69   " " for x in li
+0001b750: 7374 785d 2069 6620 6973 696e 7374 616e  stx] if isinstan
+0001b760: 6365 286c 6973 7478 2c6c 6973 7429 2065  ce(listx,list) e
+0001b770: 6c73 6520 2220 2229 292e 7661 6c75 6573  lse " ")).values
+0001b780: 0a20 2020 2020 2020 2065 7863 6570 743a  .        except:
+0001b790: 0a20 2020 2020 2020 2020 2020 2070 7269  .            pri
+0001b7a0: 6e74 2827 2020 2020 4572 726f 723a 2072  nt('    Error: r
+0001b7b0: 6574 7572 6e69 6e67 2077 6974 686f 7574  eturning without
+0001b7c0: 2063 7265 6174 696e 6720 6e65 7720 636f   creating new co
+0001b7d0: 6c75 6d6e 2729 0a20 2020 2065 6c73 653a  lumn').    else:
+0001b7e0: 0a20 2020 2020 2020 2070 7269 6e74 2827  .        print('
+0001b7f0: 436f 756c 6420 6e6f 7420 7065 7266 6f72  Could not perfor
+0001b800: 6d20 6163 7469 6f6e 2e20 506c 6561 7365  m action. Please
+0001b810: 2063 6865 636b 2079 6f75 7220 696e 7075   check your inpu
+0001b820: 7473 2061 6e64 2074 7279 2061 6761 696e  ts and try again
+0001b830: 2729 0a20 2020 2020 2020 2072 6574 7572  ').        retur
+0001b840: 6e20 6466 740a 2020 2020 7265 7475 726e  n dft.    return
+0001b850: 2064 6674 0a23 2323 2323 2323 2323 2323   dft.###########
+0001b860: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001b870: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001b880: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001b890: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001b8a0: 2323 2323 230a 6465 6620 4645 5f61 6464  #####.def FE_add
+0001b8b0: 5f61 6765 5f62 795f 6461 7465 5f63 6f6c  _age_by_date_col
+0001b8c0: 2864 6674 2c20 6461 7465 5f63 6f6c 2c20  (dft, date_col, 
+0001b8d0: 6167 655f 666f 726d 6174 293a 0a20 2020  age_format):.   
+0001b8e0: 2022 2222 0a20 2020 2046 4520 6d65 616e   """.    FE mean
+0001b8f0: 7320 4645 4154 5552 4520 454e 4749 4e45  s FEATURE ENGINE
+0001b900: 4552 494e 4720 2d20 5468 6174 206d 6561  ERING - That mea
+0001b910: 6e73 2074 6869 7320 6675 6e63 7469 6f6e  ns this function
+0001b920: 2077 696c 6c20 6372 6561 7465 206e 6577   will create new
+0001b930: 2066 6561 7475 7265 730a 2020 2020 2323   features.    ##
+0001b940: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001b950: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001b960: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001b970: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001b980: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001b990: 2323 2323 0a20 2020 2054 6869 7320 6861  ####.    This ha
+0001b9a0: 6e64 7920 6675 6e63 7469 6f6e 2067 6574  ndy function get
+0001b9b0: 7320 796f 7520 6167 6520 6672 6f6d 2074  s you age from t
+0001b9c0: 6865 2064 6174 655f 636f 6c20 746f 2074  he date_col to t
+0001b9d0: 6f64 6179 2e20 4974 2063 616e 2062 6520  oday. It can be 
+0001b9e0: 636f 756e 7465 6420 696e 206d 6f6e 7468  counted in month
+0001b9f0: 7320 6f72 2079 6561 7273 206f 7220 6461  s or years or da
+0001ba00: 7973 2e0a 2020 2020 2323 2323 2323 2323  ys..    ########
+0001ba10: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001ba20: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001ba30: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001ba40: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001ba50: 2323 2323 2323 2323 2323 2323 2323 0a20  ##############. 
+0001ba60: 2020 2049 7420 7265 7475 726e 7320 7468     It returns th
+0001ba70: 6520 7361 6d65 2064 6174 6166 7261 6d65  e same dataframe
+0001ba80: 2077 6974 6820 616e 2065 7874 7261 2063   with an extra c
+0001ba90: 6f6c 756d 6e20 6164 6465 6420 7468 6174  olumn added that
+0001baa0: 2067 6976 6573 2079 6f75 2061 6765 0a20   gives you age. 
+0001bab0: 2020 2022 2222 0a20 2020 2069 6620 6e6f     """.    if no
+0001bac0: 7420 6167 655f 666f 726d 6174 2069 6e20  t age_format in 
+0001bad0: 5b27 4d27 2c27 4427 2c27 5927 5d3a 0a20  ['M','D','Y']:. 
+0001bae0: 2020 2020 2020 2070 7269 6e74 2827 4167         print('Ag
+0001baf0: 6520 6973 206e 6f74 2067 6976 656e 2069  e is not given i
+0001bb00: 6e20 7269 6768 7420 666f 726d 6174 2e20  n right format. 
+0001bb10: 4d75 7374 2062 6520 6f6e 6520 6f66 2044  Must be one of D
+0001bb20: 2c20 5920 6f72 204d 2729 0a20 2020 2020  , Y or M').     
+0001bb30: 2020 2072 6574 7572 6e20 6466 740a 2020     return dft.  
+0001bb40: 2020 6e65 775f 6461 7465 5f63 6f6c 203d    new_date_col =
+0001bb50: 2027 6c61 7374 5f27 2b64 6174 655f 636f   'last_'+date_co
+0001bb60: 6c2b 275f 696e 5f6d 6f6e 7468 7327 0a20  l+'_in_months'. 
+0001bb70: 2020 2074 7279 3a0a 2020 2020 2020 2020     try:.        
+0001bb80: 6e6f 7720 3d20 7064 2e54 696d 6573 7461  now = pd.Timesta
+0001bb90: 6d70 2827 6e6f 7727 290a 2020 2020 2020  mp('now').      
+0001bba0: 2020 6466 745b 6461 7465 5f63 6f6c 5d20    dft[date_col] 
+0001bbb0: 3d20 7064 2e74 6f5f 6461 7465 7469 6d65  = pd.to_datetime
+0001bbc0: 2864 6674 5b64 6174 655f 636f 6c5d 2c20  (dft[date_col], 
+0001bbd0: 666f 726d 6174 3d27 2579 2d25 6d2d 2564  format='%y-%m-%d
+0001bbe0: 2729 0a20 2020 2020 2020 2064 6674 5b64  ').        dft[d
+0001bbf0: 6174 655f 636f 6c5d 203d 2064 6674 5b64  ate_col] = dft[d
+0001bc00: 6174 655f 636f 6c5d 2e77 6865 7265 2864  ate_col].where(d
+0001bc10: 6674 5b64 6174 655f 636f 6c5d 203c 206e  ft[date_col] < n
+0001bc20: 6f77 2c20 6466 745b 6461 7465 5f63 6f6c  ow, dft[date_col
+0001bc30: 5d20 2d20 206e 702e 7469 6d65 6465 6c74  ] -  np.timedelt
+0001bc40: 6136 3428 3130 302c 2061 6765 5f66 6f72  a64(100, age_for
+0001bc50: 6d61 7429 290a 2020 2020 2020 2020 6966  mat)).        if
+0001bc60: 2061 6765 5f66 6f72 6d61 7420 3d3d 2027   age_format == '
+0001bc70: 4d27 3a0a 2020 2020 2020 2020 2020 2020  M':.            
+0001bc80: 6466 745b 6e65 775f 6461 7465 5f63 6f6c  dft[new_date_col
+0001bc90: 5d20 3d20 286e 6f77 202d 2064 6674 5b64  ] = (now - dft[d
+0001bca0: 6174 655f 636f 6c5d 292e 6173 7479 7065  ate_col]).astype
+0001bcb0: 2827 3c6d 385b 4d5d 2729 0a20 2020 2020  ('<m8[M]').     
+0001bcc0: 2020 2065 6c69 6620 6167 655f 666f 726d     elif age_form
+0001bcd0: 6174 203d 3d20 2759 273a 0a20 2020 2020  at == 'Y':.     
+0001bce0: 2020 2020 2020 2064 6674 5b6e 6577 5f64         dft[new_d
+0001bcf0: 6174 655f 636f 6c5d 203d 2028 6e6f 7720  ate_col] = (now 
+0001bd00: 2d20 6466 745b 6461 7465 5f63 6f6c 5d29  - dft[date_col])
+0001bd10: 2e61 7374 7970 6528 273c 6d38 5b59 5d27  .astype('<m8[Y]'
+0001bd20: 290a 2020 2020 2020 2020 656c 6966 2061  ).        elif a
+0001bd30: 6765 5f66 6f72 6d61 7420 3d3d 2027 4427  ge_format == 'D'
+0001bd40: 3a0a 2020 2020 2020 2020 2020 2020 6466  :.            df
+0001bd50: 745b 6e65 775f 6461 7465 5f63 6f6c 5d20  t[new_date_col] 
+0001bd60: 3d20 286e 6f77 202d 2064 6674 5b64 6174  = (now - dft[dat
+0001bd70: 655f 636f 6c5d 292e 6173 7479 7065 2827  e_col]).astype('
+0001bd80: 3c6d 385b 445d 2729 0a20 2020 2065 7863  <m8[D]').    exc
+0001bd90: 6570 743a 0a20 2020 2020 2020 2070 7269  ept:.        pri
+0001bda0: 6e74 2827 2020 2020 4572 726f 7220 696e  nt('    Error in
+0001bdb0: 2064 6174 6520 666f 726d 6174 7469 6e67   date formatting
+0001bdc0: 2e20 506c 6561 7365 2063 6865 636b 2079  . Please check y
+0001bdd0: 6f75 7220 696e 7075 7420 616e 6420 7472  our input and tr
+0001bde0: 7920 6167 6169 6e27 290a 2020 2020 7265  y again').    re
+0001bdf0: 7475 726e 2064 6674 0a23 2323 2323 2323  turn dft.#######
+0001be00: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001be10: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001be20: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 0001be30: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001be40: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001be50: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001be60: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001be70: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001be80: 2323 2323 230a 2020 2020 2222 220a 2020  #####.    """.  
-0001be90: 2020 6e65 775f 636f 6c20 3d20 2772 6f77    new_col = 'row
-0001bea0: 5f63 6f75 6e74 5f69 6e63 6c5f 6e75 6c6c  _count_incl_null
-0001beb0: 5f72 6f77 7327 0a20 2020 2069 6620 6973  _rows'.    if is
-0001bec0: 696e 7374 616e 6365 2869 645f 636f 6c2c  instance(id_col,
-0001bed0: 2073 7472 293a 0a20 2020 2020 2020 2067   str):.        g
-0001bee0: 726f 7570 6279 5f63 6f6c 756d 6e73 203d  roupby_columns =
-0001bef0: 2020 5b69 645f 636f 6c5d 0a20 2020 2065    [id_col].    e
-0001bf00: 6c73 653a 0a20 2020 2020 2020 2067 726f  lse:.        gro
-0001bf10: 7570 6279 5f63 6f6c 756d 6e73 203d 2063  upby_columns = c
-0001bf20: 6f70 792e 6465 6570 636f 7079 2869 645f  opy.deepcopy(id_
-0001bf30: 636f 6c29 0a20 2020 2023 2323 206c 656e  col).    ### len
-0001bf40: 2067 6976 6573 2079 6f75 2063 6f75 6e74   gives you count
-0001bf50: 206f 6620 616c 6c20 7468 6520 726f 7773   of all the rows
-0001bf60: 2069 6e63 6c75 6469 6e67 206e 756c 6c20   including null 
-0001bf70: 726f 7773 2069 6e20 796f 7572 2064 6174  rows in your dat
-0001bf80: 610a 2020 2020 6772 6f75 7065 645f 6c65  a.    grouped_le
-0001bf90: 6e20 3d20 6466 742e 6772 6f75 7062 7928  n = dft.groupby(
-0001bfa0: 6772 6f75 7062 795f 636f 6c75 6d6e 7329  groupby_columns)
-0001bfb0: 2e61 7070 6c79 286c 656e 290a 2020 2020  .apply(len).    
-0001bfc0: 6772 6f75 7065 645f 7661 6c20 3d20 6772  grouped_val = gr
-0001bfd0: 6f75 7065 645f 6c65 6e2e 7661 6c75 6573  ouped_len.values
-0001bfe0: 0a20 2020 2067 726f 7570 6564 5f6c 656e  .    grouped_len
-0001bff0: 203d 2070 642e 4461 7461 4672 616d 6528   = pd.DataFrame(
-0001c000: 6772 6f75 7065 645f 7661 6c2c 2063 6f6c  grouped_val, col
-0001c010: 756d 6e73 3d5b 6e65 775f 636f 6c5d 2c69  umns=[new_col],i
-0001c020: 6e64 6578 3d67 726f 7570 6564 5f6c 656e  ndex=grouped_len
-0001c030: 2e69 6e64 6578 290a 2020 2020 7265 7475  .index).    retu
-0001c040: 726e 2067 726f 7570 6564 5f6c 656e 0a23  rn grouped_len.#
+0001be40: 2323 2323 2323 2323 2323 0a64 6566 2046  ##########.def F
+0001be50: 455f 636f 756e 745f 726f 7773 5f66 6f72  E_count_rows_for
+0001be60: 5f61 6c6c 5f63 6f6c 756d 6e73 5f62 795f  _all_columns_by_
+0001be70: 6772 6f75 7028 6466 742c 2069 645f 636f  group(dft, id_co
+0001be80: 6c29 3a0a 2020 2020 2222 220a 2020 2020  l):.    """.    
+0001be90: 4645 206d 6561 6e73 2046 4541 5455 5245  FE means FEATURE
+0001bea0: 2045 4e47 494e 4545 5249 4e47 202d 2054   ENGINEERING - T
+0001beb0: 6861 7420 6d65 616e 7320 7468 6973 2066  hat means this f
+0001bec0: 756e 6374 696f 6e20 7769 6c6c 2063 7265  unction will cre
+0001bed0: 6174 6520 6e65 7720 6665 6174 7572 6573  ate new features
+0001bee0: 0a20 2020 2023 2323 2323 2323 2323 2323  .    ###########
+0001bef0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001bf00: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001bf10: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001bf20: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001bf30: 2323 2323 2323 2323 2323 230a 2020 2020  ###########.    
+0001bf40: 5468 6973 2068 616e 6479 2066 756e 6374  This handy funct
+0001bf50: 696f 6e20 6769 7665 7320 796f 7520 6120  ion gives you a 
+0001bf60: 636f 756e 7420 6f66 2061 6c6c 2072 6f77  count of all row
+0001bf70: 7320 6279 2067 726f 7570 7320 6261 7365  s by groups base
+0001bf80: 6420 6f6e 2069 645f 636f 6c20 696e 2079  d on id_col in y
+0001bf90: 6f75 7220 6461 7461 6672 616d 652e 0a20  our dataframe.. 
+0001bfa0: 2020 2052 656d 656d 6265 7220 7468 6174     Remember that
+0001bfb0: 2069 7420 636f 756e 7473 206f 6e6c 7920   it counts only 
+0001bfc0: 6e6f 6e2d 6e75 6c6c 2072 6f77 732e 2048  non-null rows. H
+0001bfd0: 656e 6365 2069 7420 6973 2061 2064 6966  ence it is a dif
+0001bfe0: 6665 7265 6e74 2063 6f75 6e74 2074 6861  ferent count tha
+0001bff0: 6e20 6f74 6865 7220 636f 756e 7420 6675  n other count fu
+0001c000: 6e63 7469 6f6e 2e0a 2020 2020 2323 2323  nction..    ####
+0001c010: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001c020: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001c030: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001c040: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 0001c050: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001c060: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001c070: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001c080: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001c090: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001c0a0: 0a23 2043 616e 2077 6520 7365 6520 6966  .# Can we see if
-0001c0b0: 2061 2066 6561 7475 7265 206f 7220 6665   a feature or fe
-0001c0c0: 6174 7572 6573 2068 6173 2073 6f6d 6520  atures has some 
-0001c0d0: 6f75 746c 6965 7273 2061 6e64 2068 6f77  outliers and how
-0001c0e0: 2063 616e 2077 6520 6361 7020 7468 656d   can we cap them
-0001c0f0: 3f0a 6672 6f6d 2063 6f6c 6c65 6374 696f  ?.from collectio
-0001c100: 6e73 2069 6d70 6f72 7420 436f 756e 7465  ns import Counte
-0001c110: 720a 6465 6620 4645 5f63 6170 7069 6e67  r.def FE_capping
-0001c120: 5f6f 7574 6c69 6572 735f 6265 796f 6e64  _outliers_beyond
-0001c130: 5f49 5152 5f52 616e 6765 2864 662c 2066  _IQR_Range(df, f
-0001c140: 6561 7475 7265 732c 2063 6170 5f61 745f  eatures, cap_at_
-0001c150: 6e74 685f 6c61 7267 6573 743d 352c 2049  nth_largest=5, I
-0001c160: 5152 5f6d 756c 7469 706c 6965 723d 312e  QR_multiplier=1.
-0001c170: 352c 0a20 2020 2020 2020 2020 2020 2020  5,.             
-0001c180: 2020 2020 2020 2020 2020 2020 2020 2020                  
-0001c190: 2020 2020 2020 2020 2020 2020 6472 6f70              drop
-0001c1a0: 3d46 616c 7365 2c20 7665 7262 6f73 653d  =False, verbose=
-0001c1b0: 4661 6c73 6529 3a0a 2020 2020 2222 220a  False):.    """.
-0001c1c0: 2020 2020 4645 2061 7420 7468 6520 6265      FE at the be
-0001c1d0: 6769 6e6e 696e 6720 6f66 2066 756e 6374  ginning of funct
-0001c1e0: 696f 6e20 6e61 6d65 2073 7461 6e64 7320  ion name stands 
-0001c1f0: 666f 7220 4665 6174 7572 6520 456e 6769  for Feature Engi
-0001c200: 6e65 6572 696e 672e 2046 4520 6675 6e63  neering. FE func
-0001c210: 7469 6f6e 7320 6164 6420 6f72 2064 726f  tions add or dro
-0001c220: 7020 6665 6174 7572 6573 2e0a 2020 2020  p features..    
-0001c230: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001c240: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001c250: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001c260: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001c060: 2323 0a20 2020 2049 7420 7265 7475 726e  ##.    It return
+0001c070: 7320 6120 6461 7461 6672 616d 6520 7769  s a dataframe wi
+0001c080: 7468 2069 645f 636f 6c20 6173 2074 6865  th id_col as the
+0001c090: 2069 6e64 6578 2061 6e64 2061 2062 756e   index and a bun
+0001c0a0: 6368 206f 6620 6e65 7720 636f 6c75 6d6e  ch of new column
+0001c0b0: 7320 7468 6174 2067 6976 6520 796f 7520  s that give you 
+0001c0c0: 636f 756e 7473 206f 6620 6772 6f75 7073  counts of groups
+0001c0d0: 2e0a 2020 2020 2222 220a 2020 2020 6e65  ..    """.    ne
+0001c0e0: 775f 636f 6c20 3d20 2772 6f77 5f63 6f75  w_col = 'row_cou
+0001c0f0: 6e74 5f27 0a20 2020 2069 6620 6973 696e  nt_'.    if isin
+0001c100: 7374 616e 6365 2869 645f 636f 6c2c 2073  stance(id_col, s
+0001c110: 7472 293a 0a20 2020 2020 2020 2067 726f  tr):.        gro
+0001c120: 7570 6279 5f63 6f6c 756d 6e73 203d 2020  upby_columns =  
+0001c130: 5b69 645f 636f 6c5d 0a20 2020 2065 6c73  [id_col].    els
+0001c140: 653a 0a20 2020 2020 2020 2067 726f 7570  e:.        group
+0001c150: 6279 5f63 6f6c 756d 6e73 203d 2063 6f70  by_columns = cop
+0001c160: 792e 6465 6570 636f 7079 2869 645f 636f  y.deepcopy(id_co
+0001c170: 6c29 0a20 2020 2067 726f 7570 6564 5f63  l).    grouped_c
+0001c180: 6f75 6e74 203d 2064 6674 2e67 726f 7570  ount = dft.group
+0001c190: 6279 2867 726f 7570 6279 5f63 6f6c 756d  by(groupby_colum
+0001c1a0: 6e73 292e 636f 756e 7428 292e 6164 645f  ns).count().add_
+0001c1b0: 7072 6566 6978 286e 6577 5f63 6f6c 290a  prefix(new_col).
+0001c1c0: 2020 2020 7265 7475 726e 2067 726f 7570      return group
+0001c1d0: 6564 5f63 6f75 6e74 0a23 2323 2323 2323  ed_count.#######
+0001c1e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001c1f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001c200: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001c210: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001c220: 2323 2323 2323 2323 2323 0a64 6566 2063  ##########.def c
+0001c230: 6f75 6e74 5f72 6f77 735f 6279 5f67 726f  ount_rows_by_gro
+0001c240: 7570 5f69 6e63 6c5f 6e75 6c6c 7328 6466  up_incl_nulls(df
+0001c250: 742c 2069 645f 636f 6c29 3a0a 2020 2020  t, id_col):.    
+0001c260: 2222 220a 2020 2020 2323 2323 2323 2323  """.    ########
 0001c270: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001c280: 2323 2323 2323 2323 230a 2020 2020 5479  #########.    Ty
-0001c290: 7069 6361 6c6c 7920 7765 2074 6869 6e6b  pically we think
-0001c2a0: 206f 6620 6f75 746c 6965 7273 2061 7320   of outliers as 
-0001c2b0: 6265 696e 6720 6f62 7365 7276 6174 696f  being observatio
-0001c2c0: 6e73 2062 6579 6f6e 6420 7468 6520 312e  ns beyond the 1.
-0001c2d0: 3520 496e 7465 7220 5175 6172 7469 6c65  5 Inter Quartile
-0001c2e0: 2052 616e 6765 2028 4951 5229 0a20 2020   Range (IQR).   
-0001c2f0: 2042 7574 2074 6869 7320 6675 6e63 7469   But this functi
-0001c300: 6f6e 2077 696c 6c20 616c 6c6f 7720 796f  on will allow yo
-0001c310: 7520 746f 2063 6170 2061 6e79 206f 6273  u to cap any obs
-0001c320: 6572 7661 7469 6f6e 2074 6861 7420 6973  ervation that is
-0001c330: 206d 756c 7469 706c 6520 6f66 2049 5152   multiple of IQR
-0001c340: 2072 616e 6765 2c20 7375 6368 2061 7320   range, such as 
-0001c350: 312e 352c 2032 2c20 6574 632e 0a20 2020  1.5, 2, etc..   
-0001c360: 2049 6e20 6164 6469 7469 6f6e 2c20 7468   In addition, th
-0001c370: 6973 2075 7469 6c69 7479 2068 656c 7073  is utility helps
-0001c380: 2079 6f75 2073 656c 6563 7420 7468 6520   you select the 
-0001c390: 7661 6c75 6520 746f 2063 6170 2069 7420  value to cap it 
-0001c3a0: 6174 2e0a 2020 2020 5468 6520 7661 6c75  at..    The valu
-0001c3b0: 6520 746f 2062 6520 6361 7070 6564 2069  e to be capped i
-0001c3c0: 7320 6261 7365 6420 6f6e 2022 6e22 2074  s based on "n" t
-0001c3d0: 6861 7420 796f 7520 696e 7075 742e 0a20  hat you input.. 
-0001c3e0: 2020 206e 2072 6570 7265 7365 6e74 7320     n represents 
-0001c3f0: 7468 6520 6e74 685f 6c61 7267 6573 7420  the nth_largest 
-0001c400: 6e75 6d62 6572 2062 656c 6f77 2074 6865  number below the
-0001c410: 206d 6178 696d 756d 2076 616c 7565 2074   maximum value t
-0001c420: 6f20 6361 7020 6174 210a 2020 2020 4e6f  o cap at!.    No
-0001c430: 7469 6365 2074 6861 7420 6974 2064 6f65  tice that it doe
-0001c440: 7320 6e6f 7420 7075 7420 6120 666c 6f6f  s not put a floo
-0001c450: 7220 756e 6465 7220 6d69 6e69 6d75 6d73  r under minimums
-0001c460: 2e20 596f 7520 6861 7665 2074 6f20 646f  . You have to do
-0001c470: 2074 6861 7420 796f 7572 7365 6c66 2e0a   that yourself..
-0001c480: 2020 2020 2263 6170 5f61 745f 6e74 685f      "cap_at_nth_
-0001c490: 6c61 7267 6573 7422 2073 7065 6369 6669  largest" specifi
-0001c4a0: 6573 2074 6865 206d 6178 206e 756d 6265  es the max numbe
-0001c4b0: 7220 6265 6c6f 7720 7468 6520 6c61 7267  r below the larg
-0001c4c0: 6573 7420 286d 6178 2920 6e75 6d62 6572  est (max) number
-0001c4d0: 2069 6e20 796f 7572 2063 6f6c 756d 6e20   in your column 
-0001c4e0: 746f 2063 6170 2074 6861 7420 6665 6174  to cap that feat
-0001c4f0: 7572 652e 0a20 2020 204f 7074 696f 6e61  ure..    Optiona
-0001c500: 6c6c 792c 2079 6f75 2063 616e 2064 726f  lly, you can dro
-0001c510: 7020 6365 7274 6169 6e20 6f62 7365 7276  p certain observ
-0001c520: 6174 696f 6e73 2074 6861 7420 6861 7665  ations that have
-0001c530: 2074 6f6f 206d 616e 7920 6f75 746c 6965   too many outlie
-0001c540: 7273 2069 6e20 6174 206c 6561 7374 2033  rs in at least 3
-0001c550: 2063 6f6c 756d 6e73 2e0a 2020 2020 2323   columns..    ##
-0001c560: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001c570: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001c580: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001c590: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001c5a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001c5b0: 2323 2323 2323 230a 2020 2020 496e 7075  #######.    Inpu
-0001c5c0: 7473 3a0a 2020 2020 6466 203a 2070 616e  ts:.    df : pan
-0001c5d0: 6461 7320 4461 7461 4672 616d 650a 2020  das DataFrame.  
-0001c5e0: 2020 6665 6174 7572 6573 3a20 6120 7369    features: a si
-0001c5f0: 6e67 6c65 2063 6f6c 756d 6e20 6f72 2061  ngle column or a
-0001c600: 206c 6973 7420 6f66 2063 6f6c 756d 6e73   list of columns
-0001c610: 2069 6e20 796f 7572 2044 6174 6146 7261   in your DataFra
-0001c620: 6d65 0a20 2020 2063 6170 5f61 745f 6e74  me.    cap_at_nt
-0001c630: 685f 6c61 7267 6573 743a 2064 6566 6175  h_largest: defau
-0001c640: 6c74 2069 7320 3520 3d20 796f 7520 6361  lt is 5 = you ca
-0001c650: 6e20 7365 7420 6974 2074 6f20 616e 7920  n set it to any 
-0001c660: 696e 7465 6765 7220 7375 6368 2061 7320  integer such as 
-0001c670: 312c 2032 2c20 332c 2034 2c20 352c 2065  1, 2, 3, 4, 5, e
-0001c680: 7463 2e0a 2020 2020 4951 525f 6d75 6c74  tc..    IQR_mult
-0001c690: 6970 6c69 6572 3a20 6465 6661 756c 7420  iplier: default 
-0001c6a0: 6973 2031 2e35 203d 2062 7574 2079 6f75  is 1.5 = but you
-0001c6b0: 2063 616e 2073 6574 2069 7420 746f 2061   can set it to a
-0001c6c0: 6e79 2066 6c6f 6174 2076 616c 7565 2073  ny float value s
-0001c6d0: 7563 6820 6173 2031 2c20 312e 3235 2e20  uch as 1, 1.25. 
-0001c6e0: 312e 352c 2032 2e30 2c20 6574 632e 0a0a  1.5, 2.0, etc...
-0001c6f0: 2020 2020 4f75 7470 7574 733a 0a20 2020      Outputs:.   
-0001c700: 2064 663a 2070 616e 6461 7320 4461 7461   df: pandas Data
-0001c710: 4672 616d 650a 2020 2020 4974 2072 6574  Frame.    It ret
-0001c720: 7572 6e73 2074 6865 2073 616d 6520 6461  urns the same da
-0001c730: 7461 6672 616d 6520 6173 2079 6f75 2069  taframe as you i
-0001c740: 6e70 7574 2075 6e6c 6573 7320 796f 7520  nput unless you 
-0001c750: 6368 616e 6765 2064 726f 7020 746f 2054  change drop to T
-0001c760: 7275 6520 696e 2074 6865 2069 6e70 7574  rue in the input
-0001c770: 2061 7267 756d 656e 742e 0a0a 2020 2020   argument...    
-0001c780: 4f70 7469 6f6e 616c 6c79 2c20 6974 2063  Optionally, it c
-0001c790: 616e 2064 726f 7020 6365 7274 6169 6e20  an drop certain 
-0001c7a0: 726f 7773 2074 6861 7420 6861 7665 2074  rows that have t
-0001c7b0: 6f6f 206d 616e 7920 6f75 746c 6965 7273  oo many outliers
-0001c7c0: 2069 6e20 6174 206c 6561 7374 2033 2063   in at least 3 c
-0001c7d0: 6f6c 756d 6e73 2073 696d 756c 7461 6e65  olumns simultane
-0001c7e0: 6f75 736c 792e 0a20 2020 2049 6620 6472  ously..    If dr
-0001c7f0: 6f70 3d54 7275 652c 2069 7420 7769 6c6c  op=True, it will
-0001c800: 2072 6574 7572 6e20 6120 736d 616c 6c65   return a smalle
-0001c810: 7220 6e75 6d62 6572 206f 6620 726f 7773  r number of rows
-0001c820: 2069 6e20 796f 7572 2064 6174 6166 7261   in your datafra
-0001c830: 6d65 2074 6861 6e20 7768 6174 2079 6f75  me than what you
-0001c840: 2073 656e 7420 696e 2e20 4265 2063 6172   sent in. Be car
-0001c850: 6566 756c 210a 2020 2020 2323 2323 2323  eful!.    ######
-0001c860: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001c870: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001c880: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001c890: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001c8a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001c8b0: 2323 230a 2020 2020 2222 220a 2020 2020  ###.    """.    
-0001c8c0: 6f75 746c 6965 725f 696e 6469 6365 7320  outlier_indices 
-0001c8d0: 3d20 5b5d 0a20 2020 2064 6620 3d20 6466  = [].    df = df
-0001c8e0: 2e63 6f70 7928 6465 6570 3d54 7275 6529  .copy(deep=True)
-0001c8f0: 0a20 2020 2069 6620 6973 696e 7374 616e  .    if isinstan
-0001c900: 6365 2866 6561 7475 7265 732c 2073 7472  ce(features, str
-0001c910: 293a 0a20 2020 2020 2020 2066 6561 7475  ):.        featu
-0001c920: 7265 7320 3d20 5b66 6561 7475 7265 735d  res = [features]
-0001c930: 0a20 2020 2023 2069 7465 7261 7465 206f  .    # iterate o
-0001c940: 7665 7220 6665 6174 7572 6573 2863 6f6c  ver features(col
-0001c950: 756d 6e73 290a 2020 2020 666f 7220 636f  umns).    for co
-0001c960: 6c20 696e 2066 6561 7475 7265 733a 0a20  l in features:. 
-0001c970: 2020 2020 2020 2023 2323 2074 6869 7320         ### this 
-0001c980: 6973 2068 6f77 2074 6865 2063 6f6c 756d  is how the colum
-0001c990: 6e20 6c6f 6f6b 7320 6e6f 7720 6265 666f  n looks now befo
-0001c9a0: 7265 2063 6170 7069 6e67 206f 7574 6c69  re capping outli
-0001c9b0: 6572 730a 2020 2020 2020 2020 6966 2076  ers.        if v
-0001c9c0: 6572 626f 7365 3a0a 2020 2020 2020 2020  erbose:.        
-0001c9d0: 2020 2020 6669 672c 2028 6178 312c 6178      fig, (ax1,ax
-0001c9e0: 3229 203d 2070 6c74 2e73 7562 706c 6f74  2) = plt.subplot
-0001c9f0: 7328 312c 322c 6669 6773 697a 653d 2831  s(1,2,figsize=(1
-0001ca00: 322c 3529 290a 2020 2020 2020 2020 2020  2,5)).          
-0001ca10: 2020 6466 5b63 6f6c 5d2e 706c 6f74 286b    df[col].plot(k
-0001ca20: 696e 643d 2762 6f78 272c 2074 6974 6c65  ind='box', title
-0001ca30: 203d 2027 2573 2062 6566 6f72 6520 6361   = '%s before ca
-0001ca40: 7070 696e 6720 6f75 746c 6965 7273 2720  pping outliers' 
-0001ca50: 2563 6f6c 2c20 6178 3d61 7831 290a 2020  %col, ax=ax1).  
-0001ca60: 2020 2020 2020 2320 3173 7420 7175 6172        # 1st quar
-0001ca70: 7469 6c65 2028 3235 2529 0a20 2020 2020  tile (25%).     
-0001ca80: 2020 2051 3120 3d20 6e70 2e70 6572 6365     Q1 = np.perce
-0001ca90: 6e74 696c 6528 6466 5b63 6f6c 5d2c 2032  ntile(df[col], 2
-0001caa0: 3529 0a20 2020 2020 2020 2023 2033 7264  5).        # 3rd
-0001cab0: 2071 7561 7274 696c 6520 2837 3525 290a   quartile (75%).
-0001cac0: 2020 2020 2020 2020 5133 203d 206e 702e          Q3 = np.
-0001cad0: 7065 7263 656e 7469 6c65 2864 665b 636f  percentile(df[co
-0001cae0: 6c5d 2c37 3529 0a20 2020 2020 2020 2023  l],75).        #
-0001caf0: 2049 6e74 6572 7175 6172 7469 6c65 2072   Interquartile r
-0001cb00: 616e 6765 2028 4951 5229 0a20 2020 2020  ange (IQR).     
-0001cb10: 2020 2049 5152 203d 2051 3320 2d20 5131     IQR = Q3 - Q1
-0001cb20: 0a0a 2020 2020 2020 2020 2320 6f75 746c  ..        # outl
-0001cb30: 6965 7220 7374 6570 2075 7369 6e67 206d  ier step using m
-0001cb40: 756c 7469 706c 6965 720a 2020 2020 2020  ultiplier.      
-0001cb50: 2020 6f75 746c 6965 725f 7374 6570 203d    outlier_step =
-0001cb60: 2049 5152 5f6d 756c 7469 706c 6965 7220   IQR_multiplier 
-0001cb70: 2a20 4951 520a 0a20 2020 2020 2020 206c  * IQR..        l
-0001cb80: 6f77 6572 5f6c 696d 6974 203d 2051 3120  ower_limit = Q1 
-0001cb90: 2d20 6f75 746c 6965 725f 7374 6570 0a20  - outlier_step. 
-0001cba0: 2020 2020 2020 2075 7070 6572 5f6c 696d         upper_lim
-0001cbb0: 6974 203d 2051 3320 2b20 6f75 746c 6965  it = Q3 + outlie
-0001cbc0: 725f 7374 6570 0a0a 2020 2020 2020 2020  r_step..        
-0001cbd0: 2320 4465 7465 726d 696e 6520 6120 6c69  # Determine a li
-0001cbe0: 7374 206f 6620 696e 6469 6365 7320 6f66  st of indices of
-0001cbf0: 206f 7574 6c69 6572 7320 666f 7220 6665   outliers for fe
-0001cc00: 6174 7572 6520 636f 6c0a 2020 2020 2020  ature col.      
-0001cc10: 2020 6f75 746c 6965 725f 6c69 7374 5f63    outlier_list_c
-0001cc20: 6f6c 203d 2064 665b 2864 665b 636f 6c5d  ol = df[(df[col]
-0001cc30: 203c 206c 6f77 6572 5f6c 696d 6974 2920   < lower_limit) 
-0001cc40: 7c20 2864 665b 636f 6c5d 203e 2075 7070  | (df[col] > upp
-0001cc50: 6572 5f6c 696d 6974 2029 5d2e 696e 6465  er_limit )].inde
-0001cc60: 780a 0a20 2020 2020 2020 2023 2323 2043  x..        ### C
-0001cc70: 6170 7069 6e67 2075 7369 6e67 2074 6865  apping using the
-0001cc80: 206e 206c 6172 6765 7374 2076 616c 7565   n largest value
-0001cc90: 2062 6173 6564 206f 6e20 6e20 6769 7665   based on n give
-0001cca0: 6e20 696e 2069 6e70 7574 2e0a 2020 2020  n in input..    
-0001ccb0: 2020 2020 6d61 7876 616c 203d 2064 665b      maxval = df[
-0001ccc0: 636f 6c5d 2e6d 6178 2829 2020 2323 2077  col].max()  ## w
-0001ccd0: 6861 7420 6973 2074 6865 206d 6178 696d  hat is the maxim
-0001cce0: 756d 2076 616c 7565 2069 6e20 7468 6973  um value in this
-0001ccf0: 2063 6f6c 756d 6e3f 0a20 2020 2020 2020   column?.       
-0001cd00: 206e 756d 5f6d 6178 7320 3d20 6466 5b64   num_maxs = df[d
-0001cd10: 665b 636f 6c5d 3d3d 6d61 7876 616c 5d2e  f[col]==maxval].
-0001cd20: 7368 6170 655b 305d 2023 2320 6e75 6d62  shape[0] ## numb
-0001cd30: 6572 206f 6620 726f 7773 2074 6861 7420  er of rows that 
-0001cd40: 6861 7665 206d 6178 2076 616c 7565 0a20  have max value. 
-0001cd50: 2020 2020 2020 2023 2323 2066 696e 6420         ### find 
-0001cd60: 7468 6520 6e5f 6c61 7267 6573 7420 7661  the n_largest va
-0001cd70: 6c75 6573 2061 6674 6572 2074 6865 206d  lues after the m
-0001cd80: 6178 696d 756d 2076 616c 7565 2062 6173  aximum value bas
-0001cd90: 6564 206f 6e20 6769 7665 6e20 696e 7075  ed on given inpu
-0001cda0: 7420 6e0a 2020 2020 2020 2020 6e75 6d5f  t n.        num_
-0001cdb0: 6c61 7267 6573 745f 6166 7465 725f 6d61  largest_after_ma
-0001cdc0: 7820 3d20 6e75 6d5f 6d61 7873 202b 2063  x = num_maxs + c
-0001cdd0: 6170 5f61 745f 6e74 685f 6c61 7267 6573  ap_at_nth_larges
-0001cde0: 740a 2020 2020 2020 2020 6361 7070 6564  t.        capped
-0001cdf0: 5f76 616c 7565 203d 2064 665b 636f 6c5d  _value = df[col]
-0001ce00: 2e6e 6c61 7267 6573 7428 6e75 6d5f 6c61  .nlargest(num_la
-0001ce10: 7267 6573 745f 6166 7465 725f 6d61 7829  rgest_after_max)
-0001ce20: 2e69 6c6f 635b 2d31 5d20 2323 2074 6869  .iloc[-1] ## thi
-0001ce30: 7320 6973 2074 6865 2076 616c 7565 2077  s is the value w
-0001ce40: 6520 6361 7020 6974 2061 6761 696e 7374  e cap it against
-0001ce50: 0a20 2020 2020 2020 2064 662e 6c6f 635b  .        df.loc[
-0001ce60: 6466 5b63 6f6c 5d3d 3d6d 6178 7661 6c2c  df[col]==maxval,
-0001ce70: 2063 6f6c 5d20 3d20 2063 6170 7065 645f   col] =  capped_
-0001ce80: 7661 6c75 6520 2323 206d 6178 696d 756d  value ## maximum
-0001ce90: 2076 616c 7565 7320 6172 6520 6e6f 7720   values are now 
-0001cea0: 6361 7070 6564 0a20 2020 2020 2020 2023  capped.        #
-0001ceb0: 2323 2079 6f75 2061 7265 206e 6f77 2067  ## you are now g
-0001cec0: 6f6f 6420 746f 2067 6f20 2d20 796f 7520  ood to go - you 
-0001ced0: 6361 6e20 7368 6f77 2068 6f77 2074 6865  can show how the
-0001cee0: 7920 6172 6520 6361 7070 6564 2075 7369  y are capped usi
-0001cef0: 6e67 2062 6566 6f72 6520 616e 6420 6166  ng before and af
-0001cf00: 7465 7220 7069 6373 0a20 2020 2020 2020  ter pics.       
-0001cf10: 2069 6620 7665 7262 6f73 653a 0a20 2020   if verbose:.   
-0001cf20: 2020 2020 2020 2020 2064 665b 636f 6c5d           df[col]
-0001cf30: 2e70 6c6f 7428 6b69 6e64 3d27 626f 7827  .plot(kind='box'
-0001cf40: 2c20 7469 746c 6520 3d20 2725 7320 6166  , title = '%s af
-0001cf50: 7465 7220 6361 7070 696e 6720 6f75 746c  ter capping outl
-0001cf60: 6965 7273 2720 2563 6f6c 2c20 6178 3d61  iers' %col, ax=a
-0001cf70: 7832 290a 2020 2020 2020 2020 2020 2020  x2).            
-0001cf80: 706c 742e 7368 6f77 2829 0a0a 2020 2020  plt.show()..    
-0001cf90: 2020 2020 2320 4c65 7427 7320 7361 7665      # Let's save
-0001cfa0: 2074 6865 206c 6973 7420 6f66 206f 7574   the list of out
-0001cfb0: 6c69 6572 7320 616e 6420 7365 6520 6966  liers and see if
-0001cfc0: 2074 6865 7265 2061 7265 2073 6f6d 6520   there are some 
-0001cfd0: 7769 7468 206f 7574 6c69 6572 7320 696e  with outliers in
-0001cfe0: 206d 756c 7469 706c 6520 636f 6c75 6d6e   multiple column
-0001cff0: 730a 2020 2020 2020 2020 6f75 746c 6965  s.        outlie
-0001d000: 725f 696e 6469 6365 732e 6578 7465 6e64  r_indices.extend
-0001d010: 286f 7574 6c69 6572 5f6c 6973 745f 636f  (outlier_list_co
-0001d020: 6c29 0a0a 2020 2020 2320 7365 6c65 6374  l)..    # select
-0001d030: 2063 6572 7461 696e 206f 6273 6572 7661   certain observa
-0001d040: 7469 6f6e 7320 636f 6e74 6169 6e69 6e67  tions containing
-0001d050: 206d 6f72 6520 7468 616e 206f 6e65 206f   more than one o
-0001d060: 7574 6c69 6572 2069 6e20 3220 636f 6c75  utlier in 2 colu
-0001d070: 6d6e 7320 6f72 206d 6f72 652e 2057 6520  mns or more. We 
-0001d080: 6361 6e20 6472 6f70 2074 6865 6d21 0a20  can drop them!. 
-0001d090: 2020 206f 7574 6c69 6572 5f69 6e64 6963     outlier_indic
-0001d0a0: 6573 203d 2043 6f75 6e74 6572 286f 7574  es = Counter(out
-0001d0b0: 6c69 6572 5f69 6e64 6963 6573 290a 2020  lier_indices).  
-0001d0c0: 2020 6d75 6c74 6970 6c65 5f6f 7574 6c69    multiple_outli
-0001d0d0: 6572 7320 3d20 6c69 7374 2820 6b20 666f  ers = list( k fo
-0001d0e0: 7220 6b2c 2076 2069 6e20 6f75 746c 6965  r k, v in outlie
-0001d0f0: 725f 696e 6469 6365 732e 6974 656d 7328  r_indices.items(
-0001d100: 2920 6966 2076 203e 2033 2029 0a20 2020  ) if v > 3 ).   
-0001d110: 2023 2323 206e 6f77 2064 726f 7020 7468   ### now drop th
-0001d120: 6573 6520 726f 7773 2061 6c74 6f67 6574  ese rows altoget
-0001d130: 6865 7220 2323 2323 0a20 2020 2069 6620  her ####.    if 
-0001d140: 6472 6f70 3a0a 2020 2020 2020 2020 7072  drop:.        pr
-0001d150: 696e 7428 2753 6861 7065 206f 6620 6461  int('Shape of da
-0001d160: 7461 6672 616d 6520 6265 666f 7265 206f  taframe before o
-0001d170: 7574 6c69 6572 7320 6265 696e 6720 6472  utliers being dr
-0001d180: 6f70 7065 643a 2025 7327 2025 2864 662e  opped: %s' %(df.
-0001d190: 7368 6170 652c 2929 0a20 2020 2020 2020  shape,)).       
-0001d1a0: 206e 756d 6265 725f 6f66 5f72 6f77 7320   number_of_rows 
-0001d1b0: 3d20 6466 2e73 6861 7065 5b30 5d0a 2020  = df.shape[0].  
-0001d1c0: 2020 2020 2020 6466 203d 2064 662e 6472        df = df.dr
-0001d1d0: 6f70 286d 756c 7469 706c 655f 6f75 746c  op(multiple_outl
-0001d1e0: 6965 7273 2c20 6178 6973 3d30 290a 2020  iers, axis=0).  
-0001d1f0: 2020 2020 2020 7072 696e 7428 2753 6861        print('Sha
-0001d200: 7065 206f 6620 6461 7461 6672 616d 6520  pe of dataframe 
-0001d210: 6166 7465 7220 6f75 746c 6965 7273 2062  after outliers b
-0001d220: 6569 6e67 2064 726f 7070 6564 3a20 2573  eing dropped: %s
-0001d230: 2720 2528 6466 2e73 6861 7065 2c29 290a  ' %(df.shape,)).
-0001d240: 2020 2020 2020 2020 7072 696e 7428 275c          print('\
-0001d250: 6e4e 756d 6265 725f 6f66 5f72 6f77 7320  nNumber_of_rows 
-0001d260: 7769 7468 206d 756c 7469 706c 6520 6f75  with multiple ou
-0001d270: 746c 6965 7273 2069 6e20 6d6f 7265 2074  tliers in more t
-0001d280: 6861 6e20 3320 636f 6c75 6d6e 7320 7768  han 3 columns wh
-0001d290: 6963 6820 7765 7265 2064 726f 7070 6564  ich were dropped
-0001d2a0: 203d 2025 6427 2025 286e 756d 6265 725f   = %d' %(number_
-0001d2b0: 6f66 5f72 6f77 732d 6466 2e73 6861 7065  of_rows-df.shape
-0001d2c0: 5b30 5d29 290a 2020 2020 7265 7475 726e  [0])).    return
-0001d2d0: 2064 660a 2323 2323 2323 2323 2323 2323   df.############
-0001d2e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001d2f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001d300: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001d310: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001d320: 2323 2323 230a 6465 6620 4544 415f 636c  #####.def EDA_cl
-0001d330: 6173 7369 6679 5f61 6e64 5f72 6574 7572  assify_and_retur
-0001d340: 6e5f 636f 6c73 5f62 795f 7479 7065 2864  n_cols_by_type(d
-0001d350: 6631 293a 0a20 2020 2022 2222 0a20 2020  f1):.    """.   
-0001d360: 2045 4441 2073 7461 6e64 7320 666f 7220   EDA stands for 
-0001d370: 4578 706c 6f72 6174 6f72 7920 6461 7461  Exploratory data
-0001d380: 2061 6e61 6c79 7369 732e 2054 6869 7320   analysis. This 
-0001d390: 6675 6e63 7469 6f6e 2070 6572 666f 726d  function perform
-0001d3a0: 7320 4544 4120 2d20 6865 6e63 6520 7468  s EDA - hence th
-0001d3b0: 6520 6e61 6d65 0a20 2020 2023 2323 2323  e name.    #####
-0001d3c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001d3d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001d3e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001d3f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001d400: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001d410: 2323 230a 2020 2020 5468 6973 2068 616e  ###.    This han
-0001d420: 6479 2066 756e 6374 696f 6e20 636c 6173  dy function clas
-0001d430: 7369 6669 6573 2079 6f75 7220 636f 6c75  sifies your colu
-0001d440: 6d6e 7320 696e 746f 2064 6966 6665 7265  mns into differe
-0001d450: 6e74 2074 7970 6573 203a 206d 616b 6520  nt types : make 
-0001d460: 7375 7265 2079 6f75 2073 656e 6420 6f6e  sure you send on
-0001d470: 6c79 2070 7265 6469 6374 6f72 732e 0a20  ly predictors.. 
-0001d480: 2020 2042 6577 6172 6520 7365 6e64 696e     Beware sendin
-0001d490: 6720 7461 7267 6574 2063 6f6c 756d 6e20  g target column 
-0001d4a0: 696e 746f 2074 6865 2064 6174 6166 7261  into the datafra
-0001d4b0: 6d65 2e20 596f 7520 646f 6e27 7420 7761  me. You don't wa
-0001d4c0: 6e74 2074 6f20 7374 6172 7420 6d6f 6469  nt to start modi
-0001d4d0: 6679 696e 6720 6974 2e0a 2020 2020 2323  fying it..    ##
-0001d4e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001d4f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001d500: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001d510: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001d520: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001d530: 2323 230a 2020 2020 4974 2072 6574 7572  ###.    It retur
-0001d540: 6e73 2061 206c 6973 7420 6f66 2063 6174  ns a list of cat
-0001d550: 6567 6f72 6963 616c 2063 6f6c 756d 6e73  egorical columns
-0001d560: 2c20 696e 7465 6765 7220 636f 6c73 2061  , integer cols a
-0001d570: 6e64 2066 6c6f 6174 2063 6f6c 756d 6e73  nd float columns
-0001d580: 2069 6e20 7468 6174 206f 7264 6572 2e0a   in that order..
-0001d590: 2020 2020 2222 220a 2020 2020 2323 2320      """.    ### 
-0001d5a0: 4c65 7427 7320 6669 6e64 2061 6c6c 2074  Let's find all t
-0001d5b0: 6865 2063 6174 6567 6f72 6963 616c 2065  he categorical e
-0001d5c0: 7863 6c75 6469 6e67 2069 6e74 6567 6572  xcluding integer
-0001d5d0: 2063 6f6c 756d 6e73 2069 6e20 6461 7461   columns in data
-0001d5e0: 7365 743a 2075 6e66 6f72 7475 6e61 7465  set: unfortunate
-0001d5f0: 6c79 206e 6f74 2061 6c6c 2069 6e74 6567  ly not all integ
-0001d600: 6572 7320 6172 6520 6361 7465 676f 7269  ers are categori
-0001d610: 6361 6c21 0a20 2020 2063 6174 636f 6c73  cal!.    catcols
-0001d620: 203d 2064 6631 2e73 656c 6563 745f 6474   = df1.select_dt
-0001d630: 7970 6573 2869 6e63 6c75 6465 3d27 6f62  ypes(include='ob
-0001d640: 6a65 6374 2729 2e63 6f6c 756d 6e73 2e74  ject').columns.t
-0001d650: 6f6c 6973 7428 2920 2b20 6466 312e 7365  olist() + df1.se
-0001d660: 6c65 6374 5f64 7479 7065 7328 696e 636c  lect_dtypes(incl
-0001d670: 7564 653d 2763 6174 6567 6f72 7927 292e  ude='category').
-0001d680: 636f 6c75 6d6e 732e 746f 6c69 7374 2829  columns.tolist()
-0001d690: 0a20 2020 2063 6174 7320 3d20 636f 7079  .    cats = copy
-0001d6a0: 2e64 6565 7063 6f70 7928 6361 7463 6f6c  .deepcopy(catcol
-0001d6b0: 7329 0a20 2020 206e 6c70 636f 6c73 203d  s).    nlpcols =
-0001d6c0: 205b 5d0a 2020 2020 666f 7220 6561 6368   [].    for each
-0001d6d0: 5f63 6174 2069 6e20 6361 7473 3a0a 2020  _cat in cats:.  
-0001d6e0: 2020 2020 2020 7472 793a 0a20 2020 2020        try:.     
-0001d6f0: 2020 2020 2020 2069 6620 6466 315b 5b65         if df1[[e
-0001d700: 6163 685f 6361 745d 5d2e 6669 6c6c 6e61  ach_cat]].fillna
-0001d710: 2827 6d69 7373 696e 6727 292e 6d61 7028  ('missing').map(
-0001d720: 6c65 6e29 2e6d 6561 6e28 2920 3e3d 2034  len).mean() >= 4
-0001d730: 303a 0a20 2020 2020 2020 2020 2020 2020  0:.             
-0001d740: 2020 206e 6c70 636f 6c73 2e61 7070 656e     nlpcols.appen
-0001d750: 6428 6561 6368 5f63 6174 290a 2020 2020  d(each_cat).    
-0001d760: 2020 2020 2020 2020 2020 2020 6361 7463              catc
-0001d770: 6f6c 732e 7265 6d6f 7665 2865 6163 685f  ols.remove(each_
-0001d780: 6361 7429 0a20 2020 2020 2020 2065 7863  cat).        exc
-0001d790: 6570 743a 0a20 2020 2020 2020 2020 2020  ept:.           
-0001d7a0: 2063 6f6e 7469 6e75 650a 2020 2020 696e   continue.    in
-0001d7b0: 7463 6f6c 7320 3d20 6466 312e 7365 6c65  tcols = df1.sele
-0001d7c0: 6374 5f64 7479 7065 7328 696e 636c 7564  ct_dtypes(includ
-0001d7d0: 653d 2769 6e74 6567 6572 2729 2e63 6f6c  e='integer').col
-0001d7e0: 756d 6e73 2e74 6f6c 6973 7428 290a 2020  umns.tolist().  
-0001d7f0: 2020 2320 6c65 7427 7320 6669 6e64 2061    # let's find a
-0001d800: 6c6c 2074 6865 2066 6c6f 6174 206e 756d  ll the float num
-0001d810: 6572 6963 2063 6f6c 756d 6e73 2069 6e20  eric columns in 
-0001d820: 6461 7461 0a20 2020 2066 6c6f 6174 636f  data.    floatco
-0001d830: 6c73 203d 2064 6631 2e73 656c 6563 745f  ls = df1.select_
-0001d840: 6474 7970 6573 2869 6e63 6c75 6465 3d27  dtypes(include='
-0001d850: 666c 6f61 7427 292e 636f 6c75 6d6e 732e  float').columns.
-0001d860: 746f 6c69 7374 2829 0a20 2020 2072 6574  tolist().    ret
-0001d870: 7572 6e20 6361 7463 6f6c 732c 2069 6e74  urn catcols, int
-0001d880: 636f 6c73 2c20 666c 6f61 7463 6f6c 732c  cols, floatcols,
-0001d890: 206e 6c70 636f 6c73 0a23 2323 2323 2323   nlpcols.#######
-0001d8a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001d8b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001d8c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001d8d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001d8e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001d8f0: 2323 2323 230a 6465 6620 4544 415f 636c  #####.def EDA_cl
-0001d900: 6173 7369 6679 5f66 6561 7475 7265 735f  assify_features_
-0001d910: 666f 725f 6465 6570 5f6c 6561 726e 696e  for_deep_learnin
-0001d920: 6728 7472 6169 6e2c 2074 6172 6765 742c  g(train, target,
-0001d930: 2069 6463 6f6c 7329 3a0a 2020 2020 2222   idcols):.    ""
-0001d940: 220a 2020 2020 2323 2323 2323 2323 2323  ".    ##########
+0001c280: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001c290: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001c2a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001c2b0: 2323 2323 2323 2323 2323 2323 2323 0a20  ##############. 
+0001c2c0: 2020 2054 6869 7320 6675 6e63 7469 6f6e     This function
+0001c2d0: 2067 6976 6573 2079 6f75 2074 6865 2063   gives you the c
+0001c2e0: 6f75 6e74 206f 6620 616c 6c20 7468 6520  ount of all the 
+0001c2f0: 726f 7773 2069 6e63 6c75 6469 6e67 206e  rows including n
+0001c300: 756c 6c20 726f 7773 2069 6e20 796f 7572  ull rows in your
+0001c310: 2064 6174 612e 0a20 2020 2049 7420 7265   data..    It re
+0001c320: 7475 726e 7320 6120 6461 7461 6672 616d  turns a datafram
+0001c330: 6520 7769 7468 2069 645f 636f 6c20 6173  e with id_col as
+0001c340: 2074 6865 2069 6e64 6578 2061 6e64 2074   the index and t
+0001c350: 6865 2063 6f75 6e74 7320 6f66 2072 6f77  he counts of row
+0001c360: 7320 2869 6e63 6c20 6e75 6c6c 2072 6f77  s (incl null row
+0001c370: 7329 2061 7320 6120 6e65 7720 636f 6c75  s) as a new colu
+0001c380: 6d6e 0a20 2020 2023 2323 2323 2323 2323  mn.    #########
+0001c390: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001c3a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001c3b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001c3c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001c3d0: 2323 2323 2323 2323 2323 2323 230a 2020  #############.  
+0001c3e0: 2020 2222 220a 2020 2020 6e65 775f 636f    """.    new_co
+0001c3f0: 6c20 3d20 2772 6f77 5f63 6f75 6e74 5f69  l = 'row_count_i
+0001c400: 6e63 6c5f 6e75 6c6c 5f72 6f77 7327 0a20  ncl_null_rows'. 
+0001c410: 2020 2069 6620 6973 696e 7374 616e 6365     if isinstance
+0001c420: 2869 645f 636f 6c2c 2073 7472 293a 0a20  (id_col, str):. 
+0001c430: 2020 2020 2020 2067 726f 7570 6279 5f63         groupby_c
+0001c440: 6f6c 756d 6e73 203d 2020 5b69 645f 636f  olumns =  [id_co
+0001c450: 6c5d 0a20 2020 2065 6c73 653a 0a20 2020  l].    else:.   
+0001c460: 2020 2020 2067 726f 7570 6279 5f63 6f6c       groupby_col
+0001c470: 756d 6e73 203d 2063 6f70 792e 6465 6570  umns = copy.deep
+0001c480: 636f 7079 2869 645f 636f 6c29 0a20 2020  copy(id_col).   
+0001c490: 2023 2323 206c 656e 2067 6976 6573 2079   ### len gives y
+0001c4a0: 6f75 2063 6f75 6e74 206f 6620 616c 6c20  ou count of all 
+0001c4b0: 7468 6520 726f 7773 2069 6e63 6c75 6469  the rows includi
+0001c4c0: 6e67 206e 756c 6c20 726f 7773 2069 6e20  ng null rows in 
+0001c4d0: 796f 7572 2064 6174 610a 2020 2020 6772  your data.    gr
+0001c4e0: 6f75 7065 645f 6c65 6e20 3d20 6466 742e  ouped_len = dft.
+0001c4f0: 6772 6f75 7062 7928 6772 6f75 7062 795f  groupby(groupby_
+0001c500: 636f 6c75 6d6e 7329 2e61 7070 6c79 286c  columns).apply(l
+0001c510: 656e 290a 2020 2020 6772 6f75 7065 645f  en).    grouped_
+0001c520: 7661 6c20 3d20 6772 6f75 7065 645f 6c65  val = grouped_le
+0001c530: 6e2e 7661 6c75 6573 0a20 2020 2067 726f  n.values.    gro
+0001c540: 7570 6564 5f6c 656e 203d 2070 642e 4461  uped_len = pd.Da
+0001c550: 7461 4672 616d 6528 6772 6f75 7065 645f  taFrame(grouped_
+0001c560: 7661 6c2c 2063 6f6c 756d 6e73 3d5b 6e65  val, columns=[ne
+0001c570: 775f 636f 6c5d 2c69 6e64 6578 3d67 726f  w_col],index=gro
+0001c580: 7570 6564 5f6c 656e 2e69 6e64 6578 290a  uped_len.index).
+0001c590: 2020 2020 7265 7475 726e 2067 726f 7570      return group
+0001c5a0: 6564 5f6c 656e 0a23 2323 2323 2323 2323  ed_len.#########
+0001c5b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001c5c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001c5d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001c5e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001c5f0: 2323 2323 2323 2323 0a23 2043 616e 2077  ########.# Can w
+0001c600: 6520 7365 6520 6966 2061 2066 6561 7475  e see if a featu
+0001c610: 7265 206f 7220 6665 6174 7572 6573 2068  re or features h
+0001c620: 6173 2073 6f6d 6520 6f75 746c 6965 7273  as some outliers
+0001c630: 2061 6e64 2068 6f77 2063 616e 2077 6520   and how can we 
+0001c640: 6361 7020 7468 656d 3f0a 6672 6f6d 2063  cap them?.from c
+0001c650: 6f6c 6c65 6374 696f 6e73 2069 6d70 6f72  ollections impor
+0001c660: 7420 436f 756e 7465 720a 6465 6620 4645  t Counter.def FE
+0001c670: 5f63 6170 7069 6e67 5f6f 7574 6c69 6572  _capping_outlier
+0001c680: 735f 6265 796f 6e64 5f49 5152 5f52 616e  s_beyond_IQR_Ran
+0001c690: 6765 2864 662c 2066 6561 7475 7265 732c  ge(df, features,
+0001c6a0: 2063 6170 5f61 745f 6e74 685f 6c61 7267   cap_at_nth_larg
+0001c6b0: 6573 743d 352c 2049 5152 5f6d 756c 7469  est=5, IQR_multi
+0001c6c0: 706c 6965 723d 312e 352c 0a20 2020 2020  plier=1.5,.     
+0001c6d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001c6e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+0001c6f0: 2020 2020 6472 6f70 3d46 616c 7365 2c20      drop=False, 
+0001c700: 7665 7262 6f73 653d 4661 6c73 6529 3a0a  verbose=False):.
+0001c710: 2020 2020 2222 220a 2020 2020 4645 2061      """.    FE a
+0001c720: 7420 7468 6520 6265 6769 6e6e 696e 6720  t the beginning 
+0001c730: 6f66 2066 756e 6374 696f 6e20 6e61 6d65  of function name
+0001c740: 2073 7461 6e64 7320 666f 7220 4665 6174   stands for Feat
+0001c750: 7572 6520 456e 6769 6e65 6572 696e 672e  ure Engineering.
+0001c760: 2046 4520 6675 6e63 7469 6f6e 7320 6164   FE functions ad
+0001c770: 6420 6f72 2064 726f 7020 6665 6174 7572  d or drop featur
+0001c780: 6573 2e0a 2020 2020 2323 2323 2323 2323  es..    ########
+0001c790: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001c7a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001c7b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001c7c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001c7d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001c7e0: 230a 2020 2020 5479 7069 6361 6c6c 7920  #.    Typically 
+0001c7f0: 7765 2074 6869 6e6b 206f 6620 6f75 746c  we think of outl
+0001c800: 6965 7273 2061 7320 6265 696e 6720 6f62  iers as being ob
+0001c810: 7365 7276 6174 696f 6e73 2062 6579 6f6e  servations beyon
+0001c820: 6420 7468 6520 312e 3520 496e 7465 7220  d the 1.5 Inter 
+0001c830: 5175 6172 7469 6c65 2052 616e 6765 2028  Quartile Range (
+0001c840: 4951 5229 0a20 2020 2042 7574 2074 6869  IQR).    But thi
+0001c850: 7320 6675 6e63 7469 6f6e 2077 696c 6c20  s function will 
+0001c860: 616c 6c6f 7720 796f 7520 746f 2063 6170  allow you to cap
+0001c870: 2061 6e79 206f 6273 6572 7661 7469 6f6e   any observation
+0001c880: 2074 6861 7420 6973 206d 756c 7469 706c   that is multipl
+0001c890: 6520 6f66 2049 5152 2072 616e 6765 2c20  e of IQR range, 
+0001c8a0: 7375 6368 2061 7320 312e 352c 2032 2c20  such as 1.5, 2, 
+0001c8b0: 6574 632e 0a20 2020 2049 6e20 6164 6469  etc..    In addi
+0001c8c0: 7469 6f6e 2c20 7468 6973 2075 7469 6c69  tion, this utili
+0001c8d0: 7479 2068 656c 7073 2079 6f75 2073 656c  ty helps you sel
+0001c8e0: 6563 7420 7468 6520 7661 6c75 6520 746f  ect the value to
+0001c8f0: 2063 6170 2069 7420 6174 2e0a 2020 2020   cap it at..    
+0001c900: 5468 6520 7661 6c75 6520 746f 2062 6520  The value to be 
+0001c910: 6361 7070 6564 2069 7320 6261 7365 6420  capped is based 
+0001c920: 6f6e 2022 6e22 2074 6861 7420 796f 7520  on "n" that you 
+0001c930: 696e 7075 742e 0a20 2020 206e 2072 6570  input..    n rep
+0001c940: 7265 7365 6e74 7320 7468 6520 6e74 685f  resents the nth_
+0001c950: 6c61 7267 6573 7420 6e75 6d62 6572 2062  largest number b
+0001c960: 656c 6f77 2074 6865 206d 6178 696d 756d  elow the maximum
+0001c970: 2076 616c 7565 2074 6f20 6361 7020 6174   value to cap at
+0001c980: 210a 2020 2020 4e6f 7469 6365 2074 6861  !.    Notice tha
+0001c990: 7420 6974 2064 6f65 7320 6e6f 7420 7075  t it does not pu
+0001c9a0: 7420 6120 666c 6f6f 7220 756e 6465 7220  t a floor under 
+0001c9b0: 6d69 6e69 6d75 6d73 2e20 596f 7520 6861  minimums. You ha
+0001c9c0: 7665 2074 6f20 646f 2074 6861 7420 796f  ve to do that yo
+0001c9d0: 7572 7365 6c66 2e0a 2020 2020 2263 6170  urself..    "cap
+0001c9e0: 5f61 745f 6e74 685f 6c61 7267 6573 7422  _at_nth_largest"
+0001c9f0: 2073 7065 6369 6669 6573 2074 6865 206d   specifies the m
+0001ca00: 6178 206e 756d 6265 7220 6265 6c6f 7720  ax number below 
+0001ca10: 7468 6520 6c61 7267 6573 7420 286d 6178  the largest (max
+0001ca20: 2920 6e75 6d62 6572 2069 6e20 796f 7572  ) number in your
+0001ca30: 2063 6f6c 756d 6e20 746f 2063 6170 2074   column to cap t
+0001ca40: 6861 7420 6665 6174 7572 652e 0a20 2020  hat feature..   
+0001ca50: 204f 7074 696f 6e61 6c6c 792c 2079 6f75   Optionally, you
+0001ca60: 2063 616e 2064 726f 7020 6365 7274 6169   can drop certai
+0001ca70: 6e20 6f62 7365 7276 6174 696f 6e73 2074  n observations t
+0001ca80: 6861 7420 6861 7665 2074 6f6f 206d 616e  hat have too man
+0001ca90: 7920 6f75 746c 6965 7273 2069 6e20 6174  y outliers in at
+0001caa0: 206c 6561 7374 2033 2063 6f6c 756d 6e73   least 3 columns
+0001cab0: 2e0a 2020 2020 2323 2323 2323 2323 2323  ..    ##########
+0001cac0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001cad0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001cae0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001caf0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001cb00: 2323 2323 2323 2323 2323 2323 2323 230a  ###############.
+0001cb10: 2020 2020 496e 7075 7473 3a0a 2020 2020      Inputs:.    
+0001cb20: 6466 203a 2070 616e 6461 7320 4461 7461  df : pandas Data
+0001cb30: 4672 616d 650a 2020 2020 6665 6174 7572  Frame.    featur
+0001cb40: 6573 3a20 6120 7369 6e67 6c65 2063 6f6c  es: a single col
+0001cb50: 756d 6e20 6f72 2061 206c 6973 7420 6f66  umn or a list of
+0001cb60: 2063 6f6c 756d 6e73 2069 6e20 796f 7572   columns in your
+0001cb70: 2044 6174 6146 7261 6d65 0a20 2020 2063   DataFrame.    c
+0001cb80: 6170 5f61 745f 6e74 685f 6c61 7267 6573  ap_at_nth_larges
+0001cb90: 743a 2064 6566 6175 6c74 2069 7320 3520  t: default is 5 
+0001cba0: 3d20 796f 7520 6361 6e20 7365 7420 6974  = you can set it
+0001cbb0: 2074 6f20 616e 7920 696e 7465 6765 7220   to any integer 
+0001cbc0: 7375 6368 2061 7320 312c 2032 2c20 332c  such as 1, 2, 3,
+0001cbd0: 2034 2c20 352c 2065 7463 2e0a 2020 2020   4, 5, etc..    
+0001cbe0: 4951 525f 6d75 6c74 6970 6c69 6572 3a20  IQR_multiplier: 
+0001cbf0: 6465 6661 756c 7420 6973 2031 2e35 203d  default is 1.5 =
+0001cc00: 2062 7574 2079 6f75 2063 616e 2073 6574   but you can set
+0001cc10: 2069 7420 746f 2061 6e79 2066 6c6f 6174   it to any float
+0001cc20: 2076 616c 7565 2073 7563 6820 6173 2031   value such as 1
+0001cc30: 2c20 312e 3235 2e20 312e 352c 2032 2e30  , 1.25. 1.5, 2.0
+0001cc40: 2c20 6574 632e 0a0a 2020 2020 4f75 7470  , etc...    Outp
+0001cc50: 7574 733a 0a20 2020 2064 663a 2070 616e  uts:.    df: pan
+0001cc60: 6461 7320 4461 7461 4672 616d 650a 2020  das DataFrame.  
+0001cc70: 2020 4974 2072 6574 7572 6e73 2074 6865    It returns the
+0001cc80: 2073 616d 6520 6461 7461 6672 616d 6520   same dataframe 
+0001cc90: 6173 2079 6f75 2069 6e70 7574 2075 6e6c  as you input unl
+0001cca0: 6573 7320 796f 7520 6368 616e 6765 2064  ess you change d
+0001ccb0: 726f 7020 746f 2054 7275 6520 696e 2074  rop to True in t
+0001ccc0: 6865 2069 6e70 7574 2061 7267 756d 656e  he input argumen
+0001ccd0: 742e 0a0a 2020 2020 4f70 7469 6f6e 616c  t...    Optional
+0001cce0: 6c79 2c20 6974 2063 616e 2064 726f 7020  ly, it can drop 
+0001ccf0: 6365 7274 6169 6e20 726f 7773 2074 6861  certain rows tha
+0001cd00: 7420 6861 7665 2074 6f6f 206d 616e 7920  t have too many 
+0001cd10: 6f75 746c 6965 7273 2069 6e20 6174 206c  outliers in at l
+0001cd20: 6561 7374 2033 2063 6f6c 756d 6e73 2073  east 3 columns s
+0001cd30: 696d 756c 7461 6e65 6f75 736c 792e 0a20  imultaneously.. 
+0001cd40: 2020 2049 6620 6472 6f70 3d54 7275 652c     If drop=True,
+0001cd50: 2069 7420 7769 6c6c 2072 6574 7572 6e20   it will return 
+0001cd60: 6120 736d 616c 6c65 7220 6e75 6d62 6572  a smaller number
+0001cd70: 206f 6620 726f 7773 2069 6e20 796f 7572   of rows in your
+0001cd80: 2064 6174 6166 7261 6d65 2074 6861 6e20   dataframe than 
+0001cd90: 7768 6174 2079 6f75 2073 656e 7420 696e  what you sent in
+0001cda0: 2e20 4265 2063 6172 6566 756c 210a 2020  . Be careful!.  
+0001cdb0: 2020 2323 2323 2323 2323 2323 2323 2323    ##############
+0001cdc0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001cdd0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001cde0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001cdf0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001ce00: 2323 2323 2323 2323 2323 230a 2020 2020  ###########.    
+0001ce10: 2222 220a 2020 2020 6f75 746c 6965 725f  """.    outlier_
+0001ce20: 696e 6469 6365 7320 3d20 5b5d 0a20 2020  indices = [].   
+0001ce30: 2064 6620 3d20 6466 2e63 6f70 7928 6465   df = df.copy(de
+0001ce40: 6570 3d54 7275 6529 0a20 2020 2069 6620  ep=True).    if 
+0001ce50: 6973 696e 7374 616e 6365 2866 6561 7475  isinstance(featu
+0001ce60: 7265 732c 2073 7472 293a 0a20 2020 2020  res, str):.     
+0001ce70: 2020 2066 6561 7475 7265 7320 3d20 5b66     features = [f
+0001ce80: 6561 7475 7265 735d 0a20 2020 2023 2069  eatures].    # i
+0001ce90: 7465 7261 7465 206f 7665 7220 6665 6174  terate over feat
+0001cea0: 7572 6573 2863 6f6c 756d 6e73 290a 2020  ures(columns).  
+0001ceb0: 2020 666f 7220 636f 6c20 696e 2066 6561    for col in fea
+0001cec0: 7475 7265 733a 0a20 2020 2020 2020 2023  tures:.        #
+0001ced0: 2323 2074 6869 7320 6973 2068 6f77 2074  ## this is how t
+0001cee0: 6865 2063 6f6c 756d 6e20 6c6f 6f6b 7320  he column looks 
+0001cef0: 6e6f 7720 6265 666f 7265 2063 6170 7069  now before cappi
+0001cf00: 6e67 206f 7574 6c69 6572 730a 2020 2020  ng outliers.    
+0001cf10: 2020 2020 6966 2076 6572 626f 7365 3a0a      if verbose:.
+0001cf20: 2020 2020 2020 2020 2020 2020 6669 672c              fig,
+0001cf30: 2028 6178 312c 6178 3229 203d 2070 6c74   (ax1,ax2) = plt
+0001cf40: 2e73 7562 706c 6f74 7328 312c 322c 6669  .subplots(1,2,fi
+0001cf50: 6773 697a 653d 2831 322c 3529 290a 2020  gsize=(12,5)).  
+0001cf60: 2020 2020 2020 2020 2020 6466 5b63 6f6c            df[col
+0001cf70: 5d2e 706c 6f74 286b 696e 643d 2762 6f78  ].plot(kind='box
+0001cf80: 272c 2074 6974 6c65 203d 2027 2573 2062  ', title = '%s b
+0001cf90: 6566 6f72 6520 6361 7070 696e 6720 6f75  efore capping ou
+0001cfa0: 746c 6965 7273 2720 2563 6f6c 2c20 6178  tliers' %col, ax
+0001cfb0: 3d61 7831 290a 2020 2020 2020 2020 2320  =ax1).        # 
+0001cfc0: 3173 7420 7175 6172 7469 6c65 2028 3235  1st quartile (25
+0001cfd0: 2529 0a20 2020 2020 2020 2051 3120 3d20  %).        Q1 = 
+0001cfe0: 6e70 2e70 6572 6365 6e74 696c 6528 6466  np.percentile(df
+0001cff0: 5b63 6f6c 5d2c 2032 3529 0a20 2020 2020  [col], 25).     
+0001d000: 2020 2023 2033 7264 2071 7561 7274 696c     # 3rd quartil
+0001d010: 6520 2837 3525 290a 2020 2020 2020 2020  e (75%).        
+0001d020: 5133 203d 206e 702e 7065 7263 656e 7469  Q3 = np.percenti
+0001d030: 6c65 2864 665b 636f 6c5d 2c37 3529 0a20  le(df[col],75). 
+0001d040: 2020 2020 2020 2023 2049 6e74 6572 7175         # Interqu
+0001d050: 6172 7469 6c65 2072 616e 6765 2028 4951  artile range (IQ
+0001d060: 5229 0a20 2020 2020 2020 2049 5152 203d  R).        IQR =
+0001d070: 2051 3320 2d20 5131 0a0a 2020 2020 2020   Q3 - Q1..      
+0001d080: 2020 2320 6f75 746c 6965 7220 7374 6570    # outlier step
+0001d090: 2075 7369 6e67 206d 756c 7469 706c 6965   using multiplie
+0001d0a0: 720a 2020 2020 2020 2020 6f75 746c 6965  r.        outlie
+0001d0b0: 725f 7374 6570 203d 2049 5152 5f6d 756c  r_step = IQR_mul
+0001d0c0: 7469 706c 6965 7220 2a20 4951 520a 0a20  tiplier * IQR.. 
+0001d0d0: 2020 2020 2020 206c 6f77 6572 5f6c 696d         lower_lim
+0001d0e0: 6974 203d 2051 3120 2d20 6f75 746c 6965  it = Q1 - outlie
+0001d0f0: 725f 7374 6570 0a20 2020 2020 2020 2075  r_step.        u
+0001d100: 7070 6572 5f6c 696d 6974 203d 2051 3320  pper_limit = Q3 
+0001d110: 2b20 6f75 746c 6965 725f 7374 6570 0a0a  + outlier_step..
+0001d120: 2020 2020 2020 2020 2320 4465 7465 726d          # Determ
+0001d130: 696e 6520 6120 6c69 7374 206f 6620 696e  ine a list of in
+0001d140: 6469 6365 7320 6f66 206f 7574 6c69 6572  dices of outlier
+0001d150: 7320 666f 7220 6665 6174 7572 6520 636f  s for feature co
+0001d160: 6c0a 2020 2020 2020 2020 6f75 746c 6965  l.        outlie
+0001d170: 725f 6c69 7374 5f63 6f6c 203d 2064 665b  r_list_col = df[
+0001d180: 2864 665b 636f 6c5d 203c 206c 6f77 6572  (df[col] < lower
+0001d190: 5f6c 696d 6974 2920 7c20 2864 665b 636f  _limit) | (df[co
+0001d1a0: 6c5d 203e 2075 7070 6572 5f6c 696d 6974  l] > upper_limit
+0001d1b0: 2029 5d2e 696e 6465 780a 0a20 2020 2020   )].index..     
+0001d1c0: 2020 2023 2323 2043 6170 7069 6e67 2075     ### Capping u
+0001d1d0: 7369 6e67 2074 6865 206e 206c 6172 6765  sing the n large
+0001d1e0: 7374 2076 616c 7565 2062 6173 6564 206f  st value based o
+0001d1f0: 6e20 6e20 6769 7665 6e20 696e 2069 6e70  n n given in inp
+0001d200: 7574 2e0a 2020 2020 2020 2020 6d61 7876  ut..        maxv
+0001d210: 616c 203d 2064 665b 636f 6c5d 2e6d 6178  al = df[col].max
+0001d220: 2829 2020 2323 2077 6861 7420 6973 2074  ()  ## what is t
+0001d230: 6865 206d 6178 696d 756d 2076 616c 7565  he maximum value
+0001d240: 2069 6e20 7468 6973 2063 6f6c 756d 6e3f   in this column?
+0001d250: 0a20 2020 2020 2020 206e 756d 5f6d 6178  .        num_max
+0001d260: 7320 3d20 6466 5b64 665b 636f 6c5d 3d3d  s = df[df[col]==
+0001d270: 6d61 7876 616c 5d2e 7368 6170 655b 305d  maxval].shape[0]
+0001d280: 2023 2320 6e75 6d62 6572 206f 6620 726f   ## number of ro
+0001d290: 7773 2074 6861 7420 6861 7665 206d 6178  ws that have max
+0001d2a0: 2076 616c 7565 0a20 2020 2020 2020 2023   value.        #
+0001d2b0: 2323 2066 696e 6420 7468 6520 6e5f 6c61  ## find the n_la
+0001d2c0: 7267 6573 7420 7661 6c75 6573 2061 6674  rgest values aft
+0001d2d0: 6572 2074 6865 206d 6178 696d 756d 2076  er the maximum v
+0001d2e0: 616c 7565 2062 6173 6564 206f 6e20 6769  alue based on gi
+0001d2f0: 7665 6e20 696e 7075 7420 6e0a 2020 2020  ven input n.    
+0001d300: 2020 2020 6e75 6d5f 6c61 7267 6573 745f      num_largest_
+0001d310: 6166 7465 725f 6d61 7820 3d20 6e75 6d5f  after_max = num_
+0001d320: 6d61 7873 202b 2063 6170 5f61 745f 6e74  maxs + cap_at_nt
+0001d330: 685f 6c61 7267 6573 740a 2020 2020 2020  h_largest.      
+0001d340: 2020 6361 7070 6564 5f76 616c 7565 203d    capped_value =
+0001d350: 2064 665b 636f 6c5d 2e6e 6c61 7267 6573   df[col].nlarges
+0001d360: 7428 6e75 6d5f 6c61 7267 6573 745f 6166  t(num_largest_af
+0001d370: 7465 725f 6d61 7829 2e69 6c6f 635b 2d31  ter_max).iloc[-1
+0001d380: 5d20 2323 2074 6869 7320 6973 2074 6865  ] ## this is the
+0001d390: 2076 616c 7565 2077 6520 6361 7020 6974   value we cap it
+0001d3a0: 2061 6761 696e 7374 0a20 2020 2020 2020   against.       
+0001d3b0: 2064 662e 6c6f 635b 6466 5b63 6f6c 5d3d   df.loc[df[col]=
+0001d3c0: 3d6d 6178 7661 6c2c 2063 6f6c 5d20 3d20  =maxval, col] = 
+0001d3d0: 2063 6170 7065 645f 7661 6c75 6520 2323   capped_value ##
+0001d3e0: 206d 6178 696d 756d 2076 616c 7565 7320   maximum values 
+0001d3f0: 6172 6520 6e6f 7720 6361 7070 6564 0a20  are now capped. 
+0001d400: 2020 2020 2020 2023 2323 2079 6f75 2061         ### you a
+0001d410: 7265 206e 6f77 2067 6f6f 6420 746f 2067  re now good to g
+0001d420: 6f20 2d20 796f 7520 6361 6e20 7368 6f77  o - you can show
+0001d430: 2068 6f77 2074 6865 7920 6172 6520 6361   how they are ca
+0001d440: 7070 6564 2075 7369 6e67 2062 6566 6f72  pped using befor
+0001d450: 6520 616e 6420 6166 7465 7220 7069 6373  e and after pics
+0001d460: 0a20 2020 2020 2020 2069 6620 7665 7262  .        if verb
+0001d470: 6f73 653a 0a20 2020 2020 2020 2020 2020  ose:.           
+0001d480: 2064 665b 636f 6c5d 2e70 6c6f 7428 6b69   df[col].plot(ki
+0001d490: 6e64 3d27 626f 7827 2c20 7469 746c 6520  nd='box', title 
+0001d4a0: 3d20 2725 7320 6166 7465 7220 6361 7070  = '%s after capp
+0001d4b0: 696e 6720 6f75 746c 6965 7273 2720 2563  ing outliers' %c
+0001d4c0: 6f6c 2c20 6178 3d61 7832 290a 2020 2020  ol, ax=ax2).    
+0001d4d0: 2020 2020 2020 2020 706c 742e 7368 6f77          plt.show
+0001d4e0: 2829 0a0a 2020 2020 2020 2020 2320 4c65  ()..        # Le
+0001d4f0: 7427 7320 7361 7665 2074 6865 206c 6973  t's save the lis
+0001d500: 7420 6f66 206f 7574 6c69 6572 7320 616e  t of outliers an
+0001d510: 6420 7365 6520 6966 2074 6865 7265 2061  d see if there a
+0001d520: 7265 2073 6f6d 6520 7769 7468 206f 7574  re some with out
+0001d530: 6c69 6572 7320 696e 206d 756c 7469 706c  liers in multipl
+0001d540: 6520 636f 6c75 6d6e 730a 2020 2020 2020  e columns.      
+0001d550: 2020 6f75 746c 6965 725f 696e 6469 6365    outlier_indice
+0001d560: 732e 6578 7465 6e64 286f 7574 6c69 6572  s.extend(outlier
+0001d570: 5f6c 6973 745f 636f 6c29 0a0a 2020 2020  _list_col)..    
+0001d580: 2320 7365 6c65 6374 2063 6572 7461 696e  # select certain
+0001d590: 206f 6273 6572 7661 7469 6f6e 7320 636f   observations co
+0001d5a0: 6e74 6169 6e69 6e67 206d 6f72 6520 7468  ntaining more th
+0001d5b0: 616e 206f 6e65 206f 7574 6c69 6572 2069  an one outlier i
+0001d5c0: 6e20 3220 636f 6c75 6d6e 7320 6f72 206d  n 2 columns or m
+0001d5d0: 6f72 652e 2057 6520 6361 6e20 6472 6f70  ore. We can drop
+0001d5e0: 2074 6865 6d21 0a20 2020 206f 7574 6c69   them!.    outli
+0001d5f0: 6572 5f69 6e64 6963 6573 203d 2043 6f75  er_indices = Cou
+0001d600: 6e74 6572 286f 7574 6c69 6572 5f69 6e64  nter(outlier_ind
+0001d610: 6963 6573 290a 2020 2020 6d75 6c74 6970  ices).    multip
+0001d620: 6c65 5f6f 7574 6c69 6572 7320 3d20 6c69  le_outliers = li
+0001d630: 7374 2820 6b20 666f 7220 6b2c 2076 2069  st( k for k, v i
+0001d640: 6e20 6f75 746c 6965 725f 696e 6469 6365  n outlier_indice
+0001d650: 732e 6974 656d 7328 2920 6966 2076 203e  s.items() if v >
+0001d660: 2033 2029 0a20 2020 2023 2323 206e 6f77   3 ).    ### now
+0001d670: 2064 726f 7020 7468 6573 6520 726f 7773   drop these rows
+0001d680: 2061 6c74 6f67 6574 6865 7220 2323 2323   altogether ####
+0001d690: 0a20 2020 2069 6620 6472 6f70 3a0a 2020  .    if drop:.  
+0001d6a0: 2020 2020 2020 7072 696e 7428 2753 6861        print('Sha
+0001d6b0: 7065 206f 6620 6461 7461 6672 616d 6520  pe of dataframe 
+0001d6c0: 6265 666f 7265 206f 7574 6c69 6572 7320  before outliers 
+0001d6d0: 6265 696e 6720 6472 6f70 7065 643a 2025  being dropped: %
+0001d6e0: 7327 2025 2864 662e 7368 6170 652c 2929  s' %(df.shape,))
+0001d6f0: 0a20 2020 2020 2020 206e 756d 6265 725f  .        number_
+0001d700: 6f66 5f72 6f77 7320 3d20 6466 2e73 6861  of_rows = df.sha
+0001d710: 7065 5b30 5d0a 2020 2020 2020 2020 6466  pe[0].        df
+0001d720: 203d 2064 662e 6472 6f70 286d 756c 7469   = df.drop(multi
+0001d730: 706c 655f 6f75 746c 6965 7273 2c20 6178  ple_outliers, ax
+0001d740: 6973 3d30 290a 2020 2020 2020 2020 7072  is=0).        pr
+0001d750: 696e 7428 2753 6861 7065 206f 6620 6461  int('Shape of da
+0001d760: 7461 6672 616d 6520 6166 7465 7220 6f75  taframe after ou
+0001d770: 746c 6965 7273 2062 6569 6e67 2064 726f  tliers being dro
+0001d780: 7070 6564 3a20 2573 2720 2528 6466 2e73  pped: %s' %(df.s
+0001d790: 6861 7065 2c29 290a 2020 2020 2020 2020  hape,)).        
+0001d7a0: 7072 696e 7428 275c 6e4e 756d 6265 725f  print('\nNumber_
+0001d7b0: 6f66 5f72 6f77 7320 7769 7468 206d 756c  of_rows with mul
+0001d7c0: 7469 706c 6520 6f75 746c 6965 7273 2069  tiple outliers i
+0001d7d0: 6e20 6d6f 7265 2074 6861 6e20 3320 636f  n more than 3 co
+0001d7e0: 6c75 6d6e 7320 7768 6963 6820 7765 7265  lumns which were
+0001d7f0: 2064 726f 7070 6564 203d 2025 6427 2025   dropped = %d' %
+0001d800: 286e 756d 6265 725f 6f66 5f72 6f77 732d  (number_of_rows-
+0001d810: 6466 2e73 6861 7065 5b30 5d29 290a 2020  df.shape[0])).  
+0001d820: 2020 7265 7475 726e 2064 660a 2323 2323    return df.####
+0001d830: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001d840: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001d850: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001d860: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001d870: 2323 2323 2323 2323 2323 2323 230a 6465  #############.de
+0001d880: 6620 4544 415f 636c 6173 7369 6679 5f61  f EDA_classify_a
+0001d890: 6e64 5f72 6574 7572 6e5f 636f 6c73 5f62  nd_return_cols_b
+0001d8a0: 795f 7479 7065 2864 6631 293a 0a20 2020  y_type(df1):.   
+0001d8b0: 2022 2222 0a20 2020 2045 4441 2073 7461   """.    EDA sta
+0001d8c0: 6e64 7320 666f 7220 4578 706c 6f72 6174  nds for Explorat
+0001d8d0: 6f72 7920 6461 7461 2061 6e61 6c79 7369  ory data analysi
+0001d8e0: 732e 2054 6869 7320 6675 6e63 7469 6f6e  s. This function
+0001d8f0: 2070 6572 666f 726d 7320 4544 4120 2d20   performs EDA - 
+0001d900: 6865 6e63 6520 7468 6520 6e61 6d65 0a20  hence the name. 
+0001d910: 2020 2023 2323 2323 2323 2323 2323 2323     #############
+0001d920: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001d930: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001d940: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 0001d950: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001d960: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001d970: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001d980: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001d990: 2323 2323 2323 2323 2323 2323 0a20 2020  ############.   
-0001d9a0: 2054 6869 7320 6973 2061 2073 696d 706c   This is a simpl
-0001d9b0: 6520 6d65 7468 6f64 206f 6620 636c 6173  e method of clas
-0001d9c0: 7369 6679 696e 6720 6665 6174 7572 6573  sifying features
-0001d9d0: 2069 6e74 6f20 3420 7479 7065 733a 2063   into 4 types: c
-0001d9e0: 6174 732c 2069 6e74 6567 6572 732c 2066  ats, integers, f
-0001d9f0: 6c6f 6174 7320 616e 6420 4e4c 5073 0a20  loats and NLPs. 
-0001da00: 2020 2054 6869 7320 6973 206e 6565 6465     This is neede
-0001da10: 6420 666f 7220 6465 6570 206c 6561 726e  d for deep learn
-0001da20: 696e 6720 7072 6f62 6c65 6d73 2077 6865  ing problems whe
-0001da30: 7265 2077 6520 6e65 6564 2066 6577 6572  re we need fewer
-0001da40: 2074 7970 6573 206f 6620 7661 7269 6162   types of variab
-0001da50: 6c65 7320 746f 2074 7261 6e73 666f 726d  les to transform
-0001da60: 2e0a 2020 2020 2323 2323 2323 2323 2323  ..    ##########
+0001d960: 2323 2323 2323 2323 2323 230a 2020 2020  ###########.    
+0001d970: 5468 6973 2068 616e 6479 2066 756e 6374  This handy funct
+0001d980: 696f 6e20 636c 6173 7369 6669 6573 2079  ion classifies y
+0001d990: 6f75 7220 636f 6c75 6d6e 7320 696e 746f  our columns into
+0001d9a0: 2064 6966 6665 7265 6e74 2074 7970 6573   different types
+0001d9b0: 203a 206d 616b 6520 7375 7265 2079 6f75   : make sure you
+0001d9c0: 2073 656e 6420 6f6e 6c79 2070 7265 6469   send only predi
+0001d9d0: 6374 6f72 732e 0a20 2020 2042 6577 6172  ctors..    Bewar
+0001d9e0: 6520 7365 6e64 696e 6720 7461 7267 6574  e sending target
+0001d9f0: 2063 6f6c 756d 6e20 696e 746f 2074 6865   column into the
+0001da00: 2064 6174 6166 7261 6d65 2e20 596f 7520   dataframe. You 
+0001da10: 646f 6e27 7420 7761 6e74 2074 6f20 7374  don't want to st
+0001da20: 6172 7420 6d6f 6469 6679 696e 6720 6974  art modifying it
+0001da30: 2e0a 2020 2020 2323 2323 2323 2323 2323  ..    ##########
+0001da40: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001da50: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001da60: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 0001da70: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001da80: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001da90: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001daa0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001dab0: 2323 2323 2323 2323 2323 2323 0a20 2020  ############.   
-0001dac0: 2022 2222 0a20 2020 2023 2323 2054 6573   """.    ### Tes
-0001dad0: 7420 4c61 6265 6c65 7220 6973 2061 2076  t Labeler is a v
-0001dae0: 6572 7920 696d 706f 7274 616e 7420 6469  ery important di
-0001daf0: 6374 696f 6e61 7279 2074 6861 7420 7769  ctionary that wi
-0001db00: 6c6c 2068 656c 7020 7472 616e 7366 6f72  ll help transfor
-0001db10: 6d20 7465 7374 2064 6174 6120 7361 6d65  m test data same
-0001db20: 2061 7320 7472 6169 6e20 2323 2323 0a20   as train ####. 
-0001db30: 2020 2074 6573 745f 6c61 6265 6c65 7220     test_labeler 
-0001db40: 3d20 6465 6661 756c 7464 6963 7428 6c69  = defaultdict(li
-0001db50: 7374 290a 0a20 2020 2023 2323 2320 616c  st)..    #### al
-0001db60: 6c20 636f 6c75 6d6e 7320 6172 6520 6665  l columns are fe
-0001db70: 6174 7572 6573 2065 7863 6570 7420 7468  atures except th
-0001db80: 6520 7461 7267 6574 2063 6f6c 756d 6e20  e target column 
-0001db90: 616e 6420 7468 6520 666f 6c64 7320 636f  and the folds co
-0001dba0: 6c75 6d6e 2023 2323 0a20 2020 2069 6620  lumn ###.    if 
-0001dbb0: 6973 696e 7374 616e 6365 2874 6172 6765  isinstance(targe
-0001dbc0: 742c 2073 7472 293a 0a20 2020 2020 2020  t, str):.       
-0001dbd0: 2066 6561 7475 7265 7320 3d20 5b78 2066   features = [x f
-0001dbe0: 6f72 2078 2069 6e20 6c69 7374 2874 7261  or x in list(tra
-0001dbf0: 696e 2920 6966 2078 206e 6f74 2069 6e20  in) if x not in 
-0001dc00: 5b74 6172 6765 745d 2b69 6463 6f6c 735d  [target]+idcols]
-0001dc10: 0a20 2020 2065 6c73 653a 0a20 2020 2020  .    else:.     
-0001dc20: 2020 2023 2323 2069 6e20 7468 6973 2063     ### in this c
-0001dc30: 6173 6520 7461 7267 6574 2069 7320 6120  ase target is a 
-0001dc40: 6c69 7374 2061 6e64 2068 656e 6365 2063  list and hence c
-0001dc50: 616e 2062 6520 6164 6465 6420 746f 2069  an be added to i
-0001dc60: 6463 6f6c 730a 2020 2020 2020 2020 6665  dcols.        fe
-0001dc70: 6174 7572 6573 203d 205b 7820 666f 7220  atures = [x for 
-0001dc80: 7820 696e 206c 6973 7428 7472 6169 6e29  x in list(train)
-0001dc90: 2069 6620 7820 6e6f 7420 696e 2074 6172   if x not in tar
-0001dca0: 6765 742b 6964 636f 6c73 5d0a 0a20 2020  get+idcols]..   
-0001dcb0: 2023 2323 2066 6972 7374 2066 696e 6420   ### first find 
-0001dcc0: 616c 6c20 7468 6520 7479 7065 7320 6f66  all the types of
-0001dcd0: 2063 6f6c 756d 6e73 2069 6e20 796f 7572   columns in your
-0001dce0: 2064 6174 6120 7365 7420 2323 2323 0a20   data set ####. 
-0001dcf0: 2020 2063 6174 732c 2069 6e74 732c 2066     cats, ints, f
-0001dd00: 6c6f 6174 732c 206e 6c70 7320 3d20 4544  loats, nlps = ED
-0001dd10: 415f 636c 6173 7369 6679 5f61 6e64 5f72  A_classify_and_r
-0001dd20: 6574 7572 6e5f 636f 6c73 5f62 795f 7479  eturn_cols_by_ty
-0001dd30: 7065 2874 7261 696e 5b66 6561 7475 7265  pe(train[feature
-0001dd40: 735d 290a 0a20 2020 206e 756d 6572 6963  s])..    numeric
-0001dd50: 5f66 6561 7475 7265 7320 3d20 696e 7473  _features = ints
-0001dd60: 202b 2066 6c6f 6174 730a 2020 2020 6361   + floats.    ca
-0001dd70: 7465 676f 7269 6361 6c73 5f66 6561 7475  tegoricals_featu
-0001dd80: 7265 7320 3d20 636f 7079 2e64 6565 7063  res = copy.deepc
-0001dd90: 6f70 7928 6361 7473 290a 2020 2020 6e6c  opy(cats).    nl
-0001dda0: 705f 6665 6174 7572 6573 203d 2063 6f70  p_features = cop
-0001ddb0: 792e 6465 6570 636f 7079 286e 6c70 7329  y.deepcopy(nlps)
-0001ddc0: 0a0a 2020 2020 7465 7374 5f6c 6162 656c  ..    test_label
-0001ddd0: 6572 5b27 6361 7465 676f 7269 6361 6c73  er['categoricals
-0001dde0: 5f66 6561 7475 7265 7327 5d20 3d20 6361  _features'] = ca
-0001ddf0: 7465 676f 7269 6361 6c73 5f66 6561 7475  tegoricals_featu
-0001de00: 7265 730a 2020 2020 7465 7374 5f6c 6162  res.    test_lab
-0001de10: 656c 6572 5b27 6e75 6d65 7269 635f 6665  eler['numeric_fe
-0001de20: 6174 7572 6573 275d 203d 206e 756d 6572  atures'] = numer
-0001de30: 6963 5f66 6561 7475 7265 730a 2020 2020  ic_features.    
-0001de40: 7465 7374 5f6c 6162 656c 6572 5b27 6e6c  test_labeler['nl
-0001de50: 705f 6665 6174 7572 6573 275d 203d 206e  p_features'] = n
-0001de60: 6c70 5f66 6561 7475 7265 730a 0a20 2020  lp_features..   
-0001de70: 2072 6574 7572 6e20 6361 7473 2c20 696e   return cats, in
-0001de80: 7473 2c20 666c 6f61 7473 2c20 6e6c 7073  ts, floats, nlps
-0001de90: 0a23 2323 2323 2323 2323 2323 2323 2323  .###############
+0001da80: 2323 2323 2323 2323 2323 230a 2020 2020  ###########.    
+0001da90: 4974 2072 6574 7572 6e73 2061 206c 6973  It returns a lis
+0001daa0: 7420 6f66 2063 6174 6567 6f72 6963 616c  t of categorical
+0001dab0: 2063 6f6c 756d 6e73 2c20 696e 7465 6765   columns, intege
+0001dac0: 7220 636f 6c73 2061 6e64 2066 6c6f 6174  r cols and float
+0001dad0: 2063 6f6c 756d 6e73 2069 6e20 7468 6174   columns in that
+0001dae0: 206f 7264 6572 2e0a 2020 2020 2222 220a   order..    """.
+0001daf0: 2020 2020 2323 2320 4c65 7427 7320 6669      ### Let's fi
+0001db00: 6e64 2061 6c6c 2074 6865 2063 6174 6567  nd all the categ
+0001db10: 6f72 6963 616c 2065 7863 6c75 6469 6e67  orical excluding
+0001db20: 2069 6e74 6567 6572 2063 6f6c 756d 6e73   integer columns
+0001db30: 2069 6e20 6461 7461 7365 743a 2075 6e66   in dataset: unf
+0001db40: 6f72 7475 6e61 7465 6c79 206e 6f74 2061  ortunately not a
+0001db50: 6c6c 2069 6e74 6567 6572 7320 6172 6520  ll integers are 
+0001db60: 6361 7465 676f 7269 6361 6c21 0a20 2020  categorical!.   
+0001db70: 2063 6174 636f 6c73 203d 2064 6631 2e73   catcols = df1.s
+0001db80: 656c 6563 745f 6474 7970 6573 2869 6e63  elect_dtypes(inc
+0001db90: 6c75 6465 3d27 6f62 6a65 6374 2729 2e63  lude='object').c
+0001dba0: 6f6c 756d 6e73 2e74 6f6c 6973 7428 2920  olumns.tolist() 
+0001dbb0: 2b20 6466 312e 7365 6c65 6374 5f64 7479  + df1.select_dty
+0001dbc0: 7065 7328 696e 636c 7564 653d 2763 6174  pes(include='cat
+0001dbd0: 6567 6f72 7927 292e 636f 6c75 6d6e 732e  egory').columns.
+0001dbe0: 746f 6c69 7374 2829 0a20 2020 2063 6174  tolist().    cat
+0001dbf0: 7320 3d20 636f 7079 2e64 6565 7063 6f70  s = copy.deepcop
+0001dc00: 7928 6361 7463 6f6c 7329 0a20 2020 206e  y(catcols).    n
+0001dc10: 6c70 636f 6c73 203d 205b 5d0a 2020 2020  lpcols = [].    
+0001dc20: 666f 7220 6561 6368 5f63 6174 2069 6e20  for each_cat in 
+0001dc30: 6361 7473 3a0a 2020 2020 2020 2020 7472  cats:.        tr
+0001dc40: 793a 0a20 2020 2020 2020 2020 2020 2069  y:.            i
+0001dc50: 6620 6466 315b 5b65 6163 685f 6361 745d  f df1[[each_cat]
+0001dc60: 5d2e 6669 6c6c 6e61 2827 6d69 7373 696e  ].fillna('missin
+0001dc70: 6727 292e 6d61 7028 6c65 6e29 2e6d 6561  g').map(len).mea
+0001dc80: 6e28 2920 3e3d 2034 303a 0a20 2020 2020  n() >= 40:.     
+0001dc90: 2020 2020 2020 2020 2020 206e 6c70 636f             nlpco
+0001dca0: 6c73 2e61 7070 656e 6428 6561 6368 5f63  ls.append(each_c
+0001dcb0: 6174 290a 2020 2020 2020 2020 2020 2020  at).            
+0001dcc0: 2020 2020 6361 7463 6f6c 732e 7265 6d6f      catcols.remo
+0001dcd0: 7665 2865 6163 685f 6361 7429 0a20 2020  ve(each_cat).   
+0001dce0: 2020 2020 2065 7863 6570 743a 0a20 2020       except:.   
+0001dcf0: 2020 2020 2020 2020 2063 6f6e 7469 6e75           continu
+0001dd00: 650a 2020 2020 696e 7463 6f6c 7320 3d20  e.    intcols = 
+0001dd10: 6466 312e 7365 6c65 6374 5f64 7479 7065  df1.select_dtype
+0001dd20: 7328 696e 636c 7564 653d 2769 6e74 6567  s(include='integ
+0001dd30: 6572 2729 2e63 6f6c 756d 6e73 2e74 6f6c  er').columns.tol
+0001dd40: 6973 7428 290a 2020 2020 2320 6c65 7427  ist().    # let'
+0001dd50: 7320 6669 6e64 2061 6c6c 2074 6865 2066  s find all the f
+0001dd60: 6c6f 6174 206e 756d 6572 6963 2063 6f6c  loat numeric col
+0001dd70: 756d 6e73 2069 6e20 6461 7461 0a20 2020  umns in data.   
+0001dd80: 2066 6c6f 6174 636f 6c73 203d 2064 6631   floatcols = df1
+0001dd90: 2e73 656c 6563 745f 6474 7970 6573 2869  .select_dtypes(i
+0001dda0: 6e63 6c75 6465 3d27 666c 6f61 7427 292e  nclude='float').
+0001ddb0: 636f 6c75 6d6e 732e 746f 6c69 7374 2829  columns.tolist()
+0001ddc0: 0a20 2020 2072 6574 7572 6e20 6361 7463  .    return catc
+0001ddd0: 6f6c 732c 2069 6e74 636f 6c73 2c20 666c  ols, intcols, fl
+0001dde0: 6f61 7463 6f6c 732c 206e 6c70 636f 6c73  oatcols, nlpcols
+0001ddf0: 0a23 2323 2323 2323 2323 2323 2323 2323  .###############
+0001de00: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001de10: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001de20: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001de30: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001de40: 2323 2323 2323 2323 2323 2323 230a 6465  #############.de
+0001de50: 6620 4544 415f 636c 6173 7369 6679 5f66  f EDA_classify_f
+0001de60: 6561 7475 7265 735f 666f 725f 6465 6570  eatures_for_deep
+0001de70: 5f6c 6561 726e 696e 6728 7472 6169 6e2c  _learning(train,
+0001de80: 2074 6172 6765 742c 2069 6463 6f6c 7329   target, idcols)
+0001de90: 3a0a 2020 2020 2222 220a 2020 2020 2323  :.    """.    ##
 0001dea0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 0001deb0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 0001dec0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 0001ded0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001dee0: 2323 2323 2323 2323 2323 2323 2323 0a66  ##############.f
-0001def0: 726f 6d20 6974 6572 746f 6f6c 7320 696d  rom itertools im
-0001df00: 706f 7274 2063 6f6d 6269 6e61 7469 6f6e  port combination
-0001df10: 730a 6465 6620 4645 5f63 7265 6174 655f  s.def FE_create_
-0001df20: 6361 7465 676f 7269 6361 6c5f 6665 6174  categorical_feat
-0001df30: 7572 655f 6372 6f73 7365 7328 6466 632c  ure_crosses(dfc,
-0001df40: 2063 6174 7329 3a0a 2020 2020 2222 220a   cats):.    """.
-0001df50: 2020 2020 4645 206d 6561 6e73 2046 4541      FE means FEA
-0001df60: 5455 5245 2045 4e47 494e 4545 5249 4e47  TURE ENGINEERING
-0001df70: 202d 2054 6861 7420 6d65 616e 7320 7468   - That means th
-0001df80: 6973 2066 756e 6374 696f 6e20 7769 6c6c  is function will
-0001df90: 2063 7265 6174 6520 6e65 7720 6665 6174   create new feat
-0001dfa0: 7572 6573 0a20 2020 2023 2323 2323 2323  ures.    #######
-0001dfb0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001dee0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001def0: 2323 2323 0a20 2020 2054 6869 7320 6973  ####.    This is
+0001df00: 2061 2073 696d 706c 6520 6d65 7468 6f64   a simple method
+0001df10: 206f 6620 636c 6173 7369 6679 696e 6720   of classifying 
+0001df20: 6665 6174 7572 6573 2069 6e74 6f20 3420  features into 4 
+0001df30: 7479 7065 733a 2063 6174 732c 2069 6e74  types: cats, int
+0001df40: 6567 6572 732c 2066 6c6f 6174 7320 616e  egers, floats an
+0001df50: 6420 4e4c 5073 0a20 2020 2054 6869 7320  d NLPs.    This 
+0001df60: 6973 206e 6565 6465 6420 666f 7220 6465  is needed for de
+0001df70: 6570 206c 6561 726e 696e 6720 7072 6f62  ep learning prob
+0001df80: 6c65 6d73 2077 6865 7265 2077 6520 6e65  lems where we ne
+0001df90: 6564 2066 6577 6572 2074 7970 6573 206f  ed fewer types o
+0001dfa0: 6620 7661 7269 6162 6c65 7320 746f 2074  f variables to t
+0001dfb0: 7261 6e73 666f 726d 2e0a 2020 2020 2323  ransform..    ##
 0001dfc0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 0001dfd0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 0001dfe0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001dff0: 2323 2323 2323 2323 2323 2323 2323 230a  ###############.
-0001e000: 2020 2020 5468 6973 2063 7265 6174 6573      This creates
-0001e010: 2066 6561 7475 7265 2063 726f 7373 6573   feature crosses
-0001e020: 2066 6f72 2065 6163 6820 7061 6972 206f   for each pair o
-0001e030: 6620 6361 7465 676f 7269 6361 6c20 7661  f categorical va
-0001e040: 7269 6162 6c65 7320 696e 2063 6174 732e  riables in cats.
-0001e050: 0a20 2020 2054 6865 206e 756d 6265 7220  .    The number 
-0001e060: 6f66 2066 6561 7475 7265 7320 6372 6561  of features crea
-0001e070: 7465 6420 7769 6c6c 2062 6520 6e2a 286e  ted will be n*(n
-0001e080: 2d31 292f 3220 7768 6963 6820 6d65 616e  -1)/2 which mean
-0001e090: 7320 3320 6361 7420 6665 6174 7572 6573  s 3 cat features
-0001e0a0: 2077 696c 6c20 6372 6561 7465 0a20 2020   will create.   
-0001e0b0: 2033 2a32 2f32 203d 2033 206e 6577 2066   3*2/2 = 3 new f
-0001e0c0: 6561 7475 7265 732e 2059 6f75 206d 7573  eatures. You mus
-0001e0d0: 7420 6265 2063 6172 6566 756c 2077 6974  t be careful wit
-0001e0e0: 6820 7468 6973 2066 756e 6374 696f 6e20  h this function 
-0001e0f0: 736f 2069 7420 646f 6573 6e27 7420 6372  so it doesn't cr
-0001e100: 6561 7465 2074 6f6f 206d 616e 792e 0a0a  eate too many...
-0001e110: 2020 2020 496e 7075 7473 3a0a 2020 2020      Inputs:.    
-0001e120: 6466 6320 3a20 6461 7461 6672 616d 6520  dfc : dataframe 
-0001e130: 636f 6e74 6169 6e69 6e67 2061 6c6c 2074  containing all t
-0001e140: 6865 2066 6561 7475 7265 730a 2020 2020  he features.    
-0001e150: 6361 7473 3a20 6120 6c69 7374 206f 6620  cats: a list of 
-0001e160: 6361 7465 676f 7269 6361 6c20 6665 6174  categorical feat
-0001e170: 7572 6573 2069 6e20 7468 6520 6461 7461  ures in the data
-0001e180: 6672 616d 6520 6162 6f76 6520 2864 6663  frame above (dfc
-0001e190: 290a 0a20 2020 204f 7574 7075 7473 3a0a  )..    Outputs:.
-0001e1a0: 2020 2020 6466 633a 2072 6574 7572 6e73      dfc: returns
-0001e1b0: 2074 6865 2064 6174 6166 7261 6d65 2077   the dataframe w
-0001e1c0: 6974 6820 6e65 776c 7920 6164 6465 6420  ith newly added 
-0001e1d0: 6665 6174 7572 6573 2e20 4f72 6967 696e  features. Origin
-0001e1e0: 616c 2066 6561 7475 7265 7320 6172 6520  al features are 
-0001e1f0: 756e 746f 7563 6865 642e 0a0a 2020 2020  untouched...    
-0001e200: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001e210: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001e220: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001e230: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001e240: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001e250: 2323 2323 2323 0a20 2020 2055 7361 6765  ######.    Usage
-0001e260: 3a0a 2020 2020 6466 6320 3d20 4645 5f63  :.    dfc = FE_c
-0001e270: 7265 6174 655f 6665 6174 7572 655f 6372  reate_feature_cr
-0001e280: 6f73 7365 7328 6466 632c 2063 6174 7329  osses(dfc, cats)
-0001e290: 0a20 2020 2022 2222 0a20 2020 2064 6663  .    """.    dfc
-0001e2a0: 203d 2063 6f70 792e 6465 6570 636f 7079   = copy.deepcopy
-0001e2b0: 2864 6663 290a 2020 2020 636f 6d62 6f73  (dfc).    combos
-0001e2c0: 203d 206c 6973 7428 636f 6d62 696e 6174   = list(combinat
-0001e2d0: 696f 6e73 2863 6174 732c 2032 2929 0a20  ions(cats, 2)). 
-0001e2e0: 2020 2066 6f72 2063 6174 312c 2063 6174     for cat1, cat
-0001e2f0: 3220 696e 2063 6f6d 626f 733a 0a20 2020  2 in combos:.   
-0001e300: 2020 2020 2064 6663 2e6c 6f63 5b3a 2c63       dfc.loc[:,c
-0001e310: 6174 312b 275f 6372 6f73 735f 272b 6361  at1+'_cross_'+ca
-0001e320: 7432 5d20 3d20 6466 635b 6361 7431 5d2e  t2] = dfc[cat1].
-0001e330: 6173 7479 7065 2873 7472 292b 2220 222b  astype(str)+" "+
-0001e340: 6466 635b 6361 7432 5d2e 6173 7479 7065  dfc[cat2].astype
-0001e350: 2873 7472 290a 2020 2020 7265 7475 726e  (str).    return
-0001e360: 2064 6663 0a23 2323 2323 2323 2323 2323   dfc.###########
-0001e370: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001e380: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001e390: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001e3a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001e3b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001e3c0: 2323 0a66 726f 6d20 7363 6970 792e 7374  ##.from scipy.st
-0001e3d0: 6174 7320 696d 706f 7274 2070 726f 6270  ats import probp
-0001e3e0: 6c6f 742c 736b 6577 0a64 6566 2045 4441  lot,skew.def EDA
-0001e3f0: 5f66 696e 645f 736b 6577 6564 5f76 6172  _find_skewed_var
-0001e400: 6961 626c 6573 2864 6674 2c20 736b 6577  iables(dft, skew
-0001e410: 5f6c 696d 6974 3d31 2e31 293a 0a20 2020  _limit=1.1):.   
-0001e420: 2022 2222 0a20 2020 2045 4441 2073 7461   """.    EDA sta
-0001e430: 6e64 7320 666f 7220 4578 706c 6f72 6174  nds for Explorat
-0001e440: 6f72 7920 4461 7461 2041 6e61 6c79 7369  ory Data Analysi
-0001e450: 7320 3a20 7468 6973 2066 756e 6374 696f  s : this functio
-0001e460: 6e20 7065 7266 6f72 6d73 2045 4441 0a20  n performs EDA. 
-0001e470: 2020 2023 2323 2323 2323 2323 2323 2323     #############
-0001e480: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001e490: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001e4a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001e4b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001e4c0: 2323 2323 2323 2323 230a 2020 2020 5468  #########.    Th
-0001e4d0: 6973 2066 756e 6374 696f 6e20 6669 6e64  is function find
-0001e4e0: 7320 616c 6c20 7468 6520 6869 6768 6c79  s all the highly
-0001e4f0: 2073 6b65 7765 6420 666c 6f61 7420 2863   skewed float (c
-0001e500: 6f6e 7469 6e75 6f75 7329 2076 6172 6961  ontinuous) varia
-0001e510: 626c 6573 2069 6e20 796f 7572 2044 6174  bles in your Dat
-0001e520: 6146 7261 6d65 0a20 2020 2049 7420 7365  aFrame.    It se
-0001e530: 6c65 6374 7320 7468 656d 2062 6173 6564  lects them based
-0001e540: 206f 6e20 7468 6520 736b 6577 5f6c 696d   on the skew_lim
-0001e550: 6974 2079 6f75 2073 6574 3a20 616e 7974  it you set: anyt
-0001e560: 6869 6e67 206f 7665 7220 736b 6577 2031  hing over skew 1
-0001e570: 2e31 2069 7320 7468 6520 6465 6661 756c  .1 is the defaul
-0001e580: 7420 7365 7474 696e 672e 0a20 2020 2023  t setting..    #
-0001e590: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001e5a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001e5b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001e5c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001e5d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001e5e0: 2323 2323 230a 2020 2020 496e 7075 7473  #####.    Inputs
-0001e5f0: 3a0a 2020 2020 6466 3a20 7061 6e64 6173  :.    df: pandas
-0001e600: 2044 6174 6146 7261 6d65 0a20 2020 2073   DataFrame.    s
-0001e610: 6b65 775f 6c69 6d69 743a 2064 6566 6175  kew_limit: defau
-0001e620: 6c74 2031 2e31 203d 2061 6e79 7468 696e  lt 1.1 = anythin
-0001e630: 6720 6f76 6572 2074 6869 7320 6c69 6d69  g over this limi
-0001e640: 7420 616e 6420 6974 2064 6574 6563 7473  t and it detects
-0001e650: 2069 7420 6173 2061 2068 6967 686c 7920   it as a highly 
-0001e660: 736b 6577 6564 2076 6172 2e0a 0a20 2020  skewed var...   
-0001e670: 204f 7574 7075 7473 3a0a 2020 2020 6c69   Outputs:.    li
-0001e680: 7374 206f 6620 6120 7661 7269 6162 6c65  st of a variable
-0001e690: 7320 666f 756e 6420 7468 6174 2068 6176  s found that hav
-0001e6a0: 6520 6869 6768 2073 6b65 7720 696e 2064  e high skew in d
-0001e6b0: 6174 6120 7365 742e 0a20 2020 2023 2323  ata set..    ###
-0001e6c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001e6d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001e6e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001e6f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001e700: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001e710: 2323 230a 2020 2020 596f 7520 6361 6e20  ###.    You can 
-0001e720: 7573 6520 4645 5f63 6170 7069 6e67 5f6f  use FE_capping_o
-0001e730: 7574 6c69 6572 735f 6265 796f 6e64 5f49  utliers_beyond_I
-0001e740: 5152 5f52 616e 6765 2829 2066 756e 6374  QR_Range() funct
-0001e750: 696f 6e20 746f 2063 6170 206f 7574 6c69  ion to cap outli
-0001e760: 6572 7320 696e 2074 6865 7365 2076 6172  ers in these var
-0001e770: 6961 626c 6573 2e0a 2020 2020 2222 220a  iables..    """.
-0001e780: 2020 2020 736b 6577 6564 5f76 6172 7320      skewed_vars 
-0001e790: 3d20 5b5d 0a20 2020 2063 6f6e 7469 203d  = [].    conti =
-0001e7a0: 2064 6674 2e73 656c 6563 745f 6474 7970   dft.select_dtyp
-0001e7b0: 6573 2869 6e63 6c75 6465 3d27 666c 6f61  es(include='floa
-0001e7c0: 7427 292e 636f 6c75 6d6e 732e 746f 6c69  t').columns.toli
-0001e7d0: 7374 2829 0a20 2020 2066 6f72 2065 6163  st().    for eac
-0001e7e0: 685f 636f 6e74 6920 696e 2063 6f6e 7469  h_conti in conti
-0001e7f0: 3a0a 2020 2020 2020 2020 736b 6577 5f76  :.        skew_v
-0001e800: 616c 3d72 6f75 6e64 2864 6674 5b65 6163  al=round(dft[eac
-0001e810: 685f 636f 6e74 695d 2e73 6b65 7728 292c  h_conti].skew(),
-0001e820: 2031 290a 2020 2020 2020 2020 6966 2073   1).        if s
-0001e830: 6b65 775f 7661 6c20 3e3d 2073 6b65 775f  kew_val >= skew_
-0001e840: 6c69 6d69 743a 0a20 2020 2020 2020 2020  limit:.         
-0001e850: 2020 2073 6b65 7765 645f 7661 7273 2e61     skewed_vars.a
-0001e860: 7070 656e 6428 6561 6368 5f63 6f6e 7469  ppend(each_conti
-0001e870: 290a 2020 2020 7072 696e 7428 2746 6f75  ).    print('Fou
-0001e880: 6e64 2025 6420 736b 6577 6564 2076 6172  nd %d skewed var
-0001e890: 6961 626c 6573 2069 6e20 6461 7461 2062  iables in data b
-0001e8a0: 6173 6564 206f 6e20 736b 6577 5f6c 696d  ased on skew_lim
-0001e8b0: 6974 203e 3d20 2573 2720 2528 6c65 6e28  it >= %s' %(len(
-0001e8c0: 736b 6577 6564 5f76 6172 7329 2c73 6b65  skewed_vars),ske
-0001e8d0: 775f 6c69 6d69 7429 290a 2020 2020 7265  w_limit)).    re
-0001e8e0: 7475 726e 2073 6b65 7765 645f 7661 7273  turn skewed_vars
-0001e8f0: 0a23 2323 2323 2323 2323 2323 2323 2323  .###############
+0001dff0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001e000: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001e010: 2323 2323 0a20 2020 2022 2222 0a20 2020  ####.    """.   
+0001e020: 2023 2323 2054 6573 7420 4c61 6265 6c65   ### Test Labele
+0001e030: 7220 6973 2061 2076 6572 7920 696d 706f  r is a very impo
+0001e040: 7274 616e 7420 6469 6374 696f 6e61 7279  rtant dictionary
+0001e050: 2074 6861 7420 7769 6c6c 2068 656c 7020   that will help 
+0001e060: 7472 616e 7366 6f72 6d20 7465 7374 2064  transform test d
+0001e070: 6174 6120 7361 6d65 2061 7320 7472 6169  ata same as trai
+0001e080: 6e20 2323 2323 0a20 2020 2074 6573 745f  n ####.    test_
+0001e090: 6c61 6265 6c65 7220 3d20 6465 6661 756c  labeler = defaul
+0001e0a0: 7464 6963 7428 6c69 7374 290a 0a20 2020  tdict(list)..   
+0001e0b0: 2023 2323 2320 616c 6c20 636f 6c75 6d6e   #### all column
+0001e0c0: 7320 6172 6520 6665 6174 7572 6573 2065  s are features e
+0001e0d0: 7863 6570 7420 7468 6520 7461 7267 6574  xcept the target
+0001e0e0: 2063 6f6c 756d 6e20 616e 6420 7468 6520   column and the 
+0001e0f0: 666f 6c64 7320 636f 6c75 6d6e 2023 2323  folds column ###
+0001e100: 0a20 2020 2069 6620 6973 696e 7374 616e  .    if isinstan
+0001e110: 6365 2874 6172 6765 742c 2073 7472 293a  ce(target, str):
+0001e120: 0a20 2020 2020 2020 2066 6561 7475 7265  .        feature
+0001e130: 7320 3d20 5b78 2066 6f72 2078 2069 6e20  s = [x for x in 
+0001e140: 6c69 7374 2874 7261 696e 2920 6966 2078  list(train) if x
+0001e150: 206e 6f74 2069 6e20 5b74 6172 6765 745d   not in [target]
+0001e160: 2b69 6463 6f6c 735d 0a20 2020 2065 6c73  +idcols].    els
+0001e170: 653a 0a20 2020 2020 2020 2023 2323 2069  e:.        ### i
+0001e180: 6e20 7468 6973 2063 6173 6520 7461 7267  n this case targ
+0001e190: 6574 2069 7320 6120 6c69 7374 2061 6e64  et is a list and
+0001e1a0: 2068 656e 6365 2063 616e 2062 6520 6164   hence can be ad
+0001e1b0: 6465 6420 746f 2069 6463 6f6c 730a 2020  ded to idcols.  
+0001e1c0: 2020 2020 2020 6665 6174 7572 6573 203d        features =
+0001e1d0: 205b 7820 666f 7220 7820 696e 206c 6973   [x for x in lis
+0001e1e0: 7428 7472 6169 6e29 2069 6620 7820 6e6f  t(train) if x no
+0001e1f0: 7420 696e 2074 6172 6765 742b 6964 636f  t in target+idco
+0001e200: 6c73 5d0a 0a20 2020 2023 2323 2066 6972  ls]..    ### fir
+0001e210: 7374 2066 696e 6420 616c 6c20 7468 6520  st find all the 
+0001e220: 7479 7065 7320 6f66 2063 6f6c 756d 6e73  types of columns
+0001e230: 2069 6e20 796f 7572 2064 6174 6120 7365   in your data se
+0001e240: 7420 2323 2323 0a20 2020 2063 6174 732c  t ####.    cats,
+0001e250: 2069 6e74 732c 2066 6c6f 6174 732c 206e   ints, floats, n
+0001e260: 6c70 7320 3d20 4544 415f 636c 6173 7369  lps = EDA_classi
+0001e270: 6679 5f61 6e64 5f72 6574 7572 6e5f 636f  fy_and_return_co
+0001e280: 6c73 5f62 795f 7479 7065 2874 7261 696e  ls_by_type(train
+0001e290: 5b66 6561 7475 7265 735d 290a 0a20 2020  [features])..   
+0001e2a0: 206e 756d 6572 6963 5f66 6561 7475 7265   numeric_feature
+0001e2b0: 7320 3d20 696e 7473 202b 2066 6c6f 6174  s = ints + float
+0001e2c0: 730a 2020 2020 6361 7465 676f 7269 6361  s.    categorica
+0001e2d0: 6c73 5f66 6561 7475 7265 7320 3d20 636f  ls_features = co
+0001e2e0: 7079 2e64 6565 7063 6f70 7928 6361 7473  py.deepcopy(cats
+0001e2f0: 290a 2020 2020 6e6c 705f 6665 6174 7572  ).    nlp_featur
+0001e300: 6573 203d 2063 6f70 792e 6465 6570 636f  es = copy.deepco
+0001e310: 7079 286e 6c70 7329 0a0a 2020 2020 7465  py(nlps)..    te
+0001e320: 7374 5f6c 6162 656c 6572 5b27 6361 7465  st_labeler['cate
+0001e330: 676f 7269 6361 6c73 5f66 6561 7475 7265  goricals_feature
+0001e340: 7327 5d20 3d20 6361 7465 676f 7269 6361  s'] = categorica
+0001e350: 6c73 5f66 6561 7475 7265 730a 2020 2020  ls_features.    
+0001e360: 7465 7374 5f6c 6162 656c 6572 5b27 6e75  test_labeler['nu
+0001e370: 6d65 7269 635f 6665 6174 7572 6573 275d  meric_features']
+0001e380: 203d 206e 756d 6572 6963 5f66 6561 7475   = numeric_featu
+0001e390: 7265 730a 2020 2020 7465 7374 5f6c 6162  res.    test_lab
+0001e3a0: 656c 6572 5b27 6e6c 705f 6665 6174 7572  eler['nlp_featur
+0001e3b0: 6573 275d 203d 206e 6c70 5f66 6561 7475  es'] = nlp_featu
+0001e3c0: 7265 730a 0a20 2020 2072 6574 7572 6e20  res..    return 
+0001e3d0: 6361 7473 2c20 696e 7473 2c20 666c 6f61  cats, ints, floa
+0001e3e0: 7473 2c20 6e6c 7073 0a23 2323 2323 2323  ts, nlps.#######
+0001e3f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001e400: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001e410: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001e420: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001e430: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001e440: 2323 2323 2323 0a66 726f 6d20 6974 6572  ######.from iter
+0001e450: 746f 6f6c 7320 696d 706f 7274 2063 6f6d  tools import com
+0001e460: 6269 6e61 7469 6f6e 730a 6465 6620 4645  binations.def FE
+0001e470: 5f63 7265 6174 655f 6361 7465 676f 7269  _create_categori
+0001e480: 6361 6c5f 6665 6174 7572 655f 6372 6f73  cal_feature_cros
+0001e490: 7365 7328 6466 632c 2063 6174 7329 3a0a  ses(dfc, cats):.
+0001e4a0: 2020 2020 2222 220a 2020 2020 4645 206d      """.    FE m
+0001e4b0: 6561 6e73 2046 4541 5455 5245 2045 4e47  eans FEATURE ENG
+0001e4c0: 494e 4545 5249 4e47 202d 2054 6861 7420  INEERING - That 
+0001e4d0: 6d65 616e 7320 7468 6973 2066 756e 6374  means this funct
+0001e4e0: 696f 6e20 7769 6c6c 2063 7265 6174 6520  ion will create 
+0001e4f0: 6e65 7720 6665 6174 7572 6573 0a20 2020  new features.   
+0001e500: 2023 2323 2323 2323 2323 2323 2323 2323   ###############
+0001e510: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001e520: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001e530: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001e540: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001e550: 2323 2323 2323 230a 2020 2020 5468 6973  #######.    This
+0001e560: 2063 7265 6174 6573 2066 6561 7475 7265   creates feature
+0001e570: 2063 726f 7373 6573 2066 6f72 2065 6163   crosses for eac
+0001e580: 6820 7061 6972 206f 6620 6361 7465 676f  h pair of catego
+0001e590: 7269 6361 6c20 7661 7269 6162 6c65 7320  rical variables 
+0001e5a0: 696e 2063 6174 732e 0a20 2020 2054 6865  in cats..    The
+0001e5b0: 206e 756d 6265 7220 6f66 2066 6561 7475   number of featu
+0001e5c0: 7265 7320 6372 6561 7465 6420 7769 6c6c  res created will
+0001e5d0: 2062 6520 6e2a 286e 2d31 292f 3220 7768   be n*(n-1)/2 wh
+0001e5e0: 6963 6820 6d65 616e 7320 3320 6361 7420  ich means 3 cat 
+0001e5f0: 6665 6174 7572 6573 2077 696c 6c20 6372  features will cr
+0001e600: 6561 7465 0a20 2020 2033 2a32 2f32 203d  eate.    3*2/2 =
+0001e610: 2033 206e 6577 2066 6561 7475 7265 732e   3 new features.
+0001e620: 2059 6f75 206d 7573 7420 6265 2063 6172   You must be car
+0001e630: 6566 756c 2077 6974 6820 7468 6973 2066  eful with this f
+0001e640: 756e 6374 696f 6e20 736f 2069 7420 646f  unction so it do
+0001e650: 6573 6e27 7420 6372 6561 7465 2074 6f6f  esn't create too
+0001e660: 206d 616e 792e 0a0a 2020 2020 496e 7075   many...    Inpu
+0001e670: 7473 3a0a 2020 2020 6466 6320 3a20 6461  ts:.    dfc : da
+0001e680: 7461 6672 616d 6520 636f 6e74 6169 6e69  taframe containi
+0001e690: 6e67 2061 6c6c 2074 6865 2066 6561 7475  ng all the featu
+0001e6a0: 7265 730a 2020 2020 6361 7473 3a20 6120  res.    cats: a 
+0001e6b0: 6c69 7374 206f 6620 6361 7465 676f 7269  list of categori
+0001e6c0: 6361 6c20 6665 6174 7572 6573 2069 6e20  cal features in 
+0001e6d0: 7468 6520 6461 7461 6672 616d 6520 6162  the dataframe ab
+0001e6e0: 6f76 6520 2864 6663 290a 0a20 2020 204f  ove (dfc)..    O
+0001e6f0: 7574 7075 7473 3a0a 2020 2020 6466 633a  utputs:.    dfc:
+0001e700: 2072 6574 7572 6e73 2074 6865 2064 6174   returns the dat
+0001e710: 6166 7261 6d65 2077 6974 6820 6e65 776c  aframe with newl
+0001e720: 7920 6164 6465 6420 6665 6174 7572 6573  y added features
+0001e730: 2e20 4f72 6967 696e 616c 2066 6561 7475  . Original featu
+0001e740: 7265 7320 6172 6520 756e 746f 7563 6865  res are untouche
+0001e750: 642e 0a0a 2020 2020 2323 2323 2323 2323  d...    ########
+0001e760: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001e770: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001e780: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001e790: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001e7a0: 2323 2323 2323 2323 2323 2323 2323 0a20  ##############. 
+0001e7b0: 2020 2055 7361 6765 3a0a 2020 2020 6466     Usage:.    df
+0001e7c0: 6320 3d20 4645 5f63 7265 6174 655f 6665  c = FE_create_fe
+0001e7d0: 6174 7572 655f 6372 6f73 7365 7328 6466  ature_crosses(df
+0001e7e0: 632c 2063 6174 7329 0a20 2020 2022 2222  c, cats).    """
+0001e7f0: 0a20 2020 2064 6663 203d 2063 6f70 792e  .    dfc = copy.
+0001e800: 6465 6570 636f 7079 2864 6663 290a 2020  deepcopy(dfc).  
+0001e810: 2020 636f 6d62 6f73 203d 206c 6973 7428    combos = list(
+0001e820: 636f 6d62 696e 6174 696f 6e73 2863 6174  combinations(cat
+0001e830: 732c 2032 2929 0a20 2020 2066 6f72 2063  s, 2)).    for c
+0001e840: 6174 312c 2063 6174 3220 696e 2063 6f6d  at1, cat2 in com
+0001e850: 626f 733a 0a20 2020 2020 2020 2064 6663  bos:.        dfc
+0001e860: 2e6c 6f63 5b3a 2c63 6174 312b 275f 6372  .loc[:,cat1+'_cr
+0001e870: 6f73 735f 272b 6361 7432 5d20 3d20 6466  oss_'+cat2] = df
+0001e880: 635b 6361 7431 5d2e 6173 7479 7065 2873  c[cat1].astype(s
+0001e890: 7472 292b 2220 222b 6466 635b 6361 7432  tr)+" "+dfc[cat2
+0001e8a0: 5d2e 6173 7479 7065 2873 7472 290a 2020  ].astype(str).  
+0001e8b0: 2020 7265 7475 726e 2064 6663 0a23 2323    return dfc.###
+0001e8c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001e8d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001e8e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001e8f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 0001e900: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001e910: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001e920: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001e930: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001e940: 2323 2323 2323 2323 2323 2323 2323 0a64  ##############.d
-0001e950: 6566 2069 735f 6f75 746c 6965 7228 6461  ef is_outlier(da
-0001e960: 7461 6672 616d 652c 2074 6872 6573 683d  taframe, thresh=
-0001e970: 332e 3529 3a0a 2020 2020 6966 206c 656e  3.5):.    if len
-0001e980: 2864 6174 6166 7261 6d65 2e73 6861 7065  (dataframe.shape
-0001e990: 2920 3d3d 2031 3a0a 2020 2020 2020 2020  ) == 1:.        
-0001e9a0: 6461 7461 6672 616d 6520 3d20 6461 7461  dataframe = data
-0001e9b0: 6672 616d 655b 3a2c 4e6f 6e65 5d0a 2020  frame[:,None].  
-0001e9c0: 2020 6d65 6469 616e 203d 206e 702e 6d65    median = np.me
-0001e9d0: 6469 616e 2864 6174 6166 7261 6d65 2c20  dian(dataframe, 
-0001e9e0: 6178 6973 3d30 290a 2020 2020 6469 6666  axis=0).    diff
-0001e9f0: 203d 206e 702e 7375 6d28 2864 6174 6166   = np.sum((dataf
-0001ea00: 7261 6d65 202d 206d 6564 6961 6e29 2a2a  rame - median)**
-0001ea10: 322c 2061 7869 733d 2d31 290a 2020 2020  2, axis=-1).    
-0001ea20: 6469 6666 203d 206e 702e 7371 7274 2864  diff = np.sqrt(d
-0001ea30: 6966 6629 0a20 2020 206d 6564 5f61 6273  iff).    med_abs
-0001ea40: 5f64 6576 6961 7469 6f6e 203d 206e 702e  _deviation = np.
-0001ea50: 6d65 6469 616e 2864 6966 6629 0a0a 2020  median(diff)..  
-0001ea60: 2020 6d6f 6469 6669 6564 5f7a 5f73 636f    modified_z_sco
-0001ea70: 7265 203d 2030 2e36 3734 3520 2a20 6469  re = 0.6745 * di
-0001ea80: 6666 202f 206d 6564 5f61 6273 5f64 6576  ff / med_abs_dev
-0001ea90: 6961 7469 6f6e 0a20 2020 2072 6574 7572  iation.    retur
-0001eaa0: 6e20 6d6f 6469 6669 6564 5f7a 5f73 636f  n modified_z_sco
-0001eab0: 7265 203e 2074 6872 6573 680a 0a64 6566  re > thresh..def
-0001eac0: 2045 4441 5f66 696e 645f 6f75 746c 6965   EDA_find_outlie
-0001ead0: 7273 2864 662c 2063 6f6c 2c20 7468 7265  rs(df, col, thre
-0001eae0: 7368 3d35 293a 0a20 2020 2022 2222 0a20  sh=5):.    """. 
-0001eaf0: 2020 2022 2222 0a20 2020 2023 2323 2323     """.    #####
-0001eb00: 2323 2046 696e 6473 204f 7574 6c69 6572  ## Finds Outlier
-0001eb10: 7320 616e 6420 6d61 726b 7320 7468 656d  s and marks them
-0001eb20: 2061 7320 2754 7275 6527 2069 6620 7468   as 'True' if th
-0001eb30: 6579 2061 7265 206f 7574 6c69 6572 730a  ey are outliers.
-0001eb40: 2020 2020 2323 2323 2323 2320 4461 7461      ####### Data
-0001eb50: 6672 616d 6520 7265 6665 7273 2074 6f20  frame refers to 
-0001eb60: 7468 6520 696e 7075 7420 6461 7461 6672  the input datafr
-0001eb70: 616d 6520 616e 6420 7468 7265 7368 6f6c  ame and threshol
-0001eb80: 6420 7265 6665 7273 2074 6f20 686f 7720  d refers to how 
-0001eb90: 6661 7220 6672 6f6d 2074 6865 206d 6564  far from the med
-0001eba0: 6961 6e20 6120 7661 6c75 6520 6973 0a20  ian a value is. 
-0001ebb0: 2020 2023 2323 2323 2323 2049 2061 6d20     ####### I am 
-0001ebc0: 7573 696e 6720 7468 6520 4d65 6469 616e  using the Median
-0001ebd0: 2041 6273 6f6c 7574 6520 4465 7669 6174   Absolute Deviat
-0001ebe0: 696f 6e20 4d65 7468 6f64 2028 4d41 4444  ion Method (MADD
-0001ebf0: 2920 746f 2066 696e 6420 4f75 746c 6965  ) to find Outlie
-0001ec00: 7273 2068 6572 650a 2020 2020 6d61 736b  rs here.    mask
-0001ec10: 5f6f 7574 6c69 6572 7320 3d20 6973 5f6f  _outliers = is_o
-0001ec20: 7574 6c69 6572 2864 665b 636f 6c5d 2c74  utlier(df[col],t
-0001ec30: 6872 6573 683d 7468 7265 7368 292e 6173  hresh=thresh).as
-0001ec40: 7479 7065 2869 6e74 290a 2020 2020 7265  type(int).    re
-0001ec50: 7475 726e 2064 662e 696c 6f63 5b6e 702e  turn df.iloc[np.
-0001ec60: 7768 6572 6528 6d61 736b 5f6f 7574 6c69  where(mask_outli
-0001ec70: 6572 733e 3029 5d0a 2323 2323 2323 2323  ers>0)].########
-0001ec80: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001ec90: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001eca0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001ecb0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001ecc0: 2323 2323 2323 2323 2323 230a 6465 6620  ###########.def 
-0001ecd0: 6f75 746c 6965 725f 6465 7465 726d 696e  outlier_determin
-0001ece0: 655f 7468 7265 7368 6f6c 6428 6466 2c20  e_threshold(df, 
-0001ecf0: 636f 6c29 3a0a 2020 2020 2222 220a 2020  col):.    """.  
-0001ed00: 2020 5468 6973 2066 756e 6374 696f 6e20    This function 
-0001ed10: 6175 746f 6d61 7469 6361 6c6c 7920 6465  automatically de
-0001ed20: 7465 726d 696e 6573 2074 6865 2072 6967  termines the rig
-0001ed30: 6874 2074 6872 6573 686f 6c64 2066 6f72  ht threshold for
-0001ed40: 2074 6865 2064 6174 6166 7261 6d65 2061   the dataframe a
-0001ed50: 6e64 2063 6f6c 756d 6e2e 0a20 2020 2054  nd column..    T
-0001ed60: 6872 6573 686f 6c64 2069 7320 7573 6564  hreshold is used
-0001ed70: 2074 6f20 6465 7465 726d 696e 6520 686f   to determine ho
-0001ed80: 7720 6d61 6e79 206f 7574 6c69 6572 7320  w many outliers 
-0001ed90: 7765 2073 686f 756c 6420 6465 7465 6374  we should detect
-0001eda0: 2069 6e20 7468 6520 7365 7269 6573 2e0a   in the series..
-0001edb0: 2020 2020 4120 6c6f 7720 7468 7265 7368      A low thresh
-0001edc0: 6f6c 6420 7769 6c6c 2072 6573 756c 7420  old will result 
-0001edd0: 696e 2074 6f6f 206d 616e 7920 6f75 746c  in too many outl
-0001ede0: 6965 7273 2061 6e64 2061 2076 6572 7920  iers and a very 
-0001edf0: 6869 6768 2074 6872 6573 686f 6c64 2077  high threshold w
-0001ee00: 696c 6c20 6e6f 7420 6669 6e64 2061 6e79  ill not find any
-0001ee10: 2e0a 2020 2020 5468 6973 206c 6f6f 7073  ..    This loops
-0001ee20: 2075 6e74 696c 2069 7420 6669 6e64 7320   until it finds 
-0001ee30: 6c65 7373 2074 6861 6e20 3130 2074 696d  less than 10 tim
-0001ee40: 6573 206f 7220 6d61 7869 6d75 6d20 3125  es or maximum 1%
-0001ee50: 206f 6620 6461 7461 2062 6569 6e67 206f   of data being o
-0001ee60: 7574 6c69 6572 732e 0a20 2020 2022 2222  utliers..    """
-0001ee70: 0a20 2020 2064 6620 3d20 6466 2e63 6f70  .    df = df.cop
-0001ee80: 7928 6465 6570 3d54 7275 6529 0a20 2020  y(deep=True).   
-0001ee90: 206b 6565 705f 6c6f 6f70 696e 6720 3d20   keep_looping = 
-0001eea0: 5472 7565 0a20 2020 206e 756d 6265 725f  True.    number_
-0001eeb0: 6f66 5f6c 6f6f 7073 203d 2031 0a20 2020  of_loops = 1.   
-0001eec0: 2074 6872 6573 6820 3d20 350a 2020 2020   thresh = 5.    
-0001eed0: 7768 696c 6520 6b65 6570 5f6c 6f6f 7069  while keep_loopi
-0001eee0: 6e67 3a0a 2020 2020 2020 2020 6966 206e  ng:.        if n
-0001eef0: 756d 6265 725f 6f66 5f6c 6f6f 7073 203e  umber_of_loops >
-0001ef00: 3d20 3130 3a0a 2020 2020 2020 2020 2020  = 10:.          
-0001ef10: 2020 6272 6561 6b0a 2020 2020 2020 2020    break.        
-0001ef20: 6d61 736b 5f6f 7574 6c69 6572 7320 3d20  mask_outliers = 
-0001ef30: 6973 5f6f 7574 6c69 6572 2864 665b 636f  is_outlier(df[co
-0001ef40: 6c5d 2c20 7468 7265 7368 3d74 6872 6573  l], thresh=thres
-0001ef50: 6829 2e61 7374 7970 6528 696e 7429 0a20  h).astype(int). 
-0001ef60: 2020 2020 2020 2064 666f 7574 5f69 6e64         dfout_ind
-0001ef70: 6578 203d 2064 662e 696c 6f63 5b6e 702e  ex = df.iloc[np.
-0001ef80: 7768 6572 6528 6d61 736b 5f6f 7574 6c69  where(mask_outli
-0001ef90: 6572 733e 3029 5d2e 696e 6465 780a 2020  ers>0)].index.  
-0001efa0: 2020 2020 2020 7063 745f 6f75 746c 6965        pct_outlie
-0001efb0: 7273 203d 206c 656e 2864 666f 7574 5f69  rs = len(dfout_i
-0001efc0: 6e64 6578 292f 6c65 6e28 6466 290a 2020  ndex)/len(df).  
-0001efd0: 2020 2020 2020 6966 2070 6374 5f6f 7574        if pct_out
-0001efe0: 6c69 6572 7320 3d3d 2030 3a0a 2020 2020  liers == 0:.    
-0001eff0: 2020 2020 2020 2020 6966 2074 6872 6573          if thres
-0001f000: 6820 3e20 353a 0a20 2020 2020 2020 2020  h > 5:.         
-0001f010: 2020 2020 2020 2074 6872 6573 6820 3d20         thresh = 
-0001f020: 7468 7265 7368 202d 2035 0a20 2020 2020  thresh - 5.     
-0001f030: 2020 2020 2020 2065 6c69 6620 7468 7265         elif thre
-0001f040: 7368 203d 3d20 353a 0a20 2020 2020 2020  sh == 5:.       
-0001f050: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
-0001f060: 7468 7265 7368 0a20 2020 2020 2020 2020  thresh.         
-0001f070: 2020 2065 6c73 653a 0a20 2020 2020 2020     else:.       
-0001f080: 2020 2020 2020 2020 2074 6872 6573 6820           thresh 
-0001f090: 3d20 7468 7265 7368 202d 2031 0a20 2020  = thresh - 1.   
-0001f0a0: 2020 2020 2065 6c69 6620 2070 6374 5f6f       elif  pct_o
-0001f0b0: 7574 6c69 6572 7320 3c3d 2030 2e30 313a  utliers <= 0.01:
-0001f0c0: 0a20 2020 2020 2020 2020 2020 206b 6565  .            kee
-0001f0d0: 705f 6c6f 6f70 696e 6720 3d20 4661 6c73  p_looping = Fals
-0001f0e0: 650a 2020 2020 2020 2020 656c 7365 3a0a  e.        else:.
-0001f0f0: 2020 2020 2020 2020 2020 2020 7468 7265              thre
-0001f100: 7368 5f6d 756c 7469 706c 6965 7220 3d20  sh_multiplier = 
-0001f110: 696e 7428 2870 6374 5f6f 7574 6c69 6572  int((pct_outlier
-0001f120: 732f 302e 3031 292a 302e 3529 0a20 2020  s/0.01)*0.5).   
-0001f130: 2020 2020 2020 2020 2074 6872 6573 6820           thresh 
-0001f140: 3d20 7468 7265 7368 2a74 6872 6573 685f  = thresh*thresh_
-0001f150: 6d75 6c74 6970 6c69 6572 0a20 2020 2020  multiplier.     
-0001f160: 2020 206e 756d 6265 725f 6f66 5f6c 6f6f     number_of_loo
-0001f170: 7073 202b 3d20 310a 2020 2020 7072 696e  ps += 1.    prin
-0001f180: 7428 2720 2020 2025 7320 4f75 746c 6965  t('    %s Outlie
-0001f190: 7220 7468 7265 7368 6f6c 6420 3d20 2564  r threshold = %d
-0001f1a0: 2720 2528 636f 6c2c 2074 6872 6573 6829  ' %(col, thresh)
-0001f1b0: 290a 2020 2020 7265 7475 726e 2074 6872  ).    return thr
-0001f1c0: 6573 680a 0a66 726f 6d20 636f 6c6c 6563  esh..from collec
-0001f1d0: 7469 6f6e 7320 696d 706f 7274 2043 6f75  tions import Cou
-0001f1e0: 6e74 6572 0a64 6566 2046 455f 6669 6e64  nter.def FE_find
-0001f1f0: 5f61 6e64 5f63 6170 5f6f 7574 6c69 6572  _and_cap_outlier
-0001f200: 7328 6466 2c20 6665 6174 7572 6573 2c20  s(df, features, 
-0001f210: 6472 6f70 3d46 616c 7365 2c20 7665 7262  drop=False, verb
-0001f220: 6f73 653d 4661 6c73 6529 3a0a 2020 2020  ose=False):.    
-0001f230: 2222 220a 2020 2020 4645 2061 7420 7468  """.    FE at th
-0001f240: 6520 6265 6769 6e6e 696e 6720 6f66 2066  e beginning of f
-0001f250: 756e 6374 696f 6e20 6e61 6d65 2073 7461  unction name sta
-0001f260: 6e64 7320 666f 7220 4665 6174 7572 6520  nds for Feature 
-0001f270: 456e 6769 6e65 6572 696e 672e 2046 4520  Engineering. FE 
-0001f280: 6675 6e63 7469 6f6e 7320 6164 6420 6f72  functions add or
-0001f290: 2064 726f 7020 6665 6174 7572 6573 2e0a   drop features..
-0001f2a0: 2020 2020 2323 2323 2323 2323 2323 2323      ############
-0001f2b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001f2c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001f2d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001f2e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001f2f0: 2323 2323 2323 2323 2323 2323 230a 2020  #############.  
-0001f300: 2020 5479 7069 6361 6c6c 7920 7765 2074    Typically we t
-0001f310: 6869 6e6b 206f 6620 6f75 746c 6965 7273  hink of outliers
-0001f320: 2061 7320 6265 696e 6720 6f62 7365 7276   as being observ
-0001f330: 6174 696f 6e73 2062 6579 6f6e 6420 7468  ations beyond th
-0001f340: 6520 312e 3520 496e 7465 7220 5175 6172  e 1.5 Inter Quar
-0001f350: 7469 6c65 2052 616e 6765 2028 4951 5229  tile Range (IQR)
-0001f360: 0a20 2020 2042 7574 2074 6869 7320 6675  .    But this fu
-0001f370: 6e63 7469 6f6e 2077 696c 6c20 616c 6c6f  nction will allo
-0001f380: 7720 796f 7520 746f 2063 6170 2061 6e79  w you to cap any
-0001f390: 206f 6273 6572 7661 7469 6f6e 2075 7369   observation usi
-0001f3a0: 6e67 204d 4144 4420 6d65 7468 6f64 3a0a  ng MADD method:.
-0001f3b0: 2020 2020 2020 2020 4d41 4444 3a20 4d65          MADD: Me
-0001f3c0: 6469 616e 2041 6273 6f6c 7574 6520 4465  dian Absolute De
-0001f3d0: 7669 6174 696f 6e20 4d65 7468 6f64 202d  viation Method -
-0001f3e0: 2069 7427 7320 6120 6661 7374 2061 6e64   it's a fast and
-0001f3f0: 2065 6173 7920 6d65 7468 6f64 2074 6f20   easy method to 
-0001f400: 6669 6e64 206f 7574 6c69 6572 732e 0a20  find outliers.. 
-0001f410: 2020 2049 6e20 6164 6469 7469 6f6e 2c20     In addition, 
-0001f420: 7468 6973 2075 7469 6c69 7479 2061 7574  this utility aut
-0001f430: 6f6d 6174 6963 616c 6c79 2073 656c 6563  omatically selec
-0001f440: 7473 2074 6865 2076 616c 7565 2074 6f20  ts the value to 
-0001f450: 6361 7020 6974 2061 742e 0a20 2020 2020  cap it at..     
-0001f460: 2020 2020 2d2d 2054 6865 2076 616c 7565      -- The value
-0001f470: 2074 6f20 6265 2063 6170 7065 6420 6973   to be capped is
-0001f480: 2062 6173 6564 206f 6e20 6d61 7869 6d75   based on maximu
-0001f490: 6d20 3125 206f 6620 6461 7461 2062 6569  m 1% of data bei
-0001f4a0: 6e67 206f 7574 6c69 6572 732e 0a20 2020  ng outliers..   
-0001f4b0: 2049 7420 6175 746f 6d61 7469 6361 6c6c   It automaticall
-0001f4c0: 7920 6465 7465 726d 696e 6573 2068 6f77  y determines how
-0001f4d0: 2066 6172 2061 7761 7920 6672 6f6d 206d   far away from m
-0001f4e0: 6564 6961 6e20 7468 6520 6461 7461 2070  edian the data p
-0001f4f0: 6f69 6e74 206e 6565 6473 2074 6f20 6265  oint needs to be
-0001f500: 2066 6f72 2069 7420 746f 2063 616c 6c65   for it to calle
-0001f510: 6420 616e 206f 7574 6c69 6572 2e0a 2020  d an outlier..  
-0001f520: 2020 2020 2020 202d 2d20 6974 2075 7365         -- it use
-0001f530: 7320 6120 7468 7265 7368 206e 756d 6265  s a thresh numbe
-0001f540: 723a 2074 6865 206c 6f77 6572 2069 7420  r: the lower it 
-0001f550: 6973 2c20 6d6f 7265 206f 7574 6c69 6572  is, more outlier
-0001f560: 732e 2049 7420 7374 6172 7473 2061 7420  s. It starts at 
-0001f570: 3520 6f72 2068 6967 6865 7220 6173 2074  5 or higher as t
-0001f580: 6872 6573 686f 6c64 2076 616c 7565 2e0a  hreshold value..
-0001f590: 2020 2020 4e6f 7469 6365 2074 6861 7420      Notice that 
-0001f5a0: 6974 2064 6f65 7320 6e6f 7420 7573 6520  it does not use 
-0001f5b0: 6120 6c6f 7765 7220 626f 756e 6420 746f  a lower bound to
-0001f5c0: 2066 696e 6420 746f 6f20 6c6f 7720 6f75   find too low ou
-0001f5d0: 746c 6965 7273 2e20 5468 6174 2079 6f75  tliers. That you
-0001f5e0: 2068 6176 6520 746f 2064 6f20 7468 6174   have to do that
-0001f5f0: 2079 6f75 7273 656c 662e 0a20 2020 2023   yourself..    #
-0001f600: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001f610: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001f620: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001f630: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001f640: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001f650: 2323 2323 2323 2323 0a20 2020 2049 6e70  ########.    Inp
-0001f660: 7574 733a 0a20 2020 2064 6620 3a20 7061  uts:.    df : pa
-0001f670: 6e64 6173 2044 6174 6146 7261 6d65 0a20  ndas DataFrame. 
-0001f680: 2020 2066 6561 7475 7265 733a 2061 2073     features: a s
-0001f690: 696e 676c 6520 636f 6c75 6d6e 206f 7220  ingle column or 
-0001f6a0: 6120 6c69 7374 206f 6620 636f 6c75 6d6e  a list of column
-0001f6b0: 7320 696e 2079 6f75 7220 4461 7461 4672  s in your DataFr
-0001f6c0: 616d 650a 2020 2020 6361 705f 6174 5f6e  ame.    cap_at_n
-0001f6d0: 7468 5f6c 6172 6765 7374 3a20 6465 6661  th_largest: defa
-0001f6e0: 756c 7420 6973 2035 203d 2079 6f75 2063  ult is 5 = you c
-0001f6f0: 616e 2073 6574 2069 7420 746f 2061 6e79  an set it to any
-0001f700: 2069 6e74 6567 6572 2073 7563 6820 6173   integer such as
-0001f710: 2031 2c20 322c 2033 2c20 342c 2035 2c20   1, 2, 3, 4, 5, 
-0001f720: 6574 632e 0a0a 2020 2020 4f75 7470 7574  etc...    Output
-0001f730: 733a 0a20 2020 2064 663a 2070 616e 6461  s:.    df: panda
-0001f740: 7320 4461 7461 4672 616d 650a 2020 2020  s DataFrame.    
-0001f750: 4974 2072 6574 7572 6e73 2074 6865 2073  It returns the s
-0001f760: 616d 6520 6461 7461 6672 616d 6520 6173  ame dataframe as
-0001f770: 2079 6f75 2069 6e70 7574 2075 6e6c 6573   you input unles
-0001f780: 7320 796f 7520 6368 616e 6765 2064 726f  s you change dro
-0001f790: 7020 746f 2054 7275 6520 696e 2074 6865  p to True in the
-0001f7a0: 2069 6e70 7574 2061 7267 756d 656e 742e   input argument.
-0001f7b0: 0a0a 2020 2020 4f70 7469 6f6e 616c 6c79  ..    Optionally
-0001f7c0: 2c20 6974 2063 616e 2064 726f 7020 6365  , it can drop ce
-0001f7d0: 7274 6169 6e20 726f 7773 2074 6861 7420  rtain rows that 
-0001f7e0: 6861 7665 2074 6f6f 206d 616e 7920 6f75  have too many ou
-0001f7f0: 746c 6965 7273 2069 6e20 6174 206c 6561  tliers in at lea
-0001f800: 7374 2033 2063 6f6c 756d 6e73 2073 696d  st 3 columns sim
-0001f810: 756c 7461 6e65 6f75 736c 792e 0a20 2020  ultaneously..   
-0001f820: 2049 6620 6472 6f70 3d54 7275 652c 2069   If drop=True, i
-0001f830: 7420 7769 6c6c 2072 6574 7572 6e20 6120  t will return a 
-0001f840: 736d 616c 6c65 7220 6e75 6d62 6572 206f  smaller number o
-0001f850: 6620 726f 7773 2069 6e20 796f 7572 2064  f rows in your d
-0001f860: 6174 6166 7261 6d65 2074 6861 6e20 7768  ataframe than wh
-0001f870: 6174 2079 6f75 2073 656e 7420 696e 2e20  at you sent in. 
-0001f880: 4265 2063 6172 6566 756c 210a 2020 2020  Be careful!.    
-0001f890: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001f8a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001f8b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001f8c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001f8d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-0001f8e0: 2323 2323 2323 2323 230a 2020 2020 2222  #########.    ""
-0001f8f0: 220a 2020 2020 6466 203d 2064 662e 636f  ".    df = df.co
-0001f900: 7079 2864 6565 703d 5472 7565 290a 2020  py(deep=True).  
-0001f910: 2020 6f75 746c 6965 725f 696e 6469 6365    outlier_indice
-0001f920: 7320 3d20 5b5d 0a20 2020 2069 6463 6f6c  s = [].    idcol
-0001f930: 203d 2027 6964 636f 6c27 0a20 2020 2064   = 'idcol'.    d
-0001f940: 665b 6964 636f 6c5d 203d 2072 616e 6765  f[idcol] = range
-0001f950: 286c 656e 2864 6629 290a 2020 2020 6966  (len(df)).    if
-0001f960: 2069 7369 6e73 7461 6e63 6528 6665 6174   isinstance(feat
-0001f970: 7572 6573 2c20 7374 7229 3a0a 2020 2020  ures, str):.    
-0001f980: 2020 2020 6665 6174 7572 6573 203d 205b      features = [
-0001f990: 6665 6174 7572 6573 5d0a 2020 2020 2320  features].    # 
-0001f9a0: 6974 6572 6174 6520 6f76 6572 2066 6561  iterate over fea
-0001f9b0: 7475 7265 7328 636f 6c75 6d6e 7329 0a20  tures(columns). 
-0001f9c0: 2020 2066 6f72 2063 6f6c 2069 6e20 6665     for col in fe
-0001f9d0: 6174 7572 6573 3a0a 2020 2020 2020 2020  atures:.        
-0001f9e0: 2320 4465 7465 726d 696e 6520 6120 6c69  # Determine a li
-0001f9f0: 7374 206f 6620 696e 6469 6365 7320 6f66  st of indices of
-0001fa00: 206f 7574 6c69 6572 7320 666f 7220 6665   outliers for fe
-0001fa10: 6174 7572 6520 636f 6c0a 2020 2020 2020  ature col.      
-0001fa20: 2020 7468 7265 7368 203d 206f 7574 6c69    thresh = outli
-0001fa30: 6572 5f64 6574 6572 6d69 6e65 5f74 6872  er_determine_thr
-0001fa40: 6573 686f 6c64 2864 662c 2063 6f6c 290a  eshold(df, col).
-0001fa50: 2020 2020 2020 2020 6d61 736b 5f6f 7574          mask_out
-0001fa60: 6c69 6572 7320 3d20 6973 5f6f 7574 6c69  liers = is_outli
-0001fa70: 6572 2864 665b 636f 6c5d 2c20 7468 7265  er(df[col], thre
-0001fa80: 7368 3d74 6872 6573 6829 2e61 7374 7970  sh=thresh).astyp
-0001fa90: 6528 696e 7429 0a20 2020 2020 2020 2064  e(int).        d
-0001faa0: 666f 7574 5f69 6e64 6578 203d 2064 662e  fout_index = df.
-0001fab0: 696c 6f63 5b6e 702e 7768 6572 6528 6d61  iloc[np.where(ma
-0001fac0: 736b 5f6f 7574 6c69 6572 733e 3029 5d2e  sk_outliers>0)].
-0001fad0: 696e 6465 780a 0a20 2020 2020 2020 2064  index..        d
-0001fae0: 665b 2761 6e6f 6d61 6c79 3127 5d20 3d20  f['anomaly1'] = 
-0001faf0: 300a 2020 2020 2020 2020 6466 2e6c 6f63  0.        df.loc
-0001fb00: 5b64 666f 7574 5f69 6e64 6578 202c 2761  [dfout_index ,'a
-0001fb10: 6e6f 6d61 6c79 3127 5d20 3d20 310a 0a20  nomaly1'] = 1.. 
-0001fb20: 2020 2020 2020 2023 2323 2074 6869 7320         ### this 
-0001fb30: 6973 2068 6f77 2074 6865 2063 6f6c 756d  is how the colum
-0001fb40: 6e20 6c6f 6f6b 7320 6e6f 7720 6265 666f  n looks now befo
-0001fb50: 7265 2063 6170 7069 6e67 206f 7574 6c69  re capping outli
-0001fb60: 6572 730a 2020 2020 2020 2020 6966 2076  ers.        if v
-0001fb70: 6572 626f 7365 3a0a 2020 2020 2020 2020  erbose:.        
-0001fb80: 2020 2020 6669 672c 2028 6178 312c 6178      fig, (ax1,ax
-0001fb90: 3229 203d 2070 6c74 2e73 7562 706c 6f74  2) = plt.subplot
-0001fba0: 7328 312c 322c 6669 6773 697a 653d 2831  s(1,2,figsize=(1
-0001fbb0: 322c 3529 290a 2020 2020 2020 2020 2020  2,5)).          
-0001fbc0: 2020 636f 6c6f 7273 203d 207b 303a 2762    colors = {0:'b
-0001fbd0: 6c75 6527 2c20 313a 2772 6564 277d 0a20  lue', 1:'red'}. 
-0001fbe0: 2020 2020 2020 2020 2020 2061 7831 2e73             ax1.s
-0001fbf0: 6361 7474 6572 2864 665b 6964 636f 6c5d  catter(df[idcol]
-0001fc00: 2c20 6466 5b63 6f6c 5d2c 2063 3d64 665b  , df[col], c=df[
-0001fc10: 2261 6e6f 6d61 6c79 3122 5d2e 6170 706c  "anomaly1"].appl
-0001fc20: 7928 6c61 6d62 6461 2078 3a20 636f 6c6f  y(lambda x: colo
-0001fc30: 7273 5b78 5d29 290a 2020 2020 2020 2020  rs[x])).        
-0001fc40: 2020 2020 6178 312e 7365 745f 786c 6162      ax1.set_xlab
-0001fc50: 656c 2827 526f 7720 4944 2729 0a20 2020  el('Row ID').   
-0001fc60: 2020 2020 2020 2020 2061 7831 2e73 6574           ax1.set
-0001fc70: 5f79 6c61 6265 6c28 2754 6172 6765 7420  _ylabel('Target 
-0001fc80: 7661 6c75 6573 2729 0a20 2020 2020 2020  values').       
-0001fc90: 2020 2020 2061 7831 2e73 6574 5f74 6974       ax1.set_tit
-0001fca0: 6c65 2827 2573 2062 6566 6f72 6520 6361  le('%s before ca
-0001fcb0: 7070 696e 6720 6f75 746c 6965 7273 2720  pping outliers' 
-0001fcc0: 2563 6f6c 290a 0a20 2020 2020 2020 2063  %col)..        c
-0001fcd0: 6170 7065 645f 7661 6c75 6520 3d20 6466  apped_value = df
-0001fce0: 2e6c 6f63 5b64 666f 7574 5f69 6e64 6578  .loc[dfout_index
-0001fcf0: 2c20 636f 6c5d 2e6d 696e 2829 2023 2320  , col].min() ## 
-0001fd00: 7468 6973 2069 7320 7468 6520 7661 6c75  this is the valu
-0001fd10: 6520 7765 2063 6170 2069 7420 6167 6169  e we cap it agai
-0001fd20: 6e73 740a 2020 2020 2020 2020 6466 2e6c  nst.        df.l
-0001fd30: 6f63 5b64 666f 7574 5f69 6e64 6578 2c20  oc[dfout_index, 
-0001fd40: 636f 6c5d 203d 2020 6361 7070 6564 5f76  col] =  capped_v
-0001fd50: 616c 7565 2023 2320 6d61 7869 6d75 6d20  alue ## maximum 
-0001fd60: 7661 6c75 6573 2061 7265 206e 6f77 2063  values are now c
-0001fd70: 6170 7065 640a 2020 2020 2020 2020 2323  apped.        ##
-0001fd80: 2320 796f 7520 6172 6520 6e6f 7720 676f  # you are now go
-0001fd90: 6f64 2074 6f20 676f 202d 2079 6f75 2063  od to go - you c
-0001fda0: 616e 2073 686f 7720 686f 7720 7468 6579  an show how they
-0001fdb0: 2061 7265 2063 6170 7065 6420 7573 696e   are capped usin
-0001fdc0: 6720 6265 666f 7265 2061 6e64 2061 6674  g before and aft
-0001fdd0: 6572 2070 6963 730a 2020 2020 2020 2020  er pics.        
-0001fde0: 6966 2076 6572 626f 7365 3a0a 2020 2020  if verbose:.    
-0001fdf0: 2020 2020 2020 2020 636f 6c6f 7273 203d          colors =
-0001fe00: 207b 303a 2762 6c75 6527 2c20 313a 2772   {0:'blue', 1:'r
-0001fe10: 6564 277d 0a20 2020 2020 2020 2020 2020  ed'}.           
-0001fe20: 2061 7832 2e73 6361 7474 6572 2864 665b   ax2.scatter(df[
-0001fe30: 6964 636f 6c5d 2c20 6466 5b63 6f6c 5d2c  idcol], df[col],
-0001fe40: 2063 3d64 665b 2261 6e6f 6d61 6c79 3122   c=df["anomaly1"
-0001fe50: 5d2e 6170 706c 7928 6c61 6d62 6461 2078  ].apply(lambda x
-0001fe60: 3a20 636f 6c6f 7273 5b78 5d29 290a 2020  : colors[x])).  
-0001fe70: 2020 2020 2020 2020 2020 6178 322e 7365            ax2.se
-0001fe80: 745f 786c 6162 656c 2827 526f 7720 4944  t_xlabel('Row ID
-0001fe90: 2729 0a20 2020 2020 2020 2020 2020 2061  ').            a
-0001fea0: 7832 2e73 6574 5f79 6c61 6265 6c28 2754  x2.set_ylabel('T
-0001feb0: 6172 6765 7420 7661 6c75 6573 2729 0a20  arget values'). 
-0001fec0: 2020 2020 2020 2020 2020 2061 7832 2e73             ax2.s
-0001fed0: 6574 5f74 6974 6c65 2827 2573 2061 6674  et_title('%s aft
-0001fee0: 6572 2063 6170 7069 6e67 206f 7574 6c69  er capping outli
-0001fef0: 6572 7327 2025 636f 6c29 0a0a 2020 2020  ers' %col)..    
-0001ff00: 2020 2020 2320 4c65 7427 7320 7361 7665      # Let's save
-0001ff10: 2074 6865 206c 6973 7420 6f66 206f 7574   the list of out
-0001ff20: 6c69 6572 7320 616e 6420 7365 6520 6966  liers and see if
-0001ff30: 2074 6865 7265 2061 7265 2073 6f6d 6520   there are some 
-0001ff40: 7769 7468 206f 7574 6c69 6572 7320 696e  with outliers in
-0001ff50: 206d 756c 7469 706c 6520 636f 6c75 6d6e   multiple column
-0001ff60: 730a 2020 2020 2020 2020 6f75 746c 6965  s.        outlie
-0001ff70: 725f 696e 6469 6365 732e 6578 7465 6e64  r_indices.extend
-0001ff80: 2864 666f 7574 5f69 6e64 6578 290a 0a20  (dfout_index).. 
-0001ff90: 2020 2023 2073 656c 6563 7420 6365 7274     # select cert
-0001ffa0: 6169 6e20 6f62 7365 7276 6174 696f 6e73  ain observations
-0001ffb0: 2063 6f6e 7461 696e 696e 6720 6d6f 7265   containing more
-0001ffc0: 2074 6861 6e20 6f6e 6520 6f75 746c 6965   than one outlie
-0001ffd0: 7220 696e 2032 2063 6f6c 756d 6e73 206f  r in 2 columns o
-0001ffe0: 7220 6d6f 7265 2e20 5765 2063 616e 2064  r more. We can d
-0001fff0: 726f 7020 7468 656d 210a 2020 2020 6f75  rop them!.    ou
-00020000: 746c 6965 725f 696e 6469 6365 7320 3d20  tlier_indices = 
-00020010: 436f 756e 7465 7228 6f75 746c 6965 725f  Counter(outlier_
-00020020: 696e 6469 6365 7329 0a20 2020 206d 756c  indices).    mul
-00020030: 7469 706c 655f 6f75 746c 6965 7273 203d  tiple_outliers =
-00020040: 206c 6973 7428 206b 2066 6f72 206b 2c20   list( k for k, 
-00020050: 7620 696e 206f 7574 6c69 6572 5f69 6e64  v in outlier_ind
-00020060: 6963 6573 2e69 7465 6d73 2829 2069 6620  ices.items() if 
-00020070: 7620 3e20 3320 290a 2020 2020 2323 2320  v > 3 ).    ### 
-00020080: 6e6f 7720 6472 6f70 2074 6865 7365 2072  now drop these r
-00020090: 6f77 7320 616c 746f 6765 7468 6572 2023  ows altogether #
-000200a0: 2323 230a 2020 2020 6466 203d 2064 662e  ###.    df = df.
-000200b0: 6472 6f70 285b 6964 636f 6c2c 2761 6e6f  drop([idcol,'ano
-000200c0: 6d61 6c79 3127 5d2c 2061 7869 733d 3129  maly1'], axis=1)
-000200d0: 0a20 2020 2069 6620 6472 6f70 3a0a 2020  .    if drop:.  
-000200e0: 2020 2020 2020 7072 696e 7428 2753 6861        print('Sha
-000200f0: 7065 206f 6620 6461 7461 6672 616d 6520  pe of dataframe 
-00020100: 6265 666f 7265 206f 7574 6c69 6572 7320  before outliers 
-00020110: 6265 696e 6720 6472 6f70 7065 643a 2025  being dropped: %
-00020120: 7327 2025 2864 662e 7368 6170 652c 2929  s' %(df.shape,))
-00020130: 0a20 2020 2020 2020 206e 756d 6265 725f  .        number_
-00020140: 6f66 5f72 6f77 7320 3d20 6466 2e73 6861  of_rows = df.sha
-00020150: 7065 5b30 5d0a 2020 2020 2020 2020 6466  pe[0].        df
-00020160: 203d 2064 662e 6472 6f70 286d 756c 7469   = df.drop(multi
-00020170: 706c 655f 6f75 746c 6965 7273 2c20 6178  ple_outliers, ax
-00020180: 6973 3d30 290a 2020 2020 2020 2020 7072  is=0).        pr
-00020190: 696e 7428 2753 6861 7065 206f 6620 6461  int('Shape of da
-000201a0: 7461 6672 616d 6520 6166 7465 7220 6f75  taframe after ou
-000201b0: 746c 6965 7273 2062 6569 6e67 2064 726f  tliers being dro
-000201c0: 7070 6564 3a20 2573 2720 2528 6466 2e73  pped: %s' %(df.s
-000201d0: 6861 7065 2c29 290a 2020 2020 2020 2020  hape,)).        
-000201e0: 7072 696e 7428 275c 6e4e 756d 6265 725f  print('\nNumber_
-000201f0: 6f66 5f72 6f77 7320 7769 7468 206d 756c  of_rows with mul
-00020200: 7469 706c 6520 6f75 746c 6965 7273 2069  tiple outliers i
-00020210: 6e20 6d6f 7265 2074 6861 6e20 3320 636f  n more than 3 co
-00020220: 6c75 6d6e 7320 7768 6963 6820 7765 7265  lumns which were
-00020230: 2064 726f 7070 6564 203d 2025 6427 2025   dropped = %d' %
-00020240: 286e 756d 6265 725f 6f66 5f72 6f77 732d  (number_of_rows-
-00020250: 6466 2e73 6861 7065 5b30 5d29 290a 2020  df.shape[0])).  
-00020260: 2020 7265 7475 726e 2064 660a 2323 2323    return df.####
-00020270: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00020280: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00020290: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000202a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000202b0: 2323 2323 2323 2323 2323 2323 230a 696d  #############.im
-000202c0: 706f 7274 2070 616e 6461 7320 6173 2070  port pandas as p
-000202d0: 640a 696d 706f 7274 206e 756d 7079 2061  d.import numpy a
-000202e0: 7320 6e70 0a69 6d70 6f72 7420 7064 620a  s np.import pdb.
-000202f0: 6672 6f6d 2073 6b6c 6561 726e 2e75 7469  from sklearn.uti
-00020300: 6c73 2e76 616c 6964 6174 696f 6e20 696d  ls.validation im
-00020310: 706f 7274 2063 6865 636b 5f58 5f79 2c20  port check_X_y, 
-00020320: 6368 6563 6b5f 6973 5f66 6974 7465 640a  check_is_fitted.
-00020330: 6672 6f6d 2073 6b6c 6561 726e 2e70 7265  from sklearn.pre
-00020340: 7072 6f63 6573 7369 6e67 2069 6d70 6f72  processing impor
-00020350: 7420 4c61 6265 6c45 6e63 6f64 6572 0a66  t LabelEncoder.f
-00020360: 726f 6d20 636f 6c6c 6563 7469 6f6e 7320  rom collections 
-00020370: 696d 706f 7274 2043 6f75 6e74 6572 2c20  import Counter, 
-00020380: 6465 6661 756c 7464 6963 740a 6672 6f6d  defaultdict.from
-00020390: 2073 6b6c 6561 726e 2e62 6173 6520 696d   sklearn.base im
-000203a0: 706f 7274 2042 6173 6545 7374 696d 6174  port BaseEstimat
-000203b0: 6f72 2c20 436c 6173 7369 6669 6572 4d69  or, ClassifierMi
-000203c0: 7869 6e2c 2054 7261 6e73 666f 726d 6572  xin, Transformer
-000203d0: 4d69 7869 6e0a 0a66 726f 6d20 696d 626c  Mixin..from imbl
-000203e0: 6561 726e 2e6f 7665 725f 7361 6d70 6c69  earn.over_sampli
-000203f0: 6e67 2069 6d70 6f72 7420 534d 4f54 452c  ng import SMOTE,
-00020400: 2053 564d 534d 4f54 450a 6672 6f6d 2069   SVMSMOTE.from i
-00020410: 6d62 6c65 6172 6e2e 6f76 6572 5f73 616d  mblearn.over_sam
-00020420: 706c 696e 6720 696d 706f 7274 2041 4441  pling import ADA
-00020430: 5359 4e2c 2053 4d4f 5445 4e43 0a0a 696d  SYN, SMOTENC..im
-00020440: 706f 7274 2070 616e 6461 7320 6173 2070  port pandas as p
-00020450: 640a 696d 706f 7274 206e 756d 7079 2061  d.import numpy a
-00020460: 7320 6e70 0a66 726f 6d20 636f 6c6c 6563  s np.from collec
-00020470: 7469 6f6e 7320 696d 706f 7274 2043 6f75  tions import Cou
-00020480: 6e74 6572 0a69 6d70 6f72 7420 7761 726e  nter.import warn
-00020490: 696e 6773 0a77 6172 6e69 6e67 732e 6669  ings.warnings.fi
-000204a0: 6c74 6572 7761 726e 696e 6773 2822 6967  lterwarnings("ig
-000204b0: 6e6f 7265 2229 0a23 2323 2323 2323 2323  nore").#########
-000204c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000204d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000204e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000204f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00020500: 2323 2323 2323 2323 0a69 6d70 6f72 7420  ########.import 
-00020510: 636f 7079 0a66 726f 6d20 736b 6c65 6172  copy.from sklear
-00020520: 6e2e 636c 7573 7465 7220 696d 706f 7274  n.cluster import
-00020530: 204b 4d65 616e 730a 6465 6620 4645 5f6b   KMeans.def FE_k
-00020540: 6d65 616e 735f 7265 7361 6d70 6c65 7228  means_resampler(
-00020550: 785f 7472 6169 6e2c 2079 5f74 7261 696e  x_train, y_train
-00020560: 2c20 7461 7267 6574 2c20 736d 6f74 653d  , target, smote=
-00020570: 2222 2c20 7665 7262 6f73 653d 3029 3a0a  "", verbose=0):.
-00020580: 2020 2020 2222 220a 2020 2020 5468 6973      """.    This
-00020590: 2066 756e 6374 696f 6e20 636f 6e76 6572   function conver
-000205a0: 7473 2061 2052 6567 7265 7373 696f 6e20  ts a Regression 
-000205b0: 7072 6f62 6c65 6d20 696e 746f 2061 2043  problem into a C
-000205c0: 6c61 7373 6966 6963 6174 696f 6e20 7072  lassification pr
-000205d0: 6f62 6c65 6d20 746f 2065 6e61 626c 6520  oblem to enable 
-000205e0: 534d 4f54 4521 0a20 2020 2049 7420 6973  SMOTE!.    It is
-000205f0: 2061 2076 6572 7920 7369 6d70 6c65 2077   a very simple w
-00020600: 6179 2074 6f20 7365 6e64 2079 6f75 7220  ay to send your 
-00020610: 785f 7472 6169 6e2c 2079 5f74 7261 696e  x_train, y_train
-00020620: 2069 6e20 616e 6420 6765 7420 6261 636b   in and get back
-00020630: 2061 6e20 6f76 6572 7361 6d70 6c65 6420   an oversampled 
-00020640: 785f 7472 6169 6e2c 2079 5f74 7261 696e  x_train, y_train
-00020650: 2e0a 2020 2020 5768 7920 6973 2074 6869  ..    Why is thi
-00020660: 7320 6e65 6564 6564 2069 6e20 4d61 6368  s needed in Mach
-00020670: 696e 6520 4c65 6172 6e69 6e67 2070 726f  ine Learning pro
-00020680: 626c 656d 733f 0a20 2020 2020 2020 2020  blems?.         
-00020690: 496e 2049 6d62 616c 616e 6365 6420 6461  In Imbalanced da
-000206a0: 7461 7365 7473 2c20 6573 702e 2073 6b65  tasets, esp. ske
-000206b0: 7765 6420 7265 6772 6573 7369 6f6e 2070  wed regression p
-000206c0: 726f 626c 656d 7320 7768 6572 6520 7468  roblems where th
-000206d0: 6520 7461 7267 6574 2076 6172 6961 626c  e target variabl
-000206e0: 6520 6973 2073 6b65 7765 642c 2074 6869  e is skewed, thi
-000206f0: 7320 6973 206e 6565 6465 642e 0a20 2020  s is needed..   
-00020700: 2054 7279 2074 6869 7320 6f6e 2079 6f75   Try this on you
-00020710: 7220 736b 6577 6564 2052 6567 7265 7373  r skewed Regress
-00020720: 696f 6e20 7072 6f62 6c65 6d73 2061 6e64  ion problems and
-00020730: 2073 6565 2077 6861 7420 7265 7375 6c74   see what result
-00020740: 7320 796f 7520 6765 742e 2049 7420 7368  s you get. It sh
-00020750: 6f75 6c64 2062 6520 6265 7474 6572 2e0a  ould be better..
-00020760: 2020 2020 2d2d 2d2d 2d2d 2d2d 2d2d 0a20      ----------. 
-00020770: 2020 2049 6e70 7574 730a 2020 2020 2d2d     Inputs.    --
-00020780: 2d2d 2d2d 2d2d 2d2d 0a20 2020 2078 5f74  --------.    x_t
-00020790: 7261 696e 203a 2070 616e 6461 7320 6461  rain : pandas da
-000207a0: 7461 6672 616d 653a 2079 6f75 206d 7573  taframe: you mus
-000207b0: 7420 7365 6e64 2069 6e20 7468 6520 6461  t send in the da
-000207c0: 7461 2077 6974 6820 7072 6564 6963 746f  ta with predicto
-000207d0: 7273 206f 6e6c 792e 0a20 2020 206d 696e  rs only..    min
-000207e0: 5f6e 5f73 616d 706c 6573 203a 2069 6e74  _n_samples : int
-000207f0: 2c20 6465 6661 756c 743d 353a 206d 696e  , default=5: min
-00020800: 206e 756d 6265 7220 6f66 2073 616d 706c   number of sampl
-00020810: 6573 2062 656c 6f77 2077 6869 6368 2079  es below which y
-00020820: 6f75 2063 6f6d 6269 6e65 2062 696e 730a  ou combine bins.
-00020830: 2020 2020 6269 6e73 203a 2069 6e74 2c20      bins : int, 
-00020840: 6465 6661 756c 743d 333a 2068 6f77 206d  default=3: how m
-00020850: 616e 7920 6269 6e73 2079 6f75 2077 616e  any bins you wan
-00020860: 7420 746f 2073 706c 6974 2074 6172 6765  t to split targe
-00020870: 7420 696e 746f 0a0a 2020 2020 4f75 7470  t into..    Outp
-00020880: 7574 730a 2020 2020 2d2d 2d2d 2d2d 2d2d  uts.    --------
-00020890: 2d2d 0a20 2020 206e 5f66 6561 7475 7265  --.    n_feature
-000208a0: 735f 203a 2069 6e74 0a20 2020 2020 2020  s_ : int.       
-000208b0: 2054 6865 206e 756d 6265 7220 6f66 2066   The number of f
-000208c0: 6561 7475 7265 7320 6f66 2074 6865 2064  eatures of the d
-000208d0: 6174 6120 7061 7373 6564 2074 6f20 3a6d  ata passed to :m
-000208e0: 6574 683a 6066 6974 602e 0a20 2020 2022  eth:`fit`..    "
-000208f0: 2222 0a20 2020 2078 5f74 7261 696e 5f63  "".    x_train_c
-00020900: 203d 2063 6f70 792e 6465 6570 636f 7079   = copy.deepcopy
-00020910: 2878 5f74 7261 696e 290a 2020 2020 785f  (x_train).    x_
-00020920: 7472 6169 6e5f 635b 7461 7267 6574 5d20  train_c[target] 
-00020930: 3d20 795f 7472 6169 6e2e 7661 6c75 6573  = y_train.values
-00020940: 0a0a 2020 2020 2320 5265 6772 6573 7369  ..    # Regressi
-00020950: 6f6e 2070 726f 626c 656d 2074 7572 6e65  on problem turne
-00020960: 6420 696e 746f 2043 6c61 7373 6966 6963  d into Classific
-00020970: 6174 696f 6e20 7072 6f62 6c65 6d0a 2020  ation problem.  
-00020980: 2020 6e5f 636c 7573 7465 7273 203d 206d    n_clusters = m
-00020990: 6178 2833 2c20 696e 7428 6e70 2e6c 6f67  ax(3, int(np.log
-000209a0: 3130 286c 656e 2879 5f74 7261 696e 2929  10(len(y_train))
-000209b0: 2920 2b20 3129 0a20 2020 2023 2055 7365  ) + 1).    # Use
-000209c0: 204b 4d65 616e 7320 746f 2066 696e 6420   KMeans to find 
-000209d0: 6e61 7475 7261 6c20 636c 7573 7465 7273  natural clusters
-000209e0: 2069 6e20 796f 7572 2064 6174 610a 2020   in your data.  
-000209f0: 2020 6b6d 5f6d 6f64 656c 203d 204b 4d65    km_model = KMe
-00020a00: 616e 7328 6e5f 636c 7573 7465 7273 3d6e  ans(n_clusters=n
-00020a10: 5f63 6c75 7374 6572 732c 0a20 2020 2020  _clusters,.     
-00020a20: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00020a30: 206e 5f69 6e69 743d 352c 0a20 2020 2020   n_init=5,.     
-00020a40: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00020a50: 2072 616e 646f 6d5f 7374 6174 653d 3939   random_state=99
-00020a60: 290a 2020 2020 2323 2323 2072 656d 656d  ).    #### remem
-00020a70: 6265 7220 796f 7520 6d75 7374 2070 7265  ber you must pre
-00020a80: 6469 6374 2075 7369 6e67 206f 6e6c 7920  dict using only 
-00020a90: 7072 6564 6963 746f 7220 7661 7269 6162  predictor variab
-00020aa0: 6c65 7321 0a20 2020 2079 5f74 7261 696e  les!.    y_train
-00020ab0: 5f63 203d 206b 6d5f 6d6f 6465 6c2e 6669  _c = km_model.fi
-00020ac0: 745f 7072 6564 6963 7428 785f 7472 6169  t_predict(x_trai
-00020ad0: 6e29 0a0a 2020 2020 6966 2076 6572 626f  n)..    if verbo
-00020ae0: 7365 203e 3d20 313a 0a20 2020 2020 2020  se >= 1:.       
-00020af0: 2070 7269 6e74 2827 4e75 6d62 6572 206f   print('Number o
-00020b00: 6620 636c 7573 7465 7273 2063 7265 6174  f clusters creat
-00020b10: 6564 203d 2025 6427 2025 6e5f 636c 7573  ed = %d' %n_clus
-00020b20: 7465 7273 290a 0a20 2020 2023 2323 2320  ters)..    #### 
-00020b30: 4765 6e65 7261 7465 2074 6865 206f 7665  Generate the ove
-00020b40: 722d 7361 6d70 6c65 6420 6461 7461 0a20  r-sampled data. 
-00020b50: 2020 2023 2323 2320 4144 4153 594e 202f     #### ADASYN /
-00020b60: 2053 4d4f 5445 206f 7665 7273 616d 706c   SMOTE oversampl
-00020b70: 696e 6720 2323 2323 230a 2020 2020 6966  ing #####.    if
-00020b80: 2069 7369 6e73 7461 6e63 6528 736d 6f74   isinstance(smot
-00020b90: 652c 2073 7472 293a 0a20 2020 2020 2020  e, str):.       
-00020ba0: 2078 5f74 7261 696e 5f65 7874 2c20 5f20   x_train_ext, _ 
-00020bb0: 3d20 6f76 6572 7361 6d70 6c65 5f53 4d4f  = oversample_SMO
-00020bc0: 5445 2878 5f74 7261 696e 5f63 2c20 795f  TE(x_train_c, y_
-00020bd0: 7472 6169 6e5f 6329 0a20 2020 2065 6c73  train_c).    els
-00020be0: 653a 0a20 2020 2020 2020 2078 5f74 7261  e:.        x_tra
-00020bf0: 696e 5f65 7874 2c20 5f20 3d20 736d 6f74  in_ext, _ = smot
-00020c00: 652e 6669 745f 7265 7361 6d70 6c65 2878  e.fit_resample(x
-00020c10: 5f74 7261 696e 5f63 2c20 795f 7472 6169  _train_c, y_trai
-00020c20: 6e5f 6329 0a20 2020 2079 5f74 7261 696e  n_c).    y_train
-00020c30: 5f65 7874 203d 2078 5f74 7261 696e 5f65  _ext = x_train_e
-00020c40: 7874 5b74 6172 6765 745d 2e76 616c 7565  xt[target].value
-00020c50: 730a 2020 2020 785f 7472 6169 6e5f 6578  s.    x_train_ex
-00020c60: 7420 3d20 785f 7472 6169 6e5f 6578 742e  t = x_train_ext.
-00020c70: 6472 6f70 2874 6172 6765 742c 2061 7869  drop(target, axi
-00020c80: 733d 3129 0a20 2020 2072 6574 7572 6e20  s=1).    return 
-00020c90: 2878 5f74 7261 696e 5f65 7874 2c20 795f  (x_train_ext, y_
-00020ca0: 7472 6169 6e5f 6578 7429 0a0a 2323 2323  train_ext)..####
-00020cb0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00020cc0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00020cd0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00020ce0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00020cf0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00020d00: 2323 2323 2323 2323 2323 2323 2323 230a  ###############.
-00020d10: 2320 4361 6c63 756c 6174 6520 636c 6173  # Calculate clas
-00020d20: 7320 7765 6967 6874 0a69 6d70 6f72 7420  s weight.import 
-00020d30: 636f 7079 0a66 726f 6d20 636f 6c6c 6563  copy.from collec
-00020d40: 7469 6f6e 7320 696d 706f 7274 2043 6f75  tions import Cou
-00020d50: 6e74 6572 0a66 726f 6d20 736b 6c65 6172  nter.from sklear
-00020d60: 6e2e 7574 696c 732e 636c 6173 735f 7765  n.utils.class_we
-00020d70: 6967 6874 2069 6d70 6f72 7420 636f 6d70  ight import comp
-00020d80: 7574 655f 636c 6173 735f 7765 6967 6874  ute_class_weight
-00020d90: 0a64 6566 2067 6574 5f63 6c61 7373 5f64  .def get_class_d
-00020da0: 6973 7472 6962 7574 696f 6e28 795f 696e  istribution(y_in
-00020db0: 7075 742c 2076 6572 626f 7365 3d30 293a  put, verbose=0):
-00020dc0: 0a20 2020 2079 5f69 6e70 7574 203d 2063  .    y_input = c
-00020dd0: 6f70 792e 6465 6570 636f 7079 2879 5f69  opy.deepcopy(y_i
-00020de0: 6e70 7574 290a 2020 2020 636c 6173 7365  nput).    classe
-00020df0: 7320 3d20 6e70 2e75 6e69 7175 6528 795f  s = np.unique(y_
-00020e00: 696e 7075 7429 0a20 2020 2078 7020 3d20  input).    xp = 
-00020e10: 436f 756e 7465 7228 795f 696e 7075 7429  Counter(y_input)
-00020e20: 0a20 2020 2063 6c61 7373 5f77 6569 6768  .    class_weigh
-00020e30: 7473 203d 2063 6f6d 7075 7465 5f63 6c61  ts = compute_cla
-00020e40: 7373 5f77 6569 6768 7428 2762 616c 616e  ss_weight('balan
-00020e50: 6365 6427 2c20 636c 6173 7365 733d 6e70  ced', classes=np
-00020e60: 2e75 6e69 7175 6528 795f 696e 7075 7429  .unique(y_input)
-00020e70: 2c20 793d 795f 696e 7075 7429 0a20 2020  , y=y_input).   
-00020e80: 2069 6620 6c65 6e28 636c 6173 735f 7765   if len(class_we
-00020e90: 6967 6874 735b 2863 6c61 7373 5f77 6569  ights[(class_wei
-00020ea0: 6768 7473 3e20 3130 295d 2920 3e20 303a  ghts> 10)]) > 0:
-00020eb0: 0a20 2020 2020 2020 2063 6c61 7373 5f77  .        class_w
-00020ec0: 6569 6768 7473 203d 2028 636c 6173 735f  eights = (class_
-00020ed0: 7765 6967 6874 732f 3130 290a 2020 2020  weights/10).    
-00020ee0: 656c 7365 3a0a 2020 2020 2020 2020 636c  else:.        cl
-00020ef0: 6173 735f 7765 6967 6874 7320 3d20 2863  ass_weights = (c
-00020f00: 6c61 7373 5f77 6569 6768 7473 290a 2020  lass_weights).  
-00020f10: 2020 2370 7269 6e74 2827 2020 2020 636c    #print('    cl
-00020f20: 6173 735f 7765 6967 6874 7320 3d20 2573  ass_weights = %s
-00020f30: 2720 2563 6c61 7373 5f77 6569 6768 7473  ' %class_weights
-00020f40: 290a 2020 2020 636c 6173 735f 7765 6967  ).    class_weig
-00020f50: 6874 735b 2863 6c61 7373 5f77 6569 6768  hts[(class_weigh
-00020f60: 7473 3c31 295d 3d31 0a20 2020 2063 6c61  ts<1)]=1.    cla
-00020f70: 7373 5f72 6f77 7320 3d20 636c 6173 735f  ss_rows = class_
-00020f80: 7765 6967 6874 732a 5b78 705b 785d 2066  weights*[xp[x] f
-00020f90: 6f72 2078 2069 6e20 636c 6173 7365 735d  or x in classes]
-00020fa0: 0a20 2020 2063 6c61 7373 5f72 6f77 7320  .    class_rows 
-00020fb0: 3d20 636c 6173 735f 726f 7773 2e61 7374  = class_rows.ast
-00020fc0: 7970 6528 696e 7429 0a20 2020 2063 6c61  ype(int).    cla
-00020fd0: 7373 5f77 6569 6768 7465 645f 726f 7773  ss_weighted_rows
-00020fe0: 203d 2064 6963 7428 7a69 7028 636c 6173   = dict(zip(clas
-00020ff0: 7365 732c 636c 6173 735f 726f 7773 2929  ses,class_rows))
-00021000: 0a20 2020 2069 6620 7665 7262 6f73 653a  .    if verbose:
-00021010: 0a20 2020 2020 2020 2070 7269 6e74 2827  .        print('
-00021020: 2020 2020 636c 6173 735f 7765 6967 6874      class_weight
-00021030: 6564 5f72 6f77 7320 3d20 2573 2720 2563  ed_rows = %s' %c
-00021040: 6c61 7373 5f77 6569 6768 7465 645f 726f  lass_weighted_ro
-00021050: 7773 290a 2020 2020 7265 7475 726e 2063  ws).    return c
-00021060: 6c61 7373 5f77 6569 6768 7465 645f 726f  lass_weighted_ro
-00021070: 7773 0a0a 0a64 6566 206f 7665 7273 616d  ws...def oversam
-00021080: 706c 655f 534d 4f54 4528 582c 7929 3a0a  ple_SMOTE(X,y):.
-00021090: 2020 2020 2369 6e70 7574 2044 6174 6146      #input DataF
-000210a0: 7261 6d65 0a20 2020 2023 5820 e286 9249  rame.    #X ...I
-000210b0: 6e64 6570 656e 6465 6e74 2056 6172 6961  ndependent Varia
-000210c0: 626c 6520 696e 2044 6174 6146 7261 6d65  ble in DataFrame
-000210d0: 5c0a 2020 2020 2379 20e2 8692 6465 7065  \.    #y ...depe
-000210e0: 6e64 656e 7420 5661 7269 6162 6c65 2069  ndent Variable i
-000210f0: 6e20 5061 6e64 6173 2044 6174 6146 7261  n Pandas DataFra
-00021100: 6d65 2066 6f72 6d61 740a 2020 2020 2320  me format.    # 
-00021110: 4765 7420 7468 6520 636c 6173 7320 6469  Get the class di
-00021120: 7374 7269 7562 7469 6f6e 2066 6f72 2070  striubtion for p
-00021130: 6572 666f 6d69 6e67 2072 656c 6174 6976  erfoming relativ
-00021140: 6520 7361 6d70 6c69 6e67 2069 6e20 7468  e sampling in th
-00021150: 6520 6e65 7874 206c 696e 650a 2020 2020  e next line.    
-00021160: 636c 6173 735f 7765 6967 6874 6564 5f72  class_weighted_r
-00021170: 6f77 7320 3d20 6765 745f 636c 6173 735f  ows = get_class_
-00021180: 6469 7374 7269 6275 7469 6f6e 2879 290a  distribution(y).
-00021190: 2020 2020 736d 6f74 6520 3d20 5356 4d53      smote = SVMS
-000211a0: 4d4f 5445 2820 7261 6e64 6f6d 5f73 7461  MOTE( random_sta
-000211b0: 7465 3d32 372c 0a20 2020 2020 2020 2020  te=27,.         
-000211c0: 2020 2020 2020 2020 2073 616d 706c 696e           samplin
-000211d0: 675f 7374 7261 7465 6779 3d63 6c61 7373  g_strategy=class
-000211e0: 5f77 6569 6768 7465 645f 726f 7773 290a  _weighted_rows).
-000211f0: 2020 2020 582c 2079 203d 2073 6d6f 7465      X, y = smote
-00021200: 2e66 6974 5f72 6573 616d 706c 6528 582c  .fit_resample(X,
-00021210: 2079 290a 2020 2020 7265 7475 726e 2858   y).    return(X
-00021220: 2c79 290a 0a64 6566 206f 7665 7273 616d  ,y)..def oversam
-00021230: 706c 655f 4144 4153 594e 2858 2c79 293a  ple_ADASYN(X,y):
-00021240: 0a20 2020 2023 696e 7075 7420 4461 7461  .    #input Data
-00021250: 4672 616d 650a 2020 2020 2358 20e2 8692  Frame.    #X ...
-00021260: 496e 6465 7065 6e64 656e 7420 5661 7269  Independent Vari
-00021270: 6162 6c65 2069 6e20 4461 7461 4672 616d  able in DataFram
-00021280: 655c 0a20 2020 2023 7920 e286 9264 6570  e\.    #y ...dep
-00021290: 656e 6465 6e74 2056 6172 6961 626c 6520  endent Variable 
-000212a0: 696e 2050 616e 6461 7320 4461 7461 4672  in Pandas DataFr
-000212b0: 616d 6520 666f 726d 6174 0a20 2020 2023  ame format.    #
-000212c0: 2047 6574 2074 6865 2063 6c61 7373 2064   Get the class d
-000212d0: 6973 7472 6975 6274 696f 6e20 666f 7220  istriubtion for 
-000212e0: 7065 7266 6f6d 696e 6720 7265 6c61 7469  perfoming relati
-000212f0: 7665 2073 616d 706c 696e 6720 696e 2074  ve sampling in t
-00021300: 6865 206e 6578 7420 6c69 6e65 0a20 2020  he next line.   
-00021310: 2063 6c61 7373 5f77 6569 6768 7465 645f   class_weighted_
-00021320: 726f 7773 203d 2067 6574 5f63 6c61 7373  rows = get_class
-00021330: 5f64 6973 7472 6962 7574 696f 6e28 7929  _distribution(y)
-00021340: 0a20 2020 2023 2059 6f75 7220 6661 766f  .    # Your favo
-00021350: 7572 6974 6520 6f76 6572 7361 6d70 6c65  urite oversample
-00021360: 720a 2020 2020 736d 6f74 6520 3d20 4144  r.    smote = AD
-00021370: 4153 594e 2872 616e 646f 6d5f 7374 6174  ASYN(random_stat
-00021380: 653d 3237 2c0a 2020 2020 2020 2020 2020  e=27,.          
-00021390: 2020 2020 2020 2020 2073 616d 706c 696e           samplin
-000213a0: 675f 7374 7261 7465 6779 3d63 6c61 7373  g_strategy=class
-000213b0: 5f77 6569 6768 7465 645f 726f 7773 290a  _weighted_rows).
-000213c0: 2020 2020 582c 2079 203d 2073 6d6f 7465      X, y = smote
-000213d0: 2e66 6974 5f72 6573 616d 706c 6528 582c  .fit_resample(X,
-000213e0: 2079 290a 2020 2020 7265 7475 726e 2858   y).    return(X
-000213f0: 2c79 290a 2323 2323 2323 2323 2323 2323  ,y).############
-00021400: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00021410: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00021420: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00021430: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00021440: 230a 696d 706f 7274 206e 756d 7079 2061  #.import numpy a
-00021450: 7320 6e70 0a69 6d70 6f72 7420 7061 6e64  s np.import pand
-00021460: 6173 2061 7320 7064 0a66 726f 6d20 736b  as as pd.from sk
-00021470: 6c65 6172 6e2e 6d6f 6465 6c5f 7365 6c65  learn.model_sele
-00021480: 6374 696f 6e20 696d 706f 7274 2074 7261  ction import tra
-00021490: 696e 5f74 6573 745f 7370 6c69 740a 6465  in_test_split.de
-000214a0: 6620 7370 6c69 745f 6461 7461 5f6e 5f77  f split_data_n_w
-000214b0: 6179 7328 6466 2c20 7461 7267 6574 2c20  ays(df, target, 
-000214c0: 6e5f 7370 6c69 7473 2c20 7465 7374 5f73  n_splits, test_s
-000214d0: 697a 653d 302e 322c 206d 6f64 656c 7479  ize=0.2, modelty
-000214e0: 7065 3d4e 6f6e 652c 2a2a 6b77 6172 6773  pe=None,**kwargs
-000214f0: 293a 0a20 2020 2022 2222 0a20 2020 2049  ):.    """.    I
-00021500: 6e70 7574 733a 0a20 2020 2064 663a 2064  nputs:.    df: d
-00021510: 6174 6166 7261 6d65 2074 6861 7420 796f  ataframe that yo
-00021520: 7520 7761 6e74 2074 6f20 7370 6c69 740a  u want to split.
-00021530: 2020 2020 7461 7267 6574 3a20 7468 6520      target: the 
-00021540: 7461 7267 6574 2076 6172 6961 626c 6520  target variable 
-00021550: 696e 2064 6174 6120 6672 616d 6520 2864  in data frame (d
-00021560: 6629 0a20 2020 206e 5f73 706c 6974 733a  f).    n_splits:
-00021570: 206e 756d 6265 7220 6f66 2077 6179 7320   number of ways 
-00021580: 696e 2077 6869 6368 2079 6f75 2077 616e  in which you wan
-00021590: 7420 746f 2073 706c 6974 2074 6865 2064  t to split the d
-000215a0: 6174 6120 6672 616d 6520 2864 6566 6175  ata frame (defau
-000215b0: 6c74 3d33 290a 2020 2020 7465 7374 5f73  lt=3).    test_s
-000215c0: 697a 653a 2073 697a 6520 6f66 2074 6865  ize: size of the
-000215d0: 2074 6573 7420 6461 7461 7365 743a 2064   test dataset: d
-000215e0: 6566 6175 6c74 2069 7320 302e 3220 4275  efault is 0.2 Bu
-000215f0: 7420 6974 2073 706c 6974 7320 7468 6973  t it splits this
-00021600: 2074 6573 7420 696e 746f 2076 616c 6964   test into valid
-00021610: 2061 6e64 2074 6573 7420 6861 6c66 2e0a   and test half..
-00021620: 2020 2020 4865 6e63 6520 796f 7520 7769      Hence you wi
-00021630: 6c6c 2067 6574 2031 3025 206f 6620 6466  ll get 10% of df
-00021640: 2061 7320 7465 7374 2061 6e64 2031 3025   as test and 10%
-00021650: 206f 6620 6466 2061 7320 7661 6c69 6420   of df as valid 
-00021660: 616e 6420 7265 6d61 696e 696e 6720 3830  and remaining 80
-00021670: 2520 6173 2074 7261 696e 0a20 2020 2023  % as train.    #
-00021680: 2323 2323 2323 2323 2323 2323 2323 2320  ############### 
-00021690: 2020 686f 7720 6974 2077 6f72 6b73 2023    how it works #
-000216a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000216b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000216c0: 2323 2323 2323 2323 2323 2323 2323 230a  ###############.
-000216d0: 2020 2020 596f 7520 6361 6e20 7370 6c69      You can spli
-000216e0: 7420 6120 6461 7461 6672 616d 6520 7468  t a dataframe th
-000216f0: 7265 6520 7761 7973 206f 7220 7369 7820  ree ways or six 
-00021700: 7761 7973 2064 6570 656e 6469 6e67 206f  ways depending o
-00021710: 6e20 796f 7572 206e 6565 642e 2054 6872  n your need. Thr
-00021720: 6565 2077 6179 7320 6973 3a0a 2020 2020  ee ways is:.    
-00021730: 7472 6169 6e2c 2076 616c 6964 2c20 7465  train, valid, te
-00021740: 7374 0a20 2020 2053 6978 2077 6179 7320  st.    Six ways 
-00021750: 6361 6e20 6265 3a0a 2020 2020 585f 7472  can be:.    X_tr
-00021760: 6169 6e2c 795f 7472 6169 6e2c 2058 5f76  ain,y_train, X_v
-00021770: 616c 6964 2c20 795f 7661 6c69 642c 2058  alid, y_valid, X
-00021780: 5f74 6573 742c 2079 5f74 6573 740a 2020  _test, y_test.  
-00021790: 2020 596f 7520 7769 6c6c 2067 6574 2061    You will get a
-000217a0: 206c 6973 7420 636f 6e74 6169 6e69 6e67   list containing
-000217b0: 2074 6865 7365 2064 6174 6166 7261 6d65   these dataframe
-000217c0: 732e 2e2e 6465 7065 6e64 696e 6720 6f6e  s...depending on
-000217d0: 2077 6861 7420 796f 7520 656e 7465 7265   what you entere
-000217e0: 6420 6173 206e 756d 6265 7220 6f66 2073  d as number of s
-000217f0: 706c 6974 730a 2020 2020 4f75 7470 7574  plits.    Output
-00021800: 3a20 4c69 7374 206f 6620 6461 7461 6672  : List of datafr
-00021810: 616d 6573 0a20 2020 2022 2222 0a20 2020  ames.    """.   
-00021820: 2069 6620 6b77 6172 6773 3a0a 2020 2020   if kwargs:.    
-00021830: 2020 2020 666f 7220 6b65 792c 2076 616c      for key, val
-00021840: 2069 6e20 6b77 6172 6773 3a0a 2020 2020   in kwargs:.    
-00021850: 2020 2020 2020 2020 6966 206b 6579 203d          if key =
-00021860: 3d20 276d 6f64 656c 7479 7065 273a 0a20  = 'modeltype':. 
-00021870: 2020 2020 2020 2020 2020 2020 2020 206b                 k
-00021880: 6579 203d 2076 616c 0a20 2020 2020 2020  ey = val.       
-00021890: 2020 2020 2069 6620 6b65 7920 3d3d 2027       if key == '
-000218a0: 7465 7374 5f73 697a 6527 3a0a 2020 2020  test_size':.    
-000218b0: 2020 2020 2020 2020 2020 2020 7465 7374              test
-000218c0: 5f73 697a 6520 3d20 7661 6c0a 2020 2020  _size = val.    
-000218d0: 6966 206d 6f64 656c 7479 7065 2069 7320  if modeltype is 
-000218e0: 4e6f 6e65 3a0a 2020 2020 2020 2020 6966  None:.        if
-000218f0: 2069 7369 6e73 7461 6e63 6528 7461 7267   isinstance(targ
-00021900: 6574 2c20 7374 7229 3a0a 2020 2020 2020  et, str):.      
-00021910: 2020 2020 2020 6966 2064 665b 7461 7267        if df[targ
-00021920: 6574 5d2e 6474 7970 6520 3d3d 2066 6c6f  et].dtype == flo
-00021930: 6174 3a0a 2020 2020 2020 2020 2020 2020  at:.            
-00021940: 2020 2020 6d6f 6465 6c74 7970 6520 3d20      modeltype = 
-00021950: 2752 6567 7265 7373 696f 6e27 0a20 2020  'Regression'.   
-00021960: 2020 2020 2020 2020 2065 6c73 653a 0a20           else:. 
-00021970: 2020 2020 2020 2020 2020 2020 2020 206d                 m
-00021980: 6f64 656c 7479 7065 203d 2027 436c 6173  odeltype = 'Clas
-00021990: 7369 6669 6361 7469 6f6e 270a 2020 2020  sification'.    
-000219a0: 2020 2020 2020 2020 7461 7267 6574 203d          target =
-000219b0: 205b 7461 7267 6574 5d0a 2020 2020 2020   [target].      
-000219c0: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
-000219d0: 2020 2020 6966 2064 665b 7461 7267 6574      if df[target
-000219e0: 5b30 5d5d 2e64 7479 7065 203d 3d20 666c  [0]].dtype == fl
-000219f0: 6f61 743a 0a20 2020 2020 2020 2020 2020  oat:.           
-00021a00: 2020 2020 206d 6f64 656c 7479 7065 203d       modeltype =
-00021a10: 2027 5265 6772 6573 7369 6f6e 270a 2020   'Regression'.  
-00021a20: 2020 2020 2020 2020 2020 656c 7365 3a0a            else:.
-00021a30: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00021a40: 206d 6f64 656c 7479 7065 203d 2027 436c   modeltype = 'Cl
-00021a50: 6173 7369 6669 6361 7469 6f6e 270a 2020  assification'.  
-00021a60: 2020 7072 6564 7320 3d20 5b78 2066 6f72    preds = [x for
-00021a70: 2078 2069 6e20 6c69 7374 2864 6629 2069   x in list(df) i
-00021a80: 6620 7820 6e6f 7420 696e 2074 6172 6765  f x not in targe
-00021a90: 745d 0a20 2020 2070 7269 6e74 2827 4e75  t].    print('Nu
-00021aa0: 6d62 6572 206f 6620 7072 6564 6963 746f  mber of predicto
-00021ab0: 7273 2069 6e20 6461 7461 7365 743a 2025  rs in dataset: %
-00021ac0: 6427 2025 6c65 6e28 7072 6564 7329 290a  d' %len(preds)).
-00021ad0: 2020 2020 6c69 7374 5f6f 665f 6466 7320      list_of_dfs 
-00021ae0: 3d20 5b5d 0a20 2020 2069 6620 6d6f 6465  = [].    if mode
-00021af0: 6c74 7970 6520 3d3d 2027 5265 6772 6573  ltype == 'Regres
-00021b00: 7369 6f6e 273a 0a20 2020 2020 2020 206e  sion':.        n
-00021b10: 756d 7320 3d20 696e 7428 2831 2d74 6573  ums = int((1-tes
-00021b20: 745f 7369 7a65 292a 6466 2e73 6861 7065  t_size)*df.shape
-00021b30: 5b30 5d29 0a20 2020 2020 2020 2074 7261  [0]).        tra
-00021b40: 696e 2c20 7465 7374 6c61 7267 6520 3d20  in, testlarge = 
-00021b50: 6466 5b3a 6e75 6d73 5d2c 2064 665b 6e75  df[:nums], df[nu
-00021b60: 6d73 3a5d 0a20 2020 2065 6c73 653a 0a20  ms:].    else:. 
-00021b70: 2020 2020 2020 2074 7261 696e 2c20 7465         train, te
-00021b80: 7374 6c61 7267 6520 3d20 7472 6169 6e5f  stlarge = train_
-00021b90: 7465 7374 5f73 706c 6974 2864 662c 2074  test_split(df, t
-00021ba0: 6573 745f 7369 7a65 3d74 6573 745f 7369  est_size=test_si
-00021bb0: 7a65 2c20 7261 6e64 6f6d 5f73 7461 7465  ze, random_state
-00021bc0: 3d34 3229 0a20 2020 206c 6973 745f 6f66  =42).    list_of
-00021bd0: 5f64 6673 2e61 7070 656e 6428 7472 6169  _dfs.append(trai
-00021be0: 6e29 0a20 2020 2069 6620 6e5f 7370 6c69  n).    if n_spli
-00021bf0: 7473 203d 3d20 323a 0a20 2020 2020 2020  ts == 2:.       
-00021c00: 2070 7269 6e74 2827 5265 7475 726e 696e   print('Returnin
-00021c10: 6720 6120 5475 706c 6520 7769 7468 2074  g a Tuple with t
-00021c20: 776f 2064 6174 6166 7261 6d65 7320 616e  wo dataframes an
-00021c30: 6420 7368 6170 6573 3a20 2825 732c 2573  d shapes: (%s,%s
-00021c40: 2927 2025 2874 7261 696e 2e73 6861 7065  )' %(train.shape
-00021c50: 2c20 7465 7374 6c61 7267 652e 7368 6170  , testlarge.shap
-00021c60: 6529 290a 2020 2020 2020 2020 7265 7475  e)).        retu
-00021c70: 726e 2074 7261 696e 2c20 7465 7374 6c61  rn train, testla
-00021c80: 7267 650a 2020 2020 656c 6966 206d 6f64  rge.    elif mod
-00021c90: 656c 7479 7065 203d 3d20 2752 6567 7265  eltype == 'Regre
-00021ca0: 7373 696f 6e27 2061 6e64 206e 5f73 706c  ssion' and n_spl
-00021cb0: 6974 7320 3d3d 2033 3a0a 2020 2020 2020  its == 3:.      
-00021cc0: 2020 6e75 6d73 3220 3d20 696e 7428 302e    nums2 = int(0.
-00021cd0: 352a 2874 6573 746c 6172 6765 2e73 6861  5*(testlarge.sha
-00021ce0: 7065 5b30 5d29 290a 2020 2020 2020 2020  pe[0])).        
-00021cf0: 7661 6c69 642c 2074 6573 7420 3d20 7465  valid, test = te
-00021d00: 7374 6c61 7267 655b 3a6e 756d 7332 5d2c  stlarge[:nums2],
-00021d10: 2074 6573 746c 6172 6765 5b6e 756d 7332   testlarge[nums2
-00021d20: 3a5d 0a20 2020 2020 2020 2070 7269 6e74  :].        print
-00021d30: 2827 5265 7475 726e 696e 6720 6120 5475  ('Returning a Tu
-00021d40: 706c 6520 7769 7468 2074 6872 6565 2064  ple with three d
-00021d50: 6174 6166 7261 6d65 7320 616e 6420 7368  ataframes and sh
-00021d60: 6170 6573 3a20 2825 732c 2573 2c25 7329  apes: (%s,%s,%s)
-00021d70: 2720 2528 7472 6169 6e2e 7368 6170 652c  ' %(train.shape,
-00021d80: 2076 616c 6964 2e73 6861 7065 2c20 7465   valid.shape, te
-00021d90: 7374 2e73 6861 7065 2929 0a20 2020 2020  st.shape)).     
-00021da0: 2020 2072 6574 7572 6e20 7472 6169 6e2c     return train,
-00021db0: 2076 616c 6964 2c20 7465 7374 0a20 2020   valid, test.   
-00021dc0: 2065 6c69 6620 6d6f 6465 6c74 7970 6520   elif modeltype 
-00021dd0: 3d3d 2027 436c 6173 7369 6669 6361 7469  == 'Classificati
-00021de0: 6f6e 2720 616e 6420 6e5f 7370 6c69 7473  on' and n_splits
-00021df0: 203d 3d20 333a 0a20 2020 2020 2020 2076   == 3:.        v
-00021e00: 616c 6964 2c20 7465 7374 203d 2074 7261  alid, test = tra
-00021e10: 696e 5f74 6573 745f 7370 6c69 7428 7465  in_test_split(te
-00021e20: 7374 6c61 7267 652c 2074 6573 745f 7369  stlarge, test_si
-00021e30: 7a65 3d30 2e35 2c20 7261 6e64 6f6d 5f73  ze=0.5, random_s
-00021e40: 7461 7465 3d39 3929 0a20 2020 2020 2020  tate=99).       
-00021e50: 2070 7269 6e74 2827 5265 7475 726e 696e   print('Returnin
-00021e60: 6720 6120 5475 706c 6520 7769 7468 2074  g a Tuple with t
-00021e70: 6872 6565 2064 6174 6166 7261 6d65 7320  hree dataframes 
-00021e80: 616e 6420 7368 6170 6573 3a20 2825 732c  and shapes: (%s,
-00021e90: 2573 2c25 7329 2720 2528 7472 6169 6e2e  %s,%s)' %(train.
-00021ea0: 7368 6170 652c 2076 616c 6964 2e73 6861  shape, valid.sha
-00021eb0: 7065 2c20 7465 7374 2e73 6861 7065 2929  pe, test.shape))
-00021ec0: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
-00021ed0: 7472 6169 6e2c 2076 616c 6964 2c20 7465  train, valid, te
-00021ee0: 7374 0a20 2020 2023 2323 2320 436f 6e74  st.    #### Cont
-00021ef0: 696e 7565 206f 6e6c 7920 6966 2079 6f75  inue only if you
-00021f00: 206e 6565 6420 6d6f 7265 2074 6861 6e20   need more than 
-00021f10: 3320 7370 6c69 7473 2023 2323 2323 230a  3 splits ######.
-00021f20: 2020 2020 6966 206d 6f64 656c 7479 7065      if modeltype
-00021f30: 203d 3d20 2752 6567 7265 7373 696f 6e27   == 'Regression'
-00021f40: 3a0a 2020 2020 2020 2020 6e75 6d73 3220  :.        nums2 
-00021f50: 3d20 696e 7428 302e 352a 2864 662e 7368  = int(0.5*(df.sh
-00021f60: 6170 655b 305d 202d 206e 756d 7329 290a  ape[0] - nums)).
-00021f70: 2020 2020 2020 2020 7661 6c69 642c 2074          valid, t
-00021f80: 6573 7420 3d20 7465 7374 6c61 7267 655b  est = testlarge[
-00021f90: 3a6e 756d 7332 5d2c 2074 6573 746c 6172  :nums2], testlar
-00021fa0: 6765 5b6e 756d 7332 3a5d 0a20 2020 2020  ge[nums2:].     
-00021fb0: 2020 2069 6620 6e5f 7370 6c69 7473 203d     if n_splits =
-00021fc0: 3d20 343a 0a20 2020 2020 2020 2020 2020  = 4:.           
-00021fd0: 2058 5f74 7261 696e 2c20 795f 7472 6169   X_train, y_trai
-00021fe0: 6e2c 2058 5f74 6573 742c 2079 5f74 6573  n, X_test, y_tes
-00021ff0: 7420 3d20 7472 6169 6e5b 7072 6564 735d  t = train[preds]
-00022000: 2c20 7472 6169 6e5b 7461 7267 6574 5d2c  , train[target],
-00022010: 2074 6573 746c 6172 6765 5b70 7265 6473   testlarge[preds
-00022020: 5d2c 2074 6573 746c 6172 6765 5b74 6172  ], testlarge[tar
-00022030: 6765 745d 0a20 2020 2020 2020 2020 2020  get].           
-00022040: 206c 6973 745f 6f66 5f64 6673 203d 205b   list_of_dfs = [
-00022050: 585f 7472 6169 6e2c 795f 7472 6169 6e2c  X_train,y_train,
-00022060: 2058 5f74 6573 742c 2079 5f74 6573 745d   X_test, y_test]
-00022070: 0a20 2020 2020 2020 2020 2020 2070 7269  .            pri
-00022080: 6e74 2827 5265 7475 726e 696e 6720 6120  nt('Returning a 
-00022090: 5475 706c 6520 7769 7468 2034 2064 6174  Tuple with 4 dat
-000220a0: 6166 7261 6d65 733a 2028 2573 2025 7320  aframes: (%s %s 
-000220b0: 2573 2025 7329 2720 2528 585f 7472 6169  %s %s)' %(X_trai
-000220c0: 6e2e 7368 6170 652c 795f 7472 6169 6e2e  n.shape,y_train.
-000220d0: 7368 6170 652c 0a20 2020 2020 2020 2020  shape,.         
-000220e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000220f0: 2020 2020 2020 2058 5f74 6573 742e 7368         X_test.sh
-00022100: 6170 652c 795f 7465 7374 2e73 6861 7065  ape,y_test.shape
-00022110: 2929 0a20 2020 2020 2020 2020 2020 2072  )).            r
-00022120: 6574 7572 6e20 6c69 7374 5f6f 665f 6466  eturn list_of_df
-00022130: 730a 2020 2020 2020 2020 656c 6966 206e  s.        elif n
-00022140: 5f73 706c 6974 7320 3d3d 2036 3a0a 2020  _splits == 6:.  
-00022150: 2020 2020 2020 2020 2020 585f 7472 6169            X_trai
-00022160: 6e2c 2079 5f74 7261 696e 2c20 585f 7661  n, y_train, X_va
-00022170: 6c69 642c 2079 5f76 616c 6964 2c20 585f  lid, y_valid, X_
-00022180: 7465 7374 2c20 795f 7465 7374 203d 2074  test, y_test = t
-00022190: 7261 696e 5b70 7265 6473 5d2c 2074 7261  rain[preds], tra
-000221a0: 696e 5b74 6172 6765 745d 2c20 7661 6c69  in[target], vali
-000221b0: 645b 0a20 2020 2020 2020 2020 2020 2020  d[.             
-000221c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000221d0: 2020 2020 2020 2070 7265 6473 5d2c 2076         preds], v
-000221e0: 616c 6964 5b74 6172 6765 745d 2c20 7465  alid[target], te
-000221f0: 7374 5b70 7265 6473 5d2c 2074 6573 745b  st[preds], test[
-00022200: 7461 7267 6574 5d0a 2020 2020 2020 2020  target].        
-00022210: 2020 2020 6c69 7374 5f6f 665f 6466 7320      list_of_dfs 
-00022220: 3d20 5b58 5f74 7261 696e 2c79 5f74 7261  = [X_train,y_tra
-00022230: 696e 2c20 585f 7661 6c69 642c 2079 5f76  in, X_valid, y_v
-00022240: 616c 6964 2c20 585f 7465 7374 2c20 795f  alid, X_test, y_
-00022250: 7465 7374 5d0a 2020 2020 2020 2020 2020  test].          
-00022260: 2020 7072 696e 7428 2752 6574 7572 6e69    print('Returni
-00022270: 6e67 2061 2054 7570 6c65 2077 6974 6820  ng a Tuple with 
-00022280: 7369 7820 6461 7461 6672 616d 6573 2061  six dataframes a
-00022290: 6e64 2073 6861 7065 733a 2028 2573 2025  nd shapes: (%s %
-000222a0: 7320 2573 2025 732c 2573 2c25 7329 2720  s %s %s,%s,%s)' 
-000222b0: 2528 0a20 2020 2020 2020 2020 2020 2020  %(.             
-000222c0: 2020 2058 5f74 7261 696e 2e73 6861 7065     X_train.shape
-000222d0: 2c79 5f74 7261 696e 2e73 6861 7065 2c20  ,y_train.shape, 
-000222e0: 585f 7661 6c69 642e 7368 6170 652c 795f  X_valid.shape,y_
-000222f0: 7661 6c69 642e 7368 6170 652c 585f 7465  valid.shape,X_te
-00022300: 7374 2e73 6861 7065 2c79 5f74 6573 742e  st.shape,y_test.
-00022310: 7368 6170 6529 290a 2020 2020 2020 2020  shape)).        
-00022320: 2020 2020 7265 7475 726e 206c 6973 745f      return list_
-00022330: 6f66 5f64 6673 0a20 2020 2020 2020 2065  of_dfs.        e
-00022340: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
-00022350: 2070 7269 6e74 2827 4e75 6d62 6572 206f   print('Number o
-00022360: 6620 7370 6c69 7473 206d 7573 7420 6265  f splits must be
-00022370: 2032 2c20 332c 2034 206f 7220 3627 290a   2, 3, 4 or 6').
-00022380: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-00022390: 726e 0a20 2020 2065 6c73 653a 0a20 2020  rn.    else:.   
-000223a0: 2020 2020 2069 6620 6e5f 7370 6c69 7473       if n_splits
-000223b0: 203d 3d20 343a 0a20 2020 2020 2020 2020   == 4:.         
-000223c0: 2020 2058 5f74 7261 696e 2c20 795f 7472     X_train, y_tr
-000223d0: 6169 6e2c 2058 5f74 6573 742c 2079 5f74  ain, X_test, y_t
-000223e0: 6573 7420 3d20 7472 6169 6e5b 7072 6564  est = train[pred
-000223f0: 735d 2c20 7472 6169 6e5b 7461 7267 6574  s], train[target
-00022400: 5d2c 2074 6573 746c 6172 6765 5b70 7265  ], testlarge[pre
-00022410: 6473 5d2c 2074 6573 746c 6172 6765 5b74  ds], testlarge[t
-00022420: 6172 6765 745d 0a20 2020 2020 2020 2020  arget].         
-00022430: 2020 206c 6973 745f 6f66 5f64 6673 203d     list_of_dfs =
-00022440: 205b 585f 7472 6169 6e2c 795f 7472 6169   [X_train,y_trai
-00022450: 6e2c 2058 5f74 6573 742c 2079 5f74 6573  n, X_test, y_tes
-00022460: 745d 0a20 2020 2020 2020 2020 2020 2070  t].            p
-00022470: 7269 6e74 2827 5265 7475 726e 696e 6720  rint('Returning 
-00022480: 6120 5475 706c 6520 7769 7468 2034 2064  a Tuple with 4 d
-00022490: 6174 6166 7261 6d65 733a 2028 2573 2025  ataframes: (%s %
-000224a0: 7320 2573 2025 7329 2720 2528 585f 7472  s %s %s)' %(X_tr
-000224b0: 6169 6e2e 7368 6170 652c 795f 7472 6169  ain.shape,y_trai
-000224c0: 6e2e 7368 6170 652c 0a20 2020 2020 2020  n.shape,.       
-000224d0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000224e0: 2020 2020 2020 2020 2058 5f74 6573 742e           X_test.
-000224f0: 7368 6170 652c 795f 7465 7374 2e73 6861  shape,y_test.sha
-00022500: 7065 2929 0a20 2020 2020 2020 2020 2020  pe)).           
-00022510: 2072 6574 7572 6e20 6c69 7374 5f6f 665f   return list_of_
-00022520: 6466 730a 2020 2020 2020 2020 656c 6966  dfs.        elif
-00022530: 206e 5f73 706c 6974 7320 3d3d 2036 3a0a   n_splits == 6:.
-00022540: 2020 2020 2020 2020 2020 2020 585f 7472              X_tr
-00022550: 6169 6e2c 2079 5f74 7261 696e 2c20 585f  ain, y_train, X_
-00022560: 7661 6c69 642c 2079 5f76 616c 6964 2c20  valid, y_valid, 
-00022570: 585f 7465 7374 2c20 795f 7465 7374 203d  X_test, y_test =
-00022580: 2074 7261 696e 5b70 7265 6473 5d2c 2074   train[preds], t
-00022590: 7261 696e 5b74 6172 6765 745d 2c20 7661  rain[target], va
-000225a0: 6c69 645b 0a20 2020 2020 2020 2020 2020  lid[.           
-000225b0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000225c0: 2020 2020 2020 2020 2070 7265 6473 5d2c           preds],
-000225d0: 2076 616c 6964 5b74 6172 6765 745d 2c20   valid[target], 
-000225e0: 7465 7374 5b70 7265 6473 5d2c 2074 6573  test[preds], tes
-000225f0: 745b 7461 7267 6574 5d0a 2020 2020 2020  t[target].      
-00022600: 2020 2020 2020 7072 696e 7428 2752 6574        print('Ret
-00022610: 7572 6e69 6e67 2034 2064 6174 6166 7261  urning 4 datafra
-00022620: 6d65 733a 272c 2058 5f74 7261 696e 2e73  mes:', X_train.s
-00022630: 6861 7065 2c20 795f 7472 6169 6e2e 7368  hape, y_train.sh
-00022640: 6170 652c 2058 5f74 6573 742e 7368 6170  ape, X_test.shap
-00022650: 652c 2079 5f74 6573 742e 7368 6170 6529  e, y_test.shape)
-00022660: 0a20 2020 2020 2020 2020 2020 206c 6973  .            lis
-00022670: 745f 6f66 5f64 6673 203d 205b 585f 7472  t_of_dfs = [X_tr
-00022680: 6169 6e2c 795f 7472 6169 6e2c 2058 5f76  ain,y_train, X_v
-00022690: 616c 6964 2c20 795f 7661 6c69 642c 2058  alid, y_valid, X
-000226a0: 5f74 6573 742c 2079 5f74 6573 745d 0a20  _test, y_test]. 
-000226b0: 2020 2020 2020 2020 2020 2070 7269 6e74             print
-000226c0: 2827 5265 7475 726e 696e 6720 6120 5475  ('Returning a Tu
-000226d0: 706c 6520 7769 7468 2073 6978 2064 6174  ple with six dat
-000226e0: 6166 7261 6d65 7320 616e 6420 7368 6170  aframes and shap
-000226f0: 6573 3a20 2825 7320 2573 2025 7320 2573  es: (%s %s %s %s
-00022700: 2c25 732c 2573 2927 2025 280a 2020 2020  ,%s,%s)' %(.    
-00022710: 2020 2020 2020 2020 2020 2020 585f 7472              X_tr
-00022720: 6169 6e2e 7368 6170 652c 795f 7472 6169  ain.shape,y_trai
-00022730: 6e2e 7368 6170 652c 2058 5f76 616c 6964  n.shape, X_valid
-00022740: 2e73 6861 7065 2c79 5f76 616c 6964 2e73  .shape,y_valid.s
-00022750: 6861 7065 2c58 5f74 6573 742e 7368 6170  hape,X_test.shap
-00022760: 652c 795f 7465 7374 2e73 6861 7065 2929  e,y_test.shape))
-00022770: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
-00022780: 7572 6e20 6c69 7374 5f6f 665f 6466 730a  urn list_of_dfs.
-00022790: 2020 2020 2020 2020 656c 7365 3a0a 2020          else:.  
-000227a0: 2020 2020 2020 2020 2020 7072 696e 7428            print(
-000227b0: 274e 756d 6265 7220 6f66 2073 706c 6974  'Number of split
-000227c0: 7320 6d75 7374 2062 6520 322c 2033 2c20  s must be 2, 3, 
-000227d0: 3420 6f72 2036 2729 0a20 2020 2020 2020  4 or 6').       
-000227e0: 2020 2020 2072 6574 7572 6e0a 2323 2323       return.####
-000227f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00022800: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00022810: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00022820: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00022830: 2323 2323 2323 2323 2323 2323 2323 0a64  ##############.d
-00022840: 6566 2046 455f 636f 6e63 6174 656e 6174  ef FE_concatenat
-00022850: 655f 6d75 6c74 6970 6c65 5f63 6f6c 756d  e_multiple_colum
-00022860: 6e73 2864 662c 2063 6f6c 732c 2066 696c  ns(df, cols, fil
-00022870: 6c65 723d 2220 222c 2064 726f 703d 5472  ler=" ", drop=Tr
-00022880: 7565 293a 0a20 2020 2022 2222 0a20 2020  ue):.    """.   
-00022890: 2054 6869 7320 6861 6e64 7920 6675 6e63   This handy func
-000228a0: 7469 6f6e 2063 6f6d 6269 6e65 7320 6d75  tion combines mu
-000228b0: 6c74 6970 6c65 2073 7472 696e 6720 636f  ltiple string co
-000228c0: 6c75 6d6e 7320 696e 746f 2061 2073 696e  lumns into a sin
-000228d0: 676c 6520 4e4c 5020 7465 7874 2063 6f6c  gle NLP text col
-000228e0: 756d 6e2e 0a20 2020 2059 6f75 2063 616e  umn..    You can
-000228f0: 2064 6f20 6675 7274 6865 7220 7072 652d   do further pre-
-00022900: 7072 6f63 6573 7369 6e67 206f 6e20 7375  processing on su
-00022910: 6368 2061 2063 6f6d 6269 6e65 6420 636f  ch a combined co
-00022920: 6c75 6d6e 2077 6974 6820 5446 4944 4620  lumn with TFIDF 
-00022930: 6f72 2042 4552 5420 7374 796c 6520 656d  or BERT style em
-00022940: 6265 6464 696e 672e 0a0a 2020 2020 496e  bedding...    In
-00022950: 7075 7473 0a20 2020 202d 2d2d 2d2d 2d2d  puts.    -------
-00022960: 2d2d 0a20 2020 2020 2020 2064 663a 2070  --.        df: p
-00022970: 616e 6461 7320 6461 7461 6672 616d 650a  andas dataframe.
-00022980: 2020 2020 2020 2020 636f 6c73 3a20 7374          cols: st
-00022990: 7269 6e67 2063 6f6c 756d 6e73 2074 6861  ring columns tha
-000229a0: 7420 796f 7520 7761 6e74 2074 6f20 636f  t you want to co
-000229b0: 6e63 6174 656e 6174 6520 696e 746f 2061  ncatenate into a
-000229c0: 2073 696e 676c 6520 636f 6d62 696e 6564   single combined
-000229d0: 2063 6f6c 756d 6e0a 2020 2020 2020 2020   column.        
-000229e0: 6669 6c6c 6572 3a20 7374 7269 6e67 2028  filler: string (
-000229f0: 6465 6661 756c 743a 2022 2022 293a 2079  default: " "): y
-00022a00: 6f75 2063 616e 2069 6e70 7574 2061 6e79  ou can input any
-00022a10: 2073 7472 696e 6720 7468 6174 2079 6f75   string that you
-00022a20: 2077 616e 7420 746f 2063 6f6d 6269 6e65   want to combine
-00022a30: 2074 6865 6d20 7769 7468 2e0a 2020 2020   them with..    
-00022a40: 2020 2020 6472 6f70 3a20 6465 6661 756c      drop: defaul
-00022a50: 7420 5472 7565 2e20 4966 2054 7275 652c  t True. If True,
-00022a60: 2064 726f 7020 7468 6520 636f 6c75 6d6e   drop the column
-00022a70: 7320 696e 7075 742e 2049 6620 4661 6c73  s input. If Fals
-00022a80: 652c 206b 6565 7020 7468 6520 636f 6c75  e, keep the colu
-00022a90: 6d6e 732e 0a0a 2020 2020 4f75 7470 7574  mns...    Output
-00022aa0: 733a 0a20 2020 202d 2d2d 2d2d 2d2d 2d2d  s:.    ---------
-00022ab0: 2d0a 2020 2020 2020 2020 6466 3a20 7468  -.        df: th
-00022ac0: 6572 6520 7769 6c6c 2062 6520 6120 6e65  ere will be a ne
-00022ad0: 7720 636f 6c75 6d6e 2063 616c 6c65 6420  w column called 
-00022ae0: 5b27 636f 6d62 696e 6564 275d 2074 6861  ['combined'] tha
-00022af0: 7420 7769 6c6c 2062 6520 6164 6465 6420  t will be added 
-00022b00: 746f 2079 6f75 7220 6461 7461 6672 616d  to your datafram
-00022b10: 652e 0a20 2020 2022 2222 0a20 2020 2064  e..    """.    d
-00022b20: 6620 3d20 6466 2e63 6f70 7928 6465 6570  f = df.copy(deep
-00022b30: 3d54 7275 6529 0a20 2020 2064 665b 2763  =True).    df['c
-00022b40: 6f6d 6269 6e65 6427 5d20 3d20 6466 5b63  ombined'] = df[c
-00022b50: 6f6c 735d 2e61 7070 6c79 286c 616d 6264  ols].apply(lambd
-00022b60: 6120 726f 773a 2066 696c 6c65 722e 6a6f  a row: filler.jo
-00022b70: 696e 2872 6f77 2e76 616c 7565 732e 6173  in(row.values.as
-00022b80: 7479 7065 2873 7472 2929 2c20 6178 6973  type(str)), axis
-00022b90: 3d31 290a 2020 2020 6966 2064 726f 703a  =1).    if drop:
-00022ba0: 0a20 2020 2020 2020 2064 6620 3d20 6466  .        df = df
-00022bb0: 2e64 726f 7028 636f 6c73 2c20 6178 6973  .drop(cols, axis
-00022bc0: 3d31 290a 2020 2020 7265 7475 726e 2064  =1).    return d
-00022bd0: 660a 2323 2323 2323 2323 2323 2323 2323  f.##############
-00022be0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00022bf0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00022c00: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00022c10: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00022c20: 2323 2323 0a66 726f 6d20 736b 6c65 6172  ####.from sklear
-00022c30: 6e2e 7072 6570 726f 6365 7373 696e 6720  n.preprocessing 
-00022c40: 696d 706f 7274 204b 4269 6e73 4469 7363  import KBinsDisc
-00022c50: 7265 7469 7a65 720a 6672 6f6d 2073 6b6c  retizer.from skl
-00022c60: 6561 726e 2e6d 6978 7475 7265 2069 6d70  earn.mixture imp
-00022c70: 6f72 7420 4761 7573 7369 616e 4d69 7874  ort GaussianMixt
-00022c80: 7572 650a 0a64 6566 2046 455f 6469 7363  ure..def FE_disc
-00022c90: 7265 7469 7a65 5f6e 756d 6572 6963 5f76  retize_numeric_v
-00022ca0: 6172 6961 626c 6573 2874 7261 696e 2c20  ariables(train, 
-00022cb0: 6269 6e5f 6469 6374 2c20 7465 7374 3d27  bin_dict, test='
-00022cc0: 272c 2073 7472 6174 6567 793d 276b 6d65  ', strategy='kme
-00022cd0: 616e 7327 2c76 6572 626f 7365 3d30 293a  ans',verbose=0):
-00022ce0: 0a20 2020 2022 2222 0a20 2020 2054 6869  .    """.    Thi
-00022cf0: 7320 6861 6e64 7920 6675 6e63 7469 6f6e  s handy function
-00022d00: 2064 6973 6372 6574 697a 6573 206e 756d   discretizes num
-00022d10: 6572 6963 2076 6172 6961 626c 6573 2069  eric variables i
-00022d20: 6e74 6f20 6269 6e6e 6564 2076 6172 6961  nto binned varia
-00022d30: 626c 6573 2075 7369 6e67 206b 6d65 616e  bles using kmean
-00022d40: 7320 616c 676f 7269 7468 6d2e 0a20 2020  s algorithm..   
-00022d50: 2059 6f75 206e 6565 6420 746f 2070 726f   You need to pro
-00022d60: 7669 6465 2074 6865 206e 616d 6573 206f  vide the names o
-00022d70: 6620 7468 6520 7661 7269 6162 6c65 7320  f the variables 
-00022d80: 616e 6420 7468 6520 6e75 6d62 6572 7320  and the numbers 
-00022d90: 6f66 2062 696e 7320 666f 7220 6561 6368  of bins for each
-00022da0: 2076 6172 6961 626c 6520 696e 2061 2064   variable in a d
-00022db0: 6963 7469 6f6e 6172 792e 0a20 2020 2049  ictionary..    I
-00022dc0: 7420 7769 6c6c 2072 6574 7572 6e20 7468  t will return th
-00022dd0: 6520 7361 6d65 2064 6174 6166 7261 6d65  e same dataframe
-00022de0: 2077 6974 6820 6e65 7720 6269 6e6e 6564   with new binned
-00022df0: 2076 6172 6961 626c 6573 2074 6861 7420   variables that 
-00022e00: 6974 2068 6173 2063 7265 6174 6564 2e0a  it has created..
-00022e10: 0a20 2020 2049 6e70 7574 733a 0a20 2020  .    Inputs:.   
-00022e20: 202d 2d2d 2d2d 2d2d 2d2d 2d0a 2020 2020   ----------.    
-00022e30: 6466 203a 2070 616e 6461 7320 6461 7461  df : pandas data
-00022e40: 6672 616d 6520 2d20 706c 6561 7365 2065  frame - please e
-00022e50: 6e73 7572 6520 6974 2069 7320 6120 6461  nsure it is a da
-00022e60: 7461 6672 616d 652e 204e 6f20 6172 7261  taframe. No arra
-00022e70: 7973 2070 6c65 6173 652e 0a20 2020 2062  ys please..    b
-00022e80: 696e 5f64 6963 743a 2064 6963 7469 6f6e  in_dict: diction
-00022e90: 6172 7920 6f66 206e 616d 6573 206f 6620  ary of names of 
-00022ea0: 7661 7269 6162 6c65 7320 616e 6420 7468  variables and th
-00022eb0: 6520 6269 6e73 2074 6861 7420 796f 7520  e bins that you 
-00022ec0: 7761 6e74 2066 6f72 2065 6163 6820 7661  want for each va
-00022ed0: 7269 6162 6c65 2e0a 2020 2020 7374 7261  riable..    stra
-00022ee0: 7465 6779 3a20 6465 6661 756c 7420 6973  tegy: default is
-00022ef0: 2027 6b6d 6561 6e73 273a 2062 7574 2079   'kmeans': but y
-00022f00: 6f75 2063 616e 2063 686f 6f73 653a 207b  ou can choose: {
-00022f10: 2767 6175 7573 6961 6e27 2c27 756e 6966  'gauusian','unif
-00022f20: 6f72 6d27 2c20 2771 7561 6e74 696c 6527  orm', 'quantile'
-00022f30: 2c20 276b 6d65 616e 7327 7d0a 0a20 2020  , 'kmeans'}..   
-00022f40: 204f 7574 7075 7473 3a0a 2020 2020 2d2d   Outputs:.    --
-00022f50: 2d2d 2d2d 2d2d 2d2d 0a20 2020 2064 663a  --------.    df:
-00022f60: 2070 616e 6461 7320 6461 7461 6672 616d   pandas datafram
-00022f70: 6520 7769 7468 206e 6577 2076 6172 6961  e with new varia
-00022f80: 626c 6573 2077 6974 6820 6e61 6d65 7320  bles with names 
-00022f90: 7375 6368 2061 733a 2020 7661 7269 6162  such as:  variab
-00022fa0: 6c65 2b27 5f64 6973 6372 6574 6527 0a20  le+'_discrete'. 
-00022fb0: 2020 2022 2222 0a20 2020 2064 6620 3d20     """.    df = 
-00022fc0: 636f 7079 2e64 6565 7063 6f70 7928 7472  copy.deepcopy(tr
-00022fd0: 6169 6e29 0a20 2020 2074 6573 7420 3d20  ain).    test = 
-00022fe0: 636f 7079 2e64 6565 7063 6f70 7928 7465  copy.deepcopy(te
-00022ff0: 7374 290a 2020 2020 6e75 6d5f 636f 6c73  st).    num_cols
-00023000: 203d 206c 656e 2862 696e 5f64 6963 7429   = len(bin_dict)
-00023010: 0a20 2020 206e 726f 7773 203d 2069 6e74  .    nrows = int
-00023020: 2828 6e75 6d5f 636f 6c73 2f32 292b 302e  ((num_cols/2)+0.
-00023030: 3529 0a20 2020 2023 7072 696e 7428 276e  5).    #print('n
-00023040: 726f 7773 272c 6e72 6f77 7329 0a20 2020  rows',nrows).   
-00023050: 2069 6620 7665 7262 6f73 653a 0a20 2020   if verbose:.   
-00023060: 2020 2020 2066 6967 203d 2070 6c74 2e66       fig = plt.f
-00023070: 6967 7572 6528 6669 6773 697a 653d 2831  igure(figsize=(1
-00023080: 302c 332a 6e75 6d5f 636f 6c73 2929 0a20  0,3*num_cols)). 
-00023090: 2020 2066 6f72 2069 2c20 2863 6f6c 2c20     for i, (col, 
-000230a0: 6269 6e76 616c 7565 2920 696e 2065 6e75  binvalue) in enu
-000230b0: 6d65 7261 7465 2862 696e 5f64 6963 742e  merate(bin_dict.
-000230c0: 6974 656d 7328 2929 3a0a 2020 2020 2020  items()):.      
-000230d0: 2020 6e65 775f 636f 6c20 3d20 636f 6c2b    new_col = col+
-000230e0: 275f 6469 7363 7265 7465 270a 2020 2020  '_discrete'.    
-000230f0: 2020 2020 6966 2073 7472 6174 6567 7920      if strategy 
-00023100: 3d3d 2027 6761 7573 7369 616e 273a 0a20  == 'gaussian':. 
-00023110: 2020 2020 2020 2020 2020 206b 6264 203d             kbd =
-00023120: 2047 6175 7373 6961 6e4d 6978 7475 7265   GaussianMixture
-00023130: 286e 5f63 6f6d 706f 6e65 6e74 733d 6269  (n_components=bi
-00023140: 6e76 616c 7565 2c20 7261 6e64 6f6d 5f73  nvalue, random_s
-00023150: 7461 7465 3d39 3929 0a20 2020 2020 2020  tate=99).       
-00023160: 2020 2020 2064 665b 6e65 775f 636f 6c5d       df[new_col]
-00023170: 203d 206b 6264 2e66 6974 5f70 7265 6469   = kbd.fit_predi
-00023180: 6374 2864 665b 5b63 6f6c 5d5d 292e 6173  ct(df[[col]]).as
-00023190: 7479 7065 2869 6e74 290a 2020 2020 2020  type(int).      
-000231a0: 2020 2020 2020 6966 206e 6f74 2069 7369        if not isi
-000231b0: 6e73 7461 6e63 6528 7465 7374 2c20 7374  nstance(test, st
-000231c0: 7229 3a0a 2020 2020 2020 2020 2020 2020  r):.            
-000231d0: 2020 2020 7465 7374 5b6e 6577 5f63 6f6c      test[new_col
-000231e0: 5d20 3d20 6b62 642e 7072 6564 6963 7428  ] = kbd.predict(
-000231f0: 7465 7374 5b5b 636f 6c5d 5d29 2e61 7374  test[[col]]).ast
-00023200: 7970 6528 696e 7429 0a20 2020 2020 2020  ype(int).       
-00023210: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
-00023220: 2020 206b 6264 203d 204b 4269 6e73 4469     kbd = KBinsDi
-00023230: 7363 7265 7469 7a65 7228 6e5f 6269 6e73  scretizer(n_bins
-00023240: 3d62 696e 7661 6c75 652c 2065 6e63 6f64  =binvalue, encod
-00023250: 653d 276f 7264 696e 616c 272c 2073 7472  e='ordinal', str
-00023260: 6174 6567 793d 7374 7261 7465 6779 290a  ategy=strategy).
-00023270: 2020 2020 2020 2020 2020 2020 6466 5b6e              df[n
-00023280: 6577 5f63 6f6c 5d20 3d20 6b62 642e 6669  ew_col] = kbd.fi
-00023290: 745f 7472 616e 7366 6f72 6d28 6466 5b5b  t_transform(df[[
-000232a0: 636f 6c5d 5d29 2e61 7374 7970 6528 696e  col]]).astype(in
-000232b0: 7429 0a20 2020 2020 2020 2020 2020 2069  t).            i
-000232c0: 6620 6e6f 7420 6973 696e 7374 616e 6365  f not isinstance
-000232d0: 2874 6573 742c 2073 7472 293a 0a20 2020  (test, str):.   
-000232e0: 2020 2020 2020 2020 2020 2020 2074 6573               tes
-000232f0: 745b 6e65 775f 636f 6c5d 203d 206b 6264  t[new_col] = kbd
-00023300: 2e74 7261 6e73 666f 726d 2874 6573 745b  .transform(test[
-00023310: 5b63 6f6c 5d5d 292e 6173 7479 7065 2869  [col]]).astype(i
-00023320: 6e74 290a 2020 2020 2020 2020 6966 2076  nt).        if v
-00023330: 6572 626f 7365 3a0a 2020 2020 2020 2020  erbose:.        
-00023340: 2020 2020 6178 3120 3d20 706c 742e 7375      ax1 = plt.su
-00023350: 6270 6c6f 7428 6e72 6f77 732c 322c 692b  bplot(nrows,2,i+
-00023360: 3129 0a20 2020 2020 2020 2020 2020 2061  1).            a
-00023370: 7831 2e73 6361 7474 6572 2864 665b 636f  x1.scatter(df[co
-00023380: 6c5d 2c64 665b 6e65 775f 636f 6c5d 290a  l],df[new_col]).
-00023390: 2020 2020 2020 2020 2020 2020 6178 312e              ax1.
-000233a0: 7365 745f 7469 746c 6528 6e65 775f 636f  set_title(new_co
-000233b0: 6c29 0a20 2020 2069 6620 6e6f 7420 6973  l).    if not is
-000233c0: 696e 7374 616e 6365 2874 6573 742c 2073  instance(test, s
-000233d0: 7472 293a 0a20 2020 2020 2020 2072 6574  tr):.        ret
-000233e0: 7572 6e20 6466 2c20 7465 7374 0a20 2020  urn df, test.   
-000233f0: 2065 6c73 653a 0a20 2020 2020 2020 2072   else:.        r
-00023400: 6574 7572 6e20 6466 0a23 2323 2323 2323  eturn df.#######
-00023410: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00023420: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00023430: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00023440: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00023450: 2323 2323 2323 2323 2323 230a 6465 6620  ###########.def 
-00023460: 4645 5f74 7261 6e73 666f 726d 5f6e 756d  FE_transform_num
-00023470: 6572 6963 5f63 6f6c 756d 6e73 5f74 6f5f  eric_columns_to_
-00023480: 6269 6e73 2864 662c 2062 696e 5f64 6963  bins(df, bin_dic
-00023490: 742c 2076 6572 626f 7365 3d30 293a 0a20  t, verbose=0):. 
-000234a0: 2020 2022 2222 0a20 2020 2054 6869 7320     """.    This 
-000234b0: 6861 6e64 7920 6675 6e63 7469 6f6e 2064  handy function d
-000234c0: 6973 6372 6574 697a 6573 206e 756d 6572  iscretizes numer
-000234d0: 6963 2076 6172 6961 626c 6573 2069 6e74  ic variables int
-000234e0: 6f20 6269 6e6e 6564 2076 6172 6961 626c  o binned variabl
-000234f0: 6573 2075 7369 6e67 206b 6d65 616e 7320  es using kmeans 
-00023500: 616c 676f 7269 7468 6d2e 0a20 2020 2059  algorithm..    Y
-00023510: 6f75 206e 6565 6420 746f 2070 726f 7669  ou need to provi
-00023520: 6465 2074 6865 206e 616d 6573 206f 6620  de the names of 
-00023530: 7468 6520 7661 7269 6162 6c65 7320 616e  the variables an
-00023540: 6420 7468 6520 6e75 6d62 6572 7320 6f66  d the numbers of
-00023550: 2062 696e 7320 666f 7220 6561 6368 2076   bins for each v
-00023560: 6172 6961 626c 6520 696e 2061 2064 6963  ariable in a dic
-00023570: 7469 6f6e 6172 792e 0a20 2020 2049 7420  tionary..    It 
-00023580: 7769 6c6c 2072 6574 7572 6e20 7468 6520  will return the 
-00023590: 7361 6d65 2064 6174 6166 7261 6d65 2077  same dataframe w
-000235a0: 6974 6820 6e65 7720 6269 6e6e 6564 2076  ith new binned v
-000235b0: 6172 6961 626c 6573 2074 6861 7420 6974  ariables that it
-000235c0: 2068 6173 2063 7265 6174 6564 2e0a 0a20   has created... 
-000235d0: 2020 2049 6e70 7574 733a 0a20 2020 202d     Inputs:.    -
-000235e0: 2d2d 2d2d 2d2d 2d2d 2d0a 2020 2020 6466  ---------.    df
-000235f0: 203a 2070 616e 6461 7320 6461 7461 6672   : pandas datafr
-00023600: 616d 6520 2d20 706c 6561 7365 2065 6e73  ame - please ens
-00023610: 7572 6520 6974 2069 7320 6120 6461 7461  ure it is a data
-00023620: 6672 616d 652e 204e 6f20 6172 7261 7973  frame. No arrays
-00023630: 2070 6c65 6173 652e 0a20 2020 2062 696e   please..    bin
-00023640: 5f64 6963 743a 2064 6963 7469 6f6e 6172  _dict: dictionar
-00023650: 7920 6f66 206e 616d 6573 206f 6620 7661  y of names of va
-00023660: 7269 6162 6c65 7320 616e 6420 7468 6520  riables and the 
-00023670: 6b69 6e64 206f 6620 7472 616e 7366 6f72  kind of transfor
-00023680: 6d61 7469 6f6e 2079 6f75 2077 616e 740a  mation you want.
-00023690: 2020 2020 2020 2020 6465 6661 756c 7420          default 
-000236a0: 6973 2027 6c6f 6727 3a20 6275 7420 796f  is 'log': but yo
-000236b0: 7520 6361 6e20 6368 6f6f 7365 3a20 7b27  u can choose: {'
-000236c0: 6c6f 6727 2c27 6c6f 6731 3027 2c20 2773  log','log10', 's
-000236d0: 7172 7427 2c20 276d 6178 2d61 6273 277d  qrt', 'max-abs'}
-000236e0: 0a0a 2020 2020 4f75 7470 7574 733a 0a20  ..    Outputs:. 
-000236f0: 2020 202d 2d2d 2d2d 2d2d 2d2d 2d0a 2020     ----------.  
-00023700: 2020 6466 3a20 7061 6e64 6173 2064 6174    df: pandas dat
-00023710: 6166 7261 6d65 2077 6974 6820 6e65 7720  aframe with new 
-00023720: 7661 7269 6162 6c65 7320 7769 7468 206e  variables with n
-00023730: 616d 6573 2073 7563 6820 6173 3a20 2076  ames such as:  v
-00023740: 6172 6961 626c 652b 275f 6469 7363 7265  ariable+'_discre
-00023750: 7465 270a 2020 2020 2222 220a 2020 2020  te'.    """.    
-00023760: 6466 203d 2063 6f70 792e 6465 6570 636f  df = copy.deepco
-00023770: 7079 2864 6629 0a20 2020 206e 756d 5f63  py(df).    num_c
-00023780: 6f6c 7320 3d20 6c65 6e28 6269 6e5f 6469  ols = len(bin_di
-00023790: 6374 290a 2020 2020 6e72 6f77 7320 3d20  ct).    nrows = 
-000237a0: 696e 7428 286e 756d 5f63 6f6c 732f 3229  int((num_cols/2)
-000237b0: 2b30 2e35 290a 2020 2020 6966 2076 6572  +0.5).    if ver
-000237c0: 626f 7365 3a0a 2020 2020 2020 2020 6669  bose:.        fi
-000237d0: 6720 3d20 706c 742e 6669 6775 7265 2866  g = plt.figure(f
-000237e0: 6967 7369 7a65 3d28 3130 2c33 2a6e 756d  igsize=(10,3*num
-000237f0: 5f63 6f6c 7329 290a 2020 2020 666f 7220  _cols)).    for 
-00023800: 692c 2028 636f 6c2c 2062 696e 7661 6c75  i, (col, binvalu
-00023810: 6529 2069 6e20 656e 756d 6572 6174 6528  e) in enumerate(
-00023820: 6269 6e5f 6469 6374 2e69 7465 6d73 2829  bin_dict.items()
-00023830: 293a 0a20 2020 2020 2020 206e 6577 5f63  ):.        new_c
-00023840: 6f6c 203d 2063 6f6c 2b27 5f27 2b62 696e  ol = col+'_'+bin
-00023850: 7661 6c75 650a 2020 2020 2020 2020 6966  value.        if
-00023860: 2062 696e 7661 6c75 6520 3d3d 2027 6c6f   binvalue == 'lo
-00023870: 6727 3a0a 2020 2020 2020 2020 2020 2020  g':.            
-00023880: 7072 696e 7428 2757 6172 6e69 6e67 3a20  print('Warning: 
-00023890: 4e65 6761 7469 7665 2076 616c 7565 7320  Negative values 
-000238a0: 696e 2025 7320 6861 7665 2062 6565 6e20  in %s have been 
-000238b0: 6d61 6465 2070 6f73 6974 6976 6520 6265  made positive be
-000238c0: 666f 7265 206c 6f67 2074 7261 6e73 666f  fore log transfo
-000238d0: 726d 2127 2025 636f 6c29 0a20 2020 2020  rm!' %col).     
-000238e0: 2020 2020 2020 2064 662e 6c6f 635b 6466         df.loc[df
-000238f0: 5b63 6f6c 5d3d 3d30 2c63 6f6c 5d20 3d20  [col]==0,col] = 
-00023900: 3165 2d31 3520 2023 2323 206d 616b 6520  1e-15  ### make 
-00023910: 6974 2061 2073 6d61 6c6c 206e 756d 6265  it a small numbe
-00023920: 720a 2020 2020 2020 2020 2020 2020 6466  r.            df
-00023930: 5b6e 6577 5f63 6f6c 5d20 3d20 6e70 2e61  [new_col] = np.a
-00023940: 6273 2864 665b 636f 6c5d 2e76 616c 7565  bs(df[col].value
-00023950: 7329 0a20 2020 2020 2020 2020 2020 2064  s).            d
-00023960: 665b 6e65 775f 636f 6c5d 203d 206e 702e  f[new_col] = np.
-00023970: 6c6f 6728 6466 5b6e 6577 5f63 6f6c 5d29  log(df[new_col])
-00023980: 2e76 616c 7565 730a 2020 2020 2020 2020  .values.        
-00023990: 656c 6966 2062 696e 7661 6c75 6520 3d3d  elif binvalue ==
-000239a0: 2027 6c6f 6731 3027 3a0a 2020 2020 2020   'log10':.      
-000239b0: 2020 2020 2020 7072 696e 7428 2757 6172        print('War
-000239c0: 6e69 6e67 3a20 4e65 6761 7469 7665 2076  ning: Negative v
-000239d0: 616c 7565 7320 696e 2025 7320 6861 7665  alues in %s have
-000239e0: 2062 6565 6e20 6d61 6465 2070 6f73 6974   been made posit
-000239f0: 6976 6520 6265 666f 7265 206c 6f67 3130  ive before log10
-00023a00: 2074 7261 6e73 666f 726d 2127 2025 636f   transform!' %co
-00023a10: 6c29 0a20 2020 2020 2020 2020 2020 2064  l).            d
-00023a20: 662e 6c6f 635b 6466 5b63 6f6c 5d3d 3d30  f.loc[df[col]==0
-00023a30: 2c63 6f6c 5d20 3d20 3165 2d31 3520 2023  ,col] = 1e-15  #
-00023a40: 2323 206d 616b 6520 6974 2061 2073 6d61  ## make it a sma
-00023a50: 6c6c 206e 756d 6265 720a 2020 2020 2020  ll number.      
-00023a60: 2020 2020 2020 6466 5b6e 6577 5f63 6f6c        df[new_col
-00023a70: 5d20 3d20 6e70 2e61 6273 2864 665b 636f  ] = np.abs(df[co
-00023a80: 6c5d 2e76 616c 7565 7329 0a20 2020 2020  l].values).     
-00023a90: 2020 2020 2020 2064 665b 6e65 775f 636f         df[new_co
-00023aa0: 6c5d 203d 206e 702e 6c6f 6731 3028 6466  l] = np.log10(df
-00023ab0: 5b6e 6577 5f63 6f6c 5d29 2e76 616c 7565  [new_col]).value
-00023ac0: 730a 2020 2020 2020 2020 656c 6966 2062  s.        elif b
-00023ad0: 696e 7661 6c75 6520 3d3d 2027 7371 7274  invalue == 'sqrt
-00023ae0: 273a 0a20 2020 2020 2020 2020 2020 2070  ':.            p
-00023af0: 7269 6e74 2827 5761 726e 696e 673a 204e  rint('Warning: N
-00023b00: 6567 6174 6976 6520 7661 6c75 6573 2069  egative values i
-00023b10: 6e20 2573 2068 6176 6520 6265 656e 206d  n %s have been m
-00023b20: 6164 6520 706f 7369 7469 7665 2062 6566  ade positive bef
-00023b30: 6f72 6520 7371 7274 2074 7261 6e73 666f  ore sqrt transfo
-00023b40: 726d 2127 2025 636f 6c29 0a20 2020 2020  rm!' %col).     
-00023b50: 2020 2020 2020 2064 665b 6e65 775f 636f         df[new_co
-00023b60: 6c5d 203d 206e 702e 6162 7328 6466 5b63  l] = np.abs(df[c
-00023b70: 6f6c 5d2e 7661 6c75 6573 2920 2023 2323  ol].values)  ###
-00023b80: 206d 616b 6520 6974 2061 2073 6d61 6c6c   make it a small
-00023b90: 206e 756d 6265 720a 2020 2020 2020 2020   number.        
-00023ba0: 2020 2020 6466 5b6e 6577 5f63 6f6c 5d20      df[new_col] 
-00023bb0: 3d20 6e70 2e73 7172 7428 6466 5b6e 6577  = np.sqrt(df[new
-00023bc0: 5f63 6f6c 5d29 2e76 616c 7565 730a 2020  _col]).values.  
-00023bd0: 2020 2020 2020 656c 6966 2062 696e 7661        elif binva
-00023be0: 6c75 6520 3d3d 2027 6d61 782d 6162 7327  lue == 'max-abs'
-00023bf0: 3a0a 2020 2020 2020 2020 2020 2020 7072  :.            pr
-00023c00: 696e 7428 2757 6172 6e69 6e67 3a20 4e65  int('Warning: Ne
-00023c10: 6761 7469 7665 2076 616c 7565 7320 696e  gative values in
-00023c20: 2025 7320 6861 7665 2062 6565 6e20 6d61   %s have been ma
-00023c30: 6465 2070 6f73 6974 6976 6520 6265 666f  de positive befo
-00023c40: 7265 206d 6178 2d61 6273 2074 7261 6e73  re max-abs trans
-00023c50: 666f 726d 2127 2025 636f 6c29 0a20 2020  form!' %col).   
-00023c60: 2020 2020 2020 2020 2063 6f6c 5f6d 6178           col_max
-00023c70: 203d 206d 6178 286e 702e 6162 7328 6466   = max(np.abs(df
-00023c80: 5b63 6f6c 5d2e 7661 6c75 6573 2929 0a20  [col].values)). 
-00023c90: 2020 2020 2020 2020 2020 2069 6620 636f             if co
-00023ca0: 6c5f 6d61 7820 3d3d 2030 3a0a 2020 2020  l_max == 0:.    
-00023cb0: 2020 2020 2020 2020 2020 2020 636f 6c5f              col_
-00023cc0: 6d61 7820 3d20 310a 2020 2020 2020 2020  max = 1.        
-00023cd0: 2020 2020 6466 5b6e 6577 5f63 6f6c 5d20      df[new_col] 
-00023ce0: 3d20 6e70 2e61 6273 2864 665b 636f 6c5d  = np.abs(df[col]
-00023cf0: 2e76 616c 7565 7329 2f63 6f6c 5f6d 6178  .values)/col_max
-00023d00: 0a20 2020 2020 2020 2065 6c73 653a 0a20  .        else:. 
-00023d10: 2020 2020 2020 2020 2020 2070 7269 6e74             print
-00023d20: 2827 5761 726e 696e 673a 204e 6567 6174  ('Warning: Negat
-00023d30: 6976 6520 7661 6c75 6573 2069 6e20 2573  ive values in %s
-00023d40: 2068 6176 6520 6265 656e 206d 6164 6520   have been made 
-00023d50: 706f 7369 7469 7665 2062 6566 6f72 6520  positive before 
-00023d60: 6c6f 6720 7472 616e 7366 6f72 6d21 2720  log transform!' 
-00023d70: 2563 6f6c 290a 2020 2020 2020 2020 2020  %col).          
-00023d80: 2020 6466 2e6c 6f63 5b64 665b 636f 6c5d    df.loc[df[col]
-00023d90: 3d3d 302c 636f 6c5d 203d 2031 652d 3135  ==0,col] = 1e-15
-00023da0: 2020 2323 2320 6d61 6b65 2069 7420 6120    ### make it a 
-00023db0: 736d 616c 6c20 6e75 6d62 6572 0a20 2020  small number.   
-00023dc0: 2020 2020 2020 2020 2064 665b 6e65 775f           df[new_
-00023dd0: 636f 6c5d 203d 206e 702e 6162 7328 6466  col] = np.abs(df
-00023de0: 5b63 6f6c 5d2e 7661 6c75 6573 290a 2020  [col].values).  
-00023df0: 2020 2020 2020 2020 2020 6466 5b6e 6577            df[new
-00023e00: 5f63 6f6c 5d20 3d20 6e70 2e6c 6f67 2864  _col] = np.log(d
-00023e10: 665b 6e65 775f 636f 6c5d 292e 7661 6c75  f[new_col]).valu
-00023e20: 6573 0a20 2020 2020 2020 2069 6620 7665  es.        if ve
-00023e30: 7262 6f73 653a 0a20 2020 2020 2020 2020  rbose:.         
-00023e40: 2020 2061 7831 203d 2070 6c74 2e73 7562     ax1 = plt.sub
-00023e50: 706c 6f74 286e 726f 7773 2c32 2c69 2b31  plot(nrows,2,i+1
-00023e60: 290a 2020 2020 2020 2020 2020 2020 6466  ).            df
-00023e70: 5b63 6f6c 5d2e 706c 6f74 2e6b 6465 2861  [col].plot.kde(a
-00023e80: 783d 6178 312c 206c 6162 656c 3d63 6f6c  x=ax1, label=col
-00023e90: 2c61 6c70 6861 3d30 2e35 2c63 6f6c 6f72  ,alpha=0.5,color
-00023ea0: 3d27 7227 290a 2020 2020 2020 2020 2020  ='r').          
-00023eb0: 2020 6178 3220 3d20 6178 312e 7477 696e    ax2 = ax1.twin
-00023ec0: 7928 290a 2020 2020 2020 2020 2020 2020  y().            
-00023ed0: 6466 5b6e 6577 5f63 6f6c 5d2e 706c 6f74  df[new_col].plot
-00023ee0: 2e6b 6465 2861 783d 6178 322c 6c61 6265  .kde(ax=ax2,labe
-00023ef0: 6c3d 6e65 775f 636f 6c2c 616c 7068 613d  l=new_col,alpha=
-00023f00: 302e 352c 636f 6c6f 723d 2762 2729 0a20  0.5,color='b'). 
-00023f10: 2020 2020 2020 2020 2020 2070 6c74 2e6c             plt.l
-00023f20: 6567 656e 6428 293b 0a20 2020 2072 6574  egend();.    ret
-00023f30: 7572 6e20 6466 0a23 2323 2323 2323 2323  urn df.#########
-00023f40: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00023f50: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00023f60: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00023f70: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00023f80: 2323 2323 2323 2323 0a66 726f 6d20 6974  ########.from it
-00023f90: 6572 746f 6f6c 7320 696d 706f 7274 2063  ertools import c
-00023fa0: 7963 6c65 2c20 636f 6d62 696e 6174 696f  ycle, combinatio
-00023fb0: 6e73 0a64 6566 2046 455f 6372 6561 7465  ns.def FE_create
-00023fc0: 5f69 6e74 6572 6163 7469 6f6e 5f76 6172  _interaction_var
-00023fd0: 7328 6466 2c20 696e 7478 6e5f 7661 7273  s(df, intxn_vars
-00023fe0: 293a 0a20 2020 2022 2222 0a20 2020 2054  ):.    """.    T
-00023ff0: 6869 7320 6861 6e64 7920 6675 6e63 7469  his handy functi
-00024000: 6f6e 2063 7265 6174 6573 2069 6e74 6572  on creates inter
-00024010: 6163 7469 6f6e 2076 6172 6961 626c 6573  action variables
-00024020: 2061 6d6f 6e67 2070 6169 7273 206f 6620   among pairs of 
-00024030: 6e75 6d65 7269 6320 7661 7273 2079 6f75  numeric vars you
-00024040: 2073 656e 6420 696e 2e0a 2020 2020 596f   send in..    Yo
-00024050: 7572 2069 6e70 7574 206d 7573 7420 6265  ur input must be
-00024060: 2061 2064 6174 6166 7261 6d65 2061 6e64   a dataframe and
-00024070: 2061 206c 6973 7420 6f66 2074 7570 6c65   a list of tuple
-00024080: 732e 2045 6163 6820 7475 706c 6520 6d75  s. Each tuple mu
-00024090: 7374 2063 6f6e 7461 696e 2061 2070 6169  st contain a pai
-000240a0: 7220 6f66 2076 6172 6961 626c 6573 2e0a  r of variables..
-000240b0: 2020 2020 416c 6c20 7661 7269 6162 6c65      All variable
-000240c0: 7320 6d75 7374 2062 6520 6e75 6d65 7269  s must be numeri
-000240d0: 632e 2044 6f75 626c 6520 6368 6563 6b20  c. Double check 
-000240e0: 796f 7572 2069 6e70 7574 2062 6566 6f72  your input befor
-000240f0: 6520 7365 6e64 696e 6720 7468 656d 2069  e sending them i
-00024100: 6e2e 0a20 2020 2022 2222 0a20 2020 2069  n..    """.    i
-00024110: 6620 7479 7065 2864 6629 203d 3d20 6461  f type(df) == da
-00024120: 736b 2e64 6174 6166 7261 6d65 2e63 6f72  sk.dataframe.cor
-00024130: 652e 4461 7461 4672 616d 653a 0a20 2020  e.DataFrame:.   
-00024140: 2020 2020 2023 2320 736b 6970 2069 6620       ## skip if 
-00024150: 6974 2069 7320 6120 6461 736b 2064 6174  it is a dask dat
-00024160: 6166 7261 6d65 2023 2323 230a 2020 2020  aframe ####.    
-00024170: 2020 2020 7061 7373 0a20 2020 2065 6c73      pass.    els
-00024180: 653a 0a20 2020 2020 2020 2064 6620 3d20  e:.        df = 
-00024190: 6466 2e63 6f70 7928 6465 6570 3d54 7275  df.copy(deep=Tru
-000241a0: 6529 0a20 2020 2063 6f6d 626f 7320 3d20  e).    combos = 
-000241b0: 636f 6d62 696e 6174 696f 6e73 2869 6e74  combinations(int
-000241c0: 786e 5f76 6172 732c 2032 290a 2020 2020  xn_vars, 2).    
-000241d0: 2323 2320 4920 6861 7665 2074 6573 7465  ### I have teste
-000241e0: 6420 7468 6973 2066 6f72 2062 6f74 6820  d this for both 
-000241f0: 6361 7465 676f 7279 2061 6e64 206f 626a  category and obj
-00024200: 6563 7420 6474 7970 6573 2073 6f20 646f  ect dtypes so do
-00024210: 6e27 7420 776f 7272 7920 2323 230a 2020  n't worry ###.  
-00024220: 2020 666f 7220 2865 6163 685f 696e 7478    for (each_intx
-00024230: 6e31 2c65 6163 685f 696e 7478 6e32 2920  n1,each_intxn2) 
-00024240: 2069 6e20 636f 6d62 6f73 3a0a 2020 2020   in combos:.    
-00024250: 2020 2020 6e65 775f 636f 6c20 3d20 6561      new_col = ea
-00024260: 6368 5f69 6e74 786e 3120 2b20 275f 785f  ch_intxn1 + '_x_
-00024270: 2720 2b20 6561 6368 5f69 6e74 786e 320a  ' + each_intxn2.
-00024280: 2020 2020 2020 2020 7472 793a 0a20 2020          try:.   
-00024290: 2020 2020 2020 2020 2064 665b 6e65 775f           df[new_
-000242a0: 636f 6c5d 203d 2064 665b 6561 6368 5f69  col] = df[each_i
-000242b0: 6e74 786e 315d 2e61 7374 7970 6528 7374  ntxn1].astype(st
-000242c0: 7229 202b 2027 2027 202b 2064 665b 6561  r) + ' ' + df[ea
-000242d0: 6368 5f69 6e74 786e 325d 2e61 7374 7970  ch_intxn2].astyp
-000242e0: 6528 7374 7229 0a20 2020 2020 2020 2065  e(str).        e
-000242f0: 7863 6570 743a 0a20 2020 2020 2020 2020  xcept:.         
-00024300: 2020 2063 6f6e 7469 6e75 650a 2020 2020     continue.    
-00024310: 2323 2320 7468 6973 2077 696c 6c20 7265  ### this will re
-00024320: 7475 726e 2065 7874 7261 2066 6561 7475  turn extra featu
-00024330: 7265 7320 6765 6e65 7261 7465 6420 6279  res generated by
-00024340: 2069 6e74 6572 6163 7469 6f6e 7320 2323   interactions ##
-00024350: 2323 2020 2020 0a20 2020 2072 6574 7572  ##    .    retur
-00024360: 6e20 6466 0a23 2323 2323 2323 2323 2323  n df.###########
-00024370: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00024380: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00024390: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000243a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000243b0: 2323 2323 2323 230a 696d 706f 7274 206d  #######.import m
-000243c0: 6174 706c 6f74 6c69 622e 7079 706c 6f74  atplotlib.pyplot
-000243d0: 2061 7320 706c 740a 6465 6620 4544 415f   as plt.def EDA_
-000243e0: 6269 6e6e 696e 675f 6e75 6d65 7269 635f  binning_numeric_
-000243f0: 636f 6c75 6d6e 5f64 6973 706c 6179 696e  column_displayin
-00024400: 675f 6269 6e73 2864 6674 2c20 7461 7267  g_bins(dft, targ
-00024410: 6574 2c20 6269 6e73 3d34 2c20 7465 7374  et, bins=4, test
-00024420: 3d22 2229 3a0a 2020 2020 2222 220a 2020  =""):.    """.  
-00024430: 2020 5468 6973 2073 706c 6974 7320 7468    This splits th
-00024440: 6520 6461 7461 2063 6f6c 756d 6e20 696e  e data column in
-00024450: 746f 2074 6865 206e 756d 6265 7220 6f66  to the number of
-00024460: 2062 696e 7320 7370 6563 6966 6965 6420   bins specified 
-00024470: 616e 6420 7265 7475 726e 7320 6c61 6265  and returns labe
-00024480: 6c73 2c20 6269 6e73 2c20 616e 6420 6461  ls, bins, and da
-00024490: 7461 6672 616d 652e 0a20 2020 204f 7574  taframe..    Out
-000244a0: 7075 7473 3a0a 2020 2020 2020 206c 6162  puts:.       lab
-000244b0: 656c 7320 3d20 7468 6520 6e61 6d65 7320  els = the names 
-000244c0: 6f66 2074 6865 2062 696e 730a 2020 2020  of the bins.    
-000244d0: 2020 2065 6467 6573 203d 2074 6865 2065     edges = the e
-000244e0: 6467 6573 206f 6620 7468 6520 6269 6e73  dges of the bins
-000244f0: 0a20 2020 2020 2020 6466 7420 3d20 7468  .       dft = th
-00024500: 6520 6461 7461 6672 616d 6520 7769 7468  e dataframe with
-00024510: 2061 6e20 6164 6465 6420 636f 6c75 6d6e   an added column
-00024520: 2063 616c 6c65 6420 2262 696e 6e65 645f   called "binned_
-00024530: 222b 6e61 6d65 206f 6620 7468 6520 636f  "+name of the co
-00024540: 6c75 6d6e 2079 6f75 2073 656e 7420 696e  lumn you sent in
-00024550: 0a20 2020 2022 2222 0a20 2020 2064 6674  .    """.    dft
-00024560: 203d 2063 6f70 792e 6465 6570 636f 7079   = copy.deepcopy
-00024570: 2864 6674 290a 2020 2020 5f2c 2065 6467  (dft).    _, edg
-00024580: 6573 203d 2070 642e 7163 7574 2864 6674  es = pd.qcut(dft
-00024590: 5b74 6172 6765 745d 2e64 726f 706e 6128  [target].dropna(
-000245a0: 6178 6973 3d30 292c 713d 6269 6e73 2c20  axis=0),q=bins, 
-000245b0: 7265 7462 696e 733d 5472 7565 2c20 6475  retbins=True, du
-000245c0: 706c 6963 6174 6573 3d27 6472 6f70 2729  plicates='drop')
-000245d0: 0a20 2020 2023 2323 206e 6f77 2077 6520  .    ### now we 
-000245e0: 6372 6561 7465 2061 7274 6966 6963 6961  create artificia
-000245f0: 6c20 6c61 6265 6c73 2074 6f20 6d61 7463  l labels to matc
-00024600: 6820 7468 6520 6269 6e73 2065 6467 6573  h the bins edges
-00024610: 2023 2323 230a 2020 2020 6c73 203d 205b   ####.    ls = [
-00024620: 5d0a 2020 2020 666f 7220 692c 2078 2069  ].    for i, x i
-00024630: 6e20 656e 756d 6572 6174 6528 6564 6765  n enumerate(edge
-00024640: 7329 3a0a 2020 2020 2020 2020 2370 7269  s):.        #pri
-00024650: 6e74 2827 6920 3d20 2573 2c20 6e65 7874  nt('i = %s, next
-00024660: 2069 203d 2025 7327 2025 2869 2c69 2b31   i = %s' %(i,i+1
-00024670: 2929 0a20 2020 2020 2020 2069 6620 6920  )).        if i 
-00024680: 3c20 6c65 6e28 6564 6765 7329 2d31 3a0a  < len(edges)-1:.
-00024690: 2020 2020 2020 2020 2020 2020 6c73 2e61              ls.a
-000246a0: 7070 656e 6428 2766 726f 6d5f 272b 7374  ppend('from_'+st
-000246b0: 7228 726f 756e 6428 6564 6765 735b 695d  r(round(edges[i]
-000246c0: 2c33 2929 2b27 5f74 6f5f 272b 7374 7228  ,3))+'_to_'+str(
-000246d0: 726f 756e 6428 6564 6765 735b 692b 315d  round(edges[i+1]
-000246e0: 2c33 2929 290a 2020 2020 2323 2323 2320  ,3))).    ##### 
-000246f0: 4e65 7874 2077 6520 6164 6420 6120 636f  Next we add a co
-00024700: 6c75 6d6e 2074 6f20 686f 6c64 2074 6865  lumn to hold the
-00024710: 2062 696e 7320 6372 6561 7465 6420 6279   bins created by
-00024720: 2061 626f 7665 2023 2323 2323 2323 2323   above #########
-00024730: 2323 2323 2323 0a20 2020 2064 6674 5b27  ######.    dft['
-00024740: 6269 6e6e 6564 5f27 2b74 6172 6765 745d  binned_'+target]
-00024750: 203d 2070 642e 6375 7428 6466 745b 7461   = pd.cut(dft[ta
-00024760: 7267 6574 5d2c 2062 696e 733d 6564 6765  rget], bins=edge
-00024770: 732c 2072 6574 6269 6e73 3d46 616c 7365  s, retbins=False
-00024780: 2c20 6c61 6265 6c73 3d6c 732c 2069 6e63  , labels=ls, inc
-00024790: 6c75 6465 5f6c 6f77 6573 743d 5472 7565  lude_lowest=True
-000247a0: 292e 7661 6c75 6573 2e74 6f6c 6973 7428  ).values.tolist(
-000247b0: 290a 2020 2020 6966 206e 6f74 2069 7369  ).    if not isi
-000247c0: 6e73 7461 6e63 6528 7465 7374 2c20 7374  nstance(test, st
-000247d0: 7229 3a0a 2020 2020 2020 2020 7465 7374  r):.        test
-000247e0: 5b27 6269 6e6e 6564 5f27 2b74 6172 6765  ['binned_'+targe
-000247f0: 745d 203d 2070 642e 6375 7428 7465 7374  t] = pd.cut(test
-00024800: 5b74 6172 6765 745d 2c20 6269 6e73 3d65  [target], bins=e
-00024810: 6467 6573 2c20 7265 7462 696e 733d 4661  dges, retbins=Fa
-00024820: 6c73 652c 206c 6162 656c 733d 6c73 2c20  lse, labels=ls, 
-00024830: 696e 636c 7564 655f 6c6f 7765 7374 3d54  include_lowest=T
-00024840: 7275 6529 2e76 616c 7565 732e 746f 6c69  rue).values.toli
-00024850: 7374 2829 0a20 2020 206e 726f 7773 203d  st().    nrows =
-00024860: 2069 6e74 286c 656e 2865 6467 6573 292f   int(len(edges)/
-00024870: 3220 2b20 3129 0a20 2020 2070 6c74 2e66  2 + 1).    plt.f
-00024880: 6967 7572 6528 6669 6773 697a 653d 2831  igure(figsize=(1
-00024890: 352c 6e72 6f77 732a 3329 290a 2020 2020  5,nrows*3)).    
-000248a0: 706c 742e 7375 6270 6c6f 7473 5f61 646a  plt.subplots_adj
-000248b0: 7573 7428 6873 7061 6365 3d2e 3529 0a20  ust(hspace=.5). 
-000248c0: 2020 2063 6f6c 6c65 6374 5f62 696e 7320     collect_bins 
-000248d0: 3d20 5b5d 0a20 2020 2066 6f72 2069 2069  = [].    for i i
-000248e0: 6e20 7261 6e67 6528 6c65 6e28 6564 6765  n range(len(edge
-000248f0: 7329 293a 0a20 2020 2020 2020 2069 6620  s)):.        if 
-00024900: 6920 3d3d 2030 3a0a 2020 2020 2020 2020  i == 0:.        
-00024910: 2020 2020 636f 6e74 696e 7565 0a20 2020      continue.   
-00024920: 2020 2020 2065 6c73 653a 0a20 2020 2020       else:.     
-00024930: 2020 2020 2020 2064 6674 6320 3d20 6466         dftc = df
-00024940: 745b 2864 6674 5b74 6172 6765 745d 3e65  t[(dft[target]>e
-00024950: 6467 6573 5b69 2d31 5d29 2026 2028 6466  dges[i-1]) & (df
-00024960: 745b 7461 7267 6574 5d3c 3d65 6467 6573  t[target]<=edges
-00024970: 5b69 5d29 5d0a 2020 2020 2020 2020 2020  [i])].          
-00024980: 2020 636f 6c6c 6563 745f 6269 6e73 2e61    collect_bins.a
-00024990: 7070 656e 6428 6466 7463 290a 2020 2020  ppend(dftc).    
-000249a0: 2020 2020 2020 2020 6178 3120 3d20 706c          ax1 = pl
-000249b0: 742e 7375 6270 6c6f 7428 6e72 6f77 732c  t.subplot(nrows,
-000249c0: 2032 2c20 6929 0a20 2020 2020 2020 2020   2, i).         
-000249d0: 2020 2064 6674 635b 7461 7267 6574 5d2e     dftc[target].
-000249e0: 6869 7374 2862 696e 733d 3330 2c20 6178  hist(bins=30, ax
-000249f0: 3d61 7831 290a 2020 2020 2020 2020 2020  =ax1).          
-00024a00: 2020 6178 312e 7365 745f 7469 746c 6528    ax1.set_title(
-00024a10: 2762 696e 2025 643a 2073 697a 653a 2025  'bin %d: size: %
-00024a20: 642c 2025 7320 2530 2e32 6620 746f 2025  d, %s %0.2f to %
-00024a30: 302e 3266 2720 2528 692c 2064 6674 632e  0.2f' %(i, dftc.
-00024a40: 7368 6170 655b 305d 2c20 7461 7267 6574  shape[0], target
-00024a50: 2c0a 2020 2020 2020 2020 2020 2020 2020  ,.              
-00024a60: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00024a70: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00024a80: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00024a90: 2020 2020 6564 6765 735b 692d 315d 2c20      edges[i-1], 
-00024aa0: 6564 6765 735b 695d 2929 0a20 2020 2072  edges[i])).    r
-00024ab0: 6574 7572 6e20 6c73 2c20 6564 6765 732c  eturn ls, edges,
-00024ac0: 2064 6674 2c20 7465 7374 0a23 2323 2323   dft, test.#####
-00024ad0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00024ae0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00024af0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00024b00: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00024b10: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00024b20: 2323 2323 0a66 726f 6d20 7061 7468 6c69  ####.from pathli
-00024b30: 6220 696d 706f 7274 2050 6174 680a 696d  b import Path.im
-00024b40: 706f 7274 206d 6174 706c 6f74 6c69 622e  port matplotlib.
-00024b50: 7079 706c 6f74 2061 7320 706c 740a 696d  pyplot as plt.im
-00024b60: 706f 7274 2073 6561 626f 726e 2061 7320  port seaborn as 
-00024b70: 736e 730a 6672 6f6d 2064 6174 6574 696d  sns.from datetim
-00024b80: 6520 696d 706f 7274 2064 6174 6574 696d  e import datetim
-00024b90: 652c 2064 6174 650a 6672 6f6d 2073 6b6c  e, date.from skl
-00024ba0: 6561 726e 2e6d 6574 7269 6373 2069 6d70  earn.metrics imp
-00024bb0: 6f72 7420 6d65 616e 5f73 7175 6172 6564  ort mean_squared
-00024bc0: 5f65 7272 6f72 2c20 726f 635f 6175 635f  _error, roc_auc_
-00024bd0: 7363 6f72 650a 6672 6f6d 2073 6b6c 6561  score.from sklea
-00024be0: 726e 2e70 7265 7072 6f63 6573 7369 6e67  rn.preprocessing
-00024bf0: 2069 6d70 6f72 7420 6d69 6e6d 6178 5f73   import minmax_s
-00024c00: 6361 6c65 0a23 2323 2320 5468 6973 2069  cale.#### This i
-00024c10: 7320 7768 6572 6520 7765 2061 6464 206f  s where we add o
-00024c20: 7468 6572 206c 6962 7261 7269 6573 2074  ther libraries t
-00024c30: 6f20 666f 726d 2061 2070 6970 656c 696e  o form a pipelin
-00024c40: 6520 2323 230a 696d 706f 7274 2063 6f70  e ###.import cop
-00024c50: 790a 696d 706f 7274 2074 696d 650a 696d  y.import time.im
-00024c60: 706f 7274 2072 650a 6672 6f6d 2073 6369  port re.from sci
-00024c70: 7079 2e6e 6469 6d61 6765 2069 6d70 6f72  py.ndimage impor
-00024c80: 7420 636f 6e76 6f6c 7665 0a66 726f 6d20  t convolve.from 
-00024c90: 736b 6c65 6172 6e20 696d 706f 7274 2020  sklearn import  
-00024ca0: 6461 7461 7365 7473 2c20 6d65 7472 6963  datasets, metric
-00024cb0: 730a 6672 6f6d 2073 6b6c 6561 726e 2e6d  s.from sklearn.m
-00024cc0: 6f64 656c 5f73 656c 6563 7469 6f6e 2069  odel_selection i
-00024cd0: 6d70 6f72 7420 7472 6169 6e5f 7465 7374  mport train_test
-00024ce0: 5f73 706c 6974 0a66 726f 6d20 736b 6c65  _split.from skle
-00024cf0: 6172 6e2e 7069 7065 6c69 6e65 2069 6d70  arn.pipeline imp
-00024d00: 6f72 7420 5069 7065 6c69 6e65 0a66 726f  ort Pipeline.fro
-00024d10: 6d20 736b 6c65 6172 6e2e 6d6f 6465 6c5f  m sklearn.model_
-00024d20: 7365 6c65 6374 696f 6e20 696d 706f 7274  selection import
-00024d30: 204b 466f 6c64 2c20 5374 7261 7469 6669   KFold, Stratifi
-00024d40: 6564 5368 7566 666c 6553 706c 6974 0a0a  edShuffleSplit..
-00024d50: 6465 6620 6164 645f 7465 7874 5f70 6164  def add_text_pad
-00024d60: 6469 6e67 7328 7472 6169 6e5f 6461 7461  dings(train_data
-00024d70: 2c6e 6c70 5f63 6f6c 756d 6e2c 676c 6f76  ,nlp_column,glov
-00024d80: 655f 6669 6c65 6e61 6d65 5f77 6974 685f  e_filename_with_
-00024d90: 7061 7468 2c74 6f6b 656e 697a 6564 2c0a  path,tokenized,.
-00024da0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00024db0: 2020 2020 2020 2020 2020 2020 6669 745f              fit_
-00024dc0: 666c 6167 3d54 7275 652c 0a20 2020 2020  flag=True,.     
-00024dd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00024de0: 2020 2020 2020 206d 6178 5f6c 656e 6774         max_lengt
-00024df0: 683d 3130 3029 3a0a 2020 2020 2222 220a  h=100):.    """.
-00024e00: 2020 2020 2323 2323 2323 2323 2323 2323      ############
-00024e10: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00024e20: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00024e30: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00024e40: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00024e50: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00024e60: 2323 2323 2323 0a20 2020 2054 6869 7320  ######.    This 
-00024e70: 6675 6e63 7469 6f6e 2075 7365 7320 6120  function uses a 
-00024e80: 476c 6f56 6520 7072 652d 7472 6169 6e65  GloVe pre-traine
-00024e90: 6420 6d6f 6465 6c20 746f 2061 6464 2065  d model to add e
-00024ea0: 6d62 6564 6469 6e67 7320 746f 2079 6f75  mbeddings to you
-00024eb0: 7220 6461 7461 2073 6574 2e0a 2020 2020  r data set..    
-00024ec0: 2323 2323 2323 2323 2020 4920 4e20 5020  ########  I N P 
-00024ed0: 5520 5420 2323 2323 2323 2323 2323 2323  U T ############
-00024ee0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00024ef0: 2323 3a0a 2020 2020 6461 7461 3a20 4461  ##:.    data: Da
-00024f00: 7461 4672 616d 650a 2020 2020 6e6c 705f  taFrame.    nlp_
-00024f10: 636f 6c75 6d6e 3a20 6e61 6d65 206f 6620  column: name of 
-00024f20: 7468 6520 4e4c 5020 636f 6c75 6d6e 2069  the NLP column i
-00024f30: 6e20 7468 6520 4461 7461 4672 616d 650a  n the DataFrame.
-00024f40: 2020 2020 7461 7267 6574 3a20 6e61 6d65      target: name
-00024f50: 206f 6620 7468 6520 7461 7267 6574 2076   of the target v
-00024f60: 6172 6961 626c 6520 696e 2074 6865 2044  ariable in the D
-00024f70: 6174 6146 7261 6d65 0a20 2020 2067 6c6f  ataFrame.    glo
-00024f80: 7665 6669 6c65 3a20 6c6f 6361 7469 6f6e  vefile: location
-00024f90: 206f 6620 7768 6572 6520 7468 6520 676c   of where the gl
-00024fa0: 6f76 652e 7478 7420 6669 6c65 2069 732e  ove.txt file is.
-00024fb0: 2059 6f75 206d 7573 7420 6769 7665 2074   You must give t
-00024fc0: 6865 2066 756c 6c20 7061 7468 2074 6f20  he full path to 
-00024fd0: 7468 6174 2066 696c 652e 0a20 2020 206d  that file..    m
-00024fe0: 6178 5f6c 656e 6774 683a 2073 7065 6369  ax_length: speci
-00024ff0: 6679 2074 6865 2064 696d 656e 7369 6f6e  fy the dimension
-00025000: 206f 6620 7468 6520 676c 6f76 6520 7665   of the glove ve
-00025010: 6374 6f72 2020 796f 7520 6361 6e20 6861  ctor  you can ha
-00025020: 7665 2075 7074 6f20 7468 6520 6469 6d65  ve upto the dime
-00025030: 6e73 696f 6e20 6f66 2074 6865 2067 6c6f  nsion of the glo
-00025040: 7665 2074 7874 2066 696c 652e 0a20 2020  ve txt file..   
-00025050: 2020 2020 2020 2020 4d61 6b65 2073 7572          Make sur
-00025060: 6520 796f 7520 646f 6e27 7420 6578 6365  e you don't exce
-00025070: 6564 2074 6865 2064 696d 656e 7369 6f6e  ed the dimension
-00025080: 2073 7065 6369 6669 6564 2069 6e20 7468   specified in th
-00025090: 6520 676c 6f76 652e 7478 7420 6669 6c65  e glove.txt file
-000250a0: 2e20 4f74 6865 7277 6973 652c 2065 7272  . Otherwise, err
-000250b0: 6f72 2072 6573 756c 742e 0a20 2020 2023  or result..    #
-000250c0: 2323 2323 2323 204f 2055 2054 2050 2055  ###### O U T P U
-000250d0: 2054 2023 2323 2323 2323 2323 2323 2323   T #############
-000250e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000250f0: 0a20 2020 2054 6865 2064 6174 6166 7261  .    The datafra
-00025100: 6d65 2069 7320 7370 6c69 7420 696e 746f  me is split into
-00025110: 2074 7261 696e 2061 6e64 2074 6573 7420   train and test 
-00025120: 616e 6420 6172 6520 6d6f 6469 6669 6564  and are modified
-00025130: 2069 6e74 6f20 7468 6520 7370 6563 6966   into the specif
-00025140: 6965 6420 7665 6374 6f72 2064 696d 656e  ied vector dimen
-00025150: 7369 6f6e 206f 6620 6d61 785f 6c65 6e67  sion of max_leng
-00025160: 7468 0a20 2020 2058 5f74 7261 696e 5f70  th.    X_train_p
-00025170: 6164 6465 643a 2074 6865 2074 7261 696e  added: the train
-00025180: 2064 6174 6166 7261 6d65 2077 6974 6820   dataframe with 
-00025190: 6469 6d65 6e73 696f 6e20 7370 6563 6966  dimension specif
-000251a0: 6965 6420 696e 206d 6178 5f6c 656e 6774  ied in max_lengt
-000251b0: 680a 2020 2020 795f 7472 6169 6e3a 2074  h.    y_train: t
-000251c0: 6865 2074 6172 6765 7420 7665 6374 6f72  he target vector
-000251d0: 2075 7369 6e67 2064 6174 6120 616e 6420   using data and 
-000251e0: 7461 7267 6574 2063 6f6c 756d 6e0a 2020  target column.  
-000251f0: 2020 585f 7465 7374 5f70 6164 6465 643a    X_test_padded:
-00025200: 2020 7468 6520 7465 7374 2064 6174 6166    the test dataf
-00025210: 7261 6d65 2077 6974 6820 6469 6d65 6e73  rame with dimens
-00025220: 696f 6e20 7370 6563 6966 6965 6420 696e  ion specified in
-00025230: 206d 6178 5f6c 656e 6774 680a 2020 2020   max_length.    
-00025240: 746f 6b65 6e69 7a65 643a 2054 6869 7320  tokenized: This 
-00025250: 6973 2074 6865 2074 6f6b 656e 697a 6572  is the tokenizer
-00025260: 2074 6861 7420 7761 7320 7573 6564 2074   that was used t
-00025270: 6f20 7370 6c69 7420 7468 6520 776f 7264  o split the word
-00025280: 7320 696e 2064 6174 6120 7365 742e 2054  s in data set. T
-00025290: 6869 7320 6d75 7374 2062 6520 7573 6564  his must be used
-000252a0: 206c 6174 6572 2e0a 2020 2020 2323 2323   later..    ####
-000252b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000252c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000252d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000252e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000252f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00025300: 2323 2323 2323 2323 2323 2323 2323 0a20  ##############. 
-00025310: 2020 2022 2222 0a20 2020 2074 7261 696e     """.    train
-00025320: 5f69 6e64 6578 203d 2074 7261 696e 5f64  _index = train_d
-00025330: 6174 612e 696e 6465 780a 2020 2020 2323  ata.index.    ##
-00025340: 2320 456e 636f 6465 2054 7261 696e 2064  # Encode Train d
-00025350: 6174 6120 7465 7874 2069 6e74 6f20 7365  ata text into se
-00025360: 7175 656e 6365 730a 2020 2020 7472 6169  quences.    trai
-00025370: 6e5f 6461 7461 5f65 6e63 6f64 6564 203d  n_data_encoded =
-00025380: 2074 6f6b 656e 697a 6564 2e74 6578 7473   tokenized.texts
-00025390: 5f74 6f5f 7365 7175 656e 6365 7328 7472  _to_sequences(tr
-000253a0: 6169 6e5f 6461 7461 5b6e 6c70 5f63 6f6c  ain_data[nlp_col
-000253b0: 756d 6e5d 290a 2020 2020 2323 2320 5061  umn]).    ### Pa
-000253c0: 645f 5365 7175 656e 6365 7320 6675 6e63  d_Sequences func
-000253d0: 7469 6f6e 2069 7320 7573 6564 2074 6f20  tion is used to 
-000253e0: 6d61 6b65 206c 6973 7473 206f 6620 756e  make lists of un
-000253f0: 6571 7561 6c20 6c65 6e67 7468 2074 6f20  equal length to 
-00025400: 7374 6163 6b65 6420 7365 7473 206f 6620  stacked sets of 
-00025410: 7061 6464 6564 2061 6e64 2074 7275 6e63  padded and trunc
-00025420: 6174 6564 2061 7272 6179 730a 2020 2020  ated arrays.    
-00025430: 2323 2320 5061 6420 5365 7175 656e 6365  ### Pad Sequence
-00025440: 7320 666f 7220 5472 6169 6e0a 2020 2020  s for Train.    
-00025450: 585f 7472 6169 6e5f 7061 6464 6564 203d  X_train_padded =
-00025460: 2070 6164 5f73 6571 7565 6e63 6573 2874   pad_sequences(t
-00025470: 7261 696e 5f64 6174 615f 656e 636f 6465  rain_data_encode
-00025480: 642c 0a20 2020 2020 2020 2020 2020 2020  d,.             
-00025490: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000254a0: 2020 206d 6178 6c65 6e3d 6d61 785f 6c65     maxlen=max_le
-000254b0: 6e67 7468 2c0a 2020 2020 2020 2020 2020  ngth,.          
-000254c0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-000254d0: 2020 2020 2020 7061 6464 696e 673d 2770        padding='p
-000254e0: 6f73 7427 2c0a 2020 2020 2020 2020 2020  ost',.          
-000254f0: 2020 2020 2020 2020 2020 2020 2020 2020                  
-00025500: 2020 2020 2074 7275 6e63 6174 696e 673d       truncating=
-00025510: 2770 6f73 7427 290a 2020 2020 7072 696e  'post').    prin
-00025520: 7428 2720 2020 2044 6174 6120 7368 6170  t('    Data shap
-00025530: 6520 6166 7465 7220 7061 6464 696e 6720  e after padding 
-00025540: 3d20 2573 2720 2528 585f 7472 6169 6e5f  = %s' %(X_train_
-00025550: 7061 6464 6564 2e73 6861 7065 2c29 290a  padded.shape,)).
-00025560: 2020 2020 6e65 775f 636f 6c73 203d 205b      new_cols = [
-00025570: 2767 6c6f 7665 5f64 696d 5f27 202b 2073  'glove_dim_' + s
-00025580: 7472 2878 2b31 2920 666f 7220 7820 696e  tr(x+1) for x in
-00025590: 2072 616e 6765 2858 5f74 7261 696e 5f70   range(X_train_p
-000255a0: 6164 6465 642e 7368 6170 655b 315d 295d  added.shape[1])]
-000255b0: 0a20 2020 2058 5f74 7261 696e 5f70 6164  .    X_train_pad
-000255c0: 6465 6420 3d20 7064 2e44 6174 6146 7261  ded = pd.DataFra
-000255d0: 6d65 2858 5f74 7261 696e 5f70 6164 6465  me(X_train_padde
-000255e0: 642c 2063 6f6c 756d 6e73 3d6e 6577 5f63  d, columns=new_c
-000255f0: 6f6c 732c 2069 6e64 6578 3d74 7261 696e  ols, index=train
-00025600: 5f69 6e64 6578 290a 2020 2020 6966 2066  _index).    if f
-00025610: 6974 5f66 6c61 673a 0a20 2020 2020 2020  it_flag:.       
-00025620: 2072 6574 7572 6e20 585f 7472 6169 6e5f   return X_train_
-00025630: 7061 6464 6564 2c20 746f 6b65 6e69 7a65  padded, tokenize
-00025640: 642c 2076 6f63 6162 5f73 697a 650a 2020  d, vocab_size.  
-00025650: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
-00025660: 7265 7475 726e 2058 5f74 7261 696e 5f70  return X_train_p
-00025670: 6164 6465 640a 2323 2323 2323 2323 2323  added.##########
-00025680: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00025690: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000256a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000256b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000256c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000256d0: 2323 2323 2323 2323 2323 230a 6465 6620  ###########.def 
-000256e0: 6c6f 6164 5f65 6d62 6564 6469 6e67 7328  load_embeddings(
-000256f0: 746f 6b65 6e69 7a65 642c 676c 6f76 655f  tokenized,glove_
-00025700: 6669 6c65 6e61 6d65 5f77 6974 685f 7061  filename_with_pa
-00025710: 7468 2c76 6f63 6162 5f73 697a 652c 676c  th,vocab_size,gl
-00025720: 6f76 655f 6469 6d65 6e73 696f 6e29 3a0a  ove_dimension):.
-00025730: 2020 2020 2222 220a 2020 2020 2323 2323      """.    ####
-00025740: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00025750: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00025760: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00025770: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00025780: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00025790: 2323 2323 2323 2323 2323 2323 2323 0a20  ##############. 
-000257a0: 2020 2023 2067 6c6f 7665 5f66 696c 656e     # glove_filen
-000257b0: 616d 655f 7769 7468 5f70 6174 683a 204d  ame_with_path: M
-000257c0: 616b 6520 7375 7265 2075 2068 6176 6520  ake sure u have 
-000257d0: 646f 776e 6c6f 6164 6564 2061 6e64 2075  downloaded and u
-000257e0: 6e7a 6970 7065 6420 7468 6520 476c 6f56  nzipped the GloV
-000257f0: 6520 222e 7478 7422 2066 696c 6520 746f  e ".txt" file to
-00025800: 2074 6865 206c 6f63 6174 696f 6e20 6865   the location he
-00025810: 7265 2e0a 2020 2020 2320 7765 206e 6f77  re..    # we now
-00025820: 2063 7265 6174 6520 6120 6469 6374 696f   create a dictio
-00025830: 6e61 7279 2074 6861 7420 6d61 7073 2047  nary that maps G
-00025840: 6c6f 5665 2074 6f6b 656e 7320 746f 2031  loVe tokens to 1
-00025850: 3030 2c20 6f72 2032 3030 2d20 6f72 2033  00, or 200- or 3
-00025860: 3030 2d64 696d 656e 7369 6f6e 616c 2072  00-dimensional r
-00025870: 6561 6c2d 7661 6c75 6564 2076 6563 746f  eal-valued vecto
-00025880: 7273 0a20 2020 2023 2054 6865 6e20 7765  rs.    # Then we
-00025890: 206c 6f61 6420 7468 6520 7768 6f6c 6520   load the whole 
-000258a0: 656d 6265 6464 696e 6720 696e 746f 206d  embedding into m
-000258b0: 656d 6f72 792e 204d 616b 6520 7375 7265  emory. Make sure
-000258c0: 2079 6f75 2068 6176 6520 706c 656e 7479   you have plenty
-000258d0: 206f 6620 6d65 6d6f 7279 2069 6e20 796f   of memory in yo
-000258e0: 7572 206d 6163 6869 6e65 210a 2020 2020  ur machine!.    
-000258f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00025900: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00025910: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00025920: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00025930: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00025940: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00025950: 2323 0a20 2020 2022 2222 0a20 2020 204d  ##.    """.    M
-00025960: 4158 5f4e 554d 5f57 4f52 4453 203d 2031  AX_NUM_WORDS = 1
-00025970: 3030 3030 300a 2020 2020 676c 6f76 655f  00000.    glove_
-00025980: 7061 7468 203d 2050 6174 6828 676c 6f76  path = Path(glov
-00025990: 655f 6669 6c65 6e61 6d65 5f77 6974 685f  e_filename_with_
-000259a0: 7061 7468 290a 2020 2020 7072 696e 7428  path).    print(
-000259b0: 2720 2020 2043 7265 6174 696e 6720 656d  '    Creating em
-000259c0: 6265 6464 696e 6773 2e20 5468 6973 2077  beddings. This w
-000259d0: 696c 6c20 7461 6b65 2074 696d 652e 2e2e  ill take time...
-000259e0: 2729 0a20 2020 2065 6d62 6564 6469 6e67  ').    embedding
-000259f0: 735f 696e 6465 7820 3d20 6469 6374 2829  s_index = dict()
-00025a00: 0a20 2020 2066 6f72 206c 696e 6520 696e  .    for line in
-00025a10: 2067 6c6f 7665 5f70 6174 682e 6f70 656e   glove_path.open
-00025a20: 2865 6e63 6f64 696e 673d 276c 6174 696e  (encoding='latin
-00025a30: 3127 293a 0a20 2020 2020 2020 2076 616c  1'):.        val
-00025a40: 7565 7320 3d20 6c69 6e65 2e73 706c 6974  ues = line.split
-00025a50: 2829 0a20 2020 2020 2020 2077 6f72 6420  ().        word 
-00025a60: 3d20 7661 6c75 6573 5b30 5d0a 2020 2020  = values[0].    
-00025a70: 2020 2020 7472 793a 0a20 2020 2020 2020      try:.       
-00025a80: 2020 2020 2063 6f65 6673 203d 206e 702e       coefs = np.
-00025a90: 6173 6172 7261 7928 7661 6c75 6573 5b31  asarray(values[1
-00025aa0: 3a5d 2c20 6474 7970 653d 2766 6c6f 6174  :], dtype='float
-00025ab0: 3332 2729 0a20 2020 2020 2020 2065 7863  32').        exc
-00025ac0: 6570 743a 0a20 2020 2020 2020 2020 2020  ept:.           
-00025ad0: 2063 6f6e 7469 6e75 650a 2020 2020 2020   continue.      
-00025ae0: 2020 656d 6265 6464 696e 6773 5f69 6e64    embeddings_ind
-00025af0: 6578 5b77 6f72 645d 203d 2063 6f65 6673  ex[word] = coefs
-00025b00: 0a20 2020 2070 7269 6e74 2827 4c6f 6164  .    print('Load
-00025b10: 6564 207b 3a2c 647d 2047 6c6f 7665 2076  ed {:,d} Glove v
-00025b20: 6563 746f 7273 2e27 2e66 6f72 6d61 7428  ectors.'.format(
-00025b30: 6c65 6e28 656d 6265 6464 696e 6773 5f69  len(embeddings_i
-00025b40: 6e64 6578 2929 290a 2020 2020 2354 6865  ndex))).    #The
-00025b50: 7265 2061 7265 2061 726f 756e 6420 3334  re are around 34
-00025b60: 302c 3030 3020 776f 7264 2076 6563 746f  0,000 word vecto
-00025b70: 7273 2074 6861 7420 7765 2075 7365 2074  rs that we use t
-00025b80: 6f20 6372 6561 7465 2061 6e20 656d 6265  o create an embe
-00025b90: 6464 696e 6720 6d61 7472 6978 0a20 2020  dding matrix.   
-00025ba0: 2023 2074 6861 7420 6d61 7463 6865 7320   # that matches 
-00025bb0: 7468 6520 766f 6361 6275 6c61 7279 2073  the vocabulary s
-00025bc0: 6f20 7468 6174 2074 6865 2052 4e4e 206d  o that the RNN m
-00025bd0: 6f64 656c 2063 616e 2061 6363 6573 7320  odel can access 
-00025be0: 656d 6265 6464 696e 6773 2062 7920 7468  embeddings by th
-00025bf0: 6520 746f 6b65 6e20 696e 6465 780a 2020  e token index.  
-00025c00: 2020 2320 7072 6570 6172 6520 656d 6265    # prepare embe
-00025c10: 6464 696e 6720 6d61 7472 6978 0a20 2020  dding matrix.   
-00025c20: 2077 6f72 645f 696e 6465 7820 3d20 746f   word_index = to
-00025c30: 6b65 6e69 7a65 642e 776f 7264 5f69 6e64  kenized.word_ind
-00025c40: 6578 0a20 2020 2065 6d62 6564 6469 6e67  ex.    embedding
-00025c50: 5f6d 6174 7269 7820 3d20 6e70 2e7a 6572  _matrix = np.zer
-00025c60: 6f73 2828 766f 6361 625f 7369 7a65 2c20  os((vocab_size, 
-00025c70: 676c 6f76 655f 6469 6d65 6e73 696f 6e29  glove_dimension)
-00025c80: 290a 2020 2020 7072 696e 7428 2750 7265  ).    print('Pre
-00025c90: 7061 7269 6e67 2065 6d62 6564 6469 6e67  paring embedding
-00025ca0: 206d 6174 7269 782e 2729 0a20 2020 2066   matrix.').    f
-00025cb0: 6f72 2077 6f72 642c 2069 2069 6e20 776f  or word, i in wo
-00025cc0: 7264 5f69 6e64 6578 2e69 7465 6d73 2829  rd_index.items()
-00025cd0: 3a0a 2020 2020 2020 2020 6966 2069 203e  :.        if i >
-00025ce0: 3d20 4d41 585f 4e55 4d5f 574f 5244 533a  = MAX_NUM_WORDS:
-00025cf0: 0a20 2020 2020 2020 2020 2020 2063 6f6e  .            con
-00025d00: 7469 6e75 650a 2020 2020 2020 2020 656d  tinue.        em
-00025d10: 6265 6464 696e 675f 7665 6374 6f72 203d  bedding_vector =
-00025d20: 2065 6d62 6564 6469 6e67 735f 696e 6465   embeddings_inde
-00025d30: 782e 6765 7428 776f 7264 290a 2020 2020  x.get(word).    
-00025d40: 2020 2020 6966 2065 6d62 6564 6469 6e67      if embedding
-00025d50: 5f76 6563 746f 7220 6973 206e 6f74 204e  _vector is not N
-00025d60: 6f6e 653a 0a20 2020 2020 2020 2020 2020  one:.           
-00025d70: 2023 2077 6f72 6473 206e 6f74 2066 6f75   # words not fou
-00025d80: 6e64 2069 6e20 656d 6265 6464 696e 6720  nd in embedding 
-00025d90: 696e 6465 7820 7769 6c6c 2062 6520 616c  index will be al
-00025da0: 6c2d 7a65 726f 732e 0a20 2020 2020 2020  l-zeros..       
-00025db0: 2020 2020 2065 6d62 6564 6469 6e67 5f6d       embedding_m
-00025dc0: 6174 7269 785b 695d 203d 2065 6d62 6564  atrix[i] = embed
-00025dd0: 6469 6e67 5f76 6563 746f 720a 2020 2020  ding_vector.    
-00025de0: 7072 696e 7428 2720 2020 2043 6f6d 706c  print('    Compl
-00025df0: 6574 6564 2e27 290a 2020 2020 7265 7475  eted.').    retu
-00025e00: 726e 2065 6d62 6564 6469 6e67 5f6d 6174  rn embedding_mat
-00025e10: 7269 782c 2067 6c6f 7665 5f64 696d 656e  rix, glove_dimen
-00025e20: 7369 6f6e 0a23 2323 2323 2323 2323 2323  sion.###########
-00025e30: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00025e40: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001e910: 2323 2323 2323 2323 2323 0a66 726f 6d20  ##########.from 
+0001e920: 7363 6970 792e 7374 6174 7320 696d 706f  scipy.stats impo
+0001e930: 7274 2070 726f 6270 6c6f 742c 736b 6577  rt probplot,skew
+0001e940: 0a64 6566 2045 4441 5f66 696e 645f 736b  .def EDA_find_sk
+0001e950: 6577 6564 5f76 6172 6961 626c 6573 2864  ewed_variables(d
+0001e960: 6674 2c20 736b 6577 5f6c 696d 6974 3d31  ft, skew_limit=1
+0001e970: 2e31 293a 0a20 2020 2022 2222 0a20 2020  .1):.    """.   
+0001e980: 2045 4441 2073 7461 6e64 7320 666f 7220   EDA stands for 
+0001e990: 4578 706c 6f72 6174 6f72 7920 4461 7461  Exploratory Data
+0001e9a0: 2041 6e61 6c79 7369 7320 3a20 7468 6973   Analysis : this
+0001e9b0: 2066 756e 6374 696f 6e20 7065 7266 6f72   function perfor
+0001e9c0: 6d73 2045 4441 0a20 2020 2023 2323 2323  ms EDA.    #####
+0001e9d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001e9e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001e9f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001ea00: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001ea10: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001ea20: 230a 2020 2020 5468 6973 2066 756e 6374  #.    This funct
+0001ea30: 696f 6e20 6669 6e64 7320 616c 6c20 7468  ion finds all th
+0001ea40: 6520 6869 6768 6c79 2073 6b65 7765 6420  e highly skewed 
+0001ea50: 666c 6f61 7420 2863 6f6e 7469 6e75 6f75  float (continuou
+0001ea60: 7329 2076 6172 6961 626c 6573 2069 6e20  s) variables in 
+0001ea70: 796f 7572 2044 6174 6146 7261 6d65 0a20  your DataFrame. 
+0001ea80: 2020 2049 7420 7365 6c65 6374 7320 7468     It selects th
+0001ea90: 656d 2062 6173 6564 206f 6e20 7468 6520  em based on the 
+0001eaa0: 736b 6577 5f6c 696d 6974 2079 6f75 2073  skew_limit you s
+0001eab0: 6574 3a20 616e 7974 6869 6e67 206f 7665  et: anything ove
+0001eac0: 7220 736b 6577 2031 2e31 2069 7320 7468  r skew 1.1 is th
+0001ead0: 6520 6465 6661 756c 7420 7365 7474 696e  e default settin
+0001eae0: 672e 0a20 2020 2023 2323 2323 2323 2323  g..    #########
+0001eaf0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001eb00: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001eb10: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001eb20: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001eb30: 2323 2323 2323 2323 2323 2323 230a 2020  #############.  
+0001eb40: 2020 496e 7075 7473 3a0a 2020 2020 6466    Inputs:.    df
+0001eb50: 3a20 7061 6e64 6173 2044 6174 6146 7261  : pandas DataFra
+0001eb60: 6d65 0a20 2020 2073 6b65 775f 6c69 6d69  me.    skew_limi
+0001eb70: 743a 2064 6566 6175 6c74 2031 2e31 203d  t: default 1.1 =
+0001eb80: 2061 6e79 7468 696e 6720 6f76 6572 2074   anything over t
+0001eb90: 6869 7320 6c69 6d69 7420 616e 6420 6974  his limit and it
+0001eba0: 2064 6574 6563 7473 2069 7420 6173 2061   detects it as a
+0001ebb0: 2068 6967 686c 7920 736b 6577 6564 2076   highly skewed v
+0001ebc0: 6172 2e0a 0a20 2020 204f 7574 7075 7473  ar...    Outputs
+0001ebd0: 3a0a 2020 2020 6c69 7374 206f 6620 6120  :.    list of a 
+0001ebe0: 7661 7269 6162 6c65 7320 666f 756e 6420  variables found 
+0001ebf0: 7468 6174 2068 6176 6520 6869 6768 2073  that have high s
+0001ec00: 6b65 7720 696e 2064 6174 6120 7365 742e  kew in data set.
+0001ec10: 0a20 2020 2023 2323 2323 2323 2323 2323  .    ###########
+0001ec20: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001ec30: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001ec40: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001ec50: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001ec60: 2323 2323 2323 2323 2323 230a 2020 2020  ###########.    
+0001ec70: 596f 7520 6361 6e20 7573 6520 4645 5f63  You can use FE_c
+0001ec80: 6170 7069 6e67 5f6f 7574 6c69 6572 735f  apping_outliers_
+0001ec90: 6265 796f 6e64 5f49 5152 5f52 616e 6765  beyond_IQR_Range
+0001eca0: 2829 2066 756e 6374 696f 6e20 746f 2063  () function to c
+0001ecb0: 6170 206f 7574 6c69 6572 7320 696e 2074  ap outliers in t
+0001ecc0: 6865 7365 2076 6172 6961 626c 6573 2e0a  hese variables..
+0001ecd0: 2020 2020 2222 220a 2020 2020 736b 6577      """.    skew
+0001ece0: 6564 5f76 6172 7320 3d20 5b5d 0a20 2020  ed_vars = [].   
+0001ecf0: 2063 6f6e 7469 203d 2064 6674 2e73 656c   conti = dft.sel
+0001ed00: 6563 745f 6474 7970 6573 2869 6e63 6c75  ect_dtypes(inclu
+0001ed10: 6465 3d27 666c 6f61 7427 292e 636f 6c75  de='float').colu
+0001ed20: 6d6e 732e 746f 6c69 7374 2829 0a20 2020  mns.tolist().   
+0001ed30: 2066 6f72 2065 6163 685f 636f 6e74 6920   for each_conti 
+0001ed40: 696e 2063 6f6e 7469 3a0a 2020 2020 2020  in conti:.      
+0001ed50: 2020 736b 6577 5f76 616c 3d72 6f75 6e64    skew_val=round
+0001ed60: 2864 6674 5b65 6163 685f 636f 6e74 695d  (dft[each_conti]
+0001ed70: 2e73 6b65 7728 292c 2031 290a 2020 2020  .skew(), 1).    
+0001ed80: 2020 2020 6966 2073 6b65 775f 7661 6c20      if skew_val 
+0001ed90: 3e3d 2073 6b65 775f 6c69 6d69 743a 0a20  >= skew_limit:. 
+0001eda0: 2020 2020 2020 2020 2020 2073 6b65 7765             skewe
+0001edb0: 645f 7661 7273 2e61 7070 656e 6428 6561  d_vars.append(ea
+0001edc0: 6368 5f63 6f6e 7469 290a 2020 2020 7072  ch_conti).    pr
+0001edd0: 696e 7428 2746 6f75 6e64 2025 6420 736b  int('Found %d sk
+0001ede0: 6577 6564 2076 6172 6961 626c 6573 2069  ewed variables i
+0001edf0: 6e20 6461 7461 2062 6173 6564 206f 6e20  n data based on 
+0001ee00: 736b 6577 5f6c 696d 6974 203e 3d20 2573  skew_limit >= %s
+0001ee10: 2720 2528 6c65 6e28 736b 6577 6564 5f76  ' %(len(skewed_v
+0001ee20: 6172 7329 2c73 6b65 775f 6c69 6d69 7429  ars),skew_limit)
+0001ee30: 290a 2020 2020 7265 7475 726e 2073 6b65  ).    return ske
+0001ee40: 7765 645f 7661 7273 0a23 2323 2323 2323  wed_vars.#######
+0001ee50: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001ee60: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001ee70: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001ee80: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001ee90: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001eea0: 2323 2323 2323 0a64 6566 2069 735f 6f75  ######.def is_ou
+0001eeb0: 746c 6965 7228 6461 7461 6672 616d 652c  tlier(dataframe,
+0001eec0: 2074 6872 6573 683d 332e 3529 3a0a 2020   thresh=3.5):.  
+0001eed0: 2020 6966 206c 656e 2864 6174 6166 7261    if len(datafra
+0001eee0: 6d65 2e73 6861 7065 2920 3d3d 2031 3a0a  me.shape) == 1:.
+0001eef0: 2020 2020 2020 2020 6461 7461 6672 616d          datafram
+0001ef00: 6520 3d20 6461 7461 6672 616d 655b 3a2c  e = dataframe[:,
+0001ef10: 4e6f 6e65 5d0a 2020 2020 6d65 6469 616e  None].    median
+0001ef20: 203d 206e 702e 6d65 6469 616e 2864 6174   = np.median(dat
+0001ef30: 6166 7261 6d65 2c20 6178 6973 3d30 290a  aframe, axis=0).
+0001ef40: 2020 2020 6469 6666 203d 206e 702e 7375      diff = np.su
+0001ef50: 6d28 2864 6174 6166 7261 6d65 202d 206d  m((dataframe - m
+0001ef60: 6564 6961 6e29 2a2a 322c 2061 7869 733d  edian)**2, axis=
+0001ef70: 2d31 290a 2020 2020 6469 6666 203d 206e  -1).    diff = n
+0001ef80: 702e 7371 7274 2864 6966 6629 0a20 2020  p.sqrt(diff).   
+0001ef90: 206d 6564 5f61 6273 5f64 6576 6961 7469   med_abs_deviati
+0001efa0: 6f6e 203d 206e 702e 6d65 6469 616e 2864  on = np.median(d
+0001efb0: 6966 6629 0a0a 2020 2020 6d6f 6469 6669  iff)..    modifi
+0001efc0: 6564 5f7a 5f73 636f 7265 203d 2030 2e36  ed_z_score = 0.6
+0001efd0: 3734 3520 2a20 6469 6666 202f 206d 6564  745 * diff / med
+0001efe0: 5f61 6273 5f64 6576 6961 7469 6f6e 0a20  _abs_deviation. 
+0001eff0: 2020 2072 6574 7572 6e20 6d6f 6469 6669     return modifi
+0001f000: 6564 5f7a 5f73 636f 7265 203e 2074 6872  ed_z_score > thr
+0001f010: 6573 680a 0a64 6566 2045 4441 5f66 696e  esh..def EDA_fin
+0001f020: 645f 6f75 746c 6965 7273 2864 662c 2063  d_outliers(df, c
+0001f030: 6f6c 2c20 7468 7265 7368 3d35 293a 0a20  ol, thresh=5):. 
+0001f040: 2020 2022 2222 0a20 2020 2022 2222 0a20     """.    """. 
+0001f050: 2020 2023 2323 2323 2323 2046 696e 6473     ####### Finds
+0001f060: 204f 7574 6c69 6572 7320 616e 6420 6d61   Outliers and ma
+0001f070: 726b 7320 7468 656d 2061 7320 2754 7275  rks them as 'Tru
+0001f080: 6527 2069 6620 7468 6579 2061 7265 206f  e' if they are o
+0001f090: 7574 6c69 6572 730a 2020 2020 2323 2323  utliers.    ####
+0001f0a0: 2323 2320 4461 7461 6672 616d 6520 7265  ### Dataframe re
+0001f0b0: 6665 7273 2074 6f20 7468 6520 696e 7075  fers to the inpu
+0001f0c0: 7420 6461 7461 6672 616d 6520 616e 6420  t dataframe and 
+0001f0d0: 7468 7265 7368 6f6c 6420 7265 6665 7273  threshold refers
+0001f0e0: 2074 6f20 686f 7720 6661 7220 6672 6f6d   to how far from
+0001f0f0: 2074 6865 206d 6564 6961 6e20 6120 7661   the median a va
+0001f100: 6c75 6520 6973 0a20 2020 2023 2323 2323  lue is.    #####
+0001f110: 2323 2049 2061 6d20 7573 696e 6720 7468  ## I am using th
+0001f120: 6520 4d65 6469 616e 2041 6273 6f6c 7574  e Median Absolut
+0001f130: 6520 4465 7669 6174 696f 6e20 4d65 7468  e Deviation Meth
+0001f140: 6f64 2028 4d41 4444 2920 746f 2066 696e  od (MADD) to fin
+0001f150: 6420 4f75 746c 6965 7273 2068 6572 650a  d Outliers here.
+0001f160: 2020 2020 6d61 736b 5f6f 7574 6c69 6572      mask_outlier
+0001f170: 7320 3d20 6973 5f6f 7574 6c69 6572 2864  s = is_outlier(d
+0001f180: 665b 636f 6c5d 2c74 6872 6573 683d 7468  f[col],thresh=th
+0001f190: 7265 7368 292e 6173 7479 7065 2869 6e74  resh).astype(int
+0001f1a0: 290a 2020 2020 7265 7475 726e 2064 662e  ).    return df.
+0001f1b0: 696c 6f63 5b6e 702e 7768 6572 6528 6d61  iloc[np.where(ma
+0001f1c0: 736b 5f6f 7574 6c69 6572 733e 3029 5d0a  sk_outliers>0)].
+0001f1d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001f1e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001f1f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001f200: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001f210: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001f220: 2323 230a 6465 6620 6f75 746c 6965 725f  ###.def outlier_
+0001f230: 6465 7465 726d 696e 655f 7468 7265 7368  determine_thresh
+0001f240: 6f6c 6428 6466 2c20 636f 6c29 3a0a 2020  old(df, col):.  
+0001f250: 2020 2222 220a 2020 2020 5468 6973 2066    """.    This f
+0001f260: 756e 6374 696f 6e20 6175 746f 6d61 7469  unction automati
+0001f270: 6361 6c6c 7920 6465 7465 726d 696e 6573  cally determines
+0001f280: 2074 6865 2072 6967 6874 2074 6872 6573   the right thres
+0001f290: 686f 6c64 2066 6f72 2074 6865 2064 6174  hold for the dat
+0001f2a0: 6166 7261 6d65 2061 6e64 2063 6f6c 756d  aframe and colum
+0001f2b0: 6e2e 0a20 2020 2054 6872 6573 686f 6c64  n..    Threshold
+0001f2c0: 2069 7320 7573 6564 2074 6f20 6465 7465   is used to dete
+0001f2d0: 726d 696e 6520 686f 7720 6d61 6e79 206f  rmine how many o
+0001f2e0: 7574 6c69 6572 7320 7765 2073 686f 756c  utliers we shoul
+0001f2f0: 6420 6465 7465 6374 2069 6e20 7468 6520  d detect in the 
+0001f300: 7365 7269 6573 2e0a 2020 2020 4120 6c6f  series..    A lo
+0001f310: 7720 7468 7265 7368 6f6c 6420 7769 6c6c  w threshold will
+0001f320: 2072 6573 756c 7420 696e 2074 6f6f 206d   result in too m
+0001f330: 616e 7920 6f75 746c 6965 7273 2061 6e64  any outliers and
+0001f340: 2061 2076 6572 7920 6869 6768 2074 6872   a very high thr
+0001f350: 6573 686f 6c64 2077 696c 6c20 6e6f 7420  eshold will not 
+0001f360: 6669 6e64 2061 6e79 2e0a 2020 2020 5468  find any..    Th
+0001f370: 6973 206c 6f6f 7073 2075 6e74 696c 2069  is loops until i
+0001f380: 7420 6669 6e64 7320 6c65 7373 2074 6861  t finds less tha
+0001f390: 6e20 3130 2074 696d 6573 206f 7220 6d61  n 10 times or ma
+0001f3a0: 7869 6d75 6d20 3125 206f 6620 6461 7461  ximum 1% of data
+0001f3b0: 2062 6569 6e67 206f 7574 6c69 6572 732e   being outliers.
+0001f3c0: 0a20 2020 2022 2222 0a20 2020 2064 6620  .    """.    df 
+0001f3d0: 3d20 6466 2e63 6f70 7928 6465 6570 3d54  = df.copy(deep=T
+0001f3e0: 7275 6529 0a20 2020 206b 6565 705f 6c6f  rue).    keep_lo
+0001f3f0: 6f70 696e 6720 3d20 5472 7565 0a20 2020  oping = True.   
+0001f400: 206e 756d 6265 725f 6f66 5f6c 6f6f 7073   number_of_loops
+0001f410: 203d 2031 0a20 2020 2074 6872 6573 6820   = 1.    thresh 
+0001f420: 3d20 350a 2020 2020 7768 696c 6520 6b65  = 5.    while ke
+0001f430: 6570 5f6c 6f6f 7069 6e67 3a0a 2020 2020  ep_looping:.    
+0001f440: 2020 2020 6966 206e 756d 6265 725f 6f66      if number_of
+0001f450: 5f6c 6f6f 7073 203e 3d20 3130 3a0a 2020  _loops >= 10:.  
+0001f460: 2020 2020 2020 2020 2020 6272 6561 6b0a            break.
+0001f470: 2020 2020 2020 2020 6d61 736b 5f6f 7574          mask_out
+0001f480: 6c69 6572 7320 3d20 6973 5f6f 7574 6c69  liers = is_outli
+0001f490: 6572 2864 665b 636f 6c5d 2c20 7468 7265  er(df[col], thre
+0001f4a0: 7368 3d74 6872 6573 6829 2e61 7374 7970  sh=thresh).astyp
+0001f4b0: 6528 696e 7429 0a20 2020 2020 2020 2064  e(int).        d
+0001f4c0: 666f 7574 5f69 6e64 6578 203d 2064 662e  fout_index = df.
+0001f4d0: 696c 6f63 5b6e 702e 7768 6572 6528 6d61  iloc[np.where(ma
+0001f4e0: 736b 5f6f 7574 6c69 6572 733e 3029 5d2e  sk_outliers>0)].
+0001f4f0: 696e 6465 780a 2020 2020 2020 2020 7063  index.        pc
+0001f500: 745f 6f75 746c 6965 7273 203d 206c 656e  t_outliers = len
+0001f510: 2864 666f 7574 5f69 6e64 6578 292f 6c65  (dfout_index)/le
+0001f520: 6e28 6466 290a 2020 2020 2020 2020 6966  n(df).        if
+0001f530: 2070 6374 5f6f 7574 6c69 6572 7320 3d3d   pct_outliers ==
+0001f540: 2030 3a0a 2020 2020 2020 2020 2020 2020   0:.            
+0001f550: 6966 2074 6872 6573 6820 3e20 353a 0a20  if thresh > 5:. 
+0001f560: 2020 2020 2020 2020 2020 2020 2020 2074                 t
+0001f570: 6872 6573 6820 3d20 7468 7265 7368 202d  hresh = thresh -
+0001f580: 2035 0a20 2020 2020 2020 2020 2020 2065   5.            e
+0001f590: 6c69 6620 7468 7265 7368 203d 3d20 353a  lif thresh == 5:
+0001f5a0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001f5b0: 2072 6574 7572 6e20 7468 7265 7368 0a20   return thresh. 
+0001f5c0: 2020 2020 2020 2020 2020 2065 6c73 653a             else:
+0001f5d0: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+0001f5e0: 2074 6872 6573 6820 3d20 7468 7265 7368   thresh = thresh
+0001f5f0: 202d 2031 0a20 2020 2020 2020 2065 6c69   - 1.        eli
+0001f600: 6620 2070 6374 5f6f 7574 6c69 6572 7320  f  pct_outliers 
+0001f610: 3c3d 2030 2e30 313a 0a20 2020 2020 2020  <= 0.01:.       
+0001f620: 2020 2020 206b 6565 705f 6c6f 6f70 696e       keep_loopin
+0001f630: 6720 3d20 4661 6c73 650a 2020 2020 2020  g = False.      
+0001f640: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+0001f650: 2020 2020 7468 7265 7368 5f6d 756c 7469      thresh_multi
+0001f660: 706c 6965 7220 3d20 696e 7428 2870 6374  plier = int((pct
+0001f670: 5f6f 7574 6c69 6572 732f 302e 3031 292a  _outliers/0.01)*
+0001f680: 302e 3529 0a20 2020 2020 2020 2020 2020  0.5).           
+0001f690: 2074 6872 6573 6820 3d20 7468 7265 7368   thresh = thresh
+0001f6a0: 2a74 6872 6573 685f 6d75 6c74 6970 6c69  *thresh_multipli
+0001f6b0: 6572 0a20 2020 2020 2020 206e 756d 6265  er.        numbe
+0001f6c0: 725f 6f66 5f6c 6f6f 7073 202b 3d20 310a  r_of_loops += 1.
+0001f6d0: 2020 2020 7072 696e 7428 2720 2020 2025      print('    %
+0001f6e0: 7320 4f75 746c 6965 7220 7468 7265 7368  s Outlier thresh
+0001f6f0: 6f6c 6420 3d20 2564 2720 2528 636f 6c2c  old = %d' %(col,
+0001f700: 2074 6872 6573 6829 290a 2020 2020 7265   thresh)).    re
+0001f710: 7475 726e 2074 6872 6573 680a 0a66 726f  turn thresh..fro
+0001f720: 6d20 636f 6c6c 6563 7469 6f6e 7320 696d  m collections im
+0001f730: 706f 7274 2043 6f75 6e74 6572 0a64 6566  port Counter.def
+0001f740: 2046 455f 6669 6e64 5f61 6e64 5f63 6170   FE_find_and_cap
+0001f750: 5f6f 7574 6c69 6572 7328 6466 2c20 6665  _outliers(df, fe
+0001f760: 6174 7572 6573 2c20 6472 6f70 3d46 616c  atures, drop=Fal
+0001f770: 7365 2c20 7665 7262 6f73 653d 4661 6c73  se, verbose=Fals
+0001f780: 6529 3a0a 2020 2020 2222 220a 2020 2020  e):.    """.    
+0001f790: 4645 2061 7420 7468 6520 6265 6769 6e6e  FE at the beginn
+0001f7a0: 696e 6720 6f66 2066 756e 6374 696f 6e20  ing of function 
+0001f7b0: 6e61 6d65 2073 7461 6e64 7320 666f 7220  name stands for 
+0001f7c0: 4665 6174 7572 6520 456e 6769 6e65 6572  Feature Engineer
+0001f7d0: 696e 672e 2046 4520 6675 6e63 7469 6f6e  ing. FE function
+0001f7e0: 7320 6164 6420 6f72 2064 726f 7020 6665  s add or drop fe
+0001f7f0: 6174 7572 6573 2e0a 2020 2020 2323 2323  atures..    ####
+0001f800: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001f810: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001f820: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001f830: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001f840: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001f850: 2323 2323 230a 2020 2020 5479 7069 6361  #####.    Typica
+0001f860: 6c6c 7920 7765 2074 6869 6e6b 206f 6620  lly we think of 
+0001f870: 6f75 746c 6965 7273 2061 7320 6265 696e  outliers as bein
+0001f880: 6720 6f62 7365 7276 6174 696f 6e73 2062  g observations b
+0001f890: 6579 6f6e 6420 7468 6520 312e 3520 496e  eyond the 1.5 In
+0001f8a0: 7465 7220 5175 6172 7469 6c65 2052 616e  ter Quartile Ran
+0001f8b0: 6765 2028 4951 5229 0a20 2020 2042 7574  ge (IQR).    But
+0001f8c0: 2074 6869 7320 6675 6e63 7469 6f6e 2077   this function w
+0001f8d0: 696c 6c20 616c 6c6f 7720 796f 7520 746f  ill allow you to
+0001f8e0: 2063 6170 2061 6e79 206f 6273 6572 7661   cap any observa
+0001f8f0: 7469 6f6e 2075 7369 6e67 204d 4144 4420  tion using MADD 
+0001f900: 6d65 7468 6f64 3a0a 2020 2020 2020 2020  method:.        
+0001f910: 4d41 4444 3a20 4d65 6469 616e 2041 6273  MADD: Median Abs
+0001f920: 6f6c 7574 6520 4465 7669 6174 696f 6e20  olute Deviation 
+0001f930: 4d65 7468 6f64 202d 2069 7427 7320 6120  Method - it's a 
+0001f940: 6661 7374 2061 6e64 2065 6173 7920 6d65  fast and easy me
+0001f950: 7468 6f64 2074 6f20 6669 6e64 206f 7574  thod to find out
+0001f960: 6c69 6572 732e 0a20 2020 2049 6e20 6164  liers..    In ad
+0001f970: 6469 7469 6f6e 2c20 7468 6973 2075 7469  dition, this uti
+0001f980: 6c69 7479 2061 7574 6f6d 6174 6963 616c  lity automatical
+0001f990: 6c79 2073 656c 6563 7473 2074 6865 2076  ly selects the v
+0001f9a0: 616c 7565 2074 6f20 6361 7020 6974 2061  alue to cap it a
+0001f9b0: 742e 0a20 2020 2020 2020 2020 2d2d 2054  t..         -- T
+0001f9c0: 6865 2076 616c 7565 2074 6f20 6265 2063  he value to be c
+0001f9d0: 6170 7065 6420 6973 2062 6173 6564 206f  apped is based o
+0001f9e0: 6e20 6d61 7869 6d75 6d20 3125 206f 6620  n maximum 1% of 
+0001f9f0: 6461 7461 2062 6569 6e67 206f 7574 6c69  data being outli
+0001fa00: 6572 732e 0a20 2020 2049 7420 6175 746f  ers..    It auto
+0001fa10: 6d61 7469 6361 6c6c 7920 6465 7465 726d  matically determ
+0001fa20: 696e 6573 2068 6f77 2066 6172 2061 7761  ines how far awa
+0001fa30: 7920 6672 6f6d 206d 6564 6961 6e20 7468  y from median th
+0001fa40: 6520 6461 7461 2070 6f69 6e74 206e 6565  e data point nee
+0001fa50: 6473 2074 6f20 6265 2066 6f72 2069 7420  ds to be for it 
+0001fa60: 746f 2063 616c 6c65 6420 616e 206f 7574  to called an out
+0001fa70: 6c69 6572 2e0a 2020 2020 2020 2020 202d  lier..         -
+0001fa80: 2d20 6974 2075 7365 7320 6120 7468 7265  - it uses a thre
+0001fa90: 7368 206e 756d 6265 723a 2074 6865 206c  sh number: the l
+0001faa0: 6f77 6572 2069 7420 6973 2c20 6d6f 7265  ower it is, more
+0001fab0: 206f 7574 6c69 6572 732e 2049 7420 7374   outliers. It st
+0001fac0: 6172 7473 2061 7420 3520 6f72 2068 6967  arts at 5 or hig
+0001fad0: 6865 7220 6173 2074 6872 6573 686f 6c64  her as threshold
+0001fae0: 2076 616c 7565 2e0a 2020 2020 4e6f 7469   value..    Noti
+0001faf0: 6365 2074 6861 7420 6974 2064 6f65 7320  ce that it does 
+0001fb00: 6e6f 7420 7573 6520 6120 6c6f 7765 7220  not use a lower 
+0001fb10: 626f 756e 6420 746f 2066 696e 6420 746f  bound to find to
+0001fb20: 6f20 6c6f 7720 6f75 746c 6965 7273 2e20  o low outliers. 
+0001fb30: 5468 6174 2079 6f75 2068 6176 6520 746f  That you have to
+0001fb40: 2064 6f20 7468 6174 2079 6f75 7273 656c   do that yoursel
+0001fb50: 662e 0a20 2020 2023 2323 2323 2323 2323  f..    #########
+0001fb60: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001fb70: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001fb80: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001fb90: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001fba0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001fbb0: 0a20 2020 2049 6e70 7574 733a 0a20 2020  .    Inputs:.   
+0001fbc0: 2064 6620 3a20 7061 6e64 6173 2044 6174   df : pandas Dat
+0001fbd0: 6146 7261 6d65 0a20 2020 2066 6561 7475  aFrame.    featu
+0001fbe0: 7265 733a 2061 2073 696e 676c 6520 636f  res: a single co
+0001fbf0: 6c75 6d6e 206f 7220 6120 6c69 7374 206f  lumn or a list o
+0001fc00: 6620 636f 6c75 6d6e 7320 696e 2079 6f75  f columns in you
+0001fc10: 7220 4461 7461 4672 616d 650a 2020 2020  r DataFrame.    
+0001fc20: 6361 705f 6174 5f6e 7468 5f6c 6172 6765  cap_at_nth_large
+0001fc30: 7374 3a20 6465 6661 756c 7420 6973 2035  st: default is 5
+0001fc40: 203d 2079 6f75 2063 616e 2073 6574 2069   = you can set i
+0001fc50: 7420 746f 2061 6e79 2069 6e74 6567 6572  t to any integer
+0001fc60: 2073 7563 6820 6173 2031 2c20 322c 2033   such as 1, 2, 3
+0001fc70: 2c20 342c 2035 2c20 6574 632e 0a0a 2020  , 4, 5, etc...  
+0001fc80: 2020 4f75 7470 7574 733a 0a20 2020 2064    Outputs:.    d
+0001fc90: 663a 2070 616e 6461 7320 4461 7461 4672  f: pandas DataFr
+0001fca0: 616d 650a 2020 2020 4974 2072 6574 7572  ame.    It retur
+0001fcb0: 6e73 2074 6865 2073 616d 6520 6461 7461  ns the same data
+0001fcc0: 6672 616d 6520 6173 2079 6f75 2069 6e70  frame as you inp
+0001fcd0: 7574 2075 6e6c 6573 7320 796f 7520 6368  ut unless you ch
+0001fce0: 616e 6765 2064 726f 7020 746f 2054 7275  ange drop to Tru
+0001fcf0: 6520 696e 2074 6865 2069 6e70 7574 2061  e in the input a
+0001fd00: 7267 756d 656e 742e 0a0a 2020 2020 4f70  rgument...    Op
+0001fd10: 7469 6f6e 616c 6c79 2c20 6974 2063 616e  tionally, it can
+0001fd20: 2064 726f 7020 6365 7274 6169 6e20 726f   drop certain ro
+0001fd30: 7773 2074 6861 7420 6861 7665 2074 6f6f  ws that have too
+0001fd40: 206d 616e 7920 6f75 746c 6965 7273 2069   many outliers i
+0001fd50: 6e20 6174 206c 6561 7374 2033 2063 6f6c  n at least 3 col
+0001fd60: 756d 6e73 2073 696d 756c 7461 6e65 6f75  umns simultaneou
+0001fd70: 736c 792e 0a20 2020 2049 6620 6472 6f70  sly..    If drop
+0001fd80: 3d54 7275 652c 2069 7420 7769 6c6c 2072  =True, it will r
+0001fd90: 6574 7572 6e20 6120 736d 616c 6c65 7220  eturn a smaller 
+0001fda0: 6e75 6d62 6572 206f 6620 726f 7773 2069  number of rows i
+0001fdb0: 6e20 796f 7572 2064 6174 6166 7261 6d65  n your dataframe
+0001fdc0: 2074 6861 6e20 7768 6174 2079 6f75 2073   than what you s
+0001fdd0: 656e 7420 696e 2e20 4265 2063 6172 6566  ent in. Be caref
+0001fde0: 756c 210a 2020 2020 2323 2323 2323 2323  ul!.    ########
+0001fdf0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001fe00: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001fe10: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001fe20: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001fe30: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+0001fe40: 230a 2020 2020 2222 220a 2020 2020 6466  #.    """.    df
+0001fe50: 203d 2064 662e 636f 7079 2864 6565 703d   = df.copy(deep=
+0001fe60: 5472 7565 290a 2020 2020 6f75 746c 6965  True).    outlie
+0001fe70: 725f 696e 6469 6365 7320 3d20 5b5d 0a20  r_indices = []. 
+0001fe80: 2020 2069 6463 6f6c 203d 2027 6964 636f     idcol = 'idco
+0001fe90: 6c27 0a20 2020 2064 665b 6964 636f 6c5d  l'.    df[idcol]
+0001fea0: 203d 2072 616e 6765 286c 656e 2864 6629   = range(len(df)
+0001feb0: 290a 2020 2020 6966 2069 7369 6e73 7461  ).    if isinsta
+0001fec0: 6e63 6528 6665 6174 7572 6573 2c20 7374  nce(features, st
+0001fed0: 7229 3a0a 2020 2020 2020 2020 6665 6174  r):.        feat
+0001fee0: 7572 6573 203d 205b 6665 6174 7572 6573  ures = [features
+0001fef0: 5d0a 2020 2020 2320 6974 6572 6174 6520  ].    # iterate 
+0001ff00: 6f76 6572 2066 6561 7475 7265 7328 636f  over features(co
+0001ff10: 6c75 6d6e 7329 0a20 2020 2066 6f72 2063  lumns).    for c
+0001ff20: 6f6c 2069 6e20 6665 6174 7572 6573 3a0a  ol in features:.
+0001ff30: 2020 2020 2020 2020 2320 4465 7465 726d          # Determ
+0001ff40: 696e 6520 6120 6c69 7374 206f 6620 696e  ine a list of in
+0001ff50: 6469 6365 7320 6f66 206f 7574 6c69 6572  dices of outlier
+0001ff60: 7320 666f 7220 6665 6174 7572 6520 636f  s for feature co
+0001ff70: 6c0a 2020 2020 2020 2020 7468 7265 7368  l.        thresh
+0001ff80: 203d 206f 7574 6c69 6572 5f64 6574 6572   = outlier_deter
+0001ff90: 6d69 6e65 5f74 6872 6573 686f 6c64 2864  mine_threshold(d
+0001ffa0: 662c 2063 6f6c 290a 2020 2020 2020 2020  f, col).        
+0001ffb0: 6d61 736b 5f6f 7574 6c69 6572 7320 3d20  mask_outliers = 
+0001ffc0: 6973 5f6f 7574 6c69 6572 2864 665b 636f  is_outlier(df[co
+0001ffd0: 6c5d 2c20 7468 7265 7368 3d74 6872 6573  l], thresh=thres
+0001ffe0: 6829 2e61 7374 7970 6528 696e 7429 0a20  h).astype(int). 
+0001fff0: 2020 2020 2020 2064 666f 7574 5f69 6e64         dfout_ind
+00020000: 6578 203d 2064 662e 696c 6f63 5b6e 702e  ex = df.iloc[np.
+00020010: 7768 6572 6528 6d61 736b 5f6f 7574 6c69  where(mask_outli
+00020020: 6572 733e 3029 5d2e 696e 6465 780a 0a20  ers>0)].index.. 
+00020030: 2020 2020 2020 2064 665b 2761 6e6f 6d61         df['anoma
+00020040: 6c79 3127 5d20 3d20 300a 2020 2020 2020  ly1'] = 0.      
+00020050: 2020 6466 2e6c 6f63 5b64 666f 7574 5f69    df.loc[dfout_i
+00020060: 6e64 6578 202c 2761 6e6f 6d61 6c79 3127  ndex ,'anomaly1'
+00020070: 5d20 3d20 310a 0a20 2020 2020 2020 2023  ] = 1..        #
+00020080: 2323 2074 6869 7320 6973 2068 6f77 2074  ## this is how t
+00020090: 6865 2063 6f6c 756d 6e20 6c6f 6f6b 7320  he column looks 
+000200a0: 6e6f 7720 6265 666f 7265 2063 6170 7069  now before cappi
+000200b0: 6e67 206f 7574 6c69 6572 730a 2020 2020  ng outliers.    
+000200c0: 2020 2020 6966 2076 6572 626f 7365 3a0a      if verbose:.
+000200d0: 2020 2020 2020 2020 2020 2020 6669 672c              fig,
+000200e0: 2028 6178 312c 6178 3229 203d 2070 6c74   (ax1,ax2) = plt
+000200f0: 2e73 7562 706c 6f74 7328 312c 322c 6669  .subplots(1,2,fi
+00020100: 6773 697a 653d 2831 322c 3529 290a 2020  gsize=(12,5)).  
+00020110: 2020 2020 2020 2020 2020 636f 6c6f 7273            colors
+00020120: 203d 207b 303a 2762 6c75 6527 2c20 313a   = {0:'blue', 1:
+00020130: 2772 6564 277d 0a20 2020 2020 2020 2020  'red'}.         
+00020140: 2020 2061 7831 2e73 6361 7474 6572 2864     ax1.scatter(d
+00020150: 665b 6964 636f 6c5d 2c20 6466 5b63 6f6c  f[idcol], df[col
+00020160: 5d2c 2063 3d64 665b 2261 6e6f 6d61 6c79  ], c=df["anomaly
+00020170: 3122 5d2e 6170 706c 7928 6c61 6d62 6461  1"].apply(lambda
+00020180: 2078 3a20 636f 6c6f 7273 5b78 5d29 290a   x: colors[x])).
+00020190: 2020 2020 2020 2020 2020 2020 6178 312e              ax1.
+000201a0: 7365 745f 786c 6162 656c 2827 526f 7720  set_xlabel('Row 
+000201b0: 4944 2729 0a20 2020 2020 2020 2020 2020  ID').           
+000201c0: 2061 7831 2e73 6574 5f79 6c61 6265 6c28   ax1.set_ylabel(
+000201d0: 2754 6172 6765 7420 7661 6c75 6573 2729  'Target values')
+000201e0: 0a20 2020 2020 2020 2020 2020 2061 7831  .            ax1
+000201f0: 2e73 6574 5f74 6974 6c65 2827 2573 2062  .set_title('%s b
+00020200: 6566 6f72 6520 6361 7070 696e 6720 6f75  efore capping ou
+00020210: 746c 6965 7273 2720 2563 6f6c 290a 0a20  tliers' %col).. 
+00020220: 2020 2020 2020 2063 6170 7065 645f 7661         capped_va
+00020230: 6c75 6520 3d20 6466 2e6c 6f63 5b64 666f  lue = df.loc[dfo
+00020240: 7574 5f69 6e64 6578 2c20 636f 6c5d 2e6d  ut_index, col].m
+00020250: 696e 2829 2023 2320 7468 6973 2069 7320  in() ## this is 
+00020260: 7468 6520 7661 6c75 6520 7765 2063 6170  the value we cap
+00020270: 2069 7420 6167 6169 6e73 740a 2020 2020   it against.    
+00020280: 2020 2020 6466 2e6c 6f63 5b64 666f 7574      df.loc[dfout
+00020290: 5f69 6e64 6578 2c20 636f 6c5d 203d 2020  _index, col] =  
+000202a0: 6361 7070 6564 5f76 616c 7565 2023 2320  capped_value ## 
+000202b0: 6d61 7869 6d75 6d20 7661 6c75 6573 2061  maximum values a
+000202c0: 7265 206e 6f77 2063 6170 7065 640a 2020  re now capped.  
+000202d0: 2020 2020 2020 2323 2320 796f 7520 6172        ### you ar
+000202e0: 6520 6e6f 7720 676f 6f64 2074 6f20 676f  e now good to go
+000202f0: 202d 2079 6f75 2063 616e 2073 686f 7720   - you can show 
+00020300: 686f 7720 7468 6579 2061 7265 2063 6170  how they are cap
+00020310: 7065 6420 7573 696e 6720 6265 666f 7265  ped using before
+00020320: 2061 6e64 2061 6674 6572 2070 6963 730a   and after pics.
+00020330: 2020 2020 2020 2020 6966 2076 6572 626f          if verbo
+00020340: 7365 3a0a 2020 2020 2020 2020 2020 2020  se:.            
+00020350: 636f 6c6f 7273 203d 207b 303a 2762 6c75  colors = {0:'blu
+00020360: 6527 2c20 313a 2772 6564 277d 0a20 2020  e', 1:'red'}.   
+00020370: 2020 2020 2020 2020 2061 7832 2e73 6361           ax2.sca
+00020380: 7474 6572 2864 665b 6964 636f 6c5d 2c20  tter(df[idcol], 
+00020390: 6466 5b63 6f6c 5d2c 2063 3d64 665b 2261  df[col], c=df["a
+000203a0: 6e6f 6d61 6c79 3122 5d2e 6170 706c 7928  nomaly1"].apply(
+000203b0: 6c61 6d62 6461 2078 3a20 636f 6c6f 7273  lambda x: colors
+000203c0: 5b78 5d29 290a 2020 2020 2020 2020 2020  [x])).          
+000203d0: 2020 6178 322e 7365 745f 786c 6162 656c    ax2.set_xlabel
+000203e0: 2827 526f 7720 4944 2729 0a20 2020 2020  ('Row ID').     
+000203f0: 2020 2020 2020 2061 7832 2e73 6574 5f79         ax2.set_y
+00020400: 6c61 6265 6c28 2754 6172 6765 7420 7661  label('Target va
+00020410: 6c75 6573 2729 0a20 2020 2020 2020 2020  lues').         
+00020420: 2020 2061 7832 2e73 6574 5f74 6974 6c65     ax2.set_title
+00020430: 2827 2573 2061 6674 6572 2063 6170 7069  ('%s after cappi
+00020440: 6e67 206f 7574 6c69 6572 7327 2025 636f  ng outliers' %co
+00020450: 6c29 0a0a 2020 2020 2020 2020 2320 4c65  l)..        # Le
+00020460: 7427 7320 7361 7665 2074 6865 206c 6973  t's save the lis
+00020470: 7420 6f66 206f 7574 6c69 6572 7320 616e  t of outliers an
+00020480: 6420 7365 6520 6966 2074 6865 7265 2061  d see if there a
+00020490: 7265 2073 6f6d 6520 7769 7468 206f 7574  re some with out
+000204a0: 6c69 6572 7320 696e 206d 756c 7469 706c  liers in multipl
+000204b0: 6520 636f 6c75 6d6e 730a 2020 2020 2020  e columns.      
+000204c0: 2020 6f75 746c 6965 725f 696e 6469 6365    outlier_indice
+000204d0: 732e 6578 7465 6e64 2864 666f 7574 5f69  s.extend(dfout_i
+000204e0: 6e64 6578 290a 0a20 2020 2023 2073 656c  ndex)..    # sel
+000204f0: 6563 7420 6365 7274 6169 6e20 6f62 7365  ect certain obse
+00020500: 7276 6174 696f 6e73 2063 6f6e 7461 696e  rvations contain
+00020510: 696e 6720 6d6f 7265 2074 6861 6e20 6f6e  ing more than on
+00020520: 6520 6f75 746c 6965 7220 696e 2032 2063  e outlier in 2 c
+00020530: 6f6c 756d 6e73 206f 7220 6d6f 7265 2e20  olumns or more. 
+00020540: 5765 2063 616e 2064 726f 7020 7468 656d  We can drop them
+00020550: 210a 2020 2020 6f75 746c 6965 725f 696e  !.    outlier_in
+00020560: 6469 6365 7320 3d20 436f 756e 7465 7228  dices = Counter(
+00020570: 6f75 746c 6965 725f 696e 6469 6365 7329  outlier_indices)
+00020580: 0a20 2020 206d 756c 7469 706c 655f 6f75  .    multiple_ou
+00020590: 746c 6965 7273 203d 206c 6973 7428 206b  tliers = list( k
+000205a0: 2066 6f72 206b 2c20 7620 696e 206f 7574   for k, v in out
+000205b0: 6c69 6572 5f69 6e64 6963 6573 2e69 7465  lier_indices.ite
+000205c0: 6d73 2829 2069 6620 7620 3e20 3320 290a  ms() if v > 3 ).
+000205d0: 2020 2020 2323 2320 6e6f 7720 6472 6f70      ### now drop
+000205e0: 2074 6865 7365 2072 6f77 7320 616c 746f   these rows alto
+000205f0: 6765 7468 6572 2023 2323 230a 2020 2020  gether ####.    
+00020600: 6466 203d 2064 662e 6472 6f70 285b 6964  df = df.drop([id
+00020610: 636f 6c2c 2761 6e6f 6d61 6c79 3127 5d2c  col,'anomaly1'],
+00020620: 2061 7869 733d 3129 0a20 2020 2069 6620   axis=1).    if 
+00020630: 6472 6f70 3a0a 2020 2020 2020 2020 7072  drop:.        pr
+00020640: 696e 7428 2753 6861 7065 206f 6620 6461  int('Shape of da
+00020650: 7461 6672 616d 6520 6265 666f 7265 206f  taframe before o
+00020660: 7574 6c69 6572 7320 6265 696e 6720 6472  utliers being dr
+00020670: 6f70 7065 643a 2025 7327 2025 2864 662e  opped: %s' %(df.
+00020680: 7368 6170 652c 2929 0a20 2020 2020 2020  shape,)).       
+00020690: 206e 756d 6265 725f 6f66 5f72 6f77 7320   number_of_rows 
+000206a0: 3d20 6466 2e73 6861 7065 5b30 5d0a 2020  = df.shape[0].  
+000206b0: 2020 2020 2020 6466 203d 2064 662e 6472        df = df.dr
+000206c0: 6f70 286d 756c 7469 706c 655f 6f75 746c  op(multiple_outl
+000206d0: 6965 7273 2c20 6178 6973 3d30 290a 2020  iers, axis=0).  
+000206e0: 2020 2020 2020 7072 696e 7428 2753 6861        print('Sha
+000206f0: 7065 206f 6620 6461 7461 6672 616d 6520  pe of dataframe 
+00020700: 6166 7465 7220 6f75 746c 6965 7273 2062  after outliers b
+00020710: 6569 6e67 2064 726f 7070 6564 3a20 2573  eing dropped: %s
+00020720: 2720 2528 6466 2e73 6861 7065 2c29 290a  ' %(df.shape,)).
+00020730: 2020 2020 2020 2020 7072 696e 7428 275c          print('\
+00020740: 6e4e 756d 6265 725f 6f66 5f72 6f77 7320  nNumber_of_rows 
+00020750: 7769 7468 206d 756c 7469 706c 6520 6f75  with multiple ou
+00020760: 746c 6965 7273 2069 6e20 6d6f 7265 2074  tliers in more t
+00020770: 6861 6e20 3320 636f 6c75 6d6e 7320 7768  han 3 columns wh
+00020780: 6963 6820 7765 7265 2064 726f 7070 6564  ich were dropped
+00020790: 203d 2025 6427 2025 286e 756d 6265 725f   = %d' %(number_
+000207a0: 6f66 5f72 6f77 732d 6466 2e73 6861 7065  of_rows-df.shape
+000207b0: 5b30 5d29 290a 2020 2020 7265 7475 726e  [0])).    return
+000207c0: 2064 660a 2323 2323 2323 2323 2323 2323   df.############
+000207d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000207e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000207f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00020800: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00020810: 2323 2323 230a 696d 706f 7274 2070 616e  #####.import pan
+00020820: 6461 7320 6173 2070 640a 696d 706f 7274  das as pd.import
+00020830: 206e 756d 7079 2061 7320 6e70 0a69 6d70   numpy as np.imp
+00020840: 6f72 7420 7064 620a 6672 6f6d 2073 6b6c  ort pdb.from skl
+00020850: 6561 726e 2e75 7469 6c73 2e76 616c 6964  earn.utils.valid
+00020860: 6174 696f 6e20 696d 706f 7274 2063 6865  ation import che
+00020870: 636b 5f58 5f79 2c20 6368 6563 6b5f 6973  ck_X_y, check_is
+00020880: 5f66 6974 7465 640a 6672 6f6d 2073 6b6c  _fitted.from skl
+00020890: 6561 726e 2e70 7265 7072 6f63 6573 7369  earn.preprocessi
+000208a0: 6e67 2069 6d70 6f72 7420 4c61 6265 6c45  ng import LabelE
+000208b0: 6e63 6f64 6572 0a66 726f 6d20 636f 6c6c  ncoder.from coll
+000208c0: 6563 7469 6f6e 7320 696d 706f 7274 2043  ections import C
+000208d0: 6f75 6e74 6572 2c20 6465 6661 756c 7464  ounter, defaultd
+000208e0: 6963 740a 6672 6f6d 2073 6b6c 6561 726e  ict.from sklearn
+000208f0: 2e62 6173 6520 696d 706f 7274 2042 6173  .base import Bas
+00020900: 6545 7374 696d 6174 6f72 2c20 436c 6173  eEstimator, Clas
+00020910: 7369 6669 6572 4d69 7869 6e2c 2054 7261  sifierMixin, Tra
+00020920: 6e73 666f 726d 6572 4d69 7869 6e0a 0a66  nsformerMixin..f
+00020930: 726f 6d20 696d 626c 6561 726e 2e6f 7665  rom imblearn.ove
+00020940: 725f 7361 6d70 6c69 6e67 2069 6d70 6f72  r_sampling impor
+00020950: 7420 534d 4f54 452c 2053 564d 534d 4f54  t SMOTE, SVMSMOT
+00020960: 450a 6672 6f6d 2069 6d62 6c65 6172 6e2e  E.from imblearn.
+00020970: 6f76 6572 5f73 616d 706c 696e 6720 696d  over_sampling im
+00020980: 706f 7274 2041 4441 5359 4e2c 2053 4d4f  port ADASYN, SMO
+00020990: 5445 4e43 0a0a 696d 706f 7274 2070 616e  TENC..import pan
+000209a0: 6461 7320 6173 2070 640a 696d 706f 7274  das as pd.import
+000209b0: 206e 756d 7079 2061 7320 6e70 0a66 726f   numpy as np.fro
+000209c0: 6d20 636f 6c6c 6563 7469 6f6e 7320 696d  m collections im
+000209d0: 706f 7274 2043 6f75 6e74 6572 0a69 6d70  port Counter.imp
+000209e0: 6f72 7420 7761 726e 696e 6773 0a77 6172  ort warnings.war
+000209f0: 6e69 6e67 732e 6669 6c74 6572 7761 726e  nings.filterwarn
+00020a00: 696e 6773 2822 6967 6e6f 7265 2229 0a23  ings("ignore").#
+00020a10: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00020a20: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00020a30: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00020a40: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00020a50: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00020a60: 0a69 6d70 6f72 7420 636f 7079 0a66 726f  .import copy.fro
+00020a70: 6d20 736b 6c65 6172 6e2e 636c 7573 7465  m sklearn.cluste
+00020a80: 7220 696d 706f 7274 204b 4d65 616e 730a  r import KMeans.
+00020a90: 6465 6620 4645 5f6b 6d65 616e 735f 7265  def FE_kmeans_re
+00020aa0: 7361 6d70 6c65 7228 785f 7472 6169 6e2c  sampler(x_train,
+00020ab0: 2079 5f74 7261 696e 2c20 7461 7267 6574   y_train, target
+00020ac0: 2c20 736d 6f74 653d 2222 2c20 7665 7262  , smote="", verb
+00020ad0: 6f73 653d 3029 3a0a 2020 2020 2222 220a  ose=0):.    """.
+00020ae0: 2020 2020 5468 6973 2066 756e 6374 696f      This functio
+00020af0: 6e20 636f 6e76 6572 7473 2061 2052 6567  n converts a Reg
+00020b00: 7265 7373 696f 6e20 7072 6f62 6c65 6d20  ression problem 
+00020b10: 696e 746f 2061 2043 6c61 7373 6966 6963  into a Classific
+00020b20: 6174 696f 6e20 7072 6f62 6c65 6d20 746f  ation problem to
+00020b30: 2065 6e61 626c 6520 534d 4f54 4521 0a20   enable SMOTE!. 
+00020b40: 2020 2049 7420 6973 2061 2076 6572 7920     It is a very 
+00020b50: 7369 6d70 6c65 2077 6179 2074 6f20 7365  simple way to se
+00020b60: 6e64 2079 6f75 7220 785f 7472 6169 6e2c  nd your x_train,
+00020b70: 2079 5f74 7261 696e 2069 6e20 616e 6420   y_train in and 
+00020b80: 6765 7420 6261 636b 2061 6e20 6f76 6572  get back an over
+00020b90: 7361 6d70 6c65 6420 785f 7472 6169 6e2c  sampled x_train,
+00020ba0: 2079 5f74 7261 696e 2e0a 2020 2020 5768   y_train..    Wh
+00020bb0: 7920 6973 2074 6869 7320 6e65 6564 6564  y is this needed
+00020bc0: 2069 6e20 4d61 6368 696e 6520 4c65 6172   in Machine Lear
+00020bd0: 6e69 6e67 2070 726f 626c 656d 733f 0a20  ning problems?. 
+00020be0: 2020 2020 2020 2020 496e 2049 6d62 616c          In Imbal
+00020bf0: 616e 6365 6420 6461 7461 7365 7473 2c20  anced datasets, 
+00020c00: 6573 702e 2073 6b65 7765 6420 7265 6772  esp. skewed regr
+00020c10: 6573 7369 6f6e 2070 726f 626c 656d 7320  ession problems 
+00020c20: 7768 6572 6520 7468 6520 7461 7267 6574  where the target
+00020c30: 2076 6172 6961 626c 6520 6973 2073 6b65   variable is ske
+00020c40: 7765 642c 2074 6869 7320 6973 206e 6565  wed, this is nee
+00020c50: 6465 642e 0a20 2020 2054 7279 2074 6869  ded..    Try thi
+00020c60: 7320 6f6e 2079 6f75 7220 736b 6577 6564  s on your skewed
+00020c70: 2052 6567 7265 7373 696f 6e20 7072 6f62   Regression prob
+00020c80: 6c65 6d73 2061 6e64 2073 6565 2077 6861  lems and see wha
+00020c90: 7420 7265 7375 6c74 7320 796f 7520 6765  t results you ge
+00020ca0: 742e 2049 7420 7368 6f75 6c64 2062 6520  t. It should be 
+00020cb0: 6265 7474 6572 2e0a 2020 2020 2d2d 2d2d  better..    ----
+00020cc0: 2d2d 2d2d 2d2d 0a20 2020 2049 6e70 7574  ------.    Input
+00020cd0: 730a 2020 2020 2d2d 2d2d 2d2d 2d2d 2d2d  s.    ----------
+00020ce0: 0a20 2020 2078 5f74 7261 696e 203a 2070  .    x_train : p
+00020cf0: 616e 6461 7320 6461 7461 6672 616d 653a  andas dataframe:
+00020d00: 2079 6f75 206d 7573 7420 7365 6e64 2069   you must send i
+00020d10: 6e20 7468 6520 6461 7461 2077 6974 6820  n the data with 
+00020d20: 7072 6564 6963 746f 7273 206f 6e6c 792e  predictors only.
+00020d30: 0a20 2020 206d 696e 5f6e 5f73 616d 706c  .    min_n_sampl
+00020d40: 6573 203a 2069 6e74 2c20 6465 6661 756c  es : int, defaul
+00020d50: 743d 353a 206d 696e 206e 756d 6265 7220  t=5: min number 
+00020d60: 6f66 2073 616d 706c 6573 2062 656c 6f77  of samples below
+00020d70: 2077 6869 6368 2079 6f75 2063 6f6d 6269   which you combi
+00020d80: 6e65 2062 696e 730a 2020 2020 6269 6e73  ne bins.    bins
+00020d90: 203a 2069 6e74 2c20 6465 6661 756c 743d   : int, default=
+00020da0: 333a 2068 6f77 206d 616e 7920 6269 6e73  3: how many bins
+00020db0: 2079 6f75 2077 616e 7420 746f 2073 706c   you want to spl
+00020dc0: 6974 2074 6172 6765 7420 696e 746f 0a0a  it target into..
+00020dd0: 2020 2020 4f75 7470 7574 730a 2020 2020      Outputs.    
+00020de0: 2d2d 2d2d 2d2d 2d2d 2d2d 0a20 2020 206e  ----------.    n
+00020df0: 5f66 6561 7475 7265 735f 203a 2069 6e74  _features_ : int
+00020e00: 0a20 2020 2020 2020 2054 6865 206e 756d  .        The num
+00020e10: 6265 7220 6f66 2066 6561 7475 7265 7320  ber of features 
+00020e20: 6f66 2074 6865 2064 6174 6120 7061 7373  of the data pass
+00020e30: 6564 2074 6f20 3a6d 6574 683a 6066 6974  ed to :meth:`fit
+00020e40: 602e 0a20 2020 2022 2222 0a20 2020 2078  `..    """.    x
+00020e50: 5f74 7261 696e 5f63 203d 2063 6f70 792e  _train_c = copy.
+00020e60: 6465 6570 636f 7079 2878 5f74 7261 696e  deepcopy(x_train
+00020e70: 290a 2020 2020 785f 7472 6169 6e5f 635b  ).    x_train_c[
+00020e80: 7461 7267 6574 5d20 3d20 795f 7472 6169  target] = y_trai
+00020e90: 6e2e 7661 6c75 6573 0a0a 2020 2020 2320  n.values..    # 
+00020ea0: 5265 6772 6573 7369 6f6e 2070 726f 626c  Regression probl
+00020eb0: 656d 2074 7572 6e65 6420 696e 746f 2043  em turned into C
+00020ec0: 6c61 7373 6966 6963 6174 696f 6e20 7072  lassification pr
+00020ed0: 6f62 6c65 6d0a 2020 2020 6e5f 636c 7573  oblem.    n_clus
+00020ee0: 7465 7273 203d 206d 6178 2833 2c20 696e  ters = max(3, in
+00020ef0: 7428 6e70 2e6c 6f67 3130 286c 656e 2879  t(np.log10(len(y
+00020f00: 5f74 7261 696e 2929 2920 2b20 3129 0a20  _train))) + 1). 
+00020f10: 2020 2023 2055 7365 204b 4d65 616e 7320     # Use KMeans 
+00020f20: 746f 2066 696e 6420 6e61 7475 7261 6c20  to find natural 
+00020f30: 636c 7573 7465 7273 2069 6e20 796f 7572  clusters in your
+00020f40: 2064 6174 610a 2020 2020 6b6d 5f6d 6f64   data.    km_mod
+00020f50: 656c 203d 204b 4d65 616e 7328 6e5f 636c  el = KMeans(n_cl
+00020f60: 7573 7465 7273 3d6e 5f63 6c75 7374 6572  usters=n_cluster
+00020f70: 732c 0a20 2020 2020 2020 2020 2020 2020  s,.             
+00020f80: 2020 2020 2020 2020 206e 5f69 6e69 743d           n_init=
+00020f90: 352c 0a20 2020 2020 2020 2020 2020 2020  5,.             
+00020fa0: 2020 2020 2020 2020 2072 616e 646f 6d5f           random_
+00020fb0: 7374 6174 653d 3939 290a 2020 2020 2323  state=99).    ##
+00020fc0: 2323 2072 656d 656d 6265 7220 796f 7520  ## remember you 
+00020fd0: 6d75 7374 2070 7265 6469 6374 2075 7369  must predict usi
+00020fe0: 6e67 206f 6e6c 7920 7072 6564 6963 746f  ng only predicto
+00020ff0: 7220 7661 7269 6162 6c65 7321 0a20 2020  r variables!.   
+00021000: 2079 5f74 7261 696e 5f63 203d 206b 6d5f   y_train_c = km_
+00021010: 6d6f 6465 6c2e 6669 745f 7072 6564 6963  model.fit_predic
+00021020: 7428 785f 7472 6169 6e29 0a0a 2020 2020  t(x_train)..    
+00021030: 6966 2076 6572 626f 7365 203e 3d20 313a  if verbose >= 1:
+00021040: 0a20 2020 2020 2020 2070 7269 6e74 2827  .        print('
+00021050: 4e75 6d62 6572 206f 6620 636c 7573 7465  Number of cluste
+00021060: 7273 2063 7265 6174 6564 203d 2025 6427  rs created = %d'
+00021070: 2025 6e5f 636c 7573 7465 7273 290a 0a20   %n_clusters).. 
+00021080: 2020 2023 2323 2320 4765 6e65 7261 7465     #### Generate
+00021090: 2074 6865 206f 7665 722d 7361 6d70 6c65   the over-sample
+000210a0: 6420 6461 7461 0a20 2020 2023 2323 2320  d data.    #### 
+000210b0: 4144 4153 594e 202f 2053 4d4f 5445 206f  ADASYN / SMOTE o
+000210c0: 7665 7273 616d 706c 696e 6720 2323 2323  versampling ####
+000210d0: 230a 2020 2020 6966 2069 7369 6e73 7461  #.    if isinsta
+000210e0: 6e63 6528 736d 6f74 652c 2073 7472 293a  nce(smote, str):
+000210f0: 0a20 2020 2020 2020 2078 5f74 7261 696e  .        x_train
+00021100: 5f65 7874 2c20 5f20 3d20 6f76 6572 7361  _ext, _ = oversa
+00021110: 6d70 6c65 5f53 4d4f 5445 2878 5f74 7261  mple_SMOTE(x_tra
+00021120: 696e 5f63 2c20 795f 7472 6169 6e5f 6329  in_c, y_train_c)
+00021130: 0a20 2020 2065 6c73 653a 0a20 2020 2020  .    else:.     
+00021140: 2020 2078 5f74 7261 696e 5f65 7874 2c20     x_train_ext, 
+00021150: 5f20 3d20 736d 6f74 652e 6669 745f 7265  _ = smote.fit_re
+00021160: 7361 6d70 6c65 2878 5f74 7261 696e 5f63  sample(x_train_c
+00021170: 2c20 795f 7472 6169 6e5f 6329 0a20 2020  , y_train_c).   
+00021180: 2079 5f74 7261 696e 5f65 7874 203d 2078   y_train_ext = x
+00021190: 5f74 7261 696e 5f65 7874 5b74 6172 6765  _train_ext[targe
+000211a0: 745d 2e76 616c 7565 730a 2020 2020 785f  t].values.    x_
+000211b0: 7472 6169 6e5f 6578 7420 3d20 785f 7472  train_ext = x_tr
+000211c0: 6169 6e5f 6578 742e 6472 6f70 2874 6172  ain_ext.drop(tar
+000211d0: 6765 742c 2061 7869 733d 3129 0a20 2020  get, axis=1).   
+000211e0: 2072 6574 7572 6e20 2878 5f74 7261 696e   return (x_train
+000211f0: 5f65 7874 2c20 795f 7472 6169 6e5f 6578  _ext, y_train_ex
+00021200: 7429 0a0a 2323 2323 2323 2323 2323 2323  t)..############
+00021210: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00021220: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00021230: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00021240: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00021250: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00021260: 2323 2323 2323 230a 2320 4361 6c63 756c  #######.# Calcul
+00021270: 6174 6520 636c 6173 7320 7765 6967 6874  ate class weight
+00021280: 0a69 6d70 6f72 7420 636f 7079 0a66 726f  .import copy.fro
+00021290: 6d20 636f 6c6c 6563 7469 6f6e 7320 696d  m collections im
+000212a0: 706f 7274 2043 6f75 6e74 6572 0a66 726f  port Counter.fro
+000212b0: 6d20 736b 6c65 6172 6e2e 7574 696c 732e  m sklearn.utils.
+000212c0: 636c 6173 735f 7765 6967 6874 2069 6d70  class_weight imp
+000212d0: 6f72 7420 636f 6d70 7574 655f 636c 6173  ort compute_clas
+000212e0: 735f 7765 6967 6874 0a64 6566 2067 6574  s_weight.def get
+000212f0: 5f63 6c61 7373 5f64 6973 7472 6962 7574  _class_distribut
+00021300: 696f 6e28 795f 696e 7075 742c 2076 6572  ion(y_input, ver
+00021310: 626f 7365 3d30 293a 0a20 2020 2079 5f69  bose=0):.    y_i
+00021320: 6e70 7574 203d 2063 6f70 792e 6465 6570  nput = copy.deep
+00021330: 636f 7079 2879 5f69 6e70 7574 290a 2020  copy(y_input).  
+00021340: 2020 636c 6173 7365 7320 3d20 6e70 2e75    classes = np.u
+00021350: 6e69 7175 6528 795f 696e 7075 7429 0a20  nique(y_input). 
+00021360: 2020 2078 7020 3d20 436f 756e 7465 7228     xp = Counter(
+00021370: 795f 696e 7075 7429 0a20 2020 2063 6c61  y_input).    cla
+00021380: 7373 5f77 6569 6768 7473 203d 2063 6f6d  ss_weights = com
+00021390: 7075 7465 5f63 6c61 7373 5f77 6569 6768  pute_class_weigh
+000213a0: 7428 2762 616c 616e 6365 6427 2c20 636c  t('balanced', cl
+000213b0: 6173 7365 733d 6e70 2e75 6e69 7175 6528  asses=np.unique(
+000213c0: 795f 696e 7075 7429 2c20 793d 795f 696e  y_input), y=y_in
+000213d0: 7075 7429 0a20 2020 2069 6620 6c65 6e28  put).    if len(
+000213e0: 636c 6173 735f 7765 6967 6874 735b 2863  class_weights[(c
+000213f0: 6c61 7373 5f77 6569 6768 7473 3e20 3130  lass_weights> 10
+00021400: 295d 2920 3e20 303a 0a20 2020 2020 2020  )]) > 0:.       
+00021410: 2063 6c61 7373 5f77 6569 6768 7473 203d   class_weights =
+00021420: 2028 636c 6173 735f 7765 6967 6874 732f   (class_weights/
+00021430: 3130 290a 2020 2020 656c 7365 3a0a 2020  10).    else:.  
+00021440: 2020 2020 2020 636c 6173 735f 7765 6967        class_weig
+00021450: 6874 7320 3d20 2863 6c61 7373 5f77 6569  hts = (class_wei
+00021460: 6768 7473 290a 2020 2020 2370 7269 6e74  ghts).    #print
+00021470: 2827 2020 2020 636c 6173 735f 7765 6967  ('    class_weig
+00021480: 6874 7320 3d20 2573 2720 2563 6c61 7373  hts = %s' %class
+00021490: 5f77 6569 6768 7473 290a 2020 2020 636c  _weights).    cl
+000214a0: 6173 735f 7765 6967 6874 735b 2863 6c61  ass_weights[(cla
+000214b0: 7373 5f77 6569 6768 7473 3c31 295d 3d31  ss_weights<1)]=1
+000214c0: 0a20 2020 2063 6c61 7373 5f72 6f77 7320  .    class_rows 
+000214d0: 3d20 636c 6173 735f 7765 6967 6874 732a  = class_weights*
+000214e0: 5b78 705b 785d 2066 6f72 2078 2069 6e20  [xp[x] for x in 
+000214f0: 636c 6173 7365 735d 0a20 2020 2063 6c61  classes].    cla
+00021500: 7373 5f72 6f77 7320 3d20 636c 6173 735f  ss_rows = class_
+00021510: 726f 7773 2e61 7374 7970 6528 696e 7429  rows.astype(int)
+00021520: 0a20 2020 2063 6c61 7373 5f77 6569 6768  .    class_weigh
+00021530: 7465 645f 726f 7773 203d 2064 6963 7428  ted_rows = dict(
+00021540: 7a69 7028 636c 6173 7365 732c 636c 6173  zip(classes,clas
+00021550: 735f 726f 7773 2929 0a20 2020 2069 6620  s_rows)).    if 
+00021560: 7665 7262 6f73 653a 0a20 2020 2020 2020  verbose:.       
+00021570: 2070 7269 6e74 2827 2020 2020 636c 6173   print('    clas
+00021580: 735f 7765 6967 6874 6564 5f72 6f77 7320  s_weighted_rows 
+00021590: 3d20 2573 2720 2563 6c61 7373 5f77 6569  = %s' %class_wei
+000215a0: 6768 7465 645f 726f 7773 290a 2020 2020  ghted_rows).    
+000215b0: 7265 7475 726e 2063 6c61 7373 5f77 6569  return class_wei
+000215c0: 6768 7465 645f 726f 7773 0a0a 0a64 6566  ghted_rows...def
+000215d0: 206f 7665 7273 616d 706c 655f 534d 4f54   oversample_SMOT
+000215e0: 4528 582c 7929 3a0a 2020 2020 2369 6e70  E(X,y):.    #inp
+000215f0: 7574 2044 6174 6146 7261 6d65 0a20 2020  ut DataFrame.   
+00021600: 2023 5820 e286 9249 6e64 6570 656e 6465   #X ...Independe
+00021610: 6e74 2056 6172 6961 626c 6520 696e 2044  nt Variable in D
+00021620: 6174 6146 7261 6d65 5c0a 2020 2020 2379  ataFrame\.    #y
+00021630: 20e2 8692 6465 7065 6e64 656e 7420 5661   ...dependent Va
+00021640: 7269 6162 6c65 2069 6e20 5061 6e64 6173  riable in Pandas
+00021650: 2044 6174 6146 7261 6d65 2066 6f72 6d61   DataFrame forma
+00021660: 740a 2020 2020 2320 4765 7420 7468 6520  t.    # Get the 
+00021670: 636c 6173 7320 6469 7374 7269 7562 7469  class distriubti
+00021680: 6f6e 2066 6f72 2070 6572 666f 6d69 6e67  on for perfoming
+00021690: 2072 656c 6174 6976 6520 7361 6d70 6c69   relative sampli
+000216a0: 6e67 2069 6e20 7468 6520 6e65 7874 206c  ng in the next l
+000216b0: 696e 650a 2020 2020 636c 6173 735f 7765  ine.    class_we
+000216c0: 6967 6874 6564 5f72 6f77 7320 3d20 6765  ighted_rows = ge
+000216d0: 745f 636c 6173 735f 6469 7374 7269 6275  t_class_distribu
+000216e0: 7469 6f6e 2879 290a 2020 2020 736d 6f74  tion(y).    smot
+000216f0: 6520 3d20 5356 4d53 4d4f 5445 2820 7261  e = SVMSMOTE( ra
+00021700: 6e64 6f6d 5f73 7461 7465 3d32 372c 0a20  ndom_state=27,. 
+00021710: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00021720: 2073 616d 706c 696e 675f 7374 7261 7465   sampling_strate
+00021730: 6779 3d63 6c61 7373 5f77 6569 6768 7465  gy=class_weighte
+00021740: 645f 726f 7773 290a 2020 2020 582c 2079  d_rows).    X, y
+00021750: 203d 2073 6d6f 7465 2e66 6974 5f72 6573   = smote.fit_res
+00021760: 616d 706c 6528 582c 2079 290a 2020 2020  ample(X, y).    
+00021770: 7265 7475 726e 2858 2c79 290a 0a64 6566  return(X,y)..def
+00021780: 206f 7665 7273 616d 706c 655f 4144 4153   oversample_ADAS
+00021790: 594e 2858 2c79 293a 0a20 2020 2023 696e  YN(X,y):.    #in
+000217a0: 7075 7420 4461 7461 4672 616d 650a 2020  put DataFrame.  
+000217b0: 2020 2358 20e2 8692 496e 6465 7065 6e64    #X ...Independ
+000217c0: 656e 7420 5661 7269 6162 6c65 2069 6e20  ent Variable in 
+000217d0: 4461 7461 4672 616d 655c 0a20 2020 2023  DataFrame\.    #
+000217e0: 7920 e286 9264 6570 656e 6465 6e74 2056  y ...dependent V
+000217f0: 6172 6961 626c 6520 696e 2050 616e 6461  ariable in Panda
+00021800: 7320 4461 7461 4672 616d 6520 666f 726d  s DataFrame form
+00021810: 6174 0a20 2020 2023 2047 6574 2074 6865  at.    # Get the
+00021820: 2063 6c61 7373 2064 6973 7472 6975 6274   class distriubt
+00021830: 696f 6e20 666f 7220 7065 7266 6f6d 696e  ion for perfomin
+00021840: 6720 7265 6c61 7469 7665 2073 616d 706c  g relative sampl
+00021850: 696e 6720 696e 2074 6865 206e 6578 7420  ing in the next 
+00021860: 6c69 6e65 0a20 2020 2063 6c61 7373 5f77  line.    class_w
+00021870: 6569 6768 7465 645f 726f 7773 203d 2067  eighted_rows = g
+00021880: 6574 5f63 6c61 7373 5f64 6973 7472 6962  et_class_distrib
+00021890: 7574 696f 6e28 7929 0a20 2020 2023 2059  ution(y).    # Y
+000218a0: 6f75 7220 6661 766f 7572 6974 6520 6f76  our favourite ov
+000218b0: 6572 7361 6d70 6c65 720a 2020 2020 736d  ersampler.    sm
+000218c0: 6f74 6520 3d20 4144 4153 594e 2872 616e  ote = ADASYN(ran
+000218d0: 646f 6d5f 7374 6174 653d 3237 2c0a 2020  dom_state=27,.  
+000218e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000218f0: 2073 616d 706c 696e 675f 7374 7261 7465   sampling_strate
+00021900: 6779 3d63 6c61 7373 5f77 6569 6768 7465  gy=class_weighte
+00021910: 645f 726f 7773 290a 2020 2020 582c 2079  d_rows).    X, y
+00021920: 203d 2073 6d6f 7465 2e66 6974 5f72 6573   = smote.fit_res
+00021930: 616d 706c 6528 582c 2079 290a 2020 2020  ample(X, y).    
+00021940: 7265 7475 726e 2858 2c79 290a 2323 2323  return(X,y).####
+00021950: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00021960: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00021970: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00021980: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00021990: 2323 2323 2323 2323 230a 696d 706f 7274  #########.import
+000219a0: 206e 756d 7079 2061 7320 6e70 0a69 6d70   numpy as np.imp
+000219b0: 6f72 7420 7061 6e64 6173 2061 7320 7064  ort pandas as pd
+000219c0: 0a66 726f 6d20 736b 6c65 6172 6e2e 6d6f  .from sklearn.mo
+000219d0: 6465 6c5f 7365 6c65 6374 696f 6e20 696d  del_selection im
+000219e0: 706f 7274 2074 7261 696e 5f74 6573 745f  port train_test_
+000219f0: 7370 6c69 740a 6465 6620 7370 6c69 745f  split.def split_
+00021a00: 6461 7461 5f6e 5f77 6179 7328 6466 2c20  data_n_ways(df, 
+00021a10: 7461 7267 6574 2c20 6e5f 7370 6c69 7473  target, n_splits
+00021a20: 2c20 7465 7374 5f73 697a 653d 302e 322c  , test_size=0.2,
+00021a30: 206d 6f64 656c 7479 7065 3d4e 6f6e 652c   modeltype=None,
+00021a40: 2a2a 6b77 6172 6773 293a 0a20 2020 2022  **kwargs):.    "
+00021a50: 2222 0a20 2020 2049 6e70 7574 733a 0a20  "".    Inputs:. 
+00021a60: 2020 2064 663a 2064 6174 6166 7261 6d65     df: dataframe
+00021a70: 2074 6861 7420 796f 7520 7761 6e74 2074   that you want t
+00021a80: 6f20 7370 6c69 740a 2020 2020 7461 7267  o split.    targ
+00021a90: 6574 3a20 7468 6520 7461 7267 6574 2076  et: the target v
+00021aa0: 6172 6961 626c 6520 696e 2064 6174 6120  ariable in data 
+00021ab0: 6672 616d 6520 2864 6629 0a20 2020 206e  frame (df).    n
+00021ac0: 5f73 706c 6974 733a 206e 756d 6265 7220  _splits: number 
+00021ad0: 6f66 2077 6179 7320 696e 2077 6869 6368  of ways in which
+00021ae0: 2079 6f75 2077 616e 7420 746f 2073 706c   you want to spl
+00021af0: 6974 2074 6865 2064 6174 6120 6672 616d  it the data fram
+00021b00: 6520 2864 6566 6175 6c74 3d33 290a 2020  e (default=3).  
+00021b10: 2020 7465 7374 5f73 697a 653a 2073 697a    test_size: siz
+00021b20: 6520 6f66 2074 6865 2074 6573 7420 6461  e of the test da
+00021b30: 7461 7365 743a 2064 6566 6175 6c74 2069  taset: default i
+00021b40: 7320 302e 3220 4275 7420 6974 2073 706c  s 0.2 But it spl
+00021b50: 6974 7320 7468 6973 2074 6573 7420 696e  its this test in
+00021b60: 746f 2076 616c 6964 2061 6e64 2074 6573  to valid and tes
+00021b70: 7420 6861 6c66 2e0a 2020 2020 4865 6e63  t half..    Henc
+00021b80: 6520 796f 7520 7769 6c6c 2067 6574 2031  e you will get 1
+00021b90: 3025 206f 6620 6466 2061 7320 7465 7374  0% of df as test
+00021ba0: 2061 6e64 2031 3025 206f 6620 6466 2061   and 10% of df a
+00021bb0: 7320 7661 6c69 6420 616e 6420 7265 6d61  s valid and rema
+00021bc0: 696e 696e 6720 3830 2520 6173 2074 7261  ining 80% as tra
+00021bd0: 696e 0a20 2020 2023 2323 2323 2323 2323  in.    #########
+00021be0: 2323 2323 2323 2320 2020 686f 7720 6974  #######   how it
+00021bf0: 2077 6f72 6b73 2023 2323 2323 2323 2323   works #########
+00021c00: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00021c10: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00021c20: 2323 2323 2323 230a 2020 2020 596f 7520  #######.    You 
+00021c30: 6361 6e20 7370 6c69 7420 6120 6461 7461  can split a data
+00021c40: 6672 616d 6520 7468 7265 6520 7761 7973  frame three ways
+00021c50: 206f 7220 7369 7820 7761 7973 2064 6570   or six ways dep
+00021c60: 656e 6469 6e67 206f 6e20 796f 7572 206e  ending on your n
+00021c70: 6565 642e 2054 6872 6565 2077 6179 7320  eed. Three ways 
+00021c80: 6973 3a0a 2020 2020 7472 6169 6e2c 2076  is:.    train, v
+00021c90: 616c 6964 2c20 7465 7374 0a20 2020 2053  alid, test.    S
+00021ca0: 6978 2077 6179 7320 6361 6e20 6265 3a0a  ix ways can be:.
+00021cb0: 2020 2020 585f 7472 6169 6e2c 795f 7472      X_train,y_tr
+00021cc0: 6169 6e2c 2058 5f76 616c 6964 2c20 795f  ain, X_valid, y_
+00021cd0: 7661 6c69 642c 2058 5f74 6573 742c 2079  valid, X_test, y
+00021ce0: 5f74 6573 740a 2020 2020 596f 7520 7769  _test.    You wi
+00021cf0: 6c6c 2067 6574 2061 206c 6973 7420 636f  ll get a list co
+00021d00: 6e74 6169 6e69 6e67 2074 6865 7365 2064  ntaining these d
+00021d10: 6174 6166 7261 6d65 732e 2e2e 6465 7065  ataframes...depe
+00021d20: 6e64 696e 6720 6f6e 2077 6861 7420 796f  nding on what yo
+00021d30: 7520 656e 7465 7265 6420 6173 206e 756d  u entered as num
+00021d40: 6265 7220 6f66 2073 706c 6974 730a 2020  ber of splits.  
+00021d50: 2020 4f75 7470 7574 3a20 4c69 7374 206f    Output: List o
+00021d60: 6620 6461 7461 6672 616d 6573 0a20 2020  f dataframes.   
+00021d70: 2022 2222 0a20 2020 2069 6620 6b77 6172   """.    if kwar
+00021d80: 6773 3a0a 2020 2020 2020 2020 666f 7220  gs:.        for 
+00021d90: 6b65 792c 2076 616c 2069 6e20 6b77 6172  key, val in kwar
+00021da0: 6773 3a0a 2020 2020 2020 2020 2020 2020  gs:.            
+00021db0: 6966 206b 6579 203d 3d20 276d 6f64 656c  if key == 'model
+00021dc0: 7479 7065 273a 0a20 2020 2020 2020 2020  type':.         
+00021dd0: 2020 2020 2020 206b 6579 203d 2076 616c         key = val
+00021de0: 0a20 2020 2020 2020 2020 2020 2069 6620  .            if 
+00021df0: 6b65 7920 3d3d 2027 7465 7374 5f73 697a  key == 'test_siz
+00021e00: 6527 3a0a 2020 2020 2020 2020 2020 2020  e':.            
+00021e10: 2020 2020 7465 7374 5f73 697a 6520 3d20      test_size = 
+00021e20: 7661 6c0a 2020 2020 6966 206d 6f64 656c  val.    if model
+00021e30: 7479 7065 2069 7320 4e6f 6e65 3a0a 2020  type is None:.  
+00021e40: 2020 2020 2020 6966 2069 7369 6e73 7461        if isinsta
+00021e50: 6e63 6528 7461 7267 6574 2c20 7374 7229  nce(target, str)
+00021e60: 3a0a 2020 2020 2020 2020 2020 2020 6966  :.            if
+00021e70: 2064 665b 7461 7267 6574 5d2e 6474 7970   df[target].dtyp
+00021e80: 6520 3d3d 2066 6c6f 6174 3a0a 2020 2020  e == float:.    
+00021e90: 2020 2020 2020 2020 2020 2020 6d6f 6465              mode
+00021ea0: 6c74 7970 6520 3d20 2752 6567 7265 7373  ltype = 'Regress
+00021eb0: 696f 6e27 0a20 2020 2020 2020 2020 2020  ion'.           
+00021ec0: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+00021ed0: 2020 2020 2020 206d 6f64 656c 7479 7065         modeltype
+00021ee0: 203d 2027 436c 6173 7369 6669 6361 7469   = 'Classificati
+00021ef0: 6f6e 270a 2020 2020 2020 2020 2020 2020  on'.            
+00021f00: 7461 7267 6574 203d 205b 7461 7267 6574  target = [target
+00021f10: 5d0a 2020 2020 2020 2020 656c 7365 3a0a  ].        else:.
+00021f20: 2020 2020 2020 2020 2020 2020 6966 2064              if d
+00021f30: 665b 7461 7267 6574 5b30 5d5d 2e64 7479  f[target[0]].dty
+00021f40: 7065 203d 3d20 666c 6f61 743a 0a20 2020  pe == float:.   
+00021f50: 2020 2020 2020 2020 2020 2020 206d 6f64               mod
+00021f60: 656c 7479 7065 203d 2027 5265 6772 6573  eltype = 'Regres
+00021f70: 7369 6f6e 270a 2020 2020 2020 2020 2020  sion'.          
+00021f80: 2020 656c 7365 3a0a 2020 2020 2020 2020    else:.        
+00021f90: 2020 2020 2020 2020 206d 6f64 656c 7479           modelty
+00021fa0: 7065 203d 2027 436c 6173 7369 6669 6361  pe = 'Classifica
+00021fb0: 7469 6f6e 270a 2020 2020 7072 6564 7320  tion'.    preds 
+00021fc0: 3d20 5b78 2066 6f72 2078 2069 6e20 6c69  = [x for x in li
+00021fd0: 7374 2864 6629 2069 6620 7820 6e6f 7420  st(df) if x not 
+00021fe0: 696e 2074 6172 6765 745d 0a20 2020 2070  in target].    p
+00021ff0: 7269 6e74 2827 4e75 6d62 6572 206f 6620  rint('Number of 
+00022000: 7072 6564 6963 746f 7273 2069 6e20 6461  predictors in da
+00022010: 7461 7365 743a 2025 6427 2025 6c65 6e28  taset: %d' %len(
+00022020: 7072 6564 7329 290a 2020 2020 6c69 7374  preds)).    list
+00022030: 5f6f 665f 6466 7320 3d20 5b5d 0a20 2020  _of_dfs = [].   
+00022040: 2069 6620 6d6f 6465 6c74 7970 6520 3d3d   if modeltype ==
+00022050: 2027 5265 6772 6573 7369 6f6e 273a 0a20   'Regression':. 
+00022060: 2020 2020 2020 206e 756d 7320 3d20 696e         nums = in
+00022070: 7428 2831 2d74 6573 745f 7369 7a65 292a  t((1-test_size)*
+00022080: 6466 2e73 6861 7065 5b30 5d29 0a20 2020  df.shape[0]).   
+00022090: 2020 2020 2074 7261 696e 2c20 7465 7374       train, test
+000220a0: 6c61 7267 6520 3d20 6466 5b3a 6e75 6d73  large = df[:nums
+000220b0: 5d2c 2064 665b 6e75 6d73 3a5d 0a20 2020  ], df[nums:].   
+000220c0: 2065 6c73 653a 0a20 2020 2020 2020 2074   else:.        t
+000220d0: 7261 696e 2c20 7465 7374 6c61 7267 6520  rain, testlarge 
+000220e0: 3d20 7472 6169 6e5f 7465 7374 5f73 706c  = train_test_spl
+000220f0: 6974 2864 662c 2074 6573 745f 7369 7a65  it(df, test_size
+00022100: 3d74 6573 745f 7369 7a65 2c20 7261 6e64  =test_size, rand
+00022110: 6f6d 5f73 7461 7465 3d34 3229 0a20 2020  om_state=42).   
+00022120: 206c 6973 745f 6f66 5f64 6673 2e61 7070   list_of_dfs.app
+00022130: 656e 6428 7472 6169 6e29 0a20 2020 2069  end(train).    i
+00022140: 6620 6e5f 7370 6c69 7473 203d 3d20 323a  f n_splits == 2:
+00022150: 0a20 2020 2020 2020 2070 7269 6e74 2827  .        print('
+00022160: 5265 7475 726e 696e 6720 6120 5475 706c  Returning a Tupl
+00022170: 6520 7769 7468 2074 776f 2064 6174 6166  e with two dataf
+00022180: 7261 6d65 7320 616e 6420 7368 6170 6573  rames and shapes
+00022190: 3a20 2825 732c 2573 2927 2025 2874 7261  : (%s,%s)' %(tra
+000221a0: 696e 2e73 6861 7065 2c20 7465 7374 6c61  in.shape, testla
+000221b0: 7267 652e 7368 6170 6529 290a 2020 2020  rge.shape)).    
+000221c0: 2020 2020 7265 7475 726e 2074 7261 696e      return train
+000221d0: 2c20 7465 7374 6c61 7267 650a 2020 2020  , testlarge.    
+000221e0: 656c 6966 206d 6f64 656c 7479 7065 203d  elif modeltype =
+000221f0: 3d20 2752 6567 7265 7373 696f 6e27 2061  = 'Regression' a
+00022200: 6e64 206e 5f73 706c 6974 7320 3d3d 2033  nd n_splits == 3
+00022210: 3a0a 2020 2020 2020 2020 6e75 6d73 3220  :.        nums2 
+00022220: 3d20 696e 7428 302e 352a 2874 6573 746c  = int(0.5*(testl
+00022230: 6172 6765 2e73 6861 7065 5b30 5d29 290a  arge.shape[0])).
+00022240: 2020 2020 2020 2020 7661 6c69 642c 2074          valid, t
+00022250: 6573 7420 3d20 7465 7374 6c61 7267 655b  est = testlarge[
+00022260: 3a6e 756d 7332 5d2c 2074 6573 746c 6172  :nums2], testlar
+00022270: 6765 5b6e 756d 7332 3a5d 0a20 2020 2020  ge[nums2:].     
+00022280: 2020 2070 7269 6e74 2827 5265 7475 726e     print('Return
+00022290: 696e 6720 6120 5475 706c 6520 7769 7468  ing a Tuple with
+000222a0: 2074 6872 6565 2064 6174 6166 7261 6d65   three dataframe
+000222b0: 7320 616e 6420 7368 6170 6573 3a20 2825  s and shapes: (%
+000222c0: 732c 2573 2c25 7329 2720 2528 7472 6169  s,%s,%s)' %(trai
+000222d0: 6e2e 7368 6170 652c 2076 616c 6964 2e73  n.shape, valid.s
+000222e0: 6861 7065 2c20 7465 7374 2e73 6861 7065  hape, test.shape
+000222f0: 2929 0a20 2020 2020 2020 2072 6574 7572  )).        retur
+00022300: 6e20 7472 6169 6e2c 2076 616c 6964 2c20  n train, valid, 
+00022310: 7465 7374 0a20 2020 2065 6c69 6620 6d6f  test.    elif mo
+00022320: 6465 6c74 7970 6520 3d3d 2027 436c 6173  deltype == 'Clas
+00022330: 7369 6669 6361 7469 6f6e 2720 616e 6420  sification' and 
+00022340: 6e5f 7370 6c69 7473 203d 3d20 333a 0a20  n_splits == 3:. 
+00022350: 2020 2020 2020 2076 616c 6964 2c20 7465         valid, te
+00022360: 7374 203d 2074 7261 696e 5f74 6573 745f  st = train_test_
+00022370: 7370 6c69 7428 7465 7374 6c61 7267 652c  split(testlarge,
+00022380: 2074 6573 745f 7369 7a65 3d30 2e35 2c20   test_size=0.5, 
+00022390: 7261 6e64 6f6d 5f73 7461 7465 3d39 3929  random_state=99)
+000223a0: 0a20 2020 2020 2020 2070 7269 6e74 2827  .        print('
+000223b0: 5265 7475 726e 696e 6720 6120 5475 706c  Returning a Tupl
+000223c0: 6520 7769 7468 2074 6872 6565 2064 6174  e with three dat
+000223d0: 6166 7261 6d65 7320 616e 6420 7368 6170  aframes and shap
+000223e0: 6573 3a20 2825 732c 2573 2c25 7329 2720  es: (%s,%s,%s)' 
+000223f0: 2528 7472 6169 6e2e 7368 6170 652c 2076  %(train.shape, v
+00022400: 616c 6964 2e73 6861 7065 2c20 7465 7374  alid.shape, test
+00022410: 2e73 6861 7065 2929 0a20 2020 2020 2020  .shape)).       
+00022420: 2072 6574 7572 6e20 7472 6169 6e2c 2076   return train, v
+00022430: 616c 6964 2c20 7465 7374 0a20 2020 2023  alid, test.    #
+00022440: 2323 2320 436f 6e74 696e 7565 206f 6e6c  ### Continue onl
+00022450: 7920 6966 2079 6f75 206e 6565 6420 6d6f  y if you need mo
+00022460: 7265 2074 6861 6e20 3320 7370 6c69 7473  re than 3 splits
+00022470: 2023 2323 2323 230a 2020 2020 6966 206d   ######.    if m
+00022480: 6f64 656c 7479 7065 203d 3d20 2752 6567  odeltype == 'Reg
+00022490: 7265 7373 696f 6e27 3a0a 2020 2020 2020  ression':.      
+000224a0: 2020 6e75 6d73 3220 3d20 696e 7428 302e    nums2 = int(0.
+000224b0: 352a 2864 662e 7368 6170 655b 305d 202d  5*(df.shape[0] -
+000224c0: 206e 756d 7329 290a 2020 2020 2020 2020   nums)).        
+000224d0: 7661 6c69 642c 2074 6573 7420 3d20 7465  valid, test = te
+000224e0: 7374 6c61 7267 655b 3a6e 756d 7332 5d2c  stlarge[:nums2],
+000224f0: 2074 6573 746c 6172 6765 5b6e 756d 7332   testlarge[nums2
+00022500: 3a5d 0a20 2020 2020 2020 2069 6620 6e5f  :].        if n_
+00022510: 7370 6c69 7473 203d 3d20 343a 0a20 2020  splits == 4:.   
+00022520: 2020 2020 2020 2020 2058 5f74 7261 696e           X_train
+00022530: 2c20 795f 7472 6169 6e2c 2058 5f74 6573  , y_train, X_tes
+00022540: 742c 2079 5f74 6573 7420 3d20 7472 6169  t, y_test = trai
+00022550: 6e5b 7072 6564 735d 2c20 7472 6169 6e5b  n[preds], train[
+00022560: 7461 7267 6574 5d2c 2074 6573 746c 6172  target], testlar
+00022570: 6765 5b70 7265 6473 5d2c 2074 6573 746c  ge[preds], testl
+00022580: 6172 6765 5b74 6172 6765 745d 0a20 2020  arge[target].   
+00022590: 2020 2020 2020 2020 206c 6973 745f 6f66           list_of
+000225a0: 5f64 6673 203d 205b 585f 7472 6169 6e2c  _dfs = [X_train,
+000225b0: 795f 7472 6169 6e2c 2058 5f74 6573 742c  y_train, X_test,
+000225c0: 2079 5f74 6573 745d 0a20 2020 2020 2020   y_test].       
+000225d0: 2020 2020 2070 7269 6e74 2827 5265 7475       print('Retu
+000225e0: 726e 696e 6720 6120 5475 706c 6520 7769  rning a Tuple wi
+000225f0: 7468 2034 2064 6174 6166 7261 6d65 733a  th 4 dataframes:
+00022600: 2028 2573 2025 7320 2573 2025 7329 2720   (%s %s %s %s)' 
+00022610: 2528 585f 7472 6169 6e2e 7368 6170 652c  %(X_train.shape,
+00022620: 795f 7472 6169 6e2e 7368 6170 652c 0a20  y_train.shape,. 
+00022630: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00022640: 2020 2020 2020 2020 2020 2020 2020 2058                 X
+00022650: 5f74 6573 742e 7368 6170 652c 795f 7465  _test.shape,y_te
+00022660: 7374 2e73 6861 7065 2929 0a20 2020 2020  st.shape)).     
+00022670: 2020 2020 2020 2072 6574 7572 6e20 6c69         return li
+00022680: 7374 5f6f 665f 6466 730a 2020 2020 2020  st_of_dfs.      
+00022690: 2020 656c 6966 206e 5f73 706c 6974 7320    elif n_splits 
+000226a0: 3d3d 2036 3a0a 2020 2020 2020 2020 2020  == 6:.          
+000226b0: 2020 585f 7472 6169 6e2c 2079 5f74 7261    X_train, y_tra
+000226c0: 696e 2c20 585f 7661 6c69 642c 2079 5f76  in, X_valid, y_v
+000226d0: 616c 6964 2c20 585f 7465 7374 2c20 795f  alid, X_test, y_
+000226e0: 7465 7374 203d 2074 7261 696e 5b70 7265  test = train[pre
+000226f0: 6473 5d2c 2074 7261 696e 5b74 6172 6765  ds], train[targe
+00022700: 745d 2c20 7661 6c69 645b 0a20 2020 2020  t], valid[.     
+00022710: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00022720: 2020 2020 2020 2020 2020 2020 2020 2070                 p
+00022730: 7265 6473 5d2c 2076 616c 6964 5b74 6172  reds], valid[tar
+00022740: 6765 745d 2c20 7465 7374 5b70 7265 6473  get], test[preds
+00022750: 5d2c 2074 6573 745b 7461 7267 6574 5d0a  ], test[target].
+00022760: 2020 2020 2020 2020 2020 2020 6c69 7374              list
+00022770: 5f6f 665f 6466 7320 3d20 5b58 5f74 7261  _of_dfs = [X_tra
+00022780: 696e 2c79 5f74 7261 696e 2c20 585f 7661  in,y_train, X_va
+00022790: 6c69 642c 2079 5f76 616c 6964 2c20 585f  lid, y_valid, X_
+000227a0: 7465 7374 2c20 795f 7465 7374 5d0a 2020  test, y_test].  
+000227b0: 2020 2020 2020 2020 2020 7072 696e 7428            print(
+000227c0: 2752 6574 7572 6e69 6e67 2061 2054 7570  'Returning a Tup
+000227d0: 6c65 2077 6974 6820 7369 7820 6461 7461  le with six data
+000227e0: 6672 616d 6573 2061 6e64 2073 6861 7065  frames and shape
+000227f0: 733a 2028 2573 2025 7320 2573 2025 732c  s: (%s %s %s %s,
+00022800: 2573 2c25 7329 2720 2528 0a20 2020 2020  %s,%s)' %(.     
+00022810: 2020 2020 2020 2020 2020 2058 5f74 7261             X_tra
+00022820: 696e 2e73 6861 7065 2c79 5f74 7261 696e  in.shape,y_train
+00022830: 2e73 6861 7065 2c20 585f 7661 6c69 642e  .shape, X_valid.
+00022840: 7368 6170 652c 795f 7661 6c69 642e 7368  shape,y_valid.sh
+00022850: 6170 652c 585f 7465 7374 2e73 6861 7065  ape,X_test.shape
+00022860: 2c79 5f74 6573 742e 7368 6170 6529 290a  ,y_test.shape)).
+00022870: 2020 2020 2020 2020 2020 2020 7265 7475              retu
+00022880: 726e 206c 6973 745f 6f66 5f64 6673 0a20  rn list_of_dfs. 
+00022890: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
+000228a0: 2020 2020 2020 2020 2070 7269 6e74 2827           print('
+000228b0: 4e75 6d62 6572 206f 6620 7370 6c69 7473  Number of splits
+000228c0: 206d 7573 7420 6265 2032 2c20 332c 2034   must be 2, 3, 4
+000228d0: 206f 7220 3627 290a 2020 2020 2020 2020   or 6').        
+000228e0: 2020 2020 7265 7475 726e 0a20 2020 2065      return.    e
+000228f0: 6c73 653a 0a20 2020 2020 2020 2069 6620  lse:.        if 
+00022900: 6e5f 7370 6c69 7473 203d 3d20 343a 0a20  n_splits == 4:. 
+00022910: 2020 2020 2020 2020 2020 2058 5f74 7261             X_tra
+00022920: 696e 2c20 795f 7472 6169 6e2c 2058 5f74  in, y_train, X_t
+00022930: 6573 742c 2079 5f74 6573 7420 3d20 7472  est, y_test = tr
+00022940: 6169 6e5b 7072 6564 735d 2c20 7472 6169  ain[preds], trai
+00022950: 6e5b 7461 7267 6574 5d2c 2074 6573 746c  n[target], testl
+00022960: 6172 6765 5b70 7265 6473 5d2c 2074 6573  arge[preds], tes
+00022970: 746c 6172 6765 5b74 6172 6765 745d 0a20  tlarge[target]. 
+00022980: 2020 2020 2020 2020 2020 206c 6973 745f             list_
+00022990: 6f66 5f64 6673 203d 205b 585f 7472 6169  of_dfs = [X_trai
+000229a0: 6e2c 795f 7472 6169 6e2c 2058 5f74 6573  n,y_train, X_tes
+000229b0: 742c 2079 5f74 6573 745d 0a20 2020 2020  t, y_test].     
+000229c0: 2020 2020 2020 2070 7269 6e74 2827 5265         print('Re
+000229d0: 7475 726e 696e 6720 6120 5475 706c 6520  turning a Tuple 
+000229e0: 7769 7468 2034 2064 6174 6166 7261 6d65  with 4 dataframe
+000229f0: 733a 2028 2573 2025 7320 2573 2025 7329  s: (%s %s %s %s)
+00022a00: 2720 2528 585f 7472 6169 6e2e 7368 6170  ' %(X_train.shap
+00022a10: 652c 795f 7472 6169 6e2e 7368 6170 652c  e,y_train.shape,
+00022a20: 0a20 2020 2020 2020 2020 2020 2020 2020  .               
+00022a30: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00022a40: 2058 5f74 6573 742e 7368 6170 652c 795f   X_test.shape,y_
+00022a50: 7465 7374 2e73 6861 7065 2929 0a20 2020  test.shape)).   
+00022a60: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+00022a70: 6c69 7374 5f6f 665f 6466 730a 2020 2020  list_of_dfs.    
+00022a80: 2020 2020 656c 6966 206e 5f73 706c 6974      elif n_split
+00022a90: 7320 3d3d 2036 3a0a 2020 2020 2020 2020  s == 6:.        
+00022aa0: 2020 2020 585f 7472 6169 6e2c 2079 5f74      X_train, y_t
+00022ab0: 7261 696e 2c20 585f 7661 6c69 642c 2079  rain, X_valid, y
+00022ac0: 5f76 616c 6964 2c20 585f 7465 7374 2c20  _valid, X_test, 
+00022ad0: 795f 7465 7374 203d 2074 7261 696e 5b70  y_test = train[p
+00022ae0: 7265 6473 5d2c 2074 7261 696e 5b74 6172  reds], train[tar
+00022af0: 6765 745d 2c20 7661 6c69 645b 0a20 2020  get], valid[.   
+00022b00: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00022b10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00022b20: 2070 7265 6473 5d2c 2076 616c 6964 5b74   preds], valid[t
+00022b30: 6172 6765 745d 2c20 7465 7374 5b70 7265  arget], test[pre
+00022b40: 6473 5d2c 2074 6573 745b 7461 7267 6574  ds], test[target
+00022b50: 5d0a 2020 2020 2020 2020 2020 2020 7072  ].            pr
+00022b60: 696e 7428 2752 6574 7572 6e69 6e67 2034  int('Returning 4
+00022b70: 2064 6174 6166 7261 6d65 733a 272c 2058   dataframes:', X
+00022b80: 5f74 7261 696e 2e73 6861 7065 2c20 795f  _train.shape, y_
+00022b90: 7472 6169 6e2e 7368 6170 652c 2058 5f74  train.shape, X_t
+00022ba0: 6573 742e 7368 6170 652c 2079 5f74 6573  est.shape, y_tes
+00022bb0: 742e 7368 6170 6529 0a20 2020 2020 2020  t.shape).       
+00022bc0: 2020 2020 206c 6973 745f 6f66 5f64 6673       list_of_dfs
+00022bd0: 203d 205b 585f 7472 6169 6e2c 795f 7472   = [X_train,y_tr
+00022be0: 6169 6e2c 2058 5f76 616c 6964 2c20 795f  ain, X_valid, y_
+00022bf0: 7661 6c69 642c 2058 5f74 6573 742c 2079  valid, X_test, y
+00022c00: 5f74 6573 745d 0a20 2020 2020 2020 2020  _test].         
+00022c10: 2020 2070 7269 6e74 2827 5265 7475 726e     print('Return
+00022c20: 696e 6720 6120 5475 706c 6520 7769 7468  ing a Tuple with
+00022c30: 2073 6978 2064 6174 6166 7261 6d65 7320   six dataframes 
+00022c40: 616e 6420 7368 6170 6573 3a20 2825 7320  and shapes: (%s 
+00022c50: 2573 2025 7320 2573 2c25 732c 2573 2927  %s %s %s,%s,%s)'
+00022c60: 2025 280a 2020 2020 2020 2020 2020 2020   %(.            
+00022c70: 2020 2020 585f 7472 6169 6e2e 7368 6170      X_train.shap
+00022c80: 652c 795f 7472 6169 6e2e 7368 6170 652c  e,y_train.shape,
+00022c90: 2058 5f76 616c 6964 2e73 6861 7065 2c79   X_valid.shape,y
+00022ca0: 5f76 616c 6964 2e73 6861 7065 2c58 5f74  _valid.shape,X_t
+00022cb0: 6573 742e 7368 6170 652c 795f 7465 7374  est.shape,y_test
+00022cc0: 2e73 6861 7065 2929 0a20 2020 2020 2020  .shape)).       
+00022cd0: 2020 2020 2072 6574 7572 6e20 6c69 7374       return list
+00022ce0: 5f6f 665f 6466 730a 2020 2020 2020 2020  _of_dfs.        
+00022cf0: 656c 7365 3a0a 2020 2020 2020 2020 2020  else:.          
+00022d00: 2020 7072 696e 7428 274e 756d 6265 7220    print('Number 
+00022d10: 6f66 2073 706c 6974 7320 6d75 7374 2062  of splits must b
+00022d20: 6520 322c 2033 2c20 3420 6f72 2036 2729  e 2, 3, 4 or 6')
+00022d30: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
+00022d40: 7572 6e0a 2323 2323 2323 2323 2323 2323  urn.############
+00022d50: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00022d60: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00022d70: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00022d80: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00022d90: 2323 2323 2323 0a64 6566 2046 455f 636f  ######.def FE_co
+00022da0: 6e63 6174 656e 6174 655f 6d75 6c74 6970  ncatenate_multip
+00022db0: 6c65 5f63 6f6c 756d 6e73 2864 662c 2063  le_columns(df, c
+00022dc0: 6f6c 732c 2066 696c 6c65 723d 2220 222c  ols, filler=" ",
+00022dd0: 2064 726f 703d 5472 7565 293a 0a20 2020   drop=True):.   
+00022de0: 2022 2222 0a20 2020 2054 6869 7320 6861   """.    This ha
+00022df0: 6e64 7920 6675 6e63 7469 6f6e 2063 6f6d  ndy function com
+00022e00: 6269 6e65 7320 6d75 6c74 6970 6c65 2073  bines multiple s
+00022e10: 7472 696e 6720 636f 6c75 6d6e 7320 696e  tring columns in
+00022e20: 746f 2061 2073 696e 676c 6520 4e4c 5020  to a single NLP 
+00022e30: 7465 7874 2063 6f6c 756d 6e2e 0a20 2020  text column..   
+00022e40: 2059 6f75 2063 616e 2064 6f20 6675 7274   You can do furt
+00022e50: 6865 7220 7072 652d 7072 6f63 6573 7369  her pre-processi
+00022e60: 6e67 206f 6e20 7375 6368 2061 2063 6f6d  ng on such a com
+00022e70: 6269 6e65 6420 636f 6c75 6d6e 2077 6974  bined column wit
+00022e80: 6820 5446 4944 4620 6f72 2042 4552 5420  h TFIDF or BERT 
+00022e90: 7374 796c 6520 656d 6265 6464 696e 672e  style embedding.
+00022ea0: 0a0a 2020 2020 496e 7075 7473 0a20 2020  ..    Inputs.   
+00022eb0: 202d 2d2d 2d2d 2d2d 2d2d 0a20 2020 2020   ---------.     
+00022ec0: 2020 2064 663a 2070 616e 6461 7320 6461     df: pandas da
+00022ed0: 7461 6672 616d 650a 2020 2020 2020 2020  taframe.        
+00022ee0: 636f 6c73 3a20 7374 7269 6e67 2063 6f6c  cols: string col
+00022ef0: 756d 6e73 2074 6861 7420 796f 7520 7761  umns that you wa
+00022f00: 6e74 2074 6f20 636f 6e63 6174 656e 6174  nt to concatenat
+00022f10: 6520 696e 746f 2061 2073 696e 676c 6520  e into a single 
+00022f20: 636f 6d62 696e 6564 2063 6f6c 756d 6e0a  combined column.
+00022f30: 2020 2020 2020 2020 6669 6c6c 6572 3a20          filler: 
+00022f40: 7374 7269 6e67 2028 6465 6661 756c 743a  string (default:
+00022f50: 2022 2022 293a 2079 6f75 2063 616e 2069   " "): you can i
+00022f60: 6e70 7574 2061 6e79 2073 7472 696e 6720  nput any string 
+00022f70: 7468 6174 2079 6f75 2077 616e 7420 746f  that you want to
+00022f80: 2063 6f6d 6269 6e65 2074 6865 6d20 7769   combine them wi
+00022f90: 7468 2e0a 2020 2020 2020 2020 6472 6f70  th..        drop
+00022fa0: 3a20 6465 6661 756c 7420 5472 7565 2e20  : default True. 
+00022fb0: 4966 2054 7275 652c 2064 726f 7020 7468  If True, drop th
+00022fc0: 6520 636f 6c75 6d6e 7320 696e 7075 742e  e columns input.
+00022fd0: 2049 6620 4661 6c73 652c 206b 6565 7020   If False, keep 
+00022fe0: 7468 6520 636f 6c75 6d6e 732e 0a0a 2020  the columns...  
+00022ff0: 2020 4f75 7470 7574 733a 0a20 2020 202d    Outputs:.    -
+00023000: 2d2d 2d2d 2d2d 2d2d 2d0a 2020 2020 2020  ---------.      
+00023010: 2020 6466 3a20 7468 6572 6520 7769 6c6c    df: there will
+00023020: 2062 6520 6120 6e65 7720 636f 6c75 6d6e   be a new column
+00023030: 2063 616c 6c65 6420 5b27 636f 6d62 696e   called ['combin
+00023040: 6564 275d 2074 6861 7420 7769 6c6c 2062  ed'] that will b
+00023050: 6520 6164 6465 6420 746f 2079 6f75 7220  e added to your 
+00023060: 6461 7461 6672 616d 652e 0a20 2020 2022  dataframe..    "
+00023070: 2222 0a20 2020 2064 6620 3d20 6466 2e63  "".    df = df.c
+00023080: 6f70 7928 6465 6570 3d54 7275 6529 0a20  opy(deep=True). 
+00023090: 2020 2064 665b 2763 6f6d 6269 6e65 6427     df['combined'
+000230a0: 5d20 3d20 6466 5b63 6f6c 735d 2e61 7070  ] = df[cols].app
+000230b0: 6c79 286c 616d 6264 6120 726f 773a 2066  ly(lambda row: f
+000230c0: 696c 6c65 722e 6a6f 696e 2872 6f77 2e76  iller.join(row.v
+000230d0: 616c 7565 732e 6173 7479 7065 2873 7472  alues.astype(str
+000230e0: 2929 2c20 6178 6973 3d31 290a 2020 2020  )), axis=1).    
+000230f0: 6966 2064 726f 703a 0a20 2020 2020 2020  if drop:.       
+00023100: 2064 6620 3d20 6466 2e64 726f 7028 636f   df = df.drop(co
+00023110: 6c73 2c20 6178 6973 3d31 290a 2020 2020  ls, axis=1).    
+00023120: 7265 7475 726e 2064 660a 2323 2323 2323  return df.######
+00023130: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00023140: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00023150: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00023160: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00023170: 2323 2323 2323 2323 2323 2323 0a66 726f  ############.fro
+00023180: 6d20 736b 6c65 6172 6e2e 7072 6570 726f  m sklearn.prepro
+00023190: 6365 7373 696e 6720 696d 706f 7274 204b  cessing import K
+000231a0: 4269 6e73 4469 7363 7265 7469 7a65 720a  BinsDiscretizer.
+000231b0: 6672 6f6d 2073 6b6c 6561 726e 2e6d 6978  from sklearn.mix
+000231c0: 7475 7265 2069 6d70 6f72 7420 4761 7573  ture import Gaus
+000231d0: 7369 616e 4d69 7874 7572 650a 0a64 6566  sianMixture..def
+000231e0: 2046 455f 6469 7363 7265 7469 7a65 5f6e   FE_discretize_n
+000231f0: 756d 6572 6963 5f76 6172 6961 626c 6573  umeric_variables
+00023200: 2874 7261 696e 2c20 6269 6e5f 6469 6374  (train, bin_dict
+00023210: 2c20 7465 7374 3d27 272c 2073 7472 6174  , test='', strat
+00023220: 6567 793d 276b 6d65 616e 7327 2c76 6572  egy='kmeans',ver
+00023230: 626f 7365 3d30 293a 0a20 2020 2022 2222  bose=0):.    """
+00023240: 0a20 2020 2054 6869 7320 6861 6e64 7920  .    This handy 
+00023250: 6675 6e63 7469 6f6e 2064 6973 6372 6574  function discret
+00023260: 697a 6573 206e 756d 6572 6963 2076 6172  izes numeric var
+00023270: 6961 626c 6573 2069 6e74 6f20 6269 6e6e  iables into binn
+00023280: 6564 2076 6172 6961 626c 6573 2075 7369  ed variables usi
+00023290: 6e67 206b 6d65 616e 7320 616c 676f 7269  ng kmeans algori
+000232a0: 7468 6d2e 0a20 2020 2059 6f75 206e 6565  thm..    You nee
+000232b0: 6420 746f 2070 726f 7669 6465 2074 6865  d to provide the
+000232c0: 206e 616d 6573 206f 6620 7468 6520 7661   names of the va
+000232d0: 7269 6162 6c65 7320 616e 6420 7468 6520  riables and the 
+000232e0: 6e75 6d62 6572 7320 6f66 2062 696e 7320  numbers of bins 
+000232f0: 666f 7220 6561 6368 2076 6172 6961 626c  for each variabl
+00023300: 6520 696e 2061 2064 6963 7469 6f6e 6172  e in a dictionar
+00023310: 792e 0a20 2020 2049 7420 7769 6c6c 2072  y..    It will r
+00023320: 6574 7572 6e20 7468 6520 7361 6d65 2064  eturn the same d
+00023330: 6174 6166 7261 6d65 2077 6974 6820 6e65  ataframe with ne
+00023340: 7720 6269 6e6e 6564 2076 6172 6961 626c  w binned variabl
+00023350: 6573 2074 6861 7420 6974 2068 6173 2063  es that it has c
+00023360: 7265 6174 6564 2e0a 0a20 2020 2049 6e70  reated...    Inp
+00023370: 7574 733a 0a20 2020 202d 2d2d 2d2d 2d2d  uts:.    -------
+00023380: 2d2d 2d0a 2020 2020 6466 203a 2070 616e  ---.    df : pan
+00023390: 6461 7320 6461 7461 6672 616d 6520 2d20  das dataframe - 
+000233a0: 706c 6561 7365 2065 6e73 7572 6520 6974  please ensure it
+000233b0: 2069 7320 6120 6461 7461 6672 616d 652e   is a dataframe.
+000233c0: 204e 6f20 6172 7261 7973 2070 6c65 6173   No arrays pleas
+000233d0: 652e 0a20 2020 2062 696e 5f64 6963 743a  e..    bin_dict:
+000233e0: 2064 6963 7469 6f6e 6172 7920 6f66 206e   dictionary of n
+000233f0: 616d 6573 206f 6620 7661 7269 6162 6c65  ames of variable
+00023400: 7320 616e 6420 7468 6520 6269 6e73 2074  s and the bins t
+00023410: 6861 7420 796f 7520 7761 6e74 2066 6f72  hat you want for
+00023420: 2065 6163 6820 7661 7269 6162 6c65 2e0a   each variable..
+00023430: 2020 2020 7374 7261 7465 6779 3a20 6465      strategy: de
+00023440: 6661 756c 7420 6973 2027 6b6d 6561 6e73  fault is 'kmeans
+00023450: 273a 2062 7574 2079 6f75 2063 616e 2063  ': but you can c
+00023460: 686f 6f73 653a 207b 2767 6175 7573 6961  hoose: {'gauusia
+00023470: 6e27 2c27 756e 6966 6f72 6d27 2c20 2771  n','uniform', 'q
+00023480: 7561 6e74 696c 6527 2c20 276b 6d65 616e  uantile', 'kmean
+00023490: 7327 7d0a 0a20 2020 204f 7574 7075 7473  s'}..    Outputs
+000234a0: 3a0a 2020 2020 2d2d 2d2d 2d2d 2d2d 2d2d  :.    ----------
+000234b0: 0a20 2020 2064 663a 2070 616e 6461 7320  .    df: pandas 
+000234c0: 6461 7461 6672 616d 6520 7769 7468 206e  dataframe with n
+000234d0: 6577 2076 6172 6961 626c 6573 2077 6974  ew variables wit
+000234e0: 6820 6e61 6d65 7320 7375 6368 2061 733a  h names such as:
+000234f0: 2020 7661 7269 6162 6c65 2b27 5f64 6973    variable+'_dis
+00023500: 6372 6574 6527 0a20 2020 2022 2222 0a20  crete'.    """. 
+00023510: 2020 2064 6620 3d20 636f 7079 2e64 6565     df = copy.dee
+00023520: 7063 6f70 7928 7472 6169 6e29 0a20 2020  pcopy(train).   
+00023530: 2074 6573 7420 3d20 636f 7079 2e64 6565   test = copy.dee
+00023540: 7063 6f70 7928 7465 7374 290a 2020 2020  pcopy(test).    
+00023550: 6e75 6d5f 636f 6c73 203d 206c 656e 2862  num_cols = len(b
+00023560: 696e 5f64 6963 7429 0a20 2020 206e 726f  in_dict).    nro
+00023570: 7773 203d 2069 6e74 2828 6e75 6d5f 636f  ws = int((num_co
+00023580: 6c73 2f32 292b 302e 3529 0a20 2020 2023  ls/2)+0.5).    #
+00023590: 7072 696e 7428 276e 726f 7773 272c 6e72  print('nrows',nr
+000235a0: 6f77 7329 0a20 2020 2069 6620 7665 7262  ows).    if verb
+000235b0: 6f73 653a 0a20 2020 2020 2020 2066 6967  ose:.        fig
+000235c0: 203d 2070 6c74 2e66 6967 7572 6528 6669   = plt.figure(fi
+000235d0: 6773 697a 653d 2831 302c 332a 6e75 6d5f  gsize=(10,3*num_
+000235e0: 636f 6c73 2929 0a20 2020 2066 6f72 2069  cols)).    for i
+000235f0: 2c20 2863 6f6c 2c20 6269 6e76 616c 7565  , (col, binvalue
+00023600: 2920 696e 2065 6e75 6d65 7261 7465 2862  ) in enumerate(b
+00023610: 696e 5f64 6963 742e 6974 656d 7328 2929  in_dict.items())
+00023620: 3a0a 2020 2020 2020 2020 6e65 775f 636f  :.        new_co
+00023630: 6c20 3d20 636f 6c2b 275f 6469 7363 7265  l = col+'_discre
+00023640: 7465 270a 2020 2020 2020 2020 6966 2073  te'.        if s
+00023650: 7472 6174 6567 7920 3d3d 2027 6761 7573  trategy == 'gaus
+00023660: 7369 616e 273a 0a20 2020 2020 2020 2020  sian':.         
+00023670: 2020 206b 6264 203d 2047 6175 7373 6961     kbd = Gaussia
+00023680: 6e4d 6978 7475 7265 286e 5f63 6f6d 706f  nMixture(n_compo
+00023690: 6e65 6e74 733d 6269 6e76 616c 7565 2c20  nents=binvalue, 
+000236a0: 7261 6e64 6f6d 5f73 7461 7465 3d39 3929  random_state=99)
+000236b0: 0a20 2020 2020 2020 2020 2020 2064 665b  .            df[
+000236c0: 6e65 775f 636f 6c5d 203d 206b 6264 2e66  new_col] = kbd.f
+000236d0: 6974 5f70 7265 6469 6374 2864 665b 5b63  it_predict(df[[c
+000236e0: 6f6c 5d5d 292e 6173 7479 7065 2869 6e74  ol]]).astype(int
+000236f0: 290a 2020 2020 2020 2020 2020 2020 6966  ).            if
+00023700: 206e 6f74 2069 7369 6e73 7461 6e63 6528   not isinstance(
+00023710: 7465 7374 2c20 7374 7229 3a0a 2020 2020  test, str):.    
+00023720: 2020 2020 2020 2020 2020 2020 7465 7374              test
+00023730: 5b6e 6577 5f63 6f6c 5d20 3d20 6b62 642e  [new_col] = kbd.
+00023740: 7072 6564 6963 7428 7465 7374 5b5b 636f  predict(test[[co
+00023750: 6c5d 5d29 2e61 7374 7970 6528 696e 7429  l]]).astype(int)
+00023760: 0a20 2020 2020 2020 2065 6c73 653a 0a20  .        else:. 
+00023770: 2020 2020 2020 2020 2020 206b 6264 203d             kbd =
+00023780: 204b 4269 6e73 4469 7363 7265 7469 7a65   KBinsDiscretize
+00023790: 7228 6e5f 6269 6e73 3d62 696e 7661 6c75  r(n_bins=binvalu
+000237a0: 652c 2065 6e63 6f64 653d 276f 7264 696e  e, encode='ordin
+000237b0: 616c 272c 2073 7472 6174 6567 793d 7374  al', strategy=st
+000237c0: 7261 7465 6779 290a 2020 2020 2020 2020  rategy).        
+000237d0: 2020 2020 6466 5b6e 6577 5f63 6f6c 5d20      df[new_col] 
+000237e0: 3d20 6b62 642e 6669 745f 7472 616e 7366  = kbd.fit_transf
+000237f0: 6f72 6d28 6466 5b5b 636f 6c5d 5d29 2e61  orm(df[[col]]).a
+00023800: 7374 7970 6528 696e 7429 0a20 2020 2020  stype(int).     
+00023810: 2020 2020 2020 2069 6620 6e6f 7420 6973         if not is
+00023820: 696e 7374 616e 6365 2874 6573 742c 2073  instance(test, s
+00023830: 7472 293a 0a20 2020 2020 2020 2020 2020  tr):.           
+00023840: 2020 2020 2074 6573 745b 6e65 775f 636f       test[new_co
+00023850: 6c5d 203d 206b 6264 2e74 7261 6e73 666f  l] = kbd.transfo
+00023860: 726d 2874 6573 745b 5b63 6f6c 5d5d 292e  rm(test[[col]]).
+00023870: 6173 7479 7065 2869 6e74 290a 2020 2020  astype(int).    
+00023880: 2020 2020 6966 2076 6572 626f 7365 3a0a      if verbose:.
+00023890: 2020 2020 2020 2020 2020 2020 6178 3120              ax1 
+000238a0: 3d20 706c 742e 7375 6270 6c6f 7428 6e72  = plt.subplot(nr
+000238b0: 6f77 732c 322c 692b 3129 0a20 2020 2020  ows,2,i+1).     
+000238c0: 2020 2020 2020 2061 7831 2e73 6361 7474         ax1.scatt
+000238d0: 6572 2864 665b 636f 6c5d 2c64 665b 6e65  er(df[col],df[ne
+000238e0: 775f 636f 6c5d 290a 2020 2020 2020 2020  w_col]).        
+000238f0: 2020 2020 6178 312e 7365 745f 7469 746c      ax1.set_titl
+00023900: 6528 6e65 775f 636f 6c29 0a20 2020 2069  e(new_col).    i
+00023910: 6620 6e6f 7420 6973 696e 7374 616e 6365  f not isinstance
+00023920: 2874 6573 742c 2073 7472 293a 0a20 2020  (test, str):.   
+00023930: 2020 2020 2072 6574 7572 6e20 6466 2c20       return df, 
+00023940: 7465 7374 0a20 2020 2065 6c73 653a 0a20  test.    else:. 
+00023950: 2020 2020 2020 2072 6574 7572 6e20 6466         return df
+00023960: 0a23 2323 2323 2323 2323 2323 2323 2323  .###############
+00023970: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00023980: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00023990: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000239a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000239b0: 2323 230a 6465 6620 4645 5f74 7261 6e73  ###.def FE_trans
+000239c0: 666f 726d 5f6e 756d 6572 6963 5f63 6f6c  form_numeric_col
+000239d0: 756d 6e73 5f74 6f5f 6269 6e73 2864 662c  umns_to_bins(df,
+000239e0: 2062 696e 5f64 6963 742c 2076 6572 626f   bin_dict, verbo
+000239f0: 7365 3d30 293a 0a20 2020 2022 2222 0a20  se=0):.    """. 
+00023a00: 2020 2054 6869 7320 6861 6e64 7920 6675     This handy fu
+00023a10: 6e63 7469 6f6e 2064 6973 6372 6574 697a  nction discretiz
+00023a20: 6573 206e 756d 6572 6963 2076 6172 6961  es numeric varia
+00023a30: 626c 6573 2069 6e74 6f20 6269 6e6e 6564  bles into binned
+00023a40: 2076 6172 6961 626c 6573 2075 7369 6e67   variables using
+00023a50: 206b 6d65 616e 7320 616c 676f 7269 7468   kmeans algorith
+00023a60: 6d2e 0a20 2020 2059 6f75 206e 6565 6420  m..    You need 
+00023a70: 746f 2070 726f 7669 6465 2074 6865 206e  to provide the n
+00023a80: 616d 6573 206f 6620 7468 6520 7661 7269  ames of the vari
+00023a90: 6162 6c65 7320 616e 6420 7468 6520 6e75  ables and the nu
+00023aa0: 6d62 6572 7320 6f66 2062 696e 7320 666f  mbers of bins fo
+00023ab0: 7220 6561 6368 2076 6172 6961 626c 6520  r each variable 
+00023ac0: 696e 2061 2064 6963 7469 6f6e 6172 792e  in a dictionary.
+00023ad0: 0a20 2020 2049 7420 7769 6c6c 2072 6574  .    It will ret
+00023ae0: 7572 6e20 7468 6520 7361 6d65 2064 6174  urn the same dat
+00023af0: 6166 7261 6d65 2077 6974 6820 6e65 7720  aframe with new 
+00023b00: 6269 6e6e 6564 2076 6172 6961 626c 6573  binned variables
+00023b10: 2074 6861 7420 6974 2068 6173 2063 7265   that it has cre
+00023b20: 6174 6564 2e0a 0a20 2020 2049 6e70 7574  ated...    Input
+00023b30: 733a 0a20 2020 202d 2d2d 2d2d 2d2d 2d2d  s:.    ---------
+00023b40: 2d0a 2020 2020 6466 203a 2070 616e 6461  -.    df : panda
+00023b50: 7320 6461 7461 6672 616d 6520 2d20 706c  s dataframe - pl
+00023b60: 6561 7365 2065 6e73 7572 6520 6974 2069  ease ensure it i
+00023b70: 7320 6120 6461 7461 6672 616d 652e 204e  s a dataframe. N
+00023b80: 6f20 6172 7261 7973 2070 6c65 6173 652e  o arrays please.
+00023b90: 0a20 2020 2062 696e 5f64 6963 743a 2064  .    bin_dict: d
+00023ba0: 6963 7469 6f6e 6172 7920 6f66 206e 616d  ictionary of nam
+00023bb0: 6573 206f 6620 7661 7269 6162 6c65 7320  es of variables 
+00023bc0: 616e 6420 7468 6520 6b69 6e64 206f 6620  and the kind of 
+00023bd0: 7472 616e 7366 6f72 6d61 7469 6f6e 2079  transformation y
+00023be0: 6f75 2077 616e 740a 2020 2020 2020 2020  ou want.        
+00023bf0: 6465 6661 756c 7420 6973 2027 6c6f 6727  default is 'log'
+00023c00: 3a20 6275 7420 796f 7520 6361 6e20 6368  : but you can ch
+00023c10: 6f6f 7365 3a20 7b27 6c6f 6727 2c27 6c6f  oose: {'log','lo
+00023c20: 6731 3027 2c20 2773 7172 7427 2c20 276d  g10', 'sqrt', 'm
+00023c30: 6178 2d61 6273 277d 0a0a 2020 2020 4f75  ax-abs'}..    Ou
+00023c40: 7470 7574 733a 0a20 2020 202d 2d2d 2d2d  tputs:.    -----
+00023c50: 2d2d 2d2d 2d0a 2020 2020 6466 3a20 7061  -----.    df: pa
+00023c60: 6e64 6173 2064 6174 6166 7261 6d65 2077  ndas dataframe w
+00023c70: 6974 6820 6e65 7720 7661 7269 6162 6c65  ith new variable
+00023c80: 7320 7769 7468 206e 616d 6573 2073 7563  s with names suc
+00023c90: 6820 6173 3a20 2076 6172 6961 626c 652b  h as:  variable+
+00023ca0: 275f 6469 7363 7265 7465 270a 2020 2020  '_discrete'.    
+00023cb0: 2222 220a 2020 2020 6466 203d 2063 6f70  """.    df = cop
+00023cc0: 792e 6465 6570 636f 7079 2864 6629 0a20  y.deepcopy(df). 
+00023cd0: 2020 206e 756d 5f63 6f6c 7320 3d20 6c65     num_cols = le
+00023ce0: 6e28 6269 6e5f 6469 6374 290a 2020 2020  n(bin_dict).    
+00023cf0: 6e72 6f77 7320 3d20 696e 7428 286e 756d  nrows = int((num
+00023d00: 5f63 6f6c 732f 3229 2b30 2e35 290a 2020  _cols/2)+0.5).  
+00023d10: 2020 6966 2076 6572 626f 7365 3a0a 2020    if verbose:.  
+00023d20: 2020 2020 2020 6669 6720 3d20 706c 742e        fig = plt.
+00023d30: 6669 6775 7265 2866 6967 7369 7a65 3d28  figure(figsize=(
+00023d40: 3130 2c33 2a6e 756d 5f63 6f6c 7329 290a  10,3*num_cols)).
+00023d50: 2020 2020 666f 7220 692c 2028 636f 6c2c      for i, (col,
+00023d60: 2062 696e 7661 6c75 6529 2069 6e20 656e   binvalue) in en
+00023d70: 756d 6572 6174 6528 6269 6e5f 6469 6374  umerate(bin_dict
+00023d80: 2e69 7465 6d73 2829 293a 0a20 2020 2020  .items()):.     
+00023d90: 2020 206e 6577 5f63 6f6c 203d 2063 6f6c     new_col = col
+00023da0: 2b27 5f27 2b62 696e 7661 6c75 650a 2020  +'_'+binvalue.  
+00023db0: 2020 2020 2020 6966 2062 696e 7661 6c75        if binvalu
+00023dc0: 6520 3d3d 2027 6c6f 6727 3a0a 2020 2020  e == 'log':.    
+00023dd0: 2020 2020 2020 2020 7072 696e 7428 2757          print('W
+00023de0: 6172 6e69 6e67 3a20 4e65 6761 7469 7665  arning: Negative
+00023df0: 2076 616c 7565 7320 696e 2025 7320 6861   values in %s ha
+00023e00: 7665 2062 6565 6e20 6d61 6465 2070 6f73  ve been made pos
+00023e10: 6974 6976 6520 6265 666f 7265 206c 6f67  itive before log
+00023e20: 2074 7261 6e73 666f 726d 2127 2025 636f   transform!' %co
+00023e30: 6c29 0a20 2020 2020 2020 2020 2020 2064  l).            d
+00023e40: 662e 6c6f 635b 6466 5b63 6f6c 5d3d 3d30  f.loc[df[col]==0
+00023e50: 2c63 6f6c 5d20 3d20 3165 2d31 3520 2023  ,col] = 1e-15  #
+00023e60: 2323 206d 616b 6520 6974 2061 2073 6d61  ## make it a sma
+00023e70: 6c6c 206e 756d 6265 720a 2020 2020 2020  ll number.      
+00023e80: 2020 2020 2020 6466 5b6e 6577 5f63 6f6c        df[new_col
+00023e90: 5d20 3d20 6e70 2e61 6273 2864 665b 636f  ] = np.abs(df[co
+00023ea0: 6c5d 2e76 616c 7565 7329 0a20 2020 2020  l].values).     
+00023eb0: 2020 2020 2020 2064 665b 6e65 775f 636f         df[new_co
+00023ec0: 6c5d 203d 206e 702e 6c6f 6728 6466 5b6e  l] = np.log(df[n
+00023ed0: 6577 5f63 6f6c 5d29 2e76 616c 7565 730a  ew_col]).values.
+00023ee0: 2020 2020 2020 2020 656c 6966 2062 696e          elif bin
+00023ef0: 7661 6c75 6520 3d3d 2027 6c6f 6731 3027  value == 'log10'
+00023f00: 3a0a 2020 2020 2020 2020 2020 2020 7072  :.            pr
+00023f10: 696e 7428 2757 6172 6e69 6e67 3a20 4e65  int('Warning: Ne
+00023f20: 6761 7469 7665 2076 616c 7565 7320 696e  gative values in
+00023f30: 2025 7320 6861 7665 2062 6565 6e20 6d61   %s have been ma
+00023f40: 6465 2070 6f73 6974 6976 6520 6265 666f  de positive befo
+00023f50: 7265 206c 6f67 3130 2074 7261 6e73 666f  re log10 transfo
+00023f60: 726d 2127 2025 636f 6c29 0a20 2020 2020  rm!' %col).     
+00023f70: 2020 2020 2020 2064 662e 6c6f 635b 6466         df.loc[df
+00023f80: 5b63 6f6c 5d3d 3d30 2c63 6f6c 5d20 3d20  [col]==0,col] = 
+00023f90: 3165 2d31 3520 2023 2323 206d 616b 6520  1e-15  ### make 
+00023fa0: 6974 2061 2073 6d61 6c6c 206e 756d 6265  it a small numbe
+00023fb0: 720a 2020 2020 2020 2020 2020 2020 6466  r.            df
+00023fc0: 5b6e 6577 5f63 6f6c 5d20 3d20 6e70 2e61  [new_col] = np.a
+00023fd0: 6273 2864 665b 636f 6c5d 2e76 616c 7565  bs(df[col].value
+00023fe0: 7329 0a20 2020 2020 2020 2020 2020 2064  s).            d
+00023ff0: 665b 6e65 775f 636f 6c5d 203d 206e 702e  f[new_col] = np.
+00024000: 6c6f 6731 3028 6466 5b6e 6577 5f63 6f6c  log10(df[new_col
+00024010: 5d29 2e76 616c 7565 730a 2020 2020 2020  ]).values.      
+00024020: 2020 656c 6966 2062 696e 7661 6c75 6520    elif binvalue 
+00024030: 3d3d 2027 7371 7274 273a 0a20 2020 2020  == 'sqrt':.     
+00024040: 2020 2020 2020 2070 7269 6e74 2827 5761         print('Wa
+00024050: 726e 696e 673a 204e 6567 6174 6976 6520  rning: Negative 
+00024060: 7661 6c75 6573 2069 6e20 2573 2068 6176  values in %s hav
+00024070: 6520 6265 656e 206d 6164 6520 706f 7369  e been made posi
+00024080: 7469 7665 2062 6566 6f72 6520 7371 7274  tive before sqrt
+00024090: 2074 7261 6e73 666f 726d 2127 2025 636f   transform!' %co
+000240a0: 6c29 0a20 2020 2020 2020 2020 2020 2064  l).            d
+000240b0: 665b 6e65 775f 636f 6c5d 203d 206e 702e  f[new_col] = np.
+000240c0: 6162 7328 6466 5b63 6f6c 5d2e 7661 6c75  abs(df[col].valu
+000240d0: 6573 2920 2023 2323 206d 616b 6520 6974  es)  ### make it
+000240e0: 2061 2073 6d61 6c6c 206e 756d 6265 720a   a small number.
+000240f0: 2020 2020 2020 2020 2020 2020 6466 5b6e              df[n
+00024100: 6577 5f63 6f6c 5d20 3d20 6e70 2e73 7172  ew_col] = np.sqr
+00024110: 7428 6466 5b6e 6577 5f63 6f6c 5d29 2e76  t(df[new_col]).v
+00024120: 616c 7565 730a 2020 2020 2020 2020 656c  alues.        el
+00024130: 6966 2062 696e 7661 6c75 6520 3d3d 2027  if binvalue == '
+00024140: 6d61 782d 6162 7327 3a0a 2020 2020 2020  max-abs':.      
+00024150: 2020 2020 2020 7072 696e 7428 2757 6172        print('War
+00024160: 6e69 6e67 3a20 4e65 6761 7469 7665 2076  ning: Negative v
+00024170: 616c 7565 7320 696e 2025 7320 6861 7665  alues in %s have
+00024180: 2062 6565 6e20 6d61 6465 2070 6f73 6974   been made posit
+00024190: 6976 6520 6265 666f 7265 206d 6178 2d61  ive before max-a
+000241a0: 6273 2074 7261 6e73 666f 726d 2127 2025  bs transform!' %
+000241b0: 636f 6c29 0a20 2020 2020 2020 2020 2020  col).           
+000241c0: 2063 6f6c 5f6d 6178 203d 206d 6178 286e   col_max = max(n
+000241d0: 702e 6162 7328 6466 5b63 6f6c 5d2e 7661  p.abs(df[col].va
+000241e0: 6c75 6573 2929 0a20 2020 2020 2020 2020  lues)).         
+000241f0: 2020 2069 6620 636f 6c5f 6d61 7820 3d3d     if col_max ==
+00024200: 2030 3a0a 2020 2020 2020 2020 2020 2020   0:.            
+00024210: 2020 2020 636f 6c5f 6d61 7820 3d20 310a      col_max = 1.
+00024220: 2020 2020 2020 2020 2020 2020 6466 5b6e              df[n
+00024230: 6577 5f63 6f6c 5d20 3d20 6e70 2e61 6273  ew_col] = np.abs
+00024240: 2864 665b 636f 6c5d 2e76 616c 7565 7329  (df[col].values)
+00024250: 2f63 6f6c 5f6d 6178 0a20 2020 2020 2020  /col_max.       
+00024260: 2065 6c73 653a 0a20 2020 2020 2020 2020   else:.         
+00024270: 2020 2070 7269 6e74 2827 5761 726e 696e     print('Warnin
+00024280: 673a 204e 6567 6174 6976 6520 7661 6c75  g: Negative valu
+00024290: 6573 2069 6e20 2573 2068 6176 6520 6265  es in %s have be
+000242a0: 656e 206d 6164 6520 706f 7369 7469 7665  en made positive
+000242b0: 2062 6566 6f72 6520 6c6f 6720 7472 616e   before log tran
+000242c0: 7366 6f72 6d21 2720 2563 6f6c 290a 2020  sform!' %col).  
+000242d0: 2020 2020 2020 2020 2020 6466 2e6c 6f63            df.loc
+000242e0: 5b64 665b 636f 6c5d 3d3d 302c 636f 6c5d  [df[col]==0,col]
+000242f0: 203d 2031 652d 3135 2020 2323 2320 6d61   = 1e-15  ### ma
+00024300: 6b65 2069 7420 6120 736d 616c 6c20 6e75  ke it a small nu
+00024310: 6d62 6572 0a20 2020 2020 2020 2020 2020  mber.           
+00024320: 2064 665b 6e65 775f 636f 6c5d 203d 206e   df[new_col] = n
+00024330: 702e 6162 7328 6466 5b63 6f6c 5d2e 7661  p.abs(df[col].va
+00024340: 6c75 6573 290a 2020 2020 2020 2020 2020  lues).          
+00024350: 2020 6466 5b6e 6577 5f63 6f6c 5d20 3d20    df[new_col] = 
+00024360: 6e70 2e6c 6f67 2864 665b 6e65 775f 636f  np.log(df[new_co
+00024370: 6c5d 292e 7661 6c75 6573 0a20 2020 2020  l]).values.     
+00024380: 2020 2069 6620 7665 7262 6f73 653a 0a20     if verbose:. 
+00024390: 2020 2020 2020 2020 2020 2061 7831 203d             ax1 =
+000243a0: 2070 6c74 2e73 7562 706c 6f74 286e 726f   plt.subplot(nro
+000243b0: 7773 2c32 2c69 2b31 290a 2020 2020 2020  ws,2,i+1).      
+000243c0: 2020 2020 2020 6466 5b63 6f6c 5d2e 706c        df[col].pl
+000243d0: 6f74 2e6b 6465 2861 783d 6178 312c 206c  ot.kde(ax=ax1, l
+000243e0: 6162 656c 3d63 6f6c 2c61 6c70 6861 3d30  abel=col,alpha=0
+000243f0: 2e35 2c63 6f6c 6f72 3d27 7227 290a 2020  .5,color='r').  
+00024400: 2020 2020 2020 2020 2020 6178 3220 3d20            ax2 = 
+00024410: 6178 312e 7477 696e 7928 290a 2020 2020  ax1.twiny().    
+00024420: 2020 2020 2020 2020 6466 5b6e 6577 5f63          df[new_c
+00024430: 6f6c 5d2e 706c 6f74 2e6b 6465 2861 783d  ol].plot.kde(ax=
+00024440: 6178 322c 6c61 6265 6c3d 6e65 775f 636f  ax2,label=new_co
+00024450: 6c2c 616c 7068 613d 302e 352c 636f 6c6f  l,alpha=0.5,colo
+00024460: 723d 2762 2729 0a20 2020 2020 2020 2020  r='b').         
+00024470: 2020 2070 6c74 2e6c 6567 656e 6428 293b     plt.legend();
+00024480: 0a20 2020 2072 6574 7572 6e20 6466 0a23  .    return df.#
+00024490: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000244a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000244b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000244c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000244d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000244e0: 0a66 726f 6d20 6974 6572 746f 6f6c 7320  .from itertools 
+000244f0: 696d 706f 7274 2063 7963 6c65 2c20 636f  import cycle, co
+00024500: 6d62 696e 6174 696f 6e73 0a64 6566 2046  mbinations.def F
+00024510: 455f 6372 6561 7465 5f69 6e74 6572 6163  E_create_interac
+00024520: 7469 6f6e 5f76 6172 7328 6466 2c20 696e  tion_vars(df, in
+00024530: 7478 6e5f 7661 7273 293a 0a20 2020 2022  txn_vars):.    "
+00024540: 2222 0a20 2020 2054 6869 7320 6861 6e64  "".    This hand
+00024550: 7920 6675 6e63 7469 6f6e 2063 7265 6174  y function creat
+00024560: 6573 2069 6e74 6572 6163 7469 6f6e 2076  es interaction v
+00024570: 6172 6961 626c 6573 2061 6d6f 6e67 2070  ariables among p
+00024580: 6169 7273 206f 6620 6e75 6d65 7269 6320  airs of numeric 
+00024590: 7661 7273 2079 6f75 2073 656e 6420 696e  vars you send in
+000245a0: 2e0a 2020 2020 596f 7572 2069 6e70 7574  ..    Your input
+000245b0: 206d 7573 7420 6265 2061 2064 6174 6166   must be a dataf
+000245c0: 7261 6d65 2061 6e64 2061 206c 6973 7420  rame and a list 
+000245d0: 6f66 2074 7570 6c65 732e 2045 6163 6820  of tuples. Each 
+000245e0: 7475 706c 6520 6d75 7374 2063 6f6e 7461  tuple must conta
+000245f0: 696e 2061 2070 6169 7220 6f66 2076 6172  in a pair of var
+00024600: 6961 626c 6573 2e0a 2020 2020 416c 6c20  iables..    All 
+00024610: 7661 7269 6162 6c65 7320 6d75 7374 2062  variables must b
+00024620: 6520 6e75 6d65 7269 632e 2044 6f75 626c  e numeric. Doubl
+00024630: 6520 6368 6563 6b20 796f 7572 2069 6e70  e check your inp
+00024640: 7574 2062 6566 6f72 6520 7365 6e64 696e  ut before sendin
+00024650: 6720 7468 656d 2069 6e2e 0a20 2020 2022  g them in..    "
+00024660: 2222 0a20 2020 2069 6620 7479 7065 2864  "".    if type(d
+00024670: 6629 203d 3d20 6461 736b 2e64 6174 6166  f) == dask.dataf
+00024680: 7261 6d65 2e63 6f72 652e 4461 7461 4672  rame.core.DataFr
+00024690: 616d 653a 0a20 2020 2020 2020 2023 2320  ame:.        ## 
+000246a0: 736b 6970 2069 6620 6974 2069 7320 6120  skip if it is a 
+000246b0: 6461 736b 2064 6174 6166 7261 6d65 2023  dask dataframe #
+000246c0: 2323 230a 2020 2020 2020 2020 7061 7373  ###.        pass
+000246d0: 0a20 2020 2065 6c73 653a 0a20 2020 2020  .    else:.     
+000246e0: 2020 2064 6620 3d20 6466 2e63 6f70 7928     df = df.copy(
+000246f0: 6465 6570 3d54 7275 6529 0a20 2020 2063  deep=True).    c
+00024700: 6f6d 626f 7320 3d20 636f 6d62 696e 6174  ombos = combinat
+00024710: 696f 6e73 2869 6e74 786e 5f76 6172 732c  ions(intxn_vars,
+00024720: 2032 290a 2020 2020 2323 2320 4920 6861   2).    ### I ha
+00024730: 7665 2074 6573 7465 6420 7468 6973 2066  ve tested this f
+00024740: 6f72 2062 6f74 6820 6361 7465 676f 7279  or both category
+00024750: 2061 6e64 206f 626a 6563 7420 6474 7970   and object dtyp
+00024760: 6573 2073 6f20 646f 6e27 7420 776f 7272  es so don't worr
+00024770: 7920 2323 230a 2020 2020 666f 7220 2865  y ###.    for (e
+00024780: 6163 685f 696e 7478 6e31 2c65 6163 685f  ach_intxn1,each_
+00024790: 696e 7478 6e32 2920 2069 6e20 636f 6d62  intxn2)  in comb
+000247a0: 6f73 3a0a 2020 2020 2020 2020 6e65 775f  os:.        new_
+000247b0: 636f 6c20 3d20 6561 6368 5f69 6e74 786e  col = each_intxn
+000247c0: 3120 2b20 275f 785f 2720 2b20 6561 6368  1 + '_x_' + each
+000247d0: 5f69 6e74 786e 320a 2020 2020 2020 2020  _intxn2.        
+000247e0: 7472 793a 0a20 2020 2020 2020 2020 2020  try:.           
+000247f0: 2064 665b 6e65 775f 636f 6c5d 203d 2064   df[new_col] = d
+00024800: 665b 6561 6368 5f69 6e74 786e 315d 2e61  f[each_intxn1].a
+00024810: 7374 7970 6528 7374 7229 202b 2027 2027  stype(str) + ' '
+00024820: 202b 2064 665b 6561 6368 5f69 6e74 786e   + df[each_intxn
+00024830: 325d 2e61 7374 7970 6528 7374 7229 0a20  2].astype(str). 
+00024840: 2020 2020 2020 2065 7863 6570 743a 0a20         except:. 
+00024850: 2020 2020 2020 2020 2020 2063 6f6e 7469             conti
+00024860: 6e75 650a 2020 2020 2323 2320 7468 6973  nue.    ### this
+00024870: 2077 696c 6c20 7265 7475 726e 2065 7874   will return ext
+00024880: 7261 2066 6561 7475 7265 7320 6765 6e65  ra features gene
+00024890: 7261 7465 6420 6279 2069 6e74 6572 6163  rated by interac
+000248a0: 7469 6f6e 7320 2323 2323 2020 2020 0a20  tions ####    . 
+000248b0: 2020 2072 6574 7572 6e20 6466 0a23 2323     return df.###
+000248c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000248d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000248e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000248f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00024900: 2323 2323 2323 2323 2323 2323 2323 230a  ###############.
+00024910: 696d 706f 7274 206d 6174 706c 6f74 6c69  import matplotli
+00024920: 622e 7079 706c 6f74 2061 7320 706c 740a  b.pyplot as plt.
+00024930: 6465 6620 4544 415f 6269 6e6e 696e 675f  def EDA_binning_
+00024940: 6e75 6d65 7269 635f 636f 6c75 6d6e 5f64  numeric_column_d
+00024950: 6973 706c 6179 696e 675f 6269 6e73 2864  isplaying_bins(d
+00024960: 6674 2c20 7461 7267 6574 2c20 6269 6e73  ft, target, bins
+00024970: 3d34 2c20 7465 7374 3d22 2229 3a0a 2020  =4, test=""):.  
+00024980: 2020 2222 220a 2020 2020 5468 6973 2073    """.    This s
+00024990: 706c 6974 7320 7468 6520 6461 7461 2063  plits the data c
+000249a0: 6f6c 756d 6e20 696e 746f 2074 6865 206e  olumn into the n
+000249b0: 756d 6265 7220 6f66 2062 696e 7320 7370  umber of bins sp
+000249c0: 6563 6966 6965 6420 616e 6420 7265 7475  ecified and retu
+000249d0: 726e 7320 6c61 6265 6c73 2c20 6269 6e73  rns labels, bins
+000249e0: 2c20 616e 6420 6461 7461 6672 616d 652e  , and dataframe.
+000249f0: 0a20 2020 204f 7574 7075 7473 3a0a 2020  .    Outputs:.  
+00024a00: 2020 2020 206c 6162 656c 7320 3d20 7468       labels = th
+00024a10: 6520 6e61 6d65 7320 6f66 2074 6865 2062  e names of the b
+00024a20: 696e 730a 2020 2020 2020 2065 6467 6573  ins.       edges
+00024a30: 203d 2074 6865 2065 6467 6573 206f 6620   = the edges of 
+00024a40: 7468 6520 6269 6e73 0a20 2020 2020 2020  the bins.       
+00024a50: 6466 7420 3d20 7468 6520 6461 7461 6672  dft = the datafr
+00024a60: 616d 6520 7769 7468 2061 6e20 6164 6465  ame with an adde
+00024a70: 6420 636f 6c75 6d6e 2063 616c 6c65 6420  d column called 
+00024a80: 2262 696e 6e65 645f 222b 6e61 6d65 206f  "binned_"+name o
+00024a90: 6620 7468 6520 636f 6c75 6d6e 2079 6f75  f the column you
+00024aa0: 2073 656e 7420 696e 0a20 2020 2022 2222   sent in.    """
+00024ab0: 0a20 2020 2064 6674 203d 2063 6f70 792e  .    dft = copy.
+00024ac0: 6465 6570 636f 7079 2864 6674 290a 2020  deepcopy(dft).  
+00024ad0: 2020 5f2c 2065 6467 6573 203d 2070 642e    _, edges = pd.
+00024ae0: 7163 7574 2864 6674 5b74 6172 6765 745d  qcut(dft[target]
+00024af0: 2e64 726f 706e 6128 6178 6973 3d30 292c  .dropna(axis=0),
+00024b00: 713d 6269 6e73 2c20 7265 7462 696e 733d  q=bins, retbins=
+00024b10: 5472 7565 2c20 6475 706c 6963 6174 6573  True, duplicates
+00024b20: 3d27 6472 6f70 2729 0a20 2020 2023 2323  ='drop').    ###
+00024b30: 206e 6f77 2077 6520 6372 6561 7465 2061   now we create a
+00024b40: 7274 6966 6963 6961 6c20 6c61 6265 6c73  rtificial labels
+00024b50: 2074 6f20 6d61 7463 6820 7468 6520 6269   to match the bi
+00024b60: 6e73 2065 6467 6573 2023 2323 230a 2020  ns edges ####.  
+00024b70: 2020 6c73 203d 205b 5d0a 2020 2020 666f    ls = [].    fo
+00024b80: 7220 692c 2078 2069 6e20 656e 756d 6572  r i, x in enumer
+00024b90: 6174 6528 6564 6765 7329 3a0a 2020 2020  ate(edges):.    
+00024ba0: 2020 2020 2370 7269 6e74 2827 6920 3d20      #print('i = 
+00024bb0: 2573 2c20 6e65 7874 2069 203d 2025 7327  %s, next i = %s'
+00024bc0: 2025 2869 2c69 2b31 2929 0a20 2020 2020   %(i,i+1)).     
+00024bd0: 2020 2069 6620 6920 3c20 6c65 6e28 6564     if i < len(ed
+00024be0: 6765 7329 2d31 3a0a 2020 2020 2020 2020  ges)-1:.        
+00024bf0: 2020 2020 6c73 2e61 7070 656e 6428 2766      ls.append('f
+00024c00: 726f 6d5f 272b 7374 7228 726f 756e 6428  rom_'+str(round(
+00024c10: 6564 6765 735b 695d 2c33 2929 2b27 5f74  edges[i],3))+'_t
+00024c20: 6f5f 272b 7374 7228 726f 756e 6428 6564  o_'+str(round(ed
+00024c30: 6765 735b 692b 315d 2c33 2929 290a 2020  ges[i+1],3))).  
+00024c40: 2020 2323 2323 2320 4e65 7874 2077 6520    ##### Next we 
+00024c50: 6164 6420 6120 636f 6c75 6d6e 2074 6f20  add a column to 
+00024c60: 686f 6c64 2074 6865 2062 696e 7320 6372  hold the bins cr
+00024c70: 6561 7465 6420 6279 2061 626f 7665 2023  eated by above #
+00024c80: 2323 2323 2323 2323 2323 2323 2323 0a20  ##############. 
+00024c90: 2020 2064 6674 5b27 6269 6e6e 6564 5f27     dft['binned_'
+00024ca0: 2b74 6172 6765 745d 203d 2070 642e 6375  +target] = pd.cu
+00024cb0: 7428 6466 745b 7461 7267 6574 5d2c 2062  t(dft[target], b
+00024cc0: 696e 733d 6564 6765 732c 2072 6574 6269  ins=edges, retbi
+00024cd0: 6e73 3d46 616c 7365 2c20 6c61 6265 6c73  ns=False, labels
+00024ce0: 3d6c 732c 2069 6e63 6c75 6465 5f6c 6f77  =ls, include_low
+00024cf0: 6573 743d 5472 7565 292e 7661 6c75 6573  est=True).values
+00024d00: 2e74 6f6c 6973 7428 290a 2020 2020 6966  .tolist().    if
+00024d10: 206e 6f74 2069 7369 6e73 7461 6e63 6528   not isinstance(
+00024d20: 7465 7374 2c20 7374 7229 3a0a 2020 2020  test, str):.    
+00024d30: 2020 2020 7465 7374 5b27 6269 6e6e 6564      test['binned
+00024d40: 5f27 2b74 6172 6765 745d 203d 2070 642e  _'+target] = pd.
+00024d50: 6375 7428 7465 7374 5b74 6172 6765 745d  cut(test[target]
+00024d60: 2c20 6269 6e73 3d65 6467 6573 2c20 7265  , bins=edges, re
+00024d70: 7462 696e 733d 4661 6c73 652c 206c 6162  tbins=False, lab
+00024d80: 656c 733d 6c73 2c20 696e 636c 7564 655f  els=ls, include_
+00024d90: 6c6f 7765 7374 3d54 7275 6529 2e76 616c  lowest=True).val
+00024da0: 7565 732e 746f 6c69 7374 2829 0a20 2020  ues.tolist().   
+00024db0: 206e 726f 7773 203d 2069 6e74 286c 656e   nrows = int(len
+00024dc0: 2865 6467 6573 292f 3220 2b20 3129 0a20  (edges)/2 + 1). 
+00024dd0: 2020 2070 6c74 2e66 6967 7572 6528 6669     plt.figure(fi
+00024de0: 6773 697a 653d 2831 352c 6e72 6f77 732a  gsize=(15,nrows*
+00024df0: 3329 290a 2020 2020 706c 742e 7375 6270  3)).    plt.subp
+00024e00: 6c6f 7473 5f61 646a 7573 7428 6873 7061  lots_adjust(hspa
+00024e10: 6365 3d2e 3529 0a20 2020 2063 6f6c 6c65  ce=.5).    colle
+00024e20: 6374 5f62 696e 7320 3d20 5b5d 0a20 2020  ct_bins = [].   
+00024e30: 2066 6f72 2069 2069 6e20 7261 6e67 6528   for i in range(
+00024e40: 6c65 6e28 6564 6765 7329 293a 0a20 2020  len(edges)):.   
+00024e50: 2020 2020 2069 6620 6920 3d3d 2030 3a0a       if i == 0:.
+00024e60: 2020 2020 2020 2020 2020 2020 636f 6e74              cont
+00024e70: 696e 7565 0a20 2020 2020 2020 2065 6c73  inue.        els
+00024e80: 653a 0a20 2020 2020 2020 2020 2020 2064  e:.            d
+00024e90: 6674 6320 3d20 6466 745b 2864 6674 5b74  ftc = dft[(dft[t
+00024ea0: 6172 6765 745d 3e65 6467 6573 5b69 2d31  arget]>edges[i-1
+00024eb0: 5d29 2026 2028 6466 745b 7461 7267 6574  ]) & (dft[target
+00024ec0: 5d3c 3d65 6467 6573 5b69 5d29 5d0a 2020  ]<=edges[i])].  
+00024ed0: 2020 2020 2020 2020 2020 636f 6c6c 6563            collec
+00024ee0: 745f 6269 6e73 2e61 7070 656e 6428 6466  t_bins.append(df
+00024ef0: 7463 290a 2020 2020 2020 2020 2020 2020  tc).            
+00024f00: 6178 3120 3d20 706c 742e 7375 6270 6c6f  ax1 = plt.subplo
+00024f10: 7428 6e72 6f77 732c 2032 2c20 6929 0a20  t(nrows, 2, i). 
+00024f20: 2020 2020 2020 2020 2020 2064 6674 635b             dftc[
+00024f30: 7461 7267 6574 5d2e 6869 7374 2862 696e  target].hist(bin
+00024f40: 733d 3330 2c20 6178 3d61 7831 290a 2020  s=30, ax=ax1).  
+00024f50: 2020 2020 2020 2020 2020 6178 312e 7365            ax1.se
+00024f60: 745f 7469 746c 6528 2762 696e 2025 643a  t_title('bin %d:
+00024f70: 2073 697a 653a 2025 642c 2025 7320 2530   size: %d, %s %0
+00024f80: 2e32 6620 746f 2025 302e 3266 2720 2528  .2f to %0.2f' %(
+00024f90: 692c 2064 6674 632e 7368 6170 655b 305d  i, dftc.shape[0]
+00024fa0: 2c20 7461 7267 6574 2c0a 2020 2020 2020  , target,.      
+00024fb0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00024fc0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00024fd0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00024fe0: 2020 2020 2020 2020 2020 2020 6564 6765              edge
+00024ff0: 735b 692d 315d 2c20 6564 6765 735b 695d  s[i-1], edges[i]
+00025000: 2929 0a20 2020 2072 6574 7572 6e20 6c73  )).    return ls
+00025010: 2c20 6564 6765 732c 2064 6674 2c20 7465  , edges, dft, te
+00025020: 7374 0a23 2323 2323 2323 2323 2323 2323  st.#############
+00025030: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00025040: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00025050: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00025060: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00025070: 2323 2323 2323 2323 2323 2323 0a66 726f  ############.fro
+00025080: 6d20 7061 7468 6c69 6220 696d 706f 7274  m pathlib import
+00025090: 2050 6174 680a 696d 706f 7274 206d 6174   Path.import mat
+000250a0: 706c 6f74 6c69 622e 7079 706c 6f74 2061  plotlib.pyplot a
+000250b0: 7320 706c 740a 696d 706f 7274 2073 6561  s plt.import sea
+000250c0: 626f 726e 2061 7320 736e 730a 6672 6f6d  born as sns.from
+000250d0: 2064 6174 6574 696d 6520 696d 706f 7274   datetime import
+000250e0: 2064 6174 6574 696d 652c 2064 6174 650a   datetime, date.
+000250f0: 6672 6f6d 2073 6b6c 6561 726e 2e6d 6574  from sklearn.met
+00025100: 7269 6373 2069 6d70 6f72 7420 6d65 616e  rics import mean
+00025110: 5f73 7175 6172 6564 5f65 7272 6f72 2c20  _squared_error, 
+00025120: 726f 635f 6175 635f 7363 6f72 650a 6672  roc_auc_score.fr
+00025130: 6f6d 2073 6b6c 6561 726e 2e70 7265 7072  om sklearn.prepr
+00025140: 6f63 6573 7369 6e67 2069 6d70 6f72 7420  ocessing import 
+00025150: 6d69 6e6d 6178 5f73 6361 6c65 0a23 2323  minmax_scale.###
+00025160: 2320 5468 6973 2069 7320 7768 6572 6520  # This is where 
+00025170: 7765 2061 6464 206f 7468 6572 206c 6962  we add other lib
+00025180: 7261 7269 6573 2074 6f20 666f 726d 2061  raries to form a
+00025190: 2070 6970 656c 696e 6520 2323 230a 696d   pipeline ###.im
+000251a0: 706f 7274 2063 6f70 790a 696d 706f 7274  port copy.import
+000251b0: 2074 696d 650a 696d 706f 7274 2072 650a   time.import re.
+000251c0: 6672 6f6d 2073 6369 7079 2e6e 6469 6d61  from scipy.ndima
+000251d0: 6765 2069 6d70 6f72 7420 636f 6e76 6f6c  ge import convol
+000251e0: 7665 0a66 726f 6d20 736b 6c65 6172 6e20  ve.from sklearn 
+000251f0: 696d 706f 7274 2020 6461 7461 7365 7473  import  datasets
+00025200: 2c20 6d65 7472 6963 730a 6672 6f6d 2073  , metrics.from s
+00025210: 6b6c 6561 726e 2e6d 6f64 656c 5f73 656c  klearn.model_sel
+00025220: 6563 7469 6f6e 2069 6d70 6f72 7420 7472  ection import tr
+00025230: 6169 6e5f 7465 7374 5f73 706c 6974 0a66  ain_test_split.f
+00025240: 726f 6d20 736b 6c65 6172 6e2e 7069 7065  rom sklearn.pipe
+00025250: 6c69 6e65 2069 6d70 6f72 7420 5069 7065  line import Pipe
+00025260: 6c69 6e65 0a66 726f 6d20 736b 6c65 6172  line.from sklear
+00025270: 6e2e 6d6f 6465 6c5f 7365 6c65 6374 696f  n.model_selectio
+00025280: 6e20 696d 706f 7274 204b 466f 6c64 2c20  n import KFold, 
+00025290: 5374 7261 7469 6669 6564 5368 7566 666c  StratifiedShuffl
+000252a0: 6553 706c 6974 0a0a 6465 6620 6164 645f  eSplit..def add_
+000252b0: 7465 7874 5f70 6164 6469 6e67 7328 7472  text_paddings(tr
+000252c0: 6169 6e5f 6461 7461 2c6e 6c70 5f63 6f6c  ain_data,nlp_col
+000252d0: 756d 6e2c 676c 6f76 655f 6669 6c65 6e61  umn,glove_filena
+000252e0: 6d65 5f77 6974 685f 7061 7468 2c74 6f6b  me_with_path,tok
+000252f0: 656e 697a 6564 2c0a 2020 2020 2020 2020  enized,.        
+00025300: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00025310: 2020 2020 6669 745f 666c 6167 3d54 7275      fit_flag=Tru
+00025320: 652c 0a20 2020 2020 2020 2020 2020 2020  e,.             
+00025330: 2020 2020 2020 2020 2020 2020 2020 206d                 m
+00025340: 6178 5f6c 656e 6774 683d 3130 3029 3a0a  ax_length=100):.
+00025350: 2020 2020 2222 220a 2020 2020 2323 2323      """.    ####
+00025360: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00025370: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00025380: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00025390: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000253a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000253b0: 2323 2323 2323 2323 2323 2323 2323 0a20  ##############. 
+000253c0: 2020 2054 6869 7320 6675 6e63 7469 6f6e     This function
+000253d0: 2075 7365 7320 6120 476c 6f56 6520 7072   uses a GloVe pr
+000253e0: 652d 7472 6169 6e65 6420 6d6f 6465 6c20  e-trained model 
+000253f0: 746f 2061 6464 2065 6d62 6564 6469 6e67  to add embedding
+00025400: 7320 746f 2079 6f75 7220 6461 7461 2073  s to your data s
+00025410: 6574 2e0a 2020 2020 2323 2323 2323 2323  et..    ########
+00025420: 2020 4920 4e20 5020 5520 5420 2323 2323    I N P U T ####
+00025430: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00025440: 2323 2323 2323 2323 2323 3a0a 2020 2020  ##########:.    
+00025450: 6461 7461 3a20 4461 7461 4672 616d 650a  data: DataFrame.
+00025460: 2020 2020 6e6c 705f 636f 6c75 6d6e 3a20      nlp_column: 
+00025470: 6e61 6d65 206f 6620 7468 6520 4e4c 5020  name of the NLP 
+00025480: 636f 6c75 6d6e 2069 6e20 7468 6520 4461  column in the Da
+00025490: 7461 4672 616d 650a 2020 2020 7461 7267  taFrame.    targ
+000254a0: 6574 3a20 6e61 6d65 206f 6620 7468 6520  et: name of the 
+000254b0: 7461 7267 6574 2076 6172 6961 626c 6520  target variable 
+000254c0: 696e 2074 6865 2044 6174 6146 7261 6d65  in the DataFrame
+000254d0: 0a20 2020 2067 6c6f 7665 6669 6c65 3a20  .    glovefile: 
+000254e0: 6c6f 6361 7469 6f6e 206f 6620 7768 6572  location of wher
+000254f0: 6520 7468 6520 676c 6f76 652e 7478 7420  e the glove.txt 
+00025500: 6669 6c65 2069 732e 2059 6f75 206d 7573  file is. You mus
+00025510: 7420 6769 7665 2074 6865 2066 756c 6c20  t give the full 
+00025520: 7061 7468 2074 6f20 7468 6174 2066 696c  path to that fil
+00025530: 652e 0a20 2020 206d 6178 5f6c 656e 6774  e..    max_lengt
+00025540: 683a 2073 7065 6369 6679 2074 6865 2064  h: specify the d
+00025550: 696d 656e 7369 6f6e 206f 6620 7468 6520  imension of the 
+00025560: 676c 6f76 6520 7665 6374 6f72 2020 796f  glove vector  yo
+00025570: 7520 6361 6e20 6861 7665 2075 7074 6f20  u can have upto 
+00025580: 7468 6520 6469 6d65 6e73 696f 6e20 6f66  the dimension of
+00025590: 2074 6865 2067 6c6f 7665 2074 7874 2066   the glove txt f
+000255a0: 696c 652e 0a20 2020 2020 2020 2020 2020  ile..           
+000255b0: 4d61 6b65 2073 7572 6520 796f 7520 646f  Make sure you do
+000255c0: 6e27 7420 6578 6365 6564 2074 6865 2064  n't exceed the d
+000255d0: 696d 656e 7369 6f6e 2073 7065 6369 6669  imension specifi
+000255e0: 6564 2069 6e20 7468 6520 676c 6f76 652e  ed in the glove.
+000255f0: 7478 7420 6669 6c65 2e20 4f74 6865 7277  txt file. Otherw
+00025600: 6973 652c 2065 7272 6f72 2072 6573 756c  ise, error resul
+00025610: 742e 0a20 2020 2023 2323 2323 2323 204f  t..    ####### O
+00025620: 2055 2054 2050 2055 2054 2023 2323 2323   U T P U T #####
+00025630: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00025640: 2323 2323 2323 2323 0a20 2020 2054 6865  ########.    The
+00025650: 2064 6174 6166 7261 6d65 2069 7320 7370   dataframe is sp
+00025660: 6c69 7420 696e 746f 2074 7261 696e 2061  lit into train a
+00025670: 6e64 2074 6573 7420 616e 6420 6172 6520  nd test and are 
+00025680: 6d6f 6469 6669 6564 2069 6e74 6f20 7468  modified into th
+00025690: 6520 7370 6563 6966 6965 6420 7665 6374  e specified vect
+000256a0: 6f72 2064 696d 656e 7369 6f6e 206f 6620  or dimension of 
+000256b0: 6d61 785f 6c65 6e67 7468 0a20 2020 2058  max_length.    X
+000256c0: 5f74 7261 696e 5f70 6164 6465 643a 2074  _train_padded: t
+000256d0: 6865 2074 7261 696e 2064 6174 6166 7261  he train datafra
+000256e0: 6d65 2077 6974 6820 6469 6d65 6e73 696f  me with dimensio
+000256f0: 6e20 7370 6563 6966 6965 6420 696e 206d  n specified in m
+00025700: 6178 5f6c 656e 6774 680a 2020 2020 795f  ax_length.    y_
+00025710: 7472 6169 6e3a 2074 6865 2074 6172 6765  train: the targe
+00025720: 7420 7665 6374 6f72 2075 7369 6e67 2064  t vector using d
+00025730: 6174 6120 616e 6420 7461 7267 6574 2063  ata and target c
+00025740: 6f6c 756d 6e0a 2020 2020 585f 7465 7374  olumn.    X_test
+00025750: 5f70 6164 6465 643a 2020 7468 6520 7465  _padded:  the te
+00025760: 7374 2064 6174 6166 7261 6d65 2077 6974  st dataframe wit
+00025770: 6820 6469 6d65 6e73 696f 6e20 7370 6563  h dimension spec
+00025780: 6966 6965 6420 696e 206d 6178 5f6c 656e  ified in max_len
+00025790: 6774 680a 2020 2020 746f 6b65 6e69 7a65  gth.    tokenize
+000257a0: 643a 2054 6869 7320 6973 2074 6865 2074  d: This is the t
+000257b0: 6f6b 656e 697a 6572 2074 6861 7420 7761  okenizer that wa
+000257c0: 7320 7573 6564 2074 6f20 7370 6c69 7420  s used to split 
+000257d0: 7468 6520 776f 7264 7320 696e 2064 6174  the words in dat
+000257e0: 6120 7365 742e 2054 6869 7320 6d75 7374  a set. This must
+000257f0: 2062 6520 7573 6564 206c 6174 6572 2e0a   be used later..
+00025800: 2020 2020 2323 2323 2323 2323 2323 2323      ############
+00025810: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00025820: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00025830: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00025840: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00025850: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00025860: 2323 2323 2323 0a20 2020 2022 2222 0a20  ######.    """. 
+00025870: 2020 2074 7261 696e 5f69 6e64 6578 203d     train_index =
+00025880: 2074 7261 696e 5f64 6174 612e 696e 6465   train_data.inde
+00025890: 780a 2020 2020 2323 2320 456e 636f 6465  x.    ### Encode
+000258a0: 2054 7261 696e 2064 6174 6120 7465 7874   Train data text
+000258b0: 2069 6e74 6f20 7365 7175 656e 6365 730a   into sequences.
+000258c0: 2020 2020 7472 6169 6e5f 6461 7461 5f65      train_data_e
+000258d0: 6e63 6f64 6564 203d 2074 6f6b 656e 697a  ncoded = tokeniz
+000258e0: 6564 2e74 6578 7473 5f74 6f5f 7365 7175  ed.texts_to_sequ
+000258f0: 656e 6365 7328 7472 6169 6e5f 6461 7461  ences(train_data
+00025900: 5b6e 6c70 5f63 6f6c 756d 6e5d 290a 2020  [nlp_column]).  
+00025910: 2020 2323 2320 5061 645f 5365 7175 656e    ### Pad_Sequen
+00025920: 6365 7320 6675 6e63 7469 6f6e 2069 7320  ces function is 
+00025930: 7573 6564 2074 6f20 6d61 6b65 206c 6973  used to make lis
+00025940: 7473 206f 6620 756e 6571 7561 6c20 6c65  ts of unequal le
+00025950: 6e67 7468 2074 6f20 7374 6163 6b65 6420  ngth to stacked 
+00025960: 7365 7473 206f 6620 7061 6464 6564 2061  sets of padded a
+00025970: 6e64 2074 7275 6e63 6174 6564 2061 7272  nd truncated arr
+00025980: 6179 730a 2020 2020 2323 2320 5061 6420  ays.    ### Pad 
+00025990: 5365 7175 656e 6365 7320 666f 7220 5472  Sequences for Tr
+000259a0: 6169 6e0a 2020 2020 585f 7472 6169 6e5f  ain.    X_train_
+000259b0: 7061 6464 6564 203d 2070 6164 5f73 6571  padded = pad_seq
+000259c0: 7565 6e63 6573 2874 7261 696e 5f64 6174  uences(train_dat
+000259d0: 615f 656e 636f 6465 642c 0a20 2020 2020  a_encoded,.     
+000259e0: 2020 2020 2020 2020 2020 2020 2020 2020                  
+000259f0: 2020 2020 2020 2020 2020 206d 6178 6c65             maxle
+00025a00: 6e3d 6d61 785f 6c65 6e67 7468 2c0a 2020  n=max_length,.  
+00025a10: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00025a20: 2020 2020 2020 2020 2020 2020 2020 7061                pa
+00025a30: 6464 696e 673d 2770 6f73 7427 2c0a 2020  dding='post',.  
+00025a40: 2020 2020 2020 2020 2020 2020 2020 2020                  
+00025a50: 2020 2020 2020 2020 2020 2020 2074 7275               tru
+00025a60: 6e63 6174 696e 673d 2770 6f73 7427 290a  ncating='post').
+00025a70: 2020 2020 7072 696e 7428 2720 2020 2044      print('    D
+00025a80: 6174 6120 7368 6170 6520 6166 7465 7220  ata shape after 
+00025a90: 7061 6464 696e 6720 3d20 2573 2720 2528  padding = %s' %(
+00025aa0: 585f 7472 6169 6e5f 7061 6464 6564 2e73  X_train_padded.s
+00025ab0: 6861 7065 2c29 290a 2020 2020 6e65 775f  hape,)).    new_
+00025ac0: 636f 6c73 203d 205b 2767 6c6f 7665 5f64  cols = ['glove_d
+00025ad0: 696d 5f27 202b 2073 7472 2878 2b31 2920  im_' + str(x+1) 
+00025ae0: 666f 7220 7820 696e 2072 616e 6765 2858  for x in range(X
+00025af0: 5f74 7261 696e 5f70 6164 6465 642e 7368  _train_padded.sh
+00025b00: 6170 655b 315d 295d 0a20 2020 2058 5f74  ape[1])].    X_t
+00025b10: 7261 696e 5f70 6164 6465 6420 3d20 7064  rain_padded = pd
+00025b20: 2e44 6174 6146 7261 6d65 2858 5f74 7261  .DataFrame(X_tra
+00025b30: 696e 5f70 6164 6465 642c 2063 6f6c 756d  in_padded, colum
+00025b40: 6e73 3d6e 6577 5f63 6f6c 732c 2069 6e64  ns=new_cols, ind
+00025b50: 6578 3d74 7261 696e 5f69 6e64 6578 290a  ex=train_index).
+00025b60: 2020 2020 6966 2066 6974 5f66 6c61 673a      if fit_flag:
+00025b70: 0a20 2020 2020 2020 2072 6574 7572 6e20  .        return 
+00025b80: 585f 7472 6169 6e5f 7061 6464 6564 2c20  X_train_padded, 
+00025b90: 746f 6b65 6e69 7a65 642c 2076 6f63 6162  tokenized, vocab
+00025ba0: 5f73 697a 650a 2020 2020 656c 7365 3a0a  _size.    else:.
+00025bb0: 2020 2020 2020 2020 7265 7475 726e 2058          return X
+00025bc0: 5f74 7261 696e 5f70 6164 6465 640a 2323  _train_padded.##
+00025bd0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00025be0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00025bf0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00025c00: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00025c10: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00025c20: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00025c30: 2323 230a 6465 6620 6c6f 6164 5f65 6d62  ###.def load_emb
+00025c40: 6564 6469 6e67 7328 746f 6b65 6e69 7a65  eddings(tokenize
+00025c50: 642c 676c 6f76 655f 6669 6c65 6e61 6d65  d,glove_filename
+00025c60: 5f77 6974 685f 7061 7468 2c76 6f63 6162  _with_path,vocab
+00025c70: 5f73 697a 652c 676c 6f76 655f 6469 6d65  _size,glove_dime
+00025c80: 6e73 696f 6e29 3a0a 2020 2020 2222 220a  nsion):.    """.
+00025c90: 2020 2020 2323 2323 2323 2323 2323 2323      ############
+00025ca0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00025cb0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00025cc0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00025cd0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00025ce0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00025cf0: 2323 2323 2323 0a20 2020 2023 2067 6c6f  ######.    # glo
+00025d00: 7665 5f66 696c 656e 616d 655f 7769 7468  ve_filename_with
+00025d10: 5f70 6174 683a 204d 616b 6520 7375 7265  _path: Make sure
+00025d20: 2075 2068 6176 6520 646f 776e 6c6f 6164   u have download
+00025d30: 6564 2061 6e64 2075 6e7a 6970 7065 6420  ed and unzipped 
+00025d40: 7468 6520 476c 6f56 6520 222e 7478 7422  the GloVe ".txt"
+00025d50: 2066 696c 6520 746f 2074 6865 206c 6f63   file to the loc
+00025d60: 6174 696f 6e20 6865 7265 2e0a 2020 2020  ation here..    
+00025d70: 2320 7765 206e 6f77 2063 7265 6174 6520  # we now create 
+00025d80: 6120 6469 6374 696f 6e61 7279 2074 6861  a dictionary tha
+00025d90: 7420 6d61 7073 2047 6c6f 5665 2074 6f6b  t maps GloVe tok
+00025da0: 656e 7320 746f 2031 3030 2c20 6f72 2032  ens to 100, or 2
+00025db0: 3030 2d20 6f72 2033 3030 2d64 696d 656e  00- or 300-dimen
+00025dc0: 7369 6f6e 616c 2072 6561 6c2d 7661 6c75  sional real-valu
+00025dd0: 6564 2076 6563 746f 7273 0a20 2020 2023  ed vectors.    #
+00025de0: 2054 6865 6e20 7765 206c 6f61 6420 7468   Then we load th
+00025df0: 6520 7768 6f6c 6520 656d 6265 6464 696e  e whole embeddin
+00025e00: 6720 696e 746f 206d 656d 6f72 792e 204d  g into memory. M
+00025e10: 616b 6520 7375 7265 2079 6f75 2068 6176  ake sure you hav
+00025e20: 6520 706c 656e 7479 206f 6620 6d65 6d6f  e plenty of memo
+00025e30: 7279 2069 6e20 796f 7572 206d 6163 6869  ry in your machi
+00025e40: 6e65 210a 2020 2020 2323 2323 2323 2323  ne!.    ########
 00025e50: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 00025e60: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 00025e70: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00025e80: 2323 2323 2323 2323 2323 0a69 6d70 6f72  ##########.impor
-00025e90: 7420 636f 7079 0a64 6566 2046 455f 636f  t copy.def FE_co
-00025ea0: 6e76 6572 745f 6d69 7865 645f 6461 7461  nvert_mixed_data
-00025eb0: 7479 7065 735f 746f 5f73 7472 696e 6728  types_to_string(
-00025ec0: 6466 293a 0a20 2020 2064 6620 3d20 636f  df):.    df = co
-00025ed0: 7079 2e64 6565 7063 6f70 7928 6466 290a  py.deepcopy(df).
-00025ee0: 2020 2020 666f 7220 636f 6c20 696e 2064      for col in d
-00025ef0: 662e 636f 6c75 6d6e 733a 0a20 2020 2020  f.columns:.     
-00025f00: 2020 2069 6620 6c65 6e28 6466 5b63 6f6c     if len(df[col
-00025f10: 5d2e 6170 706c 7928 7479 7065 292e 7661  ].apply(type).va
-00025f20: 6c75 655f 636f 756e 7473 2829 2920 3e20  lue_counts()) > 
-00025f30: 313a 0a20 2020 2020 2020 2020 2020 2070  1:.            p
-00025f40: 7269 6e74 2827 4d69 7865 6420 6461 7461  rint('Mixed data
-00025f50: 2074 7970 6520 6465 7465 6374 6564 2069   type detected i
-00025f60: 6e20 2573 2063 6f6c 756d 6e2e 2043 6f6e  n %s column. Con
-00025f70: 7665 7274 696e 6720 616c 6c20 726f 7773  verting all rows
-00025f80: 2074 6f20 7374 7269 6e67 2074 7970 6520   to string type 
-00025f90: 6e6f 772e 2e2e 2720 2563 6f6c 290a 2020  now...' %col).  
-00025fa0: 2020 2020 2020 2020 2020 6466 5b63 6f6c            df[col
-00025fb0: 5d20 3d20 6466 5b63 6f6c 5d2e 6d61 7028  ] = df[col].map(
-00025fc0: 6c61 6d62 6461 2078 3a20 7820 6966 2069  lambda x: x if i
-00025fd0: 7369 6e73 7461 6e63 6528 782c 2073 7472  sinstance(x, str
-00025fe0: 2920 656c 7365 2073 7472 2878 2929 2e76  ) else str(x)).v
-00025ff0: 616c 7565 730a 2020 2020 2020 2020 2020  alues.          
-00026000: 2020 6966 206c 656e 2864 665b 636f 6c5d    if len(df[col]
-00026010: 2e61 7070 6c79 2874 7970 6529 2e76 616c  .apply(type).val
-00026020: 7565 5f63 6f75 6e74 7328 2929 203d 3d20  ue_counts()) == 
-00026030: 313a 0a20 2020 2020 2020 2020 2020 2020  1:.             
-00026040: 2020 2070 7269 6e74 2827 2020 2020 636f     print('    co
-00026050: 6d70 6c65 7465 642e 2729 0a20 2020 2020  mpleted.').     
-00026060: 2020 2020 2020 2065 6c73 653a 0a20 2020         else:.   
-00026070: 2020 2020 2020 2020 2020 2020 2070 7269               pri
-00026080: 6e74 2827 2020 2020 636f 756c 6420 6e6f  nt('    could no
-00026090: 7420 6368 616e 6765 2063 6f6c 756d 6e20  t change column 
-000260a0: 7479 7065 2e20 4669 7820 6974 206d 616e  type. Fix it man
-000260b0: 7561 6c6c 7920 616e 6420 7468 656e 2072  ually and then r
-000260c0: 652d 7275 6e20 4544 412e 2729 0a20 2020  e-run EDA.').   
-000260d0: 2072 6574 7572 6e20 6466 0a23 2323 2323   return df.#####
-000260e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000260f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00026100: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00026110: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00026120: 2323 2323 2323 2323 2323 2323 230a 6465  #############.de
-00026130: 6620 7265 6d6f 7665 5f64 7570 6c69 6361  f remove_duplica
-00026140: 7465 5f63 6f6c 735f 696e 5f64 6174 6173  te_cols_in_datas
-00026150: 6574 2864 6629 3a0a 2020 2020 6466 203d  et(df):.    df =
-00026160: 2063 6f70 792e 6465 6570 636f 7079 2864   copy.deepcopy(d
-00026170: 6629 0a20 2020 206e 756d 6265 725f 6475  f).    number_du
-00026180: 706c 6963 6174 6573 203d 2064 662e 636f  plicates = df.co
-00026190: 6c75 6d6e 732e 6475 706c 6963 6174 6564  lumns.duplicated
-000261a0: 2829 2e61 7374 7970 6528 696e 7429 2e73  ().astype(int).s
-000261b0: 756d 2829 0a20 2020 2064 7570 6c69 6361  um().    duplica
-000261c0: 7465 7320 3d20 6466 2e63 6f6c 756d 6e73  tes = df.columns
-000261d0: 5b64 662e 636f 6c75 6d6e 732e 6475 706c  [df.columns.dupl
-000261e0: 6963 6174 6564 2829 5d0a 2020 2020 6966  icated()].    if
-000261f0: 2020 6e75 6d62 6572 5f64 7570 6c69 6361    number_duplica
-00026200: 7465 7320 3e20 303a 0a20 2020 2020 2020  tes > 0:.       
-00026210: 2070 7269 6e74 2827 5265 6d6f 7669 6e67   print('Removing
-00026220: 2025 6420 6475 706c 6963 6174 6520 636f   %d duplicate co
-00026230: 6c75 6d6e 2873 2920 6f66 2025 7327 2025  lumn(s) of %s' %
-00026240: 286e 756d 6265 725f 6475 706c 6963 6174  (number_duplicat
-00026250: 6573 2c20 6475 706c 6963 6174 6573 2929  es, duplicates))
-00026260: 0a20 2020 2020 2020 2064 6620 3d20 6466  .        df = df
-00026270: 2e6c 6f63 5b3a 2c7e 6466 2e63 6f6c 756d  .loc[:,~df.colum
-00026280: 6e73 2e64 7570 6c69 6361 7465 6428 295d  ns.duplicated()]
-00026290: 0a20 2020 2072 6574 7572 6e20 6466 0a23  .    return df.#
-000262a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000262b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000262c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000262d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000262e0: 2323 2323 2323 2323 2323 0a64 6566 2046  ##########.def F
-000262f0: 455f 7370 6c69 745f 6c69 7374 5f69 6e74  E_split_list_int
-00026300: 6f5f 636f 6c75 6d6e 7328 6466 2c20 636f  o_columns(df, co
-00026310: 6c2c 2063 6f6c 735f 696e 3d5b 5d29 3a0a  l, cols_in=[]):.
-00026320: 2020 2020 2222 220a 2020 2020 5468 6973      """.    This
-00026330: 2069 7320 6120 4665 6174 7572 6520 456e   is a Feature En
-00026340: 6769 6e65 6572 696e 6720 6675 6e63 7469  gineering functi
-00026350: 6f6e 2e20 4974 2077 696c 6c20 6175 746f  on. It will auto
-00026360: 6d61 7469 6361 6c6c 7920 6465 7465 6374  matically detect
-00026370: 206f 626a 6563 7420 7661 7269 6162 6c65   object variable
-00026380: 7320 7468 6174 2063 6f6e 7461 696e 206c  s that contain l
-00026390: 6973 7473 0a20 2020 2061 6e64 2063 6f6e  ists.    and con
-000263a0: 7665 7274 2074 6865 6d20 696e 746f 206e  vert them into n
-000263b0: 6577 2063 6f6c 756d 6e73 2e20 596f 7520  ew columns. You 
-000263c0: 6e65 6564 2074 6f20 7072 6f76 6964 6520  need to provide 
-000263d0: 7468 6520 6461 7461 6672 616d 652c 2074  the dataframe, t
-000263e0: 6865 206e 616d 6520 6f66 2074 6865 206f  he name of the o
-000263f0: 626a 6563 7420 636f 6c75 6d6e 2e0a 2020  bject column..  
-00026400: 2020 4f70 7469 6f6e 616c 6c79 2c20 796f    Optionally, yo
-00026410: 7520 6361 6e20 6465 6369 6465 2074 6f20  u can decide to 
-00026420: 7365 6e64 2074 6865 206e 616d 6573 206f  send the names o
-00026430: 6620 7468 6520 6e65 7720 636f 6c75 6d6e  f the new column
-00026440: 7320 796f 7520 7761 6e74 2074 6f20 6372  s you want to cr
-00026450: 6561 7465 2061 7320 636f 6c73 5f69 6e2e  eate as cols_in.
-00026460: 0a20 2020 2049 7420 7769 6c6c 2072 6574  .    It will ret
-00026470: 7572 6e20 7468 6520 6461 7461 6672 616d  urn the datafram
-00026480: 6520 7769 7468 2061 6464 6974 696f 6e61  e with additiona
-00026490: 6c20 636f 6c75 6d6e 732e 2049 7420 7769  l columns. It wi
-000264a0: 6c6c 2064 726f 7020 7468 6520 636f 6c75  ll drop the colu
-000264b0: 6d6e 2077 6869 6368 2079 6f75 2073 656e  mn which you sen
-000264c0: 7420 696e 2061 7320 696e 7075 742e 0a0a  t in as input...
-000264d0: 2020 2020 496e 7075 7473 3a0a 2020 2020      Inputs:.    
-000264e0: 2d2d 2d2d 2d2d 2d2d 0a20 2020 2064 663a  --------.    df:
-000264f0: 2070 616e 6461 7320 6461 7461 6672 616d   pandas datafram
-00026500: 650a 2020 2020 636f 6c3a 206e 616d 6520  e.    col: name 
-00026510: 6f66 2074 6865 206f 626a 6563 7420 636f  of the object co
-00026520: 6c75 6d6e 2074 6861 7420 636f 6e74 6169  lumn that contai
-00026530: 6e73 2061 206c 6973 742e 2052 656d 656d  ns a list. Remem
-00026540: 6265 7220 6974 206d 7573 7420 6265 2061  ber it must be a
-00026550: 206c 6973 7420 616e 6420 6e6f 7420 6120   list and not a 
-00026560: 7374 7269 6e67 2e0a 2020 2020 636f 6c73  string..    cols
-00026570: 5f69 6e3a 206e 616d 6573 206f 6620 7468  _in: names of th
-00026580: 6520 636f 6c75 6d6e 7320 796f 7520 7761  e columns you wa
-00026590: 6e74 2074 6f20 6372 6561 7465 2e20 4966  nt to create. If
-000265a0: 2074 6865 206e 756d 6265 7220 6f66 2063   the number of c
-000265b0: 6f6c 756d 6e73 2069 7320 6c65 7373 2074  olumns is less t
-000265c0: 6861 6e20 6c69 7374 206c 656e 6774 682c  han list length,
-000265d0: 0a20 2020 2020 2020 2020 2020 2020 6974  .             it
-000265e0: 2077 696c 6c20 6175 746f 6d61 7469 6361   will automatica
-000265f0: 6c6c 7920 6368 6f6f 7365 206f 6e6c 7920  lly choose only 
-00026600: 7468 6520 6669 7374 2066 6577 2069 7465  the fist few ite
-00026610: 6d73 206f 6620 7468 6520 6c69 7374 2074  ms of the list t
-00026620: 6f20 6d61 7463 6820 7468 6520 6c65 6e67  o match the leng
-00026630: 7468 206f 6620 636f 6c73 5f69 6e2e 0a20  th of cols_in.. 
-00026640: 2020 200a 2020 2020 4f75 7470 7574 733a     .    Outputs:
-00026650: 0a20 2020 202d 2d2d 2d2d 2d2d 2d2d 0a20  .    ---------. 
-00026660: 2020 2064 663a 2070 616e 6461 7320 6461     df: pandas da
-00026670: 7461 6672 616d 6520 7769 7468 206e 6577  taframe with new
-00026680: 2063 6f6c 756d 6e73 2061 6e64 2077 6974   columns and wit
-00026690: 686f 7574 2074 6865 2063 6f6c 756d 6e20  hout the column 
-000266a0: 796f 7520 7365 6e74 2069 6e20 6173 2069  you sent in as i
-000266b0: 6e70 7574 2e0a 2020 2020 2222 220a 2020  nput..    """.  
-000266c0: 2020 6466 203d 2063 6f70 792e 6465 6570    df = copy.deep
-000266d0: 636f 7079 2864 6629 0a20 2020 2069 6620  copy(df).    if 
-000266e0: 636f 6c73 5f69 6e3a 0a20 2020 2020 2020  cols_in:.       
-000266f0: 206d 6178 5f63 6f6c 5f6c 656e 6774 6820   max_col_length 
-00026700: 3d20 6c65 6e28 636f 6c73 5f69 6e29 0a20  = len(cols_in). 
-00026710: 2020 2020 2020 2064 665b 636f 6c73 5f69         df[cols_i
-00026720: 6e5d 203d 2064 665b 636f 6c5d 2e61 7070  n] = df[col].app
-00026730: 6c79 2870 642e 5365 7269 6573 292e 7661  ly(pd.Series).va
-00026740: 6c75 6573 5b3a 2c3a 6d61 785f 636f 6c5f  lues[:,:max_col_
-00026750: 6c65 6e67 7468 5d0a 2020 2020 2020 2020  length].        
-00026760: 6466 203d 2064 662e 6472 6f70 2863 6f6c  df = df.drop(col
-00026770: 2c61 7869 733d 3129 0a20 2020 2065 6c73  ,axis=1).    els
-00026780: 653a 0a20 2020 2020 2020 2069 6620 6c65  e:.        if le
-00026790: 6e28 6466 5b63 6f6c 5d2e 6d61 7028 7479  n(df[col].map(ty
-000267a0: 7065 292e 7661 6c75 655f 636f 756e 7473  pe).value_counts
-000267b0: 2829 293d 3d31 2061 6e64 2064 665b 636f  ())==1 and df[co
-000267c0: 6c5d 2e6d 6170 2874 7970 6529 2e76 616c  l].map(type).val
-000267d0: 7565 5f63 6f75 6e74 7328 292e 696e 6465  ue_counts().inde
-000267e0: 785b 305d 3d3d 6c69 7374 3a0a 2020 2020  x[0]==list:.    
-000267f0: 2020 2020 2020 2020 2323 2320 5265 6d65          ### Reme
-00026800: 6d62 6572 2074 6861 7420 6669 6c6c 6e61  mber that fillna
-00026810: 206f 6e6c 7920 776f 726b 7320 6174 2064   only works at d
-00026820: 6174 6166 7261 6d65 206c 6576 656c 2120  ataframe level! 
-00026830: 2323 230a 2020 2020 2020 2020 2020 2020  ###.            
-00026840: 6d61 785f 636f 6c5f 6c65 6e67 7468 203d  max_col_length =
-00026850: 2064 665b 5b63 6f6c 5d5d 2e66 696c 6c6e   df[[col]].filln
-00026860: 6128 276d 6973 7369 6e67 2729 2e6d 6170  a('missing').map
-00026870: 286c 656e 292e 6d61 7828 290a 2020 2020  (len).max().    
-00026880: 2020 2020 2020 2020 636f 6c73 203d 205b          cols = [
-00026890: 636f 6c2b 275f 272b 7374 7228 6929 2066  col+'_'+str(i) f
-000268a0: 6f72 2069 2069 6e20 7261 6e67 6528 6d61  or i in range(ma
-000268b0: 785f 636f 6c5f 6c65 6e67 7468 295d 0a20  x_col_length)]. 
-000268c0: 2020 2020 2020 2020 2020 2064 665b 636f             df[co
-000268d0: 6c73 5d20 3d20 6466 5b63 6f6c 5d2e 6170  ls] = df[col].ap
-000268e0: 706c 7928 7064 2e53 6572 6965 7329 0a20  ply(pd.Series). 
-000268f0: 2020 2020 2020 2020 2020 2064 6620 3d20             df = 
-00026900: 6466 2e64 726f 7028 636f 6c2c 6178 6973  df.drop(col,axis
-00026910: 3d31 290a 2020 2020 2020 2020 656c 7365  =1).        else
-00026920: 3a0a 2020 2020 2020 2020 2020 2020 7072  :.            pr
-00026930: 696e 7428 2743 6f6c 756d 6e20 2573 2064  int('Column %s d
-00026940: 6f65 7320 6e6f 7420 636f 6e74 6169 6e20  oes not contain 
-00026950: 6c69 7374 7320 6f72 2068 6173 206d 6978  lists or has mix
-00026960: 6564 2074 7970 6573 206f 7468 6572 2074  ed types other t
-00026970: 6861 6e20 6c69 7374 732e 2046 6978 2069  han lists. Fix i
-00026980: 7420 616e 6420 7265 7275 6e2e 2720 2563  t and rerun.' %c
-00026990: 6f6c 290a 2020 2020 7265 7475 726e 2064  ol).    return d
-000269a0: 660a 2323 2323 2323 2323 2323 2323 2323  f.##############
-000269b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000269c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000269d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000269e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000269f0: 2323 2323 2323 2323 2323 2323 2323 230a  ###############.
-00026a00: 6465 6620 4544 415f 7261 6e64 6f6d 6c79  def EDA_randomly
-00026a10: 5f73 656c 6563 745f 726f 7773 5f66 726f  _select_rows_fro
-00026a20: 6d5f 6461 7461 6672 616d 6528 7472 6169  m_dataframe(trai
-00026a30: 6e5f 6461 7461 6672 616d 652c 2074 6172  n_dataframe, tar
-00026a40: 6765 7473 2c20 6e72 6f77 735f 6c69 6d69  gets, nrows_limi
-00026a50: 742c 2044 535f 4c45 4e3d 2727 293a 0a20  t, DS_LEN=''):. 
-00026a60: 2020 206d 6178 726f 7773 203d 2031 3030     maxrows = 100
-00026a70: 3030 0a20 2020 2074 7261 696e 5f64 6174  00.    train_dat
-00026a80: 6166 7261 6d65 203d 2063 6f70 792e 6465  aframe = copy.de
-00026a90: 6570 636f 7079 2874 7261 696e 5f64 6174  epcopy(train_dat
-00026aa0: 6166 7261 6d65 290a 2020 2020 636f 7079  aframe).    copy
-00026ab0: 5f74 6172 6765 7473 203d 2063 6f70 792e  _targets = copy.
-00026ac0: 6465 6570 636f 7079 2874 6172 6765 7473  deepcopy(targets
-00026ad0: 290a 2020 2020 6966 206e 6f74 2044 535f  ).    if not DS_
-00026ae0: 4c45 4e3a 0a20 2020 2020 2020 2044 535f  LEN:.        DS_
-00026af0: 4c45 4e20 3d20 7472 6169 6e5f 6461 7461  LEN = train_data
-00026b00: 6672 616d 652e 7368 6170 655b 305d 0a20  frame.shape[0]. 
-00026b10: 2020 2023 2323 2323 2323 2077 6520 7261     ####### we ra
-00026b20: 6e64 6f6d 6c79 2073 616d 706c 6520 6120  ndomly sample a 
-00026b30: 736d 616c 6c20 6461 7461 7365 7420 746f  small dataset to
-00026b40: 2063 6c61 7373 6966 7920 6665 6174 7572   classify featur
-00026b50: 6573 2023 2323 2323 2323 2323 2323 2323  es #############
-00026b60: 2323 2323 2323 2323 0a20 2020 2074 6573  ########.    tes
-00026b70: 745f 7369 7a65 203d 206d 696e 2830 2e39  t_size = min(0.9
-00026b80: 2c20 2831 202d 2028 6d61 7872 6f77 732f  , (1 - (maxrows/
-00026b90: 4453 5f4c 454e 2929 2920 2323 2320 6d61  DS_LEN))) ### ma
-00026ba0: 6b65 2073 7572 6520 7468 6572 6520 6973  ke sure there is
-00026bb0: 2061 2073 6d61 6c6c 2074 7261 696e 2073   a small train s
-00026bc0: 697a 650a 2020 2020 6966 2074 6573 745f  ize.    if test_
-00026bd0: 7369 7a65 203c 3d20 303a 0a20 2020 2020  size <= 0:.     
-00026be0: 2020 2074 6573 745f 7369 7a65 203d 2030     test_size = 0
-00026bf0: 2e39 0a20 2020 2023 2323 2020 2046 6c6f  .9.    ###   Flo
-00026c00: 6174 2076 6172 6961 626c 6573 2061 7265  at variables are
-00026c10: 2063 6f6e 7369 6465 7265 6420 5265 6772   considered Regr
-00026c20: 6573 7369 6f6e 2023 2323 2323 2323 2323  ession #########
-00026c30: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00026c40: 2323 2323 2323 2323 2323 2323 0a20 2020  ############.   
-00026c50: 206d 6f64 656c 7479 7065 2c20 5f20 3d20   modeltype, _ = 
-00026c60: 616e 616c 797a 655f 7072 6f62 6c65 6d5f  analyze_problem_
-00026c70: 7479 7065 2874 7261 696e 5f64 6174 6166  type(train_dataf
-00026c80: 7261 6d65 5b63 6f70 795f 7461 7267 6574  rame[copy_target
-00026c90: 735d 2c20 636f 7079 5f74 6172 6765 7473  s], copy_targets
-00026ca0: 2c20 7665 7262 6f73 653d 3029 0a20 2020  , verbose=0).   
-00026cb0: 2023 2323 2323 2323 2049 6620 6974 2069   ####### If it i
-00026cc0: 7320 6120 636c 6173 7369 6669 6361 7469  s a classificati
-00026cd0: 6f6e 2070 726f 626c 656d 2c20 796f 7520  on problem, you 
-00026ce0: 6e65 6564 2074 6f20 7374 7261 7469 6679  need to stratify
-00026cf0: 2061 6e64 2073 656c 6563 7420 7361 6d70   and select samp
-00026d00: 6c65 2023 2323 0a20 2020 2069 6620 6d6f  le ###.    if mo
-00026d10: 6465 6c74 7970 6520 213d 2027 5265 6772  deltype != 'Regr
-00026d20: 6573 7369 6f6e 273a 0a20 2020 2020 2020  ession':.       
-00026d30: 2070 7269 6e74 2827 2020 2020 6c6f 6164   print('    load
-00026d40: 696e 6720 6120 7261 6e64 6f6d 2073 616d  ing a random sam
-00026d50: 706c 6520 6f66 2025 6420 726f 7773 2069  ple of %d rows i
-00026d60: 6e74 6f20 7061 6e64 6173 2066 6f72 2045  nto pandas for E
-00026d70: 4441 2720 256e 726f 7773 5f6c 696d 6974  DA' %nrows_limit
-00026d80: 290a 2020 2020 2020 2020 666f 7220 6561  ).        for ea
-00026d90: 6368 5f74 6172 6765 7420 696e 2063 6f70  ch_target in cop
-00026da0: 795f 7461 7267 6574 733a 0a20 2020 2020  y_targets:.     
-00026db0: 2020 2020 2020 2023 2323 2059 6f75 206e         ### You n
-00026dc0: 6565 6420 746f 2072 656d 6f76 6520 726f  eed to remove ro
-00026dd0: 7773 2074 6861 7420 6861 7665 2076 6572  ws that have ver
-00026de0: 7920 636c 6173 7320 7361 6d70 6c65 7320  y class samples 
-00026df0: 2d20 7468 6174 2069 7320 6120 7072 6f62  - that is a prob
-00026e00: 6c65 6d20 7768 696c 6520 7370 6c69 7474  lem while splitt
-00026e10: 696e 6720 7472 6169 6e5f 736d 616c 6c0a  ing train_small.
-00026e20: 2020 2020 2020 2020 2020 2020 6c69 7374              list
-00026e30: 5f6f 665f 6665 775f 636c 6173 7365 7320  _of_few_classes 
-00026e40: 3d20 7472 6169 6e5f 6461 7461 6672 616d  = train_datafram
-00026e50: 655b 6561 6368 5f74 6172 6765 745d 2e76  e[each_target].v
-00026e60: 616c 7565 5f63 6f75 6e74 7328 295b 7472  alue_counts()[tr
-00026e70: 6169 6e5f 6461 7461 6672 616d 655b 6561  ain_dataframe[ea
-00026e80: 6368 5f74 6172 6765 745d 2e76 616c 7565  ch_target].value
-00026e90: 5f63 6f75 6e74 7328 293c 3d33 5d2e 696e  _counts()<=3].in
-00026ea0: 6465 782e 746f 6c69 7374 2829 0a20 2020  dex.tolist().   
-00026eb0: 2020 2020 2020 2020 2074 7261 696e 5f64           train_d
-00026ec0: 6174 6166 7261 6d65 203d 2074 7261 696e  ataframe = train
-00026ed0: 5f64 6174 6166 7261 6d65 2e6c 6f63 5b7e  _dataframe.loc[~
-00026ee0: 2874 7261 696e 5f64 6174 6166 7261 6d65  (train_dataframe
-00026ef0: 5b65 6163 685f 7461 7267 6574 5d2e 6973  [each_target].is
-00026f00: 696e 286c 6973 745f 6f66 5f66 6577 5f63  in(list_of_few_c
-00026f10: 6c61 7373 6573 2929 5d0a 2020 2020 2020  lasses))].      
-00026f20: 2020 7472 793a 0a20 2020 2020 2020 2020    try:.         
-00026f30: 2020 2074 7261 696e 5f73 6d61 6c6c 2c20     train_small, 
-00026f40: 5f20 3d20 7472 6169 6e5f 7465 7374 5f73  _ = train_test_s
-00026f50: 706c 6974 2874 7261 696e 5f64 6174 6166  plit(train_dataf
-00026f60: 7261 6d65 2c20 7465 7374 5f73 697a 653d  rame, test_size=
-00026f70: 7465 7374 5f73 697a 652c 2073 7472 6174  test_size, strat
-00026f80: 6966 793d 7472 6169 6e5f 6461 7461 6672  ify=train_datafr
-00026f90: 616d 655b 7461 7267 6574 735d 290a 2020  ame[targets]).  
-00026fa0: 2020 2020 2020 6578 6365 7074 3a0a 2020        except:.  
-00026fb0: 2020 2020 2020 2020 2020 2323 2054 6869            ## Thi
-00026fc0: 7320 7370 6c69 7420 736f 6d65 7469 6d65  s split sometime
-00026fd0: 7320 6572 726f 7273 2e20 4974 2069 7320  s errors. It is 
-00026fe0: 7468 656e 2062 6574 7465 7220 746f 2073  then better to s
-00026ff0: 706c 6974 2075 7369 6e67 2061 2072 616e  plit using a ran
-00027000: 646f 6d20 7361 6d70 6c65 2023 230a 2020  dom sample ##.  
-00027010: 2020 2020 2020 2020 2020 7472 6169 6e5f            train_
-00027020: 736d 616c 6c20 3d20 7472 6169 6e5f 6461  small = train_da
-00027030: 7461 6672 616d 652e 7361 6d70 6c65 286e  taframe.sample(n
-00027040: 3d6e 726f 7773 5f6c 696d 6974 2c20 7265  =nrows_limit, re
-00027050: 706c 6163 653d 5472 7565 2c20 7261 6e64  place=True, rand
-00027060: 6f6d 5f73 7461 7465 3d39 3929 0a20 2020  om_state=99).   
-00027070: 2065 6c73 653a 0a20 2020 2020 2020 2023   else:.        #
-00027080: 2323 2046 6f72 2052 6567 7265 7373 696f  ## For Regressio
-00027090: 6e20 7072 6f62 6c65 6d73 3a20 6c6f 6164  n problems: load
-000270a0: 2061 2073 6d61 6c6c 2073 616d 706c 6520   a small sample 
-000270b0: 6f66 2064 6174 6120 696e 746f 2061 2070  of data into a p
-000270c0: 616e 6461 7320 6461 7461 6672 616d 6520  andas dataframe 
-000270d0: 2323 0a20 2020 2020 2020 2070 7269 6e74  ##.        print
-000270e0: 2827 2020 2020 6c6f 6164 696e 6720 6120  ('    loading a 
-000270f0: 7365 7175 656e 7469 616c 2073 616d 706c  sequential sampl
-00027100: 6520 6f66 2025 6420 726f 7773 2069 6e74  e of %d rows int
-00027110: 6f20 7061 6e64 6173 2066 6f72 2045 4441  o pandas for EDA
-00027120: 2720 256e 726f 7773 5f6c 696d 6974 290a  ' %nrows_limit).
-00027130: 2020 2020 2020 2020 7472 6169 6e5f 736d          train_sm
-00027140: 616c 6c20 3d20 7472 6169 6e5f 6461 7461  all = train_data
-00027150: 6672 616d 655b 3a6e 726f 7773 5f6c 696d  frame[:nrows_lim
-00027160: 6974 5d0a 2020 2020 7265 7475 726e 2074  it].    return t
-00027170: 7261 696e 5f73 6d61 6c6c 0a23 2323 2323  rain_small.#####
+00025e80: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00025e90: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00025ea0: 2323 2323 2323 2323 2323 0a20 2020 2022  ##########.    "
+00025eb0: 2222 0a20 2020 204d 4158 5f4e 554d 5f57  "".    MAX_NUM_W
+00025ec0: 4f52 4453 203d 2031 3030 3030 300a 2020  ORDS = 100000.  
+00025ed0: 2020 676c 6f76 655f 7061 7468 203d 2050    glove_path = P
+00025ee0: 6174 6828 676c 6f76 655f 6669 6c65 6e61  ath(glove_filena
+00025ef0: 6d65 5f77 6974 685f 7061 7468 290a 2020  me_with_path).  
+00025f00: 2020 7072 696e 7428 2720 2020 2043 7265    print('    Cre
+00025f10: 6174 696e 6720 656d 6265 6464 696e 6773  ating embeddings
+00025f20: 2e20 5468 6973 2077 696c 6c20 7461 6b65  . This will take
+00025f30: 2074 696d 652e 2e2e 2729 0a20 2020 2065   time...').    e
+00025f40: 6d62 6564 6469 6e67 735f 696e 6465 7820  mbeddings_index 
+00025f50: 3d20 6469 6374 2829 0a20 2020 2066 6f72  = dict().    for
+00025f60: 206c 696e 6520 696e 2067 6c6f 7665 5f70   line in glove_p
+00025f70: 6174 682e 6f70 656e 2865 6e63 6f64 696e  ath.open(encodin
+00025f80: 673d 276c 6174 696e 3127 293a 0a20 2020  g='latin1'):.   
+00025f90: 2020 2020 2076 616c 7565 7320 3d20 6c69       values = li
+00025fa0: 6e65 2e73 706c 6974 2829 0a20 2020 2020  ne.split().     
+00025fb0: 2020 2077 6f72 6420 3d20 7661 6c75 6573     word = values
+00025fc0: 5b30 5d0a 2020 2020 2020 2020 7472 793a  [0].        try:
+00025fd0: 0a20 2020 2020 2020 2020 2020 2063 6f65  .            coe
+00025fe0: 6673 203d 206e 702e 6173 6172 7261 7928  fs = np.asarray(
+00025ff0: 7661 6c75 6573 5b31 3a5d 2c20 6474 7970  values[1:], dtyp
+00026000: 653d 2766 6c6f 6174 3332 2729 0a20 2020  e='float32').   
+00026010: 2020 2020 2065 7863 6570 743a 0a20 2020       except:.   
+00026020: 2020 2020 2020 2020 2063 6f6e 7469 6e75           continu
+00026030: 650a 2020 2020 2020 2020 656d 6265 6464  e.        embedd
+00026040: 696e 6773 5f69 6e64 6578 5b77 6f72 645d  ings_index[word]
+00026050: 203d 2063 6f65 6673 0a20 2020 2070 7269   = coefs.    pri
+00026060: 6e74 2827 4c6f 6164 6564 207b 3a2c 647d  nt('Loaded {:,d}
+00026070: 2047 6c6f 7665 2076 6563 746f 7273 2e27   Glove vectors.'
+00026080: 2e66 6f72 6d61 7428 6c65 6e28 656d 6265  .format(len(embe
+00026090: 6464 696e 6773 5f69 6e64 6578 2929 290a  ddings_index))).
+000260a0: 2020 2020 2354 6865 7265 2061 7265 2061      #There are a
+000260b0: 726f 756e 6420 3334 302c 3030 3020 776f  round 340,000 wo
+000260c0: 7264 2076 6563 746f 7273 2074 6861 7420  rd vectors that 
+000260d0: 7765 2075 7365 2074 6f20 6372 6561 7465  we use to create
+000260e0: 2061 6e20 656d 6265 6464 696e 6720 6d61   an embedding ma
+000260f0: 7472 6978 0a20 2020 2023 2074 6861 7420  trix.    # that 
+00026100: 6d61 7463 6865 7320 7468 6520 766f 6361  matches the voca
+00026110: 6275 6c61 7279 2073 6f20 7468 6174 2074  bulary so that t
+00026120: 6865 2052 4e4e 206d 6f64 656c 2063 616e  he RNN model can
+00026130: 2061 6363 6573 7320 656d 6265 6464 696e   access embeddin
+00026140: 6773 2062 7920 7468 6520 746f 6b65 6e20  gs by the token 
+00026150: 696e 6465 780a 2020 2020 2320 7072 6570  index.    # prep
+00026160: 6172 6520 656d 6265 6464 696e 6720 6d61  are embedding ma
+00026170: 7472 6978 0a20 2020 2077 6f72 645f 696e  trix.    word_in
+00026180: 6465 7820 3d20 746f 6b65 6e69 7a65 642e  dex = tokenized.
+00026190: 776f 7264 5f69 6e64 6578 0a20 2020 2065  word_index.    e
+000261a0: 6d62 6564 6469 6e67 5f6d 6174 7269 7820  mbedding_matrix 
+000261b0: 3d20 6e70 2e7a 6572 6f73 2828 766f 6361  = np.zeros((voca
+000261c0: 625f 7369 7a65 2c20 676c 6f76 655f 6469  b_size, glove_di
+000261d0: 6d65 6e73 696f 6e29 290a 2020 2020 7072  mension)).    pr
+000261e0: 696e 7428 2750 7265 7061 7269 6e67 2065  int('Preparing e
+000261f0: 6d62 6564 6469 6e67 206d 6174 7269 782e  mbedding matrix.
+00026200: 2729 0a20 2020 2066 6f72 2077 6f72 642c  ').    for word,
+00026210: 2069 2069 6e20 776f 7264 5f69 6e64 6578   i in word_index
+00026220: 2e69 7465 6d73 2829 3a0a 2020 2020 2020  .items():.      
+00026230: 2020 6966 2069 203e 3d20 4d41 585f 4e55    if i >= MAX_NU
+00026240: 4d5f 574f 5244 533a 0a20 2020 2020 2020  M_WORDS:.       
+00026250: 2020 2020 2063 6f6e 7469 6e75 650a 2020       continue.  
+00026260: 2020 2020 2020 656d 6265 6464 696e 675f        embedding_
+00026270: 7665 6374 6f72 203d 2065 6d62 6564 6469  vector = embeddi
+00026280: 6e67 735f 696e 6465 782e 6765 7428 776f  ngs_index.get(wo
+00026290: 7264 290a 2020 2020 2020 2020 6966 2065  rd).        if e
+000262a0: 6d62 6564 6469 6e67 5f76 6563 746f 7220  mbedding_vector 
+000262b0: 6973 206e 6f74 204e 6f6e 653a 0a20 2020  is not None:.   
+000262c0: 2020 2020 2020 2020 2023 2077 6f72 6473           # words
+000262d0: 206e 6f74 2066 6f75 6e64 2069 6e20 656d   not found in em
+000262e0: 6265 6464 696e 6720 696e 6465 7820 7769  bedding index wi
+000262f0: 6c6c 2062 6520 616c 6c2d 7a65 726f 732e  ll be all-zeros.
+00026300: 0a20 2020 2020 2020 2020 2020 2065 6d62  .            emb
+00026310: 6564 6469 6e67 5f6d 6174 7269 785b 695d  edding_matrix[i]
+00026320: 203d 2065 6d62 6564 6469 6e67 5f76 6563   = embedding_vec
+00026330: 746f 720a 2020 2020 7072 696e 7428 2720  tor.    print(' 
+00026340: 2020 2043 6f6d 706c 6574 6564 2e27 290a     Completed.').
+00026350: 2020 2020 7265 7475 726e 2065 6d62 6564      return embed
+00026360: 6469 6e67 5f6d 6174 7269 782c 2067 6c6f  ding_matrix, glo
+00026370: 7665 5f64 696d 656e 7369 6f6e 0a23 2323  ve_dimension.###
+00026380: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00026390: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000263a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000263b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000263c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000263d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000263e0: 2323 0a69 6d70 6f72 7420 636f 7079 0a64  ##.import copy.d
+000263f0: 6566 2046 455f 636f 6e76 6572 745f 6d69  ef FE_convert_mi
+00026400: 7865 645f 6461 7461 7479 7065 735f 746f  xed_datatypes_to
+00026410: 5f73 7472 696e 6728 6466 293a 0a20 2020  _string(df):.   
+00026420: 2064 6620 3d20 636f 7079 2e64 6565 7063   df = copy.deepc
+00026430: 6f70 7928 6466 290a 2020 2020 666f 7220  opy(df).    for 
+00026440: 636f 6c20 696e 2064 662e 636f 6c75 6d6e  col in df.column
+00026450: 733a 0a20 2020 2020 2020 2069 6620 6c65  s:.        if le
+00026460: 6e28 6466 5b63 6f6c 5d2e 6170 706c 7928  n(df[col].apply(
+00026470: 7479 7065 292e 7661 6c75 655f 636f 756e  type).value_coun
+00026480: 7473 2829 2920 3e20 313a 0a20 2020 2020  ts()) > 1:.     
+00026490: 2020 2020 2020 2070 7269 6e74 2827 4d69         print('Mi
+000264a0: 7865 6420 6461 7461 2074 7970 6520 6465  xed data type de
+000264b0: 7465 6374 6564 2069 6e20 2573 2063 6f6c  tected in %s col
+000264c0: 756d 6e2e 2043 6f6e 7665 7274 696e 6720  umn. Converting 
+000264d0: 616c 6c20 726f 7773 2074 6f20 7374 7269  all rows to stri
+000264e0: 6e67 2074 7970 6520 6e6f 772e 2e2e 2720  ng type now...' 
+000264f0: 2563 6f6c 290a 2020 2020 2020 2020 2020  %col).          
+00026500: 2020 6466 5b63 6f6c 5d20 3d20 6466 5b63    df[col] = df[c
+00026510: 6f6c 5d2e 6d61 7028 6c61 6d62 6461 2078  ol].map(lambda x
+00026520: 3a20 7820 6966 2069 7369 6e73 7461 6e63  : x if isinstanc
+00026530: 6528 782c 2073 7472 2920 656c 7365 2073  e(x, str) else s
+00026540: 7472 2878 2929 2e76 616c 7565 730a 2020  tr(x)).values.  
+00026550: 2020 2020 2020 2020 2020 6966 206c 656e            if len
+00026560: 2864 665b 636f 6c5d 2e61 7070 6c79 2874  (df[col].apply(t
+00026570: 7970 6529 2e76 616c 7565 5f63 6f75 6e74  ype).value_count
+00026580: 7328 2929 203d 3d20 313a 0a20 2020 2020  s()) == 1:.     
+00026590: 2020 2020 2020 2020 2020 2070 7269 6e74             print
+000265a0: 2827 2020 2020 636f 6d70 6c65 7465 642e  ('    completed.
+000265b0: 2729 0a20 2020 2020 2020 2020 2020 2065  ').            e
+000265c0: 6c73 653a 0a20 2020 2020 2020 2020 2020  lse:.           
+000265d0: 2020 2020 2070 7269 6e74 2827 2020 2020       print('    
+000265e0: 636f 756c 6420 6e6f 7420 6368 616e 6765  could not change
+000265f0: 2063 6f6c 756d 6e20 7479 7065 2e20 4669   column type. Fi
+00026600: 7820 6974 206d 616e 7561 6c6c 7920 616e  x it manually an
+00026610: 6420 7468 656e 2072 652d 7275 6e20 4544  d then re-run ED
+00026620: 412e 2729 0a20 2020 2072 6574 7572 6e20  A.').    return 
+00026630: 6466 0a23 2323 2323 2323 2323 2323 2323  df.#############
+00026640: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00026650: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00026660: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00026670: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00026680: 2323 2323 230a 6465 6620 7265 6d6f 7665  #####.def remove
+00026690: 5f64 7570 6c69 6361 7465 5f63 6f6c 735f  _duplicate_cols_
+000266a0: 696e 5f64 6174 6173 6574 2864 6629 3a0a  in_dataset(df):.
+000266b0: 2020 2020 6466 203d 2063 6f70 792e 6465      df = copy.de
+000266c0: 6570 636f 7079 2864 6629 0a20 2020 206e  epcopy(df).    n
+000266d0: 756d 6265 725f 6475 706c 6963 6174 6573  umber_duplicates
+000266e0: 203d 2064 662e 636f 6c75 6d6e 732e 6475   = df.columns.du
+000266f0: 706c 6963 6174 6564 2829 2e61 7374 7970  plicated().astyp
+00026700: 6528 696e 7429 2e73 756d 2829 0a20 2020  e(int).sum().   
+00026710: 2064 7570 6c69 6361 7465 7320 3d20 6466   duplicates = df
+00026720: 2e63 6f6c 756d 6e73 5b64 662e 636f 6c75  .columns[df.colu
+00026730: 6d6e 732e 6475 706c 6963 6174 6564 2829  mns.duplicated()
+00026740: 5d0a 2020 2020 6966 2020 6e75 6d62 6572  ].    if  number
+00026750: 5f64 7570 6c69 6361 7465 7320 3e20 303a  _duplicates > 0:
+00026760: 0a20 2020 2020 2020 2070 7269 6e74 2827  .        print('
+00026770: 5265 6d6f 7669 6e67 2025 6420 6475 706c  Removing %d dupl
+00026780: 6963 6174 6520 636f 6c75 6d6e 2873 2920  icate column(s) 
+00026790: 6f66 2025 7327 2025 286e 756d 6265 725f  of %s' %(number_
+000267a0: 6475 706c 6963 6174 6573 2c20 6475 706c  duplicates, dupl
+000267b0: 6963 6174 6573 2929 0a20 2020 2020 2020  icates)).       
+000267c0: 2064 6620 3d20 6466 2e6c 6f63 5b3a 2c7e   df = df.loc[:,~
+000267d0: 6466 2e63 6f6c 756d 6e73 2e64 7570 6c69  df.columns.dupli
+000267e0: 6361 7465 6428 295d 0a20 2020 2072 6574  cated()].    ret
+000267f0: 7572 6e20 6466 0a23 2323 2323 2323 2323  urn df.#########
+00026800: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00026810: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00026820: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00026830: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00026840: 2323 0a64 6566 2046 455f 7370 6c69 745f  ##.def FE_split_
+00026850: 6c69 7374 5f69 6e74 6f5f 636f 6c75 6d6e  list_into_column
+00026860: 7328 6466 2c20 636f 6c2c 2063 6f6c 735f  s(df, col, cols_
+00026870: 696e 3d5b 5d29 3a0a 2020 2020 2222 220a  in=[]):.    """.
+00026880: 2020 2020 5468 6973 2069 7320 6120 4665      This is a Fe
+00026890: 6174 7572 6520 456e 6769 6e65 6572 696e  ature Engineerin
+000268a0: 6720 6675 6e63 7469 6f6e 2e20 4974 2077  g function. It w
+000268b0: 696c 6c20 6175 746f 6d61 7469 6361 6c6c  ill automaticall
+000268c0: 7920 6465 7465 6374 206f 626a 6563 7420  y detect object 
+000268d0: 7661 7269 6162 6c65 7320 7468 6174 2063  variables that c
+000268e0: 6f6e 7461 696e 206c 6973 7473 0a20 2020  ontain lists.   
+000268f0: 2061 6e64 2063 6f6e 7665 7274 2074 6865   and convert the
+00026900: 6d20 696e 746f 206e 6577 2063 6f6c 756d  m into new colum
+00026910: 6e73 2e20 596f 7520 6e65 6564 2074 6f20  ns. You need to 
+00026920: 7072 6f76 6964 6520 7468 6520 6461 7461  provide the data
+00026930: 6672 616d 652c 2074 6865 206e 616d 6520  frame, the name 
+00026940: 6f66 2074 6865 206f 626a 6563 7420 636f  of the object co
+00026950: 6c75 6d6e 2e0a 2020 2020 4f70 7469 6f6e  lumn..    Option
+00026960: 616c 6c79 2c20 796f 7520 6361 6e20 6465  ally, you can de
+00026970: 6369 6465 2074 6f20 7365 6e64 2074 6865  cide to send the
+00026980: 206e 616d 6573 206f 6620 7468 6520 6e65   names of the ne
+00026990: 7720 636f 6c75 6d6e 7320 796f 7520 7761  w columns you wa
+000269a0: 6e74 2074 6f20 6372 6561 7465 2061 7320  nt to create as 
+000269b0: 636f 6c73 5f69 6e2e 0a20 2020 2049 7420  cols_in..    It 
+000269c0: 7769 6c6c 2072 6574 7572 6e20 7468 6520  will return the 
+000269d0: 6461 7461 6672 616d 6520 7769 7468 2061  dataframe with a
+000269e0: 6464 6974 696f 6e61 6c20 636f 6c75 6d6e  dditional column
+000269f0: 732e 2049 7420 7769 6c6c 2064 726f 7020  s. It will drop 
+00026a00: 7468 6520 636f 6c75 6d6e 2077 6869 6368  the column which
+00026a10: 2079 6f75 2073 656e 7420 696e 2061 7320   you sent in as 
+00026a20: 696e 7075 742e 0a0a 2020 2020 496e 7075  input...    Inpu
+00026a30: 7473 3a0a 2020 2020 2d2d 2d2d 2d2d 2d2d  ts:.    --------
+00026a40: 0a20 2020 2064 663a 2070 616e 6461 7320  .    df: pandas 
+00026a50: 6461 7461 6672 616d 650a 2020 2020 636f  dataframe.    co
+00026a60: 6c3a 206e 616d 6520 6f66 2074 6865 206f  l: name of the o
+00026a70: 626a 6563 7420 636f 6c75 6d6e 2074 6861  bject column tha
+00026a80: 7420 636f 6e74 6169 6e73 2061 206c 6973  t contains a lis
+00026a90: 742e 2052 656d 656d 6265 7220 6974 206d  t. Remember it m
+00026aa0: 7573 7420 6265 2061 206c 6973 7420 616e  ust be a list an
+00026ab0: 6420 6e6f 7420 6120 7374 7269 6e67 2e0a  d not a string..
+00026ac0: 2020 2020 636f 6c73 5f69 6e3a 206e 616d      cols_in: nam
+00026ad0: 6573 206f 6620 7468 6520 636f 6c75 6d6e  es of the column
+00026ae0: 7320 796f 7520 7761 6e74 2074 6f20 6372  s you want to cr
+00026af0: 6561 7465 2e20 4966 2074 6865 206e 756d  eate. If the num
+00026b00: 6265 7220 6f66 2063 6f6c 756d 6e73 2069  ber of columns i
+00026b10: 7320 6c65 7373 2074 6861 6e20 6c69 7374  s less than list
+00026b20: 206c 656e 6774 682c 0a20 2020 2020 2020   length,.       
+00026b30: 2020 2020 2020 6974 2077 696c 6c20 6175        it will au
+00026b40: 746f 6d61 7469 6361 6c6c 7920 6368 6f6f  tomatically choo
+00026b50: 7365 206f 6e6c 7920 7468 6520 6669 7374  se only the fist
+00026b60: 2066 6577 2069 7465 6d73 206f 6620 7468   few items of th
+00026b70: 6520 6c69 7374 2074 6f20 6d61 7463 6820  e list to match 
+00026b80: 7468 6520 6c65 6e67 7468 206f 6620 636f  the length of co
+00026b90: 6c73 5f69 6e2e 0a20 2020 200a 2020 2020  ls_in..    .    
+00026ba0: 4f75 7470 7574 733a 0a20 2020 202d 2d2d  Outputs:.    ---
+00026bb0: 2d2d 2d2d 2d2d 0a20 2020 2064 663a 2070  ------.    df: p
+00026bc0: 616e 6461 7320 6461 7461 6672 616d 6520  andas dataframe 
+00026bd0: 7769 7468 206e 6577 2063 6f6c 756d 6e73  with new columns
+00026be0: 2061 6e64 2077 6974 686f 7574 2074 6865   and without the
+00026bf0: 2063 6f6c 756d 6e20 796f 7520 7365 6e74   column you sent
+00026c00: 2069 6e20 6173 2069 6e70 7574 2e0a 2020   in as input..  
+00026c10: 2020 2222 220a 2020 2020 6466 203d 2063    """.    df = c
+00026c20: 6f70 792e 6465 6570 636f 7079 2864 6629  opy.deepcopy(df)
+00026c30: 0a20 2020 2069 6620 636f 6c73 5f69 6e3a  .    if cols_in:
+00026c40: 0a20 2020 2020 2020 206d 6178 5f63 6f6c  .        max_col
+00026c50: 5f6c 656e 6774 6820 3d20 6c65 6e28 636f  _length = len(co
+00026c60: 6c73 5f69 6e29 0a20 2020 2020 2020 2064  ls_in).        d
+00026c70: 665b 636f 6c73 5f69 6e5d 203d 2064 665b  f[cols_in] = df[
+00026c80: 636f 6c5d 2e61 7070 6c79 2870 642e 5365  col].apply(pd.Se
+00026c90: 7269 6573 292e 7661 6c75 6573 5b3a 2c3a  ries).values[:,:
+00026ca0: 6d61 785f 636f 6c5f 6c65 6e67 7468 5d0a  max_col_length].
+00026cb0: 2020 2020 2020 2020 6466 203d 2064 662e          df = df.
+00026cc0: 6472 6f70 2863 6f6c 2c61 7869 733d 3129  drop(col,axis=1)
+00026cd0: 0a20 2020 2065 6c73 653a 0a20 2020 2020  .    else:.     
+00026ce0: 2020 2069 6620 6c65 6e28 6466 5b63 6f6c     if len(df[col
+00026cf0: 5d2e 6d61 7028 7479 7065 292e 7661 6c75  ].map(type).valu
+00026d00: 655f 636f 756e 7473 2829 293d 3d31 2061  e_counts())==1 a
+00026d10: 6e64 2064 665b 636f 6c5d 2e6d 6170 2874  nd df[col].map(t
+00026d20: 7970 6529 2e76 616c 7565 5f63 6f75 6e74  ype).value_count
+00026d30: 7328 292e 696e 6465 785b 305d 3d3d 6c69  s().index[0]==li
+00026d40: 7374 3a0a 2020 2020 2020 2020 2020 2020  st:.            
+00026d50: 2323 2320 5265 6d65 6d62 6572 2074 6861  ### Remember tha
+00026d60: 7420 6669 6c6c 6e61 206f 6e6c 7920 776f  t fillna only wo
+00026d70: 726b 7320 6174 2064 6174 6166 7261 6d65  rks at dataframe
+00026d80: 206c 6576 656c 2120 2323 230a 2020 2020   level! ###.    
+00026d90: 2020 2020 2020 2020 6d61 785f 636f 6c5f          max_col_
+00026da0: 6c65 6e67 7468 203d 2064 665b 5b63 6f6c  length = df[[col
+00026db0: 5d5d 2e66 696c 6c6e 6128 276d 6973 7369  ]].fillna('missi
+00026dc0: 6e67 2729 2e6d 6170 286c 656e 292e 6d61  ng').map(len).ma
+00026dd0: 7828 290a 2020 2020 2020 2020 2020 2020  x().            
+00026de0: 636f 6c73 203d 205b 636f 6c2b 275f 272b  cols = [col+'_'+
+00026df0: 7374 7228 6929 2066 6f72 2069 2069 6e20  str(i) for i in 
+00026e00: 7261 6e67 6528 6d61 785f 636f 6c5f 6c65  range(max_col_le
+00026e10: 6e67 7468 295d 0a20 2020 2020 2020 2020  ngth)].         
+00026e20: 2020 2064 665b 636f 6c73 5d20 3d20 6466     df[cols] = df
+00026e30: 5b63 6f6c 5d2e 6170 706c 7928 7064 2e53  [col].apply(pd.S
+00026e40: 6572 6965 7329 0a20 2020 2020 2020 2020  eries).         
+00026e50: 2020 2064 6620 3d20 6466 2e64 726f 7028     df = df.drop(
+00026e60: 636f 6c2c 6178 6973 3d31 290a 2020 2020  col,axis=1).    
+00026e70: 2020 2020 656c 7365 3a0a 2020 2020 2020      else:.      
+00026e80: 2020 2020 2020 7072 696e 7428 2743 6f6c        print('Col
+00026e90: 756d 6e20 2573 2064 6f65 7320 6e6f 7420  umn %s does not 
+00026ea0: 636f 6e74 6169 6e20 6c69 7374 7320 6f72  contain lists or
+00026eb0: 2068 6173 206d 6978 6564 2074 7970 6573   has mixed types
+00026ec0: 206f 7468 6572 2074 6861 6e20 6c69 7374   other than list
+00026ed0: 732e 2046 6978 2069 7420 616e 6420 7265  s. Fix it and re
+00026ee0: 7275 6e2e 2720 2563 6f6c 290a 2020 2020  run.' %col).    
+00026ef0: 7265 7475 726e 2064 660a 2323 2323 2323  return df.######
+00026f00: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00026f10: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00026f20: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00026f30: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00026f40: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00026f50: 2323 2323 2323 230a 6465 6620 4544 415f  #######.def EDA_
+00026f60: 7261 6e64 6f6d 6c79 5f73 656c 6563 745f  randomly_select_
+00026f70: 726f 7773 5f66 726f 6d5f 6461 7461 6672  rows_from_datafr
+00026f80: 616d 6528 7472 6169 6e5f 6461 7461 6672  ame(train_datafr
+00026f90: 616d 652c 2074 6172 6765 7473 2c20 6e72  ame, targets, nr
+00026fa0: 6f77 735f 6c69 6d69 742c 2044 535f 4c45  ows_limit, DS_LE
+00026fb0: 4e3d 2727 293a 0a20 2020 206d 6178 726f  N=''):.    maxro
+00026fc0: 7773 203d 2031 3030 3030 0a20 2020 2074  ws = 10000.    t
+00026fd0: 7261 696e 5f64 6174 6166 7261 6d65 203d  rain_dataframe =
+00026fe0: 2063 6f70 792e 6465 6570 636f 7079 2874   copy.deepcopy(t
+00026ff0: 7261 696e 5f64 6174 6166 7261 6d65 290a  rain_dataframe).
+00027000: 2020 2020 636f 7079 5f74 6172 6765 7473      copy_targets
+00027010: 203d 2063 6f70 792e 6465 6570 636f 7079   = copy.deepcopy
+00027020: 2874 6172 6765 7473 290a 2020 2020 6966  (targets).    if
+00027030: 206e 6f74 2044 535f 4c45 4e3a 0a20 2020   not DS_LEN:.   
+00027040: 2020 2020 2044 535f 4c45 4e20 3d20 7472       DS_LEN = tr
+00027050: 6169 6e5f 6461 7461 6672 616d 652e 7368  ain_dataframe.sh
+00027060: 6170 655b 305d 0a20 2020 2023 2323 2323  ape[0].    #####
+00027070: 2323 2077 6520 7261 6e64 6f6d 6c79 2073  ## we randomly s
+00027080: 616d 706c 6520 6120 736d 616c 6c20 6461  ample a small da
+00027090: 7461 7365 7420 746f 2063 6c61 7373 6966  taset to classif
+000270a0: 7920 6665 6174 7572 6573 2023 2323 2323  y features #####
+000270b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000270c0: 0a20 2020 2074 6573 745f 7369 7a65 203d  .    test_size =
+000270d0: 206d 696e 2830 2e39 2c20 2831 202d 2028   min(0.9, (1 - (
+000270e0: 6d61 7872 6f77 732f 4453 5f4c 454e 2929  maxrows/DS_LEN))
+000270f0: 2920 2323 2320 6d61 6b65 2073 7572 6520  ) ### make sure 
+00027100: 7468 6572 6520 6973 2061 2073 6d61 6c6c  there is a small
+00027110: 2074 7261 696e 2073 697a 650a 2020 2020   train size.    
+00027120: 6966 2074 6573 745f 7369 7a65 203c 3d20  if test_size <= 
+00027130: 303a 0a20 2020 2020 2020 2074 6573 745f  0:.        test_
+00027140: 7369 7a65 203d 2030 2e39 0a20 2020 2023  size = 0.9.    #
+00027150: 2323 2020 2046 6c6f 6174 2076 6172 6961  ##   Float varia
+00027160: 626c 6573 2061 7265 2063 6f6e 7369 6465  bles are conside
+00027170: 7265 6420 5265 6772 6573 7369 6f6e 2023  red Regression #
 00027180: 2323 2323 2323 2323 2323 2323 2323 2323  ################
 00027190: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000271a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000271b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000271c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000271d0: 2323 2323 2323 2323 2323 230a 636c 6173  ###########.clas
-000271e0: 7320 4665 6174 7572 6557 697a 2842 6173  s FeatureWiz(Bas
-000271f0: 6545 7374 696d 6174 6f72 2c20 5472 616e  eEstimator, Tran
-00027200: 7366 6f72 6d65 724d 6978 696e 293a 0a20  sformerMixin):. 
-00027210: 2020 2064 6566 205f 5f69 6e69 745f 5f28     def __init__(
-00027220: 7365 6c66 2c20 636f 7272 5f6c 696d 6974  self, corr_limit
-00027230: 3d30 2e39 302c 2076 6572 626f 7365 3d32  =0.90, verbose=2
-00027240: 2c20 7365 703d 272c 272c 200a 2020 2020  , sep=',', .    
-00027250: 2020 2020 6865 6164 6572 3d30 2c20 6665      header=0, fe
-00027260: 6174 7572 655f 656e 6767 3d27 272c 2063  ature_engg='', c
-00027270: 6174 6567 6f72 795f 656e 636f 6465 7273  ategory_encoders
-00027280: 3d27 272c 0a20 2020 2020 2020 2064 6173  ='',.        das
-00027290: 6b5f 7867 626f 6f73 745f 666c 6167 3d46  k_xgboost_flag=F
-000272a0: 616c 7365 2c20 6e72 6f77 733d 4e6f 6e65  alse, nrows=None
-000272b0: 2c20 736b 6970 5f73 756c 6f76 3d46 616c  , skip_sulov=Fal
-000272c0: 7365 293a 0a20 2020 2020 2020 2070 7269  se):.        pri
-000272d0: 6e74 2822 2222 7769 7a20 3d20 4665 6174  nt("""wiz = Feat
-000272e0: 7572 6557 697a 2876 6572 626f 7365 3d31  ureWiz(verbose=1
-000272f0: 290a 2020 2020 2020 2020 585f 7472 6169  ).        X_trai
-00027300: 6e5f 7365 6c65 6374 6564 203d 2077 697a  n_selected = wiz
-00027310: 2e66 6974 5f74 7261 6e73 666f 726d 2858  .fit_transform(X
-00027320: 5f74 7261 696e 2c20 795f 7472 6169 6e29  _train, y_train)
-00027330: 0a20 2020 2020 2020 2058 5f74 6573 745f  .        X_test_
-00027340: 7365 6c65 6374 6564 203d 2077 697a 2e74  selected = wiz.t
-00027350: 7261 6e73 666f 726d 2858 5f74 6573 7429  ransform(X_test)
-00027360: 0a20 2020 2020 2020 2077 697a 2e66 6561  .        wiz.fea
-00027370: 7475 7265 7320 2023 2323 2070 726f 7669  tures  ### provi
-00027380: 6465 7320 6120 6c69 7374 206f 6620 7365  des a list of se
-00027390: 6c65 6374 6564 2066 6561 7475 7265 7320  lected features 
-000273a0: 2323 2320 2020 2020 2020 2020 2020 200a  ###            .
-000273b0: 2020 2020 2020 2020 2222 2229 0a20 2020          """).   
-000273c0: 2020 2020 2073 656c 662e 6665 6174 7572       self.featur
-000273d0: 6573 203d 204e 6f6e 650a 2020 2020 2020  es = None.      
-000273e0: 2020 7365 6c66 2e63 6f72 725f 6c69 6d69    self.corr_limi
-000273f0: 743d 2063 6f72 725f 6c69 6d69 740a 2020  t= corr_limit.  
-00027400: 2020 2020 2020 7365 6c66 2e76 6572 626f        self.verbo
-00027410: 7365 3d76 6572 626f 7365 0a20 2020 2020  se=verbose.     
-00027420: 2020 2073 656c 662e 7365 703d 7365 700a     self.sep=sep.
-00027430: 2020 2020 2020 2020 7365 6c66 2e68 6561          self.hea
-00027440: 6465 723d 6865 6164 6572 0a20 2020 2020  der=header.     
-00027450: 2020 2073 656c 662e 7465 7374 5f64 6174     self.test_dat
-00027460: 6120 3d20 2222 2023 2320 6c65 6176 6520  a = "" ## leave 
-00027470: 7465 7374 6461 7461 2070 6572 6d61 6e65  testdata permane
-00027480: 6e74 6c79 2061 7320 656d 7074 7920 666f  ntly as empty fo
-00027490: 7220 6e6f 7720 2323 0a20 2020 2020 2020  r now ##.       
-000274a0: 2073 656c 662e 6665 6174 7572 655f 656e   self.feature_en
-000274b0: 6767 3d66 6561 7475 7265 5f65 6e67 670a  gg=feature_engg.
-000274c0: 2020 2020 2020 2020 7365 6c66 2e63 6174          self.cat
-000274d0: 6567 6f72 795f 656e 636f 6465 7273 3d63  egory_encoders=c
-000274e0: 6174 6567 6f72 795f 656e 636f 6465 7273  ategory_encoders
-000274f0: 0a20 2020 2020 2020 2073 656c 662e 6461  .        self.da
-00027500: 736b 5f78 6762 6f6f 7374 5f66 6c61 673d  sk_xgboost_flag=
-00027510: 6461 736b 5f78 6762 6f6f 7374 5f66 6c61  dask_xgboost_fla
-00027520: 670a 2020 2020 2020 2020 7365 6c66 2e6e  g.        self.n
-00027530: 726f 7773 3d6e 726f 7773 0a20 2020 2020  rows=nrows.     
-00027540: 2020 2073 656c 662e 736b 6970 5f73 756c     self.skip_sul
-00027550: 6f76 3d73 6b69 705f 7375 6c6f 760a 2020  ov=skip_sulov.  
-00027560: 2020 2020 2020 7365 6c66 2e58 5f73 656c        self.X_sel
-00027570: 203d 204e 6f6e 650a 0a20 2020 2064 6566   = None..    def
-00027580: 2066 6974 2873 656c 662c 2058 2c20 7929   fit(self, X, y)
-00027590: 3a0a 2020 2020 2020 2020 7374 6172 745f  :.        start_
-000275a0: 7469 6d65 203d 2074 696d 652e 7469 6d65  time = time.time
-000275b0: 2829 0a20 2020 2020 2020 2069 6620 6973  ().        if is
-000275c0: 696e 7374 616e 6365 2858 2c20 6e70 2e6e  instance(X, np.n
-000275d0: 6461 7272 6179 293a 0a20 2020 2020 2020  darray):.       
-000275e0: 2020 2020 2070 7269 6e74 2827 5820 696e       print('X in
-000275f0: 7075 7420 6d75 7374 2062 6520 6120 6461  put must be a da
-00027600: 7461 6672 616d 6520 7369 6e63 6520 7765  taframe since we
-00027610: 2075 7365 2063 6f6c 756d 6e20 6e61 6d65   use column name
-00027620: 7320 746f 2062 7569 6c64 2064 6174 6120  s to build data 
-00027630: 7069 7065 6c69 6e65 732e 2052 6574 7572  pipelines. Retur
-00027640: 6e69 6e67 2729 0a20 2020 2020 2020 2020  ning').         
-00027650: 2020 2072 6574 7572 6e20 582c 2079 0a20     return X, y. 
-00027660: 2020 2020 2020 2058 5f69 6e64 6578 203d         X_index =
-00027670: 2058 2e69 6e64 6578 0a20 2020 2020 2020   X.index.       
-00027680: 2069 6620 6973 696e 7374 616e 6365 2879   if isinstance(y
-00027690: 2c20 6e70 2e6e 6461 7272 6179 293a 0a20  , np.ndarray):. 
-000276a0: 2020 2020 2020 2020 2020 2070 7269 6e74             print
-000276b0: 2827 2020 2079 2069 6e70 7574 2069 7320  ('   y input is 
-000276c0: 616e 206e 756d 7079 2061 7272 6179 2061  an numpy array a
-000276d0: 6e64 2068 656e 6365 2063 6f6e 7665 7274  nd hence convert
-000276e0: 2069 6e74 6f20 6120 7365 7269 6573 206f   into a series o
-000276f0: 7220 6461 7461 6672 616d 6520 616e 6420  r dataframe and 
-00027700: 7265 2d74 7279 2e27 290a 2020 2020 2020  re-try.').      
-00027710: 2020 2020 2020 7265 7475 726e 2058 2c20        return X, 
-00027720: 790a 2020 2020 2020 2020 795f 696e 6465  y.        y_inde
-00027730: 7820 3d20 792e 696e 6465 780a 2020 2020  x = y.index.    
-00027740: 2020 2020 6966 2028 585f 696e 6465 7820      if (X_index 
-00027750: 3d3d 2079 5f69 6e64 6578 292e 616c 6c28  == y_index).all(
-00027760: 293a 0a20 2020 2020 2020 2020 2020 2064  ):.            d
-00027770: 6620 3d20 7064 2e63 6f6e 6361 7428 5b58  f = pd.concat([X
-00027780: 2c20 795d 2c20 6178 6973 3d31 290a 2020  , y], axis=1).  
-00027790: 2020 2020 2020 656c 7365 3a0a 2020 2020        else:.    
-000277a0: 2020 2020 2020 2020 6466 203d 2070 642e          df = pd.
-000277b0: 636f 6e63 6174 285b 582e 7265 7365 745f  concat([X.reset_
-000277c0: 696e 6465 7828 6472 6f70 3d54 7275 6529  index(drop=True)
-000277d0: 2c20 795d 2c20 6178 6973 3d31 290a 2020  , y], axis=1).  
-000277e0: 2020 2020 2020 2020 2020 6466 2e69 6e64            df.ind
-000277f0: 6578 203d 2058 5f69 6e64 6578 0a20 2020  ex = X_index.   
-00027800: 2020 2020 2023 2323 204e 6f77 2079 6f75       ### Now you
-00027810: 2063 616e 2070 726f 6365 7373 2074 6865   can process the
-00027820: 2058 2061 6e64 2079 2064 6174 6173 6574   X and y dataset
-00027830: 7320 2323 2323 0a20 2020 2020 2020 2069  s ####.        i
-00027840: 6620 6973 696e 7374 616e 6365 2879 2c20  f isinstance(y, 
-00027850: 7064 2e53 6572 6965 7329 3a0a 2020 2020  pd.Series):.    
-00027860: 2020 2020 2020 2020 7461 7267 6574 203d          target =
-00027870: 2079 2e6e 616d 650a 2020 2020 2020 2020   y.name.        
-00027880: 2020 2020 6966 2074 6172 6765 7420 6973      if target is
-00027890: 204e 6f6e 653a 0a20 2020 2020 2020 2020   None:.         
-000278a0: 2020 2020 2020 2070 7269 6e74 2827 2020         print('  
-000278b0: 2079 2069 6e70 7574 2069 7320 6120 7061   y input is a pa
-000278c0: 6e64 6173 2073 6572 6965 7320 7769 7468  ndas series with
-000278d0: 206e 6f20 6e61 6d65 2e20 436f 6e76 6572   no name. Conver
-000278e0: 7420 6974 2061 6e64 2072 652d 7472 792e  t it and re-try.
-000278f0: 2729 0a20 2020 2020 2020 2020 2020 2020  ').             
-00027900: 2020 2072 6574 7572 6e20 582c 2079 2020     return X, y  
-00027910: 2020 2020 2020 2020 2020 2020 2020 0a20                . 
-00027920: 2020 2020 2020 2065 6c69 6620 6973 696e         elif isin
-00027930: 7374 616e 6365 2879 2c20 7064 2e44 6174  stance(y, pd.Dat
-00027940: 6146 7261 6d65 293a 0a20 2020 2020 2020  aFrame):.       
-00027950: 2020 2020 2074 6172 6765 7420 3d20 792e       target = y.
-00027960: 636f 6c75 6d6e 732e 746f 6c69 7374 2829  columns.tolist()
-00027970: 0a20 2020 2020 2020 2065 6c69 6620 6973  .        elif is
-00027980: 696e 7374 616e 6365 2858 2c20 6e70 2e6e  instance(X, np.n
-00027990: 6461 7272 6179 293a 0a20 2020 2020 2020  darray):.       
-000279a0: 2020 2020 2070 7269 6e74 2827 7920 6d75       print('y mu
-000279b0: 7374 2062 6520 6120 7064 2e53 6572 6965  st be a pd.Serie
-000279c0: 7320 6f72 2070 642e 4461 7461 4672 616d  s or pd.DataFram
-000279d0: 6520 7369 6e63 6520 7765 2075 7365 2063  e since we use c
-000279e0: 6f6c 756d 6e20 6e61 6d65 7320 746f 2062  olumn names to b
-000279f0: 7569 6c64 2064 6174 6120 7069 7065 6c69  uild data pipeli
-00027a00: 6e65 2e20 5265 7475 726e 696e 6727 290a  ne. Returning').
-00027a10: 2020 2020 2020 2020 2020 2020 7265 7475              retu
-00027a20: 726e 207b 7d2c 207b 7d0a 2020 2020 2020  rn {}, {}.      
-00027a30: 2020 2323 2323 2053 656e 6420 7461 7267    #### Send targ
-00027a40: 6574 2076 6172 6961 626c 6520 6173 2069  et variable as i
-00027a50: 7420 6973 2073 6f20 7468 6174 2079 5f74  t is so that y_t
-00027a60: 7261 696e 2069 7320 616e 616c 797a 6564  rain is analyzed
-00027a70: 2070 726f 7065 726c 7920 2323 230a 2020   properly ###.  
-00027a80: 2020 2020 2020 2320 5365 6c65 6374 2066        # Select f
-00027a90: 6561 7475 7265 7320 7573 696e 6720 6665  eatures using fe
-00027aa0: 6174 7572 6577 697a 0a20 2020 2020 2020  aturewiz.       
-00027ab0: 2066 6561 7475 7265 732c 2058 5f73 656c   features, X_sel
-00027ac0: 203d 2066 6561 7475 7265 7769 7a28 6466   = featurewiz(df
-00027ad0: 2c20 7461 7267 6574 2c20 7365 6c66 2e63  , target, self.c
-00027ae0: 6f72 725f 6c69 6d69 742c 2073 656c 662e  orr_limit, self.
-00027af0: 7665 7262 6f73 652c 2073 656c 662e 7365  verbose, self.se
-00027b00: 702c 200a 2020 2020 2020 2020 2020 2020  p, .            
-00027b10: 2020 2020 7365 6c66 2e68 6561 6465 722c      self.header,
-00027b20: 2073 656c 662e 7465 7374 5f64 6174 612c   self.test_data,
-00027b30: 2073 656c 662e 6665 6174 7572 655f 656e   self.feature_en
-00027b40: 6767 2c20 7365 6c66 2e63 6174 6567 6f72  gg, self.categor
-00027b50: 795f 656e 636f 6465 7273 2c0a 2020 2020  y_encoders,.    
-00027b60: 2020 2020 2020 2020 2020 2020 7365 6c66              self
-00027b70: 2e64 6173 6b5f 7867 626f 6f73 745f 666c  .dask_xgboost_fl
-00027b80: 6167 2c20 7365 6c66 2e6e 726f 7773 2c20  ag, self.nrows, 
-00027b90: 7365 6c66 2e73 6b69 705f 7375 6c6f 7629  self.skip_sulov)
-00027ba0: 0a20 2020 2020 2020 2023 2043 6f6e 7665  .        # Conve
-00027bb0: 7274 2074 6865 2072 656d 6169 6e69 6e67  rt the remaining
-00027bc0: 2063 6f6c 756d 6e20 6e61 6d65 7320 6261   column names ba
-00027bd0: 636b 2074 6f20 696e 7465 6765 7273 2061  ck to integers a
-00027be0: 6e64 2064 726f 7020 7468 650a 2020 2020  nd drop the.    
-00027bf0: 2020 2020 6469 6666 7469 6d65 203d 206d      difftime = m
-00027c00: 6178 2831 2c20 696e 7428 7469 6d65 2e74  ax(1, int(time.t
-00027c10: 696d 6528 292d 7374 6172 745f 7469 6d65  ime()-start_time
-00027c20: 2929 0a20 2020 2020 2020 2070 7269 6e74  )).        print
-00027c30: 2827 2020 2020 5469 6d65 2074 616b 656e  ('    Time taken
-00027c40: 2074 6f20 6372 6561 7465 2065 6e74 6972   to create entir
-00027c50: 6520 7069 7065 6c69 6e65 203d 2025 7320  e pipeline = %s 
-00027c60: 7365 636f 6e64 2873 2927 2025 6469 6666  second(s)' %diff
-00027c70: 7469 6d65 290a 2020 2020 2020 2020 2320  time).        # 
-00027c80: 636f 6c75 6d6e 206f 6620 6c61 6265 6c73  column of labels
-00027c90: 0a20 2020 2020 2020 2073 656c 662e 6665  .        self.fe
-00027ca0: 6174 7572 6573 203d 2066 6561 7475 7265  atures = feature
-00027cb0: 730a 2020 2020 2020 2020 7365 6c66 2e58  s.        self.X
-00027cc0: 5f73 656c 203d 2058 5f73 656c 0a20 2020  _sel = X_sel.   
-00027cd0: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
-00027ce0: 0a0a 2020 2020 6465 6620 7472 616e 7366  ..    def transf
-00027cf0: 6f72 6d28 7365 6c66 2c20 5829 3a0a 2020  orm(self, X):.  
-00027d00: 2020 2020 2020 7472 793a 0a20 2020 2020        try:.     
-00027d10: 2020 2020 2020 2072 6574 7572 6e20 585b         return X[
-00027d20: 7365 6c66 2e66 6561 7475 7265 735d 0a20  self.features]. 
-00027d30: 2020 2020 2020 2065 7863 6570 743a 0a20         except:. 
-00027d40: 2020 2020 2020 2020 2020 2070 7269 6e74             print
-00027d50: 2827 5265 7475 726e 696e 6720 7472 616e  ('Returning tran
-00027d60: 7366 6f72 6d65 6420 6461 7461 6672 616d  sformed datafram
-00027d70: 6520 7769 7468 2025 6420 6665 6174 7572  e with %d featur
-00027d80: 6573 2720 256c 656e 2873 656c 662e 6665  es' %len(self.fe
-00027d90: 6174 7572 6573 2929 0a20 2020 2020 2020  atures)).       
-00027da0: 2020 2020 2072 6574 7572 6e20 7365 6c66       return self
-00027db0: 2e58 5f73 656c 0a23 2323 2323 2323 2323  .X_sel.#########
-00027dc0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00027dd0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00027de0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00027df0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00027e00: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00027e10: 2323 2323 2323 2323 2323 0a64 6566 2045  ##########.def E
-00027e20: 4441 5f72 656d 6f76 655f 7370 6563 6961  DA_remove_specia
-00027e30: 6c5f 6368 6172 7328 6466 293a 0a20 2020  l_chars(df):.   
-00027e40: 2022 2222 0a20 2020 2054 6869 7320 6675   """.    This fu
-00027e50: 6e63 7469 6f6e 2072 656d 6f76 6573 2073  nction removes s
-00027e60: 7065 6369 616c 2063 6861 7273 2066 726f  pecial chars fro
-00027e70: 6d20 636f 6c75 6d6e 206e 616d 6573 2061  m column names a
-00027e80: 6e64 2072 6574 7572 6e73 2061 2064 6620  nd returns a df 
-00027e90: 7769 7468 206e 6577 2063 6f6c 756d 6e20  with new column 
-00027ea0: 6e61 6d65 732e 0a20 2020 2049 6e70 7574  names..    Input
-00027eb0: 7320 616e 6420 6f75 7470 7574 7320 6172  s and outputs ar
-00027ec0: 6520 626f 7468 2074 6865 2073 616d 6520  e both the same 
-00027ed0: 6461 7461 6672 616d 6520 6578 6365 7074  dataframe except
-00027ee0: 2063 6f6c 756d 6e20 6e61 6d65 7320 6172   column names ar
-00027ef0: 6520 6368 616e 6765 642e 0a20 2020 2022  e changed..    "
-00027f00: 2222 0a20 2020 2069 6d70 6f72 7420 636f  "".    import co
-00027f10: 7079 0a20 2020 2069 6d70 6f72 7420 7265  py.    import re
-00027f20: 0a20 2020 2063 6f6c 7320 3d20 6466 2e63  .    cols = df.c
-00027f30: 6f6c 756d 6e73 2e74 6f6c 6973 7428 290a  olumns.tolist().
-00027f40: 2020 2020 636f 7079 5f63 6f6c 7320 3d20      copy_cols = 
-00027f50: 636f 7079 2e64 6565 7063 6f70 7928 636f  copy.deepcopy(co
-00027f60: 6c73 290a 2020 2020 7365 7220 3d20 7064  ls).    ser = pd
-00027f70: 2e53 6572 6965 7328 636f 6c73 290a 2020  .Series(cols).  
-00027f80: 2020 2323 2320 5468 6973 2066 756e 6374    ### This funct
-00027f90: 696f 6e20 7265 6d6f 7665 7320 616c 6c20  ion removes all 
-00027fa0: 7370 6563 6961 6c20 6368 6172 7320 6672  special chars fr
-00027fb0: 6f6d 2061 206c 6973 7420 2323 230a 2020  om a list ###.  
-00027fc0: 2020 7265 6d6f 7665 5f73 7065 6369 616c    remove_special
-00027fd0: 5f63 6861 7273 203d 2020 6c61 6d62 6461  _chars =  lambda
-00027fe0: 2078 3a72 652e 7375 6228 275b 5e41 2d5a   x:re.sub('[^A-Z
-00027ff0: 612d 7a30 2d39 5f5d 2b27 2c20 2727 2c20  a-z0-9_]+', '', 
-00028000: 7829 0a20 2020 206e 6577 6c73 203d 2073  x).    newls = s
-00028010: 6572 2e6d 6170 2872 656d 6f76 655f 7370  er.map(remove_sp
-00028020: 6563 6961 6c5f 6368 6172 7329 2e76 616c  ecial_chars).val
-00028030: 7565 732e 746f 6c69 7374 2829 0a20 2020  ues.tolist().   
-00028040: 2064 662e 636f 6c75 6d6e 7320 3d20 6e65   df.columns = ne
-00028050: 776c 730a 2020 2020 7265 7475 726e 2064  wls.    return d
-00028060: 660a 2323 2323 2323 2323 2323 2323 2323  f.##############
-00028070: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00028080: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00028090: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000280a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000280b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000280c0: 2323 2323 230a 6465 6620 6461 736b 5f78  #####.def dask_x
-000280d0: 6762 6f6f 7374 5f74 7261 696e 696e 6728  gboost_training(
-000280e0: 585f 7472 6169 6e78 2c20 795f 7472 6169  X_trainx, y_trai
-000280f0: 6e78 2c20 7061 7261 6d73 293a 0a20 2020  nx, params):.   
-00028100: 200a 2020 2020 636c 7573 7465 7220 3d20   .    cluster = 
-00028110: 6461 736b 2e64 6973 7472 6962 7574 6564  dask.distributed
-00028120: 2e4c 6f63 616c 436c 7573 7465 7228 290a  .LocalCluster().
-00028130: 2020 2020 6461 736b 5f63 6c69 656e 7420      dask_client 
-00028140: 3d20 6461 736b 2e64 6973 7472 6962 7574  = dask.distribut
-00028150: 6564 2e43 6c69 656e 7428 636c 7573 7465  ed.Client(cluste
-00028160: 7229 0a20 2020 2058 5f74 7261 696e 7820  r).    X_trainx 
-00028170: 3d20 6464 2e66 726f 6d5f 7061 6e64 6173  = dd.from_pandas
-00028180: 2858 5f74 7261 696e 2c20 6e70 6172 7469  (X_train, nparti
-00028190: 7469 6f6e 733d 3129 0a20 2020 2079 5f74  tions=1).    y_t
-000281a0: 7261 696e 7820 3d20 6464 2e66 726f 6d5f  rainx = dd.from_
-000281b0: 7061 6e64 6173 2879 5f74 7261 696e 2c20  pandas(y_train, 
-000281c0: 6e70 6172 7469 7469 6f6e 733d 3129 0a20  npartitions=1). 
-000281d0: 2020 2070 7269 6e74 2822 4441 534b 2058     print("DASK X
-000281e0: 4742 6f6f 7374 2074 7261 696e 696e 672e  GBoost training.
-000281f0: 2e2e 2229 0a20 2020 2064 7472 6169 6e20  ..").    dtrain 
-00028200: 3d20 7867 622e 6461 736b 2e44 6173 6b44  = xgb.dask.DaskD
-00028210: 4d61 7472 6978 2864 6173 6b5f 636c 6965  Matrix(dask_clie
-00028220: 6e74 2c20 585f 7472 6169 6e78 2c20 795f  nt, X_trainx, y_
-00028230: 7472 6169 6e78 290a 2020 2020 6273 7420  trainx).    bst 
-00028240: 3d20 7867 622e 6461 736b 2e74 7261 696e  = xgb.dask.train
-00028250: 2864 6173 6b5f 636c 6965 6e74 2c20 7061  (dask_client, pa
-00028260: 7261 6d73 2c20 6474 7261 696e 2c20 6e75  rams, dtrain, nu
-00028270: 6d5f 626f 6f73 745f 726f 756e 643d 3130  m_boost_round=10
-00028280: 290a 2020 2020 6461 736b 5f63 6c69 656e  ).    dask_clien
-00028290: 742e 636c 6f73 6528 290a 2020 2020 7072  t.close().    pr
-000282a0: 696e 7428 2220 2020 2074 7261 696e 696e  int("    trainin
-000282b0: 6720 636f 6d70 6c65 7465 642e 2e2e 2229  g completed...")
-000282c0: 0a20 2020 2072 6574 7572 6e20 6273 740a  .    return bst.
-000282d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000282e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000282f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00028300: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00028310: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00028320: 2323 2323 0a64 6566 2046 455f 7265 6d6f  ####.def FE_remo
-00028330: 7665 5f63 6f6d 6d61 735f 696e 5f6e 756d  ve_commas_in_num
-00028340: 6572 6963 7328 7472 6169 6e2c 206e 756d  erics(train, num
-00028350: 733d 5b5d 293a 0a20 2020 2022 2222 200a  s=[]):.    """ .
-00028360: 2020 2020 5468 6973 2066 756e 6374 696f      This functio
-00028370: 6e20 7265 6d6f 7665 7320 636f 6d6d 6173  n removes commas
-00028380: 2069 6e20 6e75 6d65 7269 6320 636f 6c75   in numeric colu
-00028390: 6d6e 7320 616e 6420 7265 7475 726e 7320  mns and returns 
-000283a0: 7468 6520 636f 6c75 6d6e 7320 7472 616e  the columns tran
-000283b0: 7366 6f72 6d65 642e 0a20 2020 2059 6f75  sformed..    You
-000283c0: 2063 616e 2073 656e 6420 696e 2061 2064   can send in a d
-000283d0: 6174 6166 7261 6d65 2077 6974 6820 6f6e  ataframe with on
-000283e0: 6520 636f 6c75 6d6e 206e 616d 6520 6173  e column name as
-000283f0: 2061 2073 7472 696e 6720 6f72 2061 206c   a string or a l
-00028400: 6973 7420 6f66 2063 6f6c 756d 6e73 2e0a  ist of columns..
-00028410: 2020 2020 5265 7475 726e 7320 6120 7369      Returns a si
-00028420: 6e67 6c65 2061 7272 6179 2069 6620 6f6e  ngle array if on
-00028430: 6c79 206f 6e65 2063 6f6c 756d 6e20 6973  ly one column is
-00028440: 2073 656e 742e 0a20 2020 2052 6574 7572   sent..    Retur
-00028450: 6e73 2074 6865 2065 6e74 6972 6520 6461  ns the entire da
-00028460: 7461 6672 616d 6520 6966 2061 206c 6973  taframe if a lis
-00028470: 7420 6f66 2063 6f6c 756d 6e73 2069 7320  t of columns is 
-00028480: 7365 6e74 2e20 5468 6973 2069 6e63 6c75  sent. This inclu
-00028490: 6465 7320 616c 6c20 636f 6c75 6d6e 732e  des all columns.
-000284a0: 0a20 2020 2022 2222 0a20 2020 2074 7261  .    """.    tra
-000284b0: 696e 203d 2063 6f70 792e 6465 6570 636f  in = copy.deepco
-000284c0: 7079 2874 7261 696e 290a 2020 2020 6966  py(train).    if
-000284d0: 2069 7369 6e73 7461 6e63 6528 6e75 6d73   isinstance(nums
-000284e0: 2c20 7374 7229 3a0a 2020 2020 2020 2020  , str):.        
-000284f0: 7265 7475 726e 2074 7261 696e 5b65 6163  return train[eac
-00028500: 685f 6e75 6d5d 2e6d 6170 286c 616d 6264  h_num].map(lambd
-00028510: 6120 783a 2066 6c6f 6174 2822 222e 6a6f  a x: float("".jo
-00028520: 696e 2820 782e 7370 6c69 7428 222c 2229  in( x.split(",")
-00028530: 2929 292e 7661 6c75 6573 0a20 2020 2065  ))).values.    e
-00028540: 6c73 653a 0a20 2020 2020 2020 2066 6f72  lse:.        for
-00028550: 2065 6163 685f 6e75 6d20 696e 206e 756d   each_num in num
-00028560: 733a 0a20 2020 2020 2020 2020 2020 2074  s:.            t
-00028570: 7261 696e 5b65 6163 685f 6e75 6d5d 203d  rain[each_num] =
-00028580: 2074 7261 696e 5b65 6163 685f 6e75 6d5d   train[each_num]
-00028590: 2e6d 6170 286c 616d 6264 6120 783a 2066  .map(lambda x: f
-000285a0: 6c6f 6174 2822 222e 6a6f 696e 2820 782e  loat("".join( x.
-000285b0: 7370 6c69 7428 222c 2229 2929 292e 7661  split(",")))).va
-000285c0: 6c75 6573 0a20 2020 2072 6574 7572 6e20  lues.    return 
-000285d0: 7472 6169 6e0a 2323 2323 2323 2323 2323  train.##########
-000285e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000285f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00028600: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000271a0: 2323 2323 0a20 2020 206d 6f64 656c 7479  ####.    modelty
+000271b0: 7065 2c20 5f20 3d20 616e 616c 797a 655f  pe, _ = analyze_
+000271c0: 7072 6f62 6c65 6d5f 7479 7065 2874 7261  problem_type(tra
+000271d0: 696e 5f64 6174 6166 7261 6d65 5b63 6f70  in_dataframe[cop
+000271e0: 795f 7461 7267 6574 735d 2c20 636f 7079  y_targets], copy
+000271f0: 5f74 6172 6765 7473 2c20 7665 7262 6f73  _targets, verbos
+00027200: 653d 3029 0a20 2020 2023 2323 2323 2323  e=0).    #######
+00027210: 2049 6620 6974 2069 7320 6120 636c 6173   If it is a clas
+00027220: 7369 6669 6361 7469 6f6e 2070 726f 626c  sification probl
+00027230: 656d 2c20 796f 7520 6e65 6564 2074 6f20  em, you need to 
+00027240: 7374 7261 7469 6679 2061 6e64 2073 656c  stratify and sel
+00027250: 6563 7420 7361 6d70 6c65 2023 2323 0a20  ect sample ###. 
+00027260: 2020 2069 6620 6d6f 6465 6c74 7970 6520     if modeltype 
+00027270: 213d 2027 5265 6772 6573 7369 6f6e 273a  != 'Regression':
+00027280: 0a20 2020 2020 2020 2070 7269 6e74 2827  .        print('
+00027290: 2020 2020 6c6f 6164 696e 6720 6120 7261      loading a ra
+000272a0: 6e64 6f6d 2073 616d 706c 6520 6f66 2025  ndom sample of %
+000272b0: 6420 726f 7773 2069 6e74 6f20 7061 6e64  d rows into pand
+000272c0: 6173 2066 6f72 2045 4441 2720 256e 726f  as for EDA' %nro
+000272d0: 7773 5f6c 696d 6974 290a 2020 2020 2020  ws_limit).      
+000272e0: 2020 666f 7220 6561 6368 5f74 6172 6765    for each_targe
+000272f0: 7420 696e 2063 6f70 795f 7461 7267 6574  t in copy_target
+00027300: 733a 0a20 2020 2020 2020 2020 2020 2023  s:.            #
+00027310: 2323 2059 6f75 206e 6565 6420 746f 2072  ## You need to r
+00027320: 656d 6f76 6520 726f 7773 2074 6861 7420  emove rows that 
+00027330: 6861 7665 2076 6572 7920 636c 6173 7320  have very class 
+00027340: 7361 6d70 6c65 7320 2d20 7468 6174 2069  samples - that i
+00027350: 7320 6120 7072 6f62 6c65 6d20 7768 696c  s a problem whil
+00027360: 6520 7370 6c69 7474 696e 6720 7472 6169  e splitting trai
+00027370: 6e5f 736d 616c 6c0a 2020 2020 2020 2020  n_small.        
+00027380: 2020 2020 6c69 7374 5f6f 665f 6665 775f      list_of_few_
+00027390: 636c 6173 7365 7320 3d20 7472 6169 6e5f  classes = train_
+000273a0: 6461 7461 6672 616d 655b 6561 6368 5f74  dataframe[each_t
+000273b0: 6172 6765 745d 2e76 616c 7565 5f63 6f75  arget].value_cou
+000273c0: 6e74 7328 295b 7472 6169 6e5f 6461 7461  nts()[train_data
+000273d0: 6672 616d 655b 6561 6368 5f74 6172 6765  frame[each_targe
+000273e0: 745d 2e76 616c 7565 5f63 6f75 6e74 7328  t].value_counts(
+000273f0: 293c 3d33 5d2e 696e 6465 782e 746f 6c69  )<=3].index.toli
+00027400: 7374 2829 0a20 2020 2020 2020 2020 2020  st().           
+00027410: 2074 7261 696e 5f64 6174 6166 7261 6d65   train_dataframe
+00027420: 203d 2074 7261 696e 5f64 6174 6166 7261   = train_datafra
+00027430: 6d65 2e6c 6f63 5b7e 2874 7261 696e 5f64  me.loc[~(train_d
+00027440: 6174 6166 7261 6d65 5b65 6163 685f 7461  ataframe[each_ta
+00027450: 7267 6574 5d2e 6973 696e 286c 6973 745f  rget].isin(list_
+00027460: 6f66 5f66 6577 5f63 6c61 7373 6573 2929  of_few_classes))
+00027470: 5d0a 2020 2020 2020 2020 7472 793a 0a20  ].        try:. 
+00027480: 2020 2020 2020 2020 2020 2074 7261 696e             train
+00027490: 5f73 6d61 6c6c 2c20 5f20 3d20 7472 6169  _small, _ = trai
+000274a0: 6e5f 7465 7374 5f73 706c 6974 2874 7261  n_test_split(tra
+000274b0: 696e 5f64 6174 6166 7261 6d65 2c20 7465  in_dataframe, te
+000274c0: 7374 5f73 697a 653d 7465 7374 5f73 697a  st_size=test_siz
+000274d0: 652c 2073 7472 6174 6966 793d 7472 6169  e, stratify=trai
+000274e0: 6e5f 6461 7461 6672 616d 655b 7461 7267  n_dataframe[targ
+000274f0: 6574 735d 290a 2020 2020 2020 2020 6578  ets]).        ex
+00027500: 6365 7074 3a0a 2020 2020 2020 2020 2020  cept:.          
+00027510: 2020 2323 2054 6869 7320 7370 6c69 7420    ## This split 
+00027520: 736f 6d65 7469 6d65 7320 6572 726f 7273  sometimes errors
+00027530: 2e20 4974 2069 7320 7468 656e 2062 6574  . It is then bet
+00027540: 7465 7220 746f 2073 706c 6974 2075 7369  ter to split usi
+00027550: 6e67 2061 2072 616e 646f 6d20 7361 6d70  ng a random samp
+00027560: 6c65 2023 230a 2020 2020 2020 2020 2020  le ##.          
+00027570: 2020 7472 6169 6e5f 736d 616c 6c20 3d20    train_small = 
+00027580: 7472 6169 6e5f 6461 7461 6672 616d 652e  train_dataframe.
+00027590: 7361 6d70 6c65 286e 3d6e 726f 7773 5f6c  sample(n=nrows_l
+000275a0: 696d 6974 2c20 7265 706c 6163 653d 5472  imit, replace=Tr
+000275b0: 7565 2c20 7261 6e64 6f6d 5f73 7461 7465  ue, random_state
+000275c0: 3d39 3929 0a20 2020 2065 6c73 653a 0a20  =99).    else:. 
+000275d0: 2020 2020 2020 2023 2323 2046 6f72 2052         ### For R
+000275e0: 6567 7265 7373 696f 6e20 7072 6f62 6c65  egression proble
+000275f0: 6d73 3a20 6c6f 6164 2061 2073 6d61 6c6c  ms: load a small
+00027600: 2073 616d 706c 6520 6f66 2064 6174 6120   sample of data 
+00027610: 696e 746f 2061 2070 616e 6461 7320 6461  into a pandas da
+00027620: 7461 6672 616d 6520 2323 0a20 2020 2020  taframe ##.     
+00027630: 2020 2070 7269 6e74 2827 2020 2020 6c6f     print('    lo
+00027640: 6164 696e 6720 6120 7365 7175 656e 7469  ading a sequenti
+00027650: 616c 2073 616d 706c 6520 6f66 2025 6420  al sample of %d 
+00027660: 726f 7773 2069 6e74 6f20 7061 6e64 6173  rows into pandas
+00027670: 2066 6f72 2045 4441 2720 256e 726f 7773   for EDA' %nrows
+00027680: 5f6c 696d 6974 290a 2020 2020 2020 2020  _limit).        
+00027690: 7472 6169 6e5f 736d 616c 6c20 3d20 7472  train_small = tr
+000276a0: 6169 6e5f 6461 7461 6672 616d 655b 3a6e  ain_dataframe[:n
+000276b0: 726f 7773 5f6c 696d 6974 5d0a 2020 2020  rows_limit].    
+000276c0: 7265 7475 726e 2074 7261 696e 5f73 6d61  return train_sma
+000276d0: 6c6c 0a23 2323 2323 2323 2323 2323 2323  ll.#############
+000276e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000276f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00027700: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00027710: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00027720: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00027730: 2323 230a 636c 6173 7320 4665 6174 7572  ###.class Featur
+00027740: 6557 697a 2842 6173 6545 7374 696d 6174  eWiz(BaseEstimat
+00027750: 6f72 2c20 5472 616e 7366 6f72 6d65 724d  or, TransformerM
+00027760: 6978 696e 293a 0a20 2020 2064 6566 205f  ixin):.    def _
+00027770: 5f69 6e69 745f 5f28 7365 6c66 2c20 636f  _init__(self, co
+00027780: 7272 5f6c 696d 6974 3d30 2e39 302c 2076  rr_limit=0.90, v
+00027790: 6572 626f 7365 3d32 2c20 7365 703d 272c  erbose=2, sep=',
+000277a0: 272c 200a 2020 2020 2020 2020 6865 6164  ', .        head
+000277b0: 6572 3d30 2c20 6665 6174 7572 655f 656e  er=0, feature_en
+000277c0: 6767 3d27 272c 2063 6174 6567 6f72 795f  gg='', category_
+000277d0: 656e 636f 6465 7273 3d27 272c 0a20 2020  encoders='',.   
+000277e0: 2020 2020 2064 6173 6b5f 7867 626f 6f73       dask_xgboos
+000277f0: 745f 666c 6167 3d46 616c 7365 2c20 6e72  t_flag=False, nr
+00027800: 6f77 733d 4e6f 6e65 2c20 736b 6970 5f73  ows=None, skip_s
+00027810: 756c 6f76 3d46 616c 7365 2c20 736b 6970  ulov=False, skip
+00027820: 5f78 6762 6f6f 7374 3d46 616c 7365 293a  _xgboost=False):
+00027830: 0a20 2020 2020 2020 2070 7269 6e74 2822  .        print("
+00027840: 2222 7769 7a20 3d20 4665 6174 7572 6557  ""wiz = FeatureW
+00027850: 697a 2876 6572 626f 7365 3d31 290a 2020  iz(verbose=1).  
+00027860: 2020 2020 2020 585f 7472 6169 6e5f 7365        X_train_se
+00027870: 6c65 6374 6564 203d 2077 697a 2e66 6974  lected = wiz.fit
+00027880: 5f74 7261 6e73 666f 726d 2858 5f74 7261  _transform(X_tra
+00027890: 696e 2c20 795f 7472 6169 6e29 0a20 2020  in, y_train).   
+000278a0: 2020 2020 2058 5f74 6573 745f 7365 6c65       X_test_sele
+000278b0: 6374 6564 203d 2077 697a 2e74 7261 6e73  cted = wiz.trans
+000278c0: 666f 726d 2858 5f74 6573 7429 0a20 2020  form(X_test).   
+000278d0: 2020 2020 2077 697a 2e66 6561 7475 7265       wiz.feature
+000278e0: 7320 2023 2323 2070 726f 7669 6465 7320  s  ### provides 
+000278f0: 6120 6c69 7374 206f 6620 7365 6c65 6374  a list of select
+00027900: 6564 2066 6561 7475 7265 7320 2323 2320  ed features ### 
+00027910: 2020 2020 2020 2020 2020 200a 2020 2020             .    
+00027920: 2020 2020 2222 2229 0a20 2020 2020 2020      """).       
+00027930: 2073 656c 662e 6665 6174 7572 6573 203d   self.features =
+00027940: 204e 6f6e 650a 2020 2020 2020 2020 7365   None.        se
+00027950: 6c66 2e63 6f72 725f 6c69 6d69 743d 2063  lf.corr_limit= c
+00027960: 6f72 725f 6c69 6d69 740a 2020 2020 2020  orr_limit.      
+00027970: 2020 7365 6c66 2e76 6572 626f 7365 3d76    self.verbose=v
+00027980: 6572 626f 7365 0a20 2020 2020 2020 2073  erbose.        s
+00027990: 656c 662e 7365 703d 7365 700a 2020 2020  elf.sep=sep.    
+000279a0: 2020 2020 7365 6c66 2e68 6561 6465 723d      self.header=
+000279b0: 6865 6164 6572 0a20 2020 2020 2020 2073  header.        s
+000279c0: 656c 662e 7465 7374 5f64 6174 6120 3d20  elf.test_data = 
+000279d0: 2222 2023 2320 6c65 6176 6520 7465 7374  "" ## leave test
+000279e0: 6461 7461 2070 6572 6d61 6e65 6e74 6c79  data permanently
+000279f0: 2061 7320 656d 7074 7920 666f 7220 6e6f   as empty for no
+00027a00: 7720 2323 0a20 2020 2020 2020 2073 656c  w ##.        sel
+00027a10: 662e 6665 6174 7572 655f 656e 6767 3d66  f.feature_engg=f
+00027a20: 6561 7475 7265 5f65 6e67 670a 2020 2020  eature_engg.    
+00027a30: 2020 2020 7365 6c66 2e63 6174 6567 6f72      self.categor
+00027a40: 795f 656e 636f 6465 7273 3d63 6174 6567  y_encoders=categ
+00027a50: 6f72 795f 656e 636f 6465 7273 0a20 2020  ory_encoders.   
+00027a60: 2020 2020 2073 656c 662e 6461 736b 5f78       self.dask_x
+00027a70: 6762 6f6f 7374 5f66 6c61 673d 6461 736b  gboost_flag=dask
+00027a80: 5f78 6762 6f6f 7374 5f66 6c61 670a 2020  _xgboost_flag.  
+00027a90: 2020 2020 2020 7365 6c66 2e6e 726f 7773        self.nrows
+00027aa0: 3d6e 726f 7773 0a20 2020 2020 2020 2073  =nrows.        s
+00027ab0: 656c 662e 736b 6970 5f73 756c 6f76 3d73  elf.skip_sulov=s
+00027ac0: 6b69 705f 7375 6c6f 760a 2020 2020 2020  kip_sulov.      
+00027ad0: 2020 7365 6c66 2e73 6b69 705f 7867 626f    self.skip_xgbo
+00027ae0: 6f73 743d 736b 6970 5f78 6762 6f6f 7374  ost=skip_xgboost
+00027af0: 0a20 2020 2020 2020 2073 656c 662e 585f  .        self.X_
+00027b00: 7365 6c20 3d20 4e6f 6e65 0a0a 2020 2020  sel = None..    
+00027b10: 6465 6620 6669 7428 7365 6c66 2c20 582c  def fit(self, X,
+00027b20: 2079 293a 0a20 2020 2020 2020 2073 7461   y):.        sta
+00027b30: 7274 5f74 696d 6520 3d20 7469 6d65 2e74  rt_time = time.t
+00027b40: 696d 6528 290a 2020 2020 2020 2020 6966  ime().        if
+00027b50: 2069 7369 6e73 7461 6e63 6528 582c 206e   isinstance(X, n
+00027b60: 702e 6e64 6172 7261 7929 3a0a 2020 2020  p.ndarray):.    
+00027b70: 2020 2020 2020 2020 7072 696e 7428 2758          print('X
+00027b80: 2069 6e70 7574 206d 7573 7420 6265 2061   input must be a
+00027b90: 2064 6174 6166 7261 6d65 2073 696e 6365   dataframe since
+00027ba0: 2077 6520 7573 6520 636f 6c75 6d6e 206e   we use column n
+00027bb0: 616d 6573 2074 6f20 6275 696c 6420 6461  ames to build da
+00027bc0: 7461 2070 6970 656c 696e 6573 2e20 5265  ta pipelines. Re
+00027bd0: 7475 726e 696e 6727 290a 2020 2020 2020  turning').      
+00027be0: 2020 2020 2020 7265 7475 726e 2058 2c20        return X, 
+00027bf0: 790a 2020 2020 2020 2020 585f 696e 6465  y.        X_inde
+00027c00: 7820 3d20 582e 696e 6465 780a 2020 2020  x = X.index.    
+00027c10: 2020 2020 6966 2069 7369 6e73 7461 6e63      if isinstanc
+00027c20: 6528 792c 206e 702e 6e64 6172 7261 7929  e(y, np.ndarray)
+00027c30: 3a0a 2020 2020 2020 2020 2020 2020 7072  :.            pr
+00027c40: 696e 7428 2720 2020 7920 696e 7075 7420  int('   y input 
+00027c50: 6973 2061 6e20 6e75 6d70 7920 6172 7261  is an numpy arra
+00027c60: 7920 616e 6420 6865 6e63 6520 636f 6e76  y and hence conv
+00027c70: 6572 7420 696e 746f 2061 2073 6572 6965  ert into a serie
+00027c80: 7320 6f72 2064 6174 6166 7261 6d65 2061  s or dataframe a
+00027c90: 6e64 2072 652d 7472 792e 2729 0a20 2020  nd re-try.').   
+00027ca0: 2020 2020 2020 2020 2072 6574 7572 6e20           return 
+00027cb0: 582c 2079 0a20 2020 2020 2020 2079 5f69  X, y.        y_i
+00027cc0: 6e64 6578 203d 2079 2e69 6e64 6578 0a20  ndex = y.index. 
+00027cd0: 2020 2020 2020 2069 6620 2858 5f69 6e64         if (X_ind
+00027ce0: 6578 203d 3d20 795f 696e 6465 7829 2e61  ex == y_index).a
+00027cf0: 6c6c 2829 3a0a 2020 2020 2020 2020 2020  ll():.          
+00027d00: 2020 6466 203d 2070 642e 636f 6e63 6174    df = pd.concat
+00027d10: 285b 582c 2079 5d2c 2061 7869 733d 3129  ([X, y], axis=1)
+00027d20: 0a20 2020 2020 2020 2065 6c73 653a 0a20  .        else:. 
+00027d30: 2020 2020 2020 2020 2020 2064 6620 3d20             df = 
+00027d40: 7064 2e63 6f6e 6361 7428 5b58 2e72 6573  pd.concat([X.res
+00027d50: 6574 5f69 6e64 6578 2864 726f 703d 5472  et_index(drop=Tr
+00027d60: 7565 292c 2079 5d2c 2061 7869 733d 3129  ue), y], axis=1)
+00027d70: 0a20 2020 2020 2020 2020 2020 2064 662e  .            df.
+00027d80: 696e 6465 7820 3d20 585f 696e 6465 780a  index = X_index.
+00027d90: 2020 2020 2020 2020 2323 2320 4e6f 7720          ### Now 
+00027da0: 796f 7520 6361 6e20 7072 6f63 6573 7320  you can process 
+00027db0: 7468 6520 5820 616e 6420 7920 6461 7461  the X and y data
+00027dc0: 7365 7473 2023 2323 230a 2020 2020 2020  sets ####.      
+00027dd0: 2020 6966 2069 7369 6e73 7461 6e63 6528    if isinstance(
+00027de0: 792c 2070 642e 5365 7269 6573 293a 0a20  y, pd.Series):. 
+00027df0: 2020 2020 2020 2020 2020 2074 6172 6765             targe
+00027e00: 7420 3d20 792e 6e61 6d65 0a20 2020 2020  t = y.name.     
+00027e10: 2020 2020 2020 2069 6620 7461 7267 6574         if target
+00027e20: 2069 7320 4e6f 6e65 3a0a 2020 2020 2020   is None:.      
+00027e30: 2020 2020 2020 2020 2020 7072 696e 7428            print(
+00027e40: 2720 2020 7920 696e 7075 7420 6973 2061  '   y input is a
+00027e50: 2070 616e 6461 7320 7365 7269 6573 2077   pandas series w
+00027e60: 6974 6820 6e6f 206e 616d 652e 2043 6f6e  ith no name. Con
+00027e70: 7665 7274 2069 7420 616e 6420 7265 2d74  vert it and re-t
+00027e80: 7279 2e27 290a 2020 2020 2020 2020 2020  ry.').          
+00027e90: 2020 2020 2020 7265 7475 726e 2058 2c20        return X, 
+00027ea0: 7920 2020 2020 2020 2020 2020 2020 2020  y               
+00027eb0: 200a 2020 2020 2020 2020 656c 6966 2069   .        elif i
+00027ec0: 7369 6e73 7461 6e63 6528 792c 2070 642e  sinstance(y, pd.
+00027ed0: 4461 7461 4672 616d 6529 3a0a 2020 2020  DataFrame):.    
+00027ee0: 2020 2020 2020 2020 7461 7267 6574 203d          target =
+00027ef0: 2079 2e63 6f6c 756d 6e73 2e74 6f6c 6973   y.columns.tolis
+00027f00: 7428 290a 2020 2020 2020 2020 656c 6966  t().        elif
+00027f10: 2069 7369 6e73 7461 6e63 6528 582c 206e   isinstance(X, n
+00027f20: 702e 6e64 6172 7261 7929 3a0a 2020 2020  p.ndarray):.    
+00027f30: 2020 2020 2020 2020 7072 696e 7428 2779          print('y
+00027f40: 206d 7573 7420 6265 2061 2070 642e 5365   must be a pd.Se
+00027f50: 7269 6573 206f 7220 7064 2e44 6174 6146  ries or pd.DataF
+00027f60: 7261 6d65 2073 696e 6365 2077 6520 7573  rame since we us
+00027f70: 6520 636f 6c75 6d6e 206e 616d 6573 2074  e column names t
+00027f80: 6f20 6275 696c 6420 6461 7461 2070 6970  o build data pip
+00027f90: 656c 696e 652e 2052 6574 7572 6e69 6e67  eline. Returning
+00027fa0: 2729 0a20 2020 2020 2020 2020 2020 2072  ').            r
+00027fb0: 6574 7572 6e20 7b7d 2c20 7b7d 0a20 2020  eturn {}, {}.   
+00027fc0: 2020 2020 2023 2323 2320 5365 6e64 2074       #### Send t
+00027fd0: 6172 6765 7420 7661 7269 6162 6c65 2061  arget variable a
+00027fe0: 7320 6974 2069 7320 736f 2074 6861 7420  s it is so that 
+00027ff0: 795f 7472 6169 6e20 6973 2061 6e61 6c79  y_train is analy
+00028000: 7a65 6420 7072 6f70 6572 6c79 2023 2323  zed properly ###
+00028010: 0a20 2020 2020 2020 2023 2053 656c 6563  .        # Selec
+00028020: 7420 6665 6174 7572 6573 2075 7369 6e67  t features using
+00028030: 2066 6561 7475 7265 7769 7a0a 2020 2020   featurewiz.    
+00028040: 2020 2020 6665 6174 7572 6573 2c20 585f      features, X_
+00028050: 7365 6c20 3d20 6665 6174 7572 6577 697a  sel = featurewiz
+00028060: 2864 662c 2074 6172 6765 742c 2073 656c  (df, target, sel
+00028070: 662e 636f 7272 5f6c 696d 6974 2c20 7365  f.corr_limit, se
+00028080: 6c66 2e76 6572 626f 7365 2c20 7365 6c66  lf.verbose, self
+00028090: 2e73 6570 2c20 0a20 2020 2020 2020 2020  .sep, .         
+000280a0: 2020 2020 2020 2073 656c 662e 6865 6164         self.head
+000280b0: 6572 2c20 7365 6c66 2e74 6573 745f 6461  er, self.test_da
+000280c0: 7461 2c20 7365 6c66 2e66 6561 7475 7265  ta, self.feature
+000280d0: 5f65 6e67 672c 2073 656c 662e 6361 7465  _engg, self.cate
+000280e0: 676f 7279 5f65 6e63 6f64 6572 732c 0a20  gory_encoders,. 
+000280f0: 2020 2020 2020 2020 2020 2020 2020 2073                 s
+00028100: 656c 662e 6461 736b 5f78 6762 6f6f 7374  elf.dask_xgboost
+00028110: 5f66 6c61 672c 2073 656c 662e 6e72 6f77  _flag, self.nrow
+00028120: 732c 2073 656c 662e 736b 6970 5f73 756c  s, self.skip_sul
+00028130: 6f76 2c20 7365 6c66 2e73 6b69 705f 7867  ov, self.skip_xg
+00028140: 626f 6f73 7429 0a20 2020 2020 2020 2023  boost).        #
+00028150: 2043 6f6e 7665 7274 2074 6865 2072 656d   Convert the rem
+00028160: 6169 6e69 6e67 2063 6f6c 756d 6e20 6e61  aining column na
+00028170: 6d65 7320 6261 636b 2074 6f20 696e 7465  mes back to inte
+00028180: 6765 7273 2061 6e64 2064 726f 7020 7468  gers and drop th
+00028190: 650a 2020 2020 2020 2020 6469 6666 7469  e.        diffti
+000281a0: 6d65 203d 206d 6178 2831 2c20 696e 7428  me = max(1, int(
+000281b0: 7469 6d65 2e74 696d 6528 292d 7374 6172  time.time()-star
+000281c0: 745f 7469 6d65 2929 0a20 2020 2020 2020  t_time)).       
+000281d0: 2070 7269 6e74 2827 2020 2020 5469 6d65   print('    Time
+000281e0: 2074 616b 656e 2074 6f20 6372 6561 7465   taken to create
+000281f0: 2065 6e74 6972 6520 7069 7065 6c69 6e65   entire pipeline
+00028200: 203d 2025 7320 7365 636f 6e64 2873 2927   = %s second(s)'
+00028210: 2025 6469 6666 7469 6d65 290a 2020 2020   %difftime).    
+00028220: 2020 2020 2320 636f 6c75 6d6e 206f 6620      # column of 
+00028230: 6c61 6265 6c73 0a20 2020 2020 2020 2073  labels.        s
+00028240: 656c 662e 6665 6174 7572 6573 203d 2066  elf.features = f
+00028250: 6561 7475 7265 730a 2020 2020 2020 2020  eatures.        
+00028260: 7365 6c66 2e58 5f73 656c 203d 2058 5f73  self.X_sel = X_s
+00028270: 656c 0a20 2020 2020 2020 2072 6574 7572  el.        retur
+00028280: 6e20 7365 6c66 0a0a 2020 2020 6465 6620  n self..    def 
+00028290: 7472 616e 7366 6f72 6d28 7365 6c66 2c20  transform(self, 
+000282a0: 5829 3a0a 2020 2020 2020 2020 7472 793a  X):.        try:
+000282b0: 0a20 2020 2020 2020 2020 2020 2072 6574  .            ret
+000282c0: 7572 6e20 585b 7365 6c66 2e66 6561 7475  urn X[self.featu
+000282d0: 7265 735d 0a20 2020 2020 2020 2065 7863  res].        exc
+000282e0: 6570 743a 0a20 2020 2020 2020 2020 2020  ept:.           
+000282f0: 2070 7269 6e74 2827 5265 7475 726e 696e   print('Returnin
+00028300: 6720 7472 616e 7366 6f72 6d65 6420 6461  g transformed da
+00028310: 7461 6672 616d 6520 7769 7468 2025 6420  taframe with %d 
+00028320: 6665 6174 7572 6573 2720 256c 656e 2873  features' %len(s
+00028330: 656c 662e 6665 6174 7572 6573 2929 0a20  elf.features)). 
+00028340: 2020 2020 2020 2020 2020 2072 6574 7572             retur
+00028350: 6e20 7365 6c66 2e58 5f73 656c 0a23 2323  n self.X_sel.###
+00028360: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00028370: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00028380: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00028390: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000283a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000283b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000283c0: 0a64 6566 2045 4441 5f72 656d 6f76 655f  .def EDA_remove_
+000283d0: 7370 6563 6961 6c5f 6368 6172 7328 6466  special_chars(df
+000283e0: 293a 0a20 2020 2022 2222 0a20 2020 2054  ):.    """.    T
+000283f0: 6869 7320 6675 6e63 7469 6f6e 2072 656d  his function rem
+00028400: 6f76 6573 2073 7065 6369 616c 2063 6861  oves special cha
+00028410: 7273 2066 726f 6d20 636f 6c75 6d6e 206e  rs from column n
+00028420: 616d 6573 2061 6e64 2072 6574 7572 6e73  ames and returns
+00028430: 2061 2064 6620 7769 7468 206e 6577 2063   a df with new c
+00028440: 6f6c 756d 6e20 6e61 6d65 732e 0a20 2020  olumn names..   
+00028450: 2049 6e70 7574 7320 616e 6420 6f75 7470   Inputs and outp
+00028460: 7574 7320 6172 6520 626f 7468 2074 6865  uts are both the
+00028470: 2073 616d 6520 6461 7461 6672 616d 6520   same dataframe 
+00028480: 6578 6365 7074 2063 6f6c 756d 6e20 6e61  except column na
+00028490: 6d65 7320 6172 6520 6368 616e 6765 642e  mes are changed.
+000284a0: 0a20 2020 2022 2222 0a20 2020 2069 6d70  .    """.    imp
+000284b0: 6f72 7420 636f 7079 0a20 2020 2069 6d70  ort copy.    imp
+000284c0: 6f72 7420 7265 0a20 2020 2063 6f6c 7320  ort re.    cols 
+000284d0: 3d20 6466 2e63 6f6c 756d 6e73 2e74 6f6c  = df.columns.tol
+000284e0: 6973 7428 290a 2020 2020 636f 7079 5f63  ist().    copy_c
+000284f0: 6f6c 7320 3d20 636f 7079 2e64 6565 7063  ols = copy.deepc
+00028500: 6f70 7928 636f 6c73 290a 2020 2020 7365  opy(cols).    se
+00028510: 7220 3d20 7064 2e53 6572 6965 7328 636f  r = pd.Series(co
+00028520: 6c73 290a 2020 2020 2323 2320 5468 6973  ls).    ### This
+00028530: 2066 756e 6374 696f 6e20 7265 6d6f 7665   function remove
+00028540: 7320 616c 6c20 7370 6563 6961 6c20 6368  s all special ch
+00028550: 6172 7320 6672 6f6d 2061 206c 6973 7420  ars from a list 
+00028560: 2323 230a 2020 2020 7265 6d6f 7665 5f73  ###.    remove_s
+00028570: 7065 6369 616c 5f63 6861 7273 203d 2020  pecial_chars =  
+00028580: 6c61 6d62 6461 2078 3a72 652e 7375 6228  lambda x:re.sub(
+00028590: 275b 5e41 2d5a 612d 7a30 2d39 5f5d 2b27  '[^A-Za-z0-9_]+'
+000285a0: 2c20 2727 2c20 7829 0a20 2020 206e 6577  , '', x).    new
+000285b0: 6c73 203d 2073 6572 2e6d 6170 2872 656d  ls = ser.map(rem
+000285c0: 6f76 655f 7370 6563 6961 6c5f 6368 6172  ove_special_char
+000285d0: 7329 2e76 616c 7565 732e 746f 6c69 7374  s).values.tolist
+000285e0: 2829 0a20 2020 2064 662e 636f 6c75 6d6e  ().    df.column
+000285f0: 7320 3d20 6e65 776c 730a 2020 2020 7265  s = newls.    re
+00028600: 7475 726e 2064 660a 2323 2323 2323 2323  turn df.########
 00028610: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00028620: 2323 2323 2323 2323 2323 0a23 2323 2074  ##########.### t
-00028630: 6869 7320 776f 726b 7320 6f6e 6c79 206f  his works only o
-00028640: 6e20 7061 6e64 6173 2064 6174 6166 7261  n pandas datafra
-00028650: 6d65 7320 6275 7420 6974 2069 7320 6578  mes but it is ex
-00028660: 7472 656d 656c 7920 6661 7374 0a69 6d70  tremely fast.imp
-00028670: 6f72 7420 636f 7079 0a64 6566 2046 455f  ort copy.def FE_
-00028680: 6361 6c63 756c 6174 655f 6475 7261 7469  calculate_durati
-00028690: 6f6e 5f66 726f 6d5f 7469 6d65 7374 616d  on_from_timestam
-000286a0: 7028 6466 2c20 6964 5f63 6f6c 756d 6e2c  p(df, id_column,
-000286b0: 2074 696d 6573 7461 6d70 5f63 6f6c 756d   timestamp_colum
-000286c0: 6e29 3a0a 2020 2020 2222 220a 2020 2020  n):.    """.    
-000286d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000286e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-000286f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00028700: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00028710: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00028720: 2323 230a 2020 2020 4361 6c63 756c 6174  ###.    Calculat
-00028730: 6520 7468 6520 746f 7461 6c20 7469 6d65  e the total time
-00028740: 2061 6e64 2061 7665 7261 6765 2074 696d   and average tim
-00028750: 6520 7370 656e 7420 6f6e 6c69 6e65 2070  e spent online p
-00028760: 6572 2064 6179 2062 7920 7573 6572 2e20  er day by user. 
-00028770: 0a20 2020 2041 6c73 6f20 6974 2063 616c  .    Also it cal
-00028780: 6375 6c61 7465 7320 7468 6520 6e75 6d62  culates the numb
-00028790: 6572 206f 6620 6c6f 6769 6e73 2070 6572  er of logins per
-000287a0: 2075 7365 7220 7065 7220 6461 792e 0a20   user per day.. 
-000287b0: 2020 2023 2323 2020 2054 6869 7320 6973     ###   This is
-000287c0: 2076 6572 7920 7573 6566 756c 2066 6f72   very useful for
-000287d0: 206c 6f67 7320 6461 7461 2c20 494f 5420   logs data, IOT 
-000287e0: 6461 7461 2c20 616e 6420 7069 6e67 7320  data, and pings 
-000287f0: 6672 6f6d 2076 6973 6974 7320 6461 7461  from visits data
-00028800: 2023 2323 2323 0a20 2020 2054 6869 7320   #####.    This 
-00028810: 6675 6e63 7469 6f6e 2074 616b 6573 2061  function takes a
-00028820: 2044 6174 6146 7261 6d65 2077 6974 6820   DataFrame with 
-00028830: 7573 6572 2069 6473 2061 6e64 2074 696d  user ids and tim
-00028840: 6573 7461 6d70 7320 286f 6620 6c6f 6769  estamps (of logi
-00028850: 6e73 2c20 6574 632e 2920 0a20 2020 2061  ns, etc.) .    a
-00028860: 6e64 2072 6574 7572 6e73 2061 2044 6174  nd returns a Dat
-00028870: 6146 7261 6d65 2077 6974 6820 6475 7261  aFrame with dura
-00028880: 7469 6f6e 206f 7220 7468 6520 7469 6d65  tion or the time
-00028890: 2073 7065 6e74 2062 6574 7765 656e 2074   spent between t
-000288a0: 776f 2074 696d 6573 7461 6d70 732e 0a20  wo timestamps.. 
-000288b0: 2020 2054 6869 7320 6973 2063 616c 6375     This is calcu
-000288c0: 6c61 7465 6420 6279 2074 616b 696e 6720  lated by taking 
-000288d0: 7061 6972 7320 6f66 2072 6f77 7320 616e  pairs of rows an
-000288e0: 6420 6173 7375 6d69 6e67 2074 6865 2066  d assuming the f
-000288f0: 6972 7374 2072 6f77 2069 7320 6c6f 6769  irst row is logi
-00028900: 6e0a 2020 2020 616e 6420 7468 6520 7365  n.    and the se
-00028910: 636f 6e64 2072 6f77 2069 7320 6c6f 676f  cond row is logo
-00028920: 7574 2e20 5468 656e 2077 6520 7375 6274  ut. Then we subt
-00028930: 7261 6374 2074 6865 2074 696d 6573 7461  ract the timesta
-00028940: 6d70 206f 6620 7468 6520 6c6f 6769 6e20  mp of the login 
-00028950: 6672 6f6d 200a 2020 2020 7468 6520 7469  from .    the ti
-00028960: 6d65 7374 616d 7020 6f66 2074 6865 206c  mestamp of the l
-00028970: 6f67 6f75 7420 666f 7220 6561 6368 2070  ogout for each p
-00028980: 6169 7220 6f66 2072 6f77 732e 2054 6869  air of rows. Thi
-00028990: 7320 6675 6e63 7469 6f6e 2075 7365 7320  s function uses 
-000289a0: 616c 7465 726e 6174 6520 726f 7773 0a20  alternate rows. 
-000289b0: 2020 206f 6620 6120 6461 7461 6672 616d     of a datafram
-000289c0: 6520 616e 6420 7370 6c69 7473 2074 6865  e and splits the
-000289d0: 6d20 696e 746f 2073 6570 6172 6174 6520  m into separate 
-000289e0: 636f 6c75 6d6e 732e 2049 7420 7468 656e  columns. It then
-000289f0: 2073 7562 7472 6163 7473 2074 6865 2074   subtracts the t
-00028a00: 776f 200a 2020 2020 636f 6c75 6d6e 7320  wo .    columns 
-00028a10: 746f 2066 696e 6420 7469 6d65 2064 656c  to find time del
-00028a20: 7461 2069 6e20 7365 636f 6e64 7320 6475  ta in seconds du
-00028a30: 7269 6e67 2074 686f 7365 2074 776f 2074  ring those two t
-00028a40: 696d 6573 2e20 4974 2061 6c73 6f20 656c  imes. It also el
-00028a50: 696d 696e 6174 6573 0a20 2020 2061 6e79  iminates.    any
-00028a60: 2064 6174 6120 656e 7472 7920 6572 726f   data entry erro
-00028a70: 7273 2062 7920 7265 6d6f 7669 6e67 206e  rs by removing n
-00028a80: 6567 6174 6976 6520 6475 7261 7469 6f6e  egative duration
-00028a90: 732e 2054 6869 7320 6973 2074 6865 2062  s. This is the b
-00028aa0: 6573 7420 616e 6420 0a20 2020 2073 7065  est and .    spe
-00028ab0: 6564 6965 7374 2077 6179 2074 6f20 6361  ediest way to ca
-00028ac0: 6c63 756c 6174 6520 6f6e 6c69 6e65 2074  lculate online t
-00028ad0: 696d 6520 7370 656e 7420 7065 7220 7573  ime spent per us
-00028ae0: 6572 2070 6572 2064 6179 2e0a 2020 2020  er per day..    
-00028af0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00028b00: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00028b10: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00028b20: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00028b30: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00028b40: 2323 230a 2020 2020 5061 7261 6d65 7465  ###.    Paramete
-00028b50: 7273 0a20 2020 202d 2d2d 2d2d 2d2d 2d2d  rs.    ---------
-00028b60: 2d0a 2020 2020 6466 203a 2070 616e 6461  -.    df : panda
-00028b70: 732e 4461 7461 4672 616d 650a 2020 2020  s.DataFrame.    
-00028b80: 2020 2020 5468 6520 696e 7075 7420 4461      The input Da
-00028b90: 7461 4672 616d 6520 7769 7468 2075 7365  taFrame with use
-00028ba0: 7220 6964 732c 2074 696d 6573 7461 6d70  r ids, timestamp
-00028bb0: 7320 616e 6420 7661 6c75 6573 2e0a 2020  s and values..  
-00028bc0: 2020 6964 5f63 6f6c 756d 6e20 3a20 7374    id_column : st
-00028bd0: 720a 2020 2020 2020 2020 5468 6520 6e61  r.        The na
-00028be0: 6d65 206f 6620 7468 6520 636f 6c75 6d6e  me of the column
-00028bf0: 2074 6861 7420 636f 6e74 6169 6e73 2074   that contains t
-00028c00: 6865 2075 7365 7220 6964 732e 0a20 2020  he user ids..   
-00028c10: 2074 696d 6573 7461 6d70 5f63 6f6c 756d   timestamp_colum
-00028c20: 6e20 3a20 7374 720a 2020 2020 2020 2020  n : str.        
-00028c30: 4e61 6d65 206f 6620 7468 6520 7469 6d65  Name of the time
-00028c40: 7374 616d 7020 636f 6c75 6d6e 0a0a 2020  stamp column..  
-00028c50: 2020 5265 7475 726e 730a 2020 2020 2d2d    Returns.    --
-00028c60: 2d2d 2d2d 2d0a 2020 2020 7265 7375 6c74  -----.    result
-00028c70: 203a 2070 616e 6461 732e 4461 7461 4672   : pandas.DataFr
-00028c80: 616d 650a 2020 2020 2020 2020 5468 6520  ame.        The 
-00028c90: 6f75 7470 7574 2044 6174 6146 7261 6d65  output DataFrame
-00028ca0: 2077 6974 6820 7573 6572 2069 6473 2c20   with user ids, 
-00028cb0: 6461 7465 732c 2061 7665 7261 6765 2074  dates, average t
-00028cc0: 696d 6520 7370 656e 7420 616e 6420 6e75  ime spent and nu
-00028cd0: 6d62 6572 206f 6620 6c6f 6769 6e73 2e0a  mber of logins..
-00028ce0: 2020 2020 2222 220a 2020 2020 6466 203d      """.    df =
-00028cf0: 2063 6f70 792e 6465 6570 636f 7079 2864   copy.deepcopy(d
-00028d00: 6629 0a20 2020 2023 2043 7265 6174 6520  f).    # Create 
-00028d10: 616e 2065 6d70 7479 2044 6174 6146 7261  an empty DataFra
-00028d20: 6d65 2074 6f20 7374 6f72 6520 7468 6520  me to store the 
-00028d30: 7265 7375 6c74 730a 2020 2020 636f 6c75  results.    colu
-00028d40: 6d6e 7320 3d20 5b69 645f 636f 6c75 6d6e  mns = [id_column
-00028d50: 2c20 7469 6d65 7374 616d 705f 636f 6c75  , timestamp_colu
-00028d60: 6d6e 5d0a 2020 2020 6466 203d 2064 665b  mn].    df = df[
-00028d70: 636f 6c75 6d6e 735d 0a20 2020 206c 656e  columns].    len
-00028d80: 6720 3d20 6c65 6e28 6466 290a 2020 2020  g = len(df).    
-00028d90: 2320 5265 7368 6170 6520 7468 6520 4461  # Reshape the Da
-00028da0: 7461 4672 616d 6520 696e 746f 2074 776f  taFrame into two
-00028db0: 2063 6f6c 756d 6e73 2062 7920 7374 6163   columns by stac
-00028dc0: 6b69 6e67 2065 7665 7279 206f 7468 6572  king every other
-00028dd0: 2072 6f77 0a20 2020 2064 6631 203d 2064   row.    df1 = d
-00028de0: 662e 696c 6f63 5b3a 3a32 5d20 2320 7365  f.iloc[::2] # se
-00028df0: 6c65 6374 2065 7665 7279 2065 7665 6e20  lect every even 
-00028e00: 726f 770a 2020 2020 6466 3220 3d20 6466  row.    df2 = df
-00028e10: 2e64 726f 7028 302c 2061 7869 733d 3029  .drop(0, axis=0)
-00028e20: 2023 2064 726f 7020 7468 6520 6669 7273   # drop the firs
-00028e30: 7420 726f 770a 2020 2020 6466 3220 3d20  t row.    df2 = 
-00028e40: 6466 322e 696c 6f63 5b3a 3a32 5d20 2320  df2.iloc[::2] # 
-00028e50: 7365 6c65 6374 2065 7665 7279 2065 7665  select every eve
-00028e60: 6e20 726f 7720 6672 6f6d 2074 6865 2072  n row from the r
-00028e70: 656d 6169 6e69 6e67 2072 6f77 730a 2020  emaining rows.  
-00028e80: 2020 2320 4966 206c 656e 6774 6820 6f66    # If length of
-00028e90: 2064 6174 6166 7261 6d65 2069 7320 6e6f   dataframe is no
-00028ea0: 7420 616e 2065 7665 6e20 6e75 6d62 6572  t an even number
-00028eb0: 2c20 7072 6f63 6573 7320 756e 7469 6c20  , process until 
-00028ec0: 7468 6520 6c61 7374 2072 6f77 0a20 2020  the last row.   
-00028ed0: 2069 6620 6c65 6e67 2532 2021 3d20 303a   if leng%2 != 0:
-00028ee0: 0a20 2020 2020 2020 206c 6173 7472 6f77  .        lastrow
-00028ef0: 203d 2064 6963 7428 6466 2e69 6c6f 635b   = dict(df.iloc[
-00028f00: 2d31 5d29 2023 2067 6574 2074 6865 206c  -1]) # get the l
-00028f10: 6173 7420 726f 7720 6173 2061 2064 6963  ast row as a dic
-00028f20: 7469 6f6e 6172 790a 2020 2020 2020 2020  tionary.        
-00028f30: 6466 3220 3d20 6466 322e 6170 7065 6e64  df2 = df2.append
-00028f40: 286c 6173 7472 6f77 2c20 6967 6e6f 7265  (lastrow, ignore
-00028f50: 5f69 6e64 6578 3d54 7275 6529 2023 2061  _index=True) # a
-00028f60: 7070 656e 6420 6974 2074 6f20 6466 320a  ppend it to df2.
-00028f70: 2020 2020 6466 3120 3d20 6466 312e 7265      df1 = df1.re
-00028f80: 6e61 6d65 2863 6f6c 756d 6e73 3d7b 7469  name(columns={ti
-00028f90: 6d65 7374 616d 705f 636f 6c75 6d6e 3a74  mestamp_column:t
-00028fa0: 696d 6573 7461 6d70 5f63 6f6c 756d 6e2b  imestamp_column+
-00028fb0: 275f 6265 6769 6e27 7d29 2023 2072 656e  '_begin'}) # ren
-00028fc0: 616d 6520 7468 6520 7469 6d65 7374 616d  ame the timestam
-00028fd0: 7020 636f 6c75 6d6e 2069 6e20 6466 310a  p column in df1.
-00028fe0: 2020 2020 6466 3220 3d20 6466 322e 7265      df2 = df2.re
-00028ff0: 6e61 6d65 2863 6f6c 756d 6e73 3d7b 7469  name(columns={ti
-00029000: 6d65 7374 616d 705f 636f 6c75 6d6e 3a74  mestamp_column:t
-00029010: 696d 6573 7461 6d70 5f63 6f6c 756d 6e2b  imestamp_column+
-00029020: 275f 656e 6427 7d29 2023 2072 656e 616d  '_end'}) # renam
-00029030: 6520 7468 6520 7469 6d65 7374 616d 7020  e the timestamp 
-00029040: 636f 6c75 6d6e 2069 6e20 6466 320a 2020  column in df2.  
-00029050: 2020 6466 3178 203d 2064 6631 2e72 6573    df1x = df1.res
-00029060: 6574 5f69 6e64 6578 2864 726f 703d 5472  et_index(drop=Tr
-00029070: 7565 2920 2320 7265 7365 7420 7468 6520  ue) # reset the 
-00029080: 696e 6465 7820 6f66 2064 6631 0a20 2020  index of df1.   
-00029090: 2064 6632 7820 3d20 6466 322e 7265 7365   df2x = df2.rese
-000290a0: 745f 696e 6465 7828 6472 6f70 3d54 7275  t_index(drop=Tru
-000290b0: 6529 2023 2072 6573 6574 2074 6865 2069  e) # reset the i
-000290c0: 6e64 6578 206f 6620 6466 320a 2020 2020  ndex of df2.    
-000290d0: 6466 3320 3d20 7064 2e63 6f6e 6361 7428  df3 = pd.concat(
-000290e0: 5b64 6631 782c 2064 6632 785d 2c20 6178  [df1x, df2x], ax
-000290f0: 6973 3d31 2920 2320 636f 6e63 6174 656e  is=1) # concaten
-00029100: 6174 6520 6466 3120 616e 6420 6466 3220  ate df1 and df2 
-00029110: 686f 7269 7a6f 6e74 616c 6c79 0a20 2020  horizontally.   
-00029120: 2072 6573 756c 7420 3d20 6466 332e 696c   result = df3.il
-00029130: 6f63 5b3a 2c5b 302c 312c 335d 5d20 2320  oc[:,[0,1,3]] # 
-00029140: 7365 6c65 6374 206f 6e6c 7920 7468 6520  select only the 
-00029150: 7265 6c65 7661 6e74 2063 6f6c 756d 6e73  relevant columns
-00029160: 2066 726f 6d20 6466 330a 2020 2020 2320   from df3.    # 
-00029170: 6361 6c63 756c 6174 6520 7468 6520 7469  calculate the ti
-00029180: 6d65 2064 6966 6665 7265 6e63 6520 6265  me difference be
-00029190: 7477 6565 6e20 6561 6368 2070 6169 7220  tween each pair 
-000291a0: 6f66 2072 6f77 730a 2020 2020 7265 7375  of rows.    resu
-000291b0: 6c74 5b22 7469 6d65 5f64 6966 6622 5d20  lt["time_diff"] 
-000291c0: 3d20 7265 7375 6c74 5b74 696d 6573 7461  = result[timesta
-000291d0: 6d70 5f63 6f6c 756d 6e2b 225f 656e 6422  mp_column+"_end"
-000291e0: 5d20 2d20 7265 7375 6c74 5b74 696d 6573  ] - result[times
-000291f0: 7461 6d70 5f63 6f6c 756d 6e2b 225f 6265  tamp_column+"_be
-00029200: 6769 6e22 5d20 0a20 2020 2023 636f 6e76  gin"] .    #conv
-00029210: 6572 7420 7468 6520 7661 6c75 655f 6469  ert the value_di
-00029220: 6666 2063 6f6c 756d 6e20 746f 2073 6563  ff column to sec
-00029230: 6f6e 6473 2075 7369 6e67 206e 702e 7469  onds using np.ti
-00029240: 6d65 6465 6c74 6136 3428 312c 2027 7327  medelta64(1, 's'
-00029250: 2920 6675 6e63 7469 6f6e 0a20 2020 2072  ) function.    r
-00029260: 6573 756c 745b 2774 696d 655f 6469 6666  esult['time_diff
-00029270: 275d 203d 2072 6573 756c 745b 2774 696d  '] = result['tim
-00029280: 655f 6469 6666 275d 202f 206e 702e 7469  e_diff'] / np.ti
-00029290: 6d65 6465 6c74 6136 3428 312c 2027 7327  medelta64(1, 's'
-000292a0: 290a 2020 2020 7265 7375 6c74 2e6c 6f63  ).    result.loc
-000292b0: 5b28 7265 7375 6c74 5b27 7469 6d65 5f64  [(result['time_d
-000292c0: 6966 6627 5d3c 3029 2c22 7469 6d65 5f64  iff']<0),"time_d
-000292d0: 6966 6622 5d20 3d20 300a 2020 2020 0a20  iff"] = 0.    . 
-000292e0: 2020 2023 7265 7475 726e 2074 6865 2072     #return the r
-000292f0: 6573 756c 740a 2020 2020 7265 7475 726e  esult.    return
-00029300: 2072 6573 756c 740a 2323 2323 2323 2323   result.########
-00029310: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00029320: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00029330: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00029340: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00029350: 2323 2323 2323 2323 2323 2323 2323 2323  ################
-00029360: 2323 2323 2323 230a 0a                   #######..
+00028620: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00028630: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00028640: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00028650: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00028660: 2323 2323 2323 2323 2323 230a 6465 6620  ###########.def 
+00028670: 6461 736b 5f78 6762 6f6f 7374 5f74 7261  dask_xgboost_tra
+00028680: 696e 696e 6728 585f 7472 6169 6e78 2c20  ining(X_trainx, 
+00028690: 795f 7472 6169 6e78 2c20 7061 7261 6d73  y_trainx, params
+000286a0: 293a 0a20 2020 200a 2020 2020 636c 7573  ):.    .    clus
+000286b0: 7465 7220 3d20 6461 736b 2e64 6973 7472  ter = dask.distr
+000286c0: 6962 7574 6564 2e4c 6f63 616c 436c 7573  ibuted.LocalClus
+000286d0: 7465 7228 290a 2020 2020 6461 736b 5f63  ter().    dask_c
+000286e0: 6c69 656e 7420 3d20 6461 736b 2e64 6973  lient = dask.dis
+000286f0: 7472 6962 7574 6564 2e43 6c69 656e 7428  tributed.Client(
+00028700: 636c 7573 7465 7229 0a20 2020 2058 5f74  cluster).    X_t
+00028710: 7261 696e 7820 3d20 6464 2e66 726f 6d5f  rainx = dd.from_
+00028720: 7061 6e64 6173 2858 5f74 7261 696e 2c20  pandas(X_train, 
+00028730: 6e70 6172 7469 7469 6f6e 733d 3129 0a20  npartitions=1). 
+00028740: 2020 2079 5f74 7261 696e 7820 3d20 6464     y_trainx = dd
+00028750: 2e66 726f 6d5f 7061 6e64 6173 2879 5f74  .from_pandas(y_t
+00028760: 7261 696e 2c20 6e70 6172 7469 7469 6f6e  rain, npartition
+00028770: 733d 3129 0a20 2020 2070 7269 6e74 2822  s=1).    print("
+00028780: 4441 534b 2058 4742 6f6f 7374 2074 7261  DASK XGBoost tra
+00028790: 696e 696e 672e 2e2e 2229 0a20 2020 2064  ining...").    d
+000287a0: 7472 6169 6e20 3d20 7867 622e 6461 736b  train = xgb.dask
+000287b0: 2e44 6173 6b44 4d61 7472 6978 2864 6173  .DaskDMatrix(das
+000287c0: 6b5f 636c 6965 6e74 2c20 585f 7472 6169  k_client, X_trai
+000287d0: 6e78 2c20 795f 7472 6169 6e78 290a 2020  nx, y_trainx).  
+000287e0: 2020 6273 7420 3d20 7867 622e 6461 736b    bst = xgb.dask
+000287f0: 2e74 7261 696e 2864 6173 6b5f 636c 6965  .train(dask_clie
+00028800: 6e74 2c20 7061 7261 6d73 2c20 6474 7261  nt, params, dtra
+00028810: 696e 2c20 6e75 6d5f 626f 6f73 745f 726f  in, num_boost_ro
+00028820: 756e 643d 3130 290a 2020 2020 6461 736b  und=10).    dask
+00028830: 5f63 6c69 656e 742e 636c 6f73 6528 290a  _client.close().
+00028840: 2020 2020 7072 696e 7428 2220 2020 2074      print("    t
+00028850: 7261 696e 696e 6720 636f 6d70 6c65 7465  raining complete
+00028860: 642e 2e2e 2229 0a20 2020 2072 6574 7572  d...").    retur
+00028870: 6e20 6273 740a 2323 2323 2323 2323 2323  n bst.##########
+00028880: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00028890: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000288a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000288b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000288c0: 2323 2323 2323 2323 2323 0a64 6566 2046  ##########.def F
+000288d0: 455f 7265 6d6f 7665 5f63 6f6d 6d61 735f  E_remove_commas_
+000288e0: 696e 5f6e 756d 6572 6963 7328 7472 6169  in_numerics(trai
+000288f0: 6e2c 206e 756d 733d 5b5d 293a 0a20 2020  n, nums=[]):.   
+00028900: 2022 2222 200a 2020 2020 5468 6973 2066   """ .    This f
+00028910: 756e 6374 696f 6e20 7265 6d6f 7665 7320  unction removes 
+00028920: 636f 6d6d 6173 2069 6e20 6e75 6d65 7269  commas in numeri
+00028930: 6320 636f 6c75 6d6e 7320 616e 6420 7265  c columns and re
+00028940: 7475 726e 7320 7468 6520 636f 6c75 6d6e  turns the column
+00028950: 7320 7472 616e 7366 6f72 6d65 642e 0a20  s transformed.. 
+00028960: 2020 2059 6f75 2063 616e 2073 656e 6420     You can send 
+00028970: 696e 2061 2064 6174 6166 7261 6d65 2077  in a dataframe w
+00028980: 6974 6820 6f6e 6520 636f 6c75 6d6e 206e  ith one column n
+00028990: 616d 6520 6173 2061 2073 7472 696e 6720  ame as a string 
+000289a0: 6f72 2061 206c 6973 7420 6f66 2063 6f6c  or a list of col
+000289b0: 756d 6e73 2e0a 2020 2020 5265 7475 726e  umns..    Return
+000289c0: 7320 6120 7369 6e67 6c65 2061 7272 6179  s a single array
+000289d0: 2069 6620 6f6e 6c79 206f 6e65 2063 6f6c   if only one col
+000289e0: 756d 6e20 6973 2073 656e 742e 0a20 2020  umn is sent..   
+000289f0: 2052 6574 7572 6e73 2074 6865 2065 6e74   Returns the ent
+00028a00: 6972 6520 6461 7461 6672 616d 6520 6966  ire dataframe if
+00028a10: 2061 206c 6973 7420 6f66 2063 6f6c 756d   a list of colum
+00028a20: 6e73 2069 7320 7365 6e74 2e20 5468 6973  ns is sent. This
+00028a30: 2069 6e63 6c75 6465 7320 616c 6c20 636f   includes all co
+00028a40: 6c75 6d6e 732e 0a20 2020 2022 2222 0a20  lumns..    """. 
+00028a50: 2020 2074 7261 696e 203d 2063 6f70 792e     train = copy.
+00028a60: 6465 6570 636f 7079 2874 7261 696e 290a  deepcopy(train).
+00028a70: 2020 2020 6966 2069 7369 6e73 7461 6e63      if isinstanc
+00028a80: 6528 6e75 6d73 2c20 7374 7229 3a0a 2020  e(nums, str):.  
+00028a90: 2020 2020 2020 7265 7475 726e 2074 7261        return tra
+00028aa0: 696e 5b65 6163 685f 6e75 6d5d 2e6d 6170  in[each_num].map
+00028ab0: 286c 616d 6264 6120 783a 2066 6c6f 6174  (lambda x: float
+00028ac0: 2822 222e 6a6f 696e 2820 782e 7370 6c69  ("".join( x.spli
+00028ad0: 7428 222c 2229 2929 292e 7661 6c75 6573  t(",")))).values
+00028ae0: 0a20 2020 2065 6c73 653a 0a20 2020 2020  .    else:.     
+00028af0: 2020 2066 6f72 2065 6163 685f 6e75 6d20     for each_num 
+00028b00: 696e 206e 756d 733a 0a20 2020 2020 2020  in nums:.       
+00028b10: 2020 2020 2074 7261 696e 5b65 6163 685f       train[each_
+00028b20: 6e75 6d5d 203d 2074 7261 696e 5b65 6163  num] = train[eac
+00028b30: 685f 6e75 6d5d 2e6d 6170 286c 616d 6264  h_num].map(lambd
+00028b40: 6120 783a 2066 6c6f 6174 2822 222e 6a6f  a x: float("".jo
+00028b50: 696e 2820 782e 7370 6c69 7428 222c 2229  in( x.split(",")
+00028b60: 2929 292e 7661 6c75 6573 0a20 2020 2072  ))).values.    r
+00028b70: 6574 7572 6e20 7472 6169 6e0a 2323 2323  eturn train.####
+00028b80: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00028b90: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00028ba0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00028bb0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00028bc0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00028bd0: 0a23 2323 2074 6869 7320 776f 726b 7320  .### this works 
+00028be0: 6f6e 6c79 206f 6e20 7061 6e64 6173 2064  only on pandas d
+00028bf0: 6174 6166 7261 6d65 7320 6275 7420 6974  ataframes but it
+00028c00: 2069 7320 6578 7472 656d 656c 7920 6661   is extremely fa
+00028c10: 7374 0a69 6d70 6f72 7420 636f 7079 0a64  st.import copy.d
+00028c20: 6566 2046 455f 6361 6c63 756c 6174 655f  ef FE_calculate_
+00028c30: 6475 7261 7469 6f6e 5f66 726f 6d5f 7469  duration_from_ti
+00028c40: 6d65 7374 616d 7028 6466 2c20 6964 5f63  mestamp(df, id_c
+00028c50: 6f6c 756d 6e2c 2074 696d 6573 7461 6d70  olumn, timestamp
+00028c60: 5f63 6f6c 756d 6e29 3a0a 2020 2020 2222  _column):.    ""
+00028c70: 220a 2020 2020 2323 2323 2323 2323 2323  ".    ##########
+00028c80: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00028c90: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00028ca0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00028cb0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00028cc0: 2323 2323 2323 2323 230a 2020 2020 4361  #########.    Ca
+00028cd0: 6c63 756c 6174 6520 7468 6520 746f 7461  lculate the tota
+00028ce0: 6c20 7469 6d65 2061 6e64 2061 7665 7261  l time and avera
+00028cf0: 6765 2074 696d 6520 7370 656e 7420 6f6e  ge time spent on
+00028d00: 6c69 6e65 2070 6572 2064 6179 2062 7920  line per day by 
+00028d10: 7573 6572 2e20 0a20 2020 2041 6c73 6f20  user. .    Also 
+00028d20: 6974 2063 616c 6375 6c61 7465 7320 7468  it calculates th
+00028d30: 6520 6e75 6d62 6572 206f 6620 6c6f 6769  e number of logi
+00028d40: 6e73 2070 6572 2075 7365 7220 7065 7220  ns per user per 
+00028d50: 6461 792e 0a20 2020 2023 2323 2020 2054  day..    ###   T
+00028d60: 6869 7320 6973 2076 6572 7920 7573 6566  his is very usef
+00028d70: 756c 2066 6f72 206c 6f67 7320 6461 7461  ul for logs data
+00028d80: 2c20 494f 5420 6461 7461 2c20 616e 6420  , IOT data, and 
+00028d90: 7069 6e67 7320 6672 6f6d 2076 6973 6974  pings from visit
+00028da0: 7320 6461 7461 2023 2323 2323 0a20 2020  s data #####.   
+00028db0: 2054 6869 7320 6675 6e63 7469 6f6e 2074   This function t
+00028dc0: 616b 6573 2061 2044 6174 6146 7261 6d65  akes a DataFrame
+00028dd0: 2077 6974 6820 7573 6572 2069 6473 2061   with user ids a
+00028de0: 6e64 2074 696d 6573 7461 6d70 7320 286f  nd timestamps (o
+00028df0: 6620 6c6f 6769 6e73 2c20 6574 632e 2920  f logins, etc.) 
+00028e00: 0a20 2020 2061 6e64 2072 6574 7572 6e73  .    and returns
+00028e10: 2061 2044 6174 6146 7261 6d65 2077 6974   a DataFrame wit
+00028e20: 6820 6475 7261 7469 6f6e 206f 7220 7468  h duration or th
+00028e30: 6520 7469 6d65 2073 7065 6e74 2062 6574  e time spent bet
+00028e40: 7765 656e 2074 776f 2074 696d 6573 7461  ween two timesta
+00028e50: 6d70 732e 0a20 2020 2054 6869 7320 6973  mps..    This is
+00028e60: 2063 616c 6375 6c61 7465 6420 6279 2074   calculated by t
+00028e70: 616b 696e 6720 7061 6972 7320 6f66 2072  aking pairs of r
+00028e80: 6f77 7320 616e 6420 6173 7375 6d69 6e67  ows and assuming
+00028e90: 2074 6865 2066 6972 7374 2072 6f77 2069   the first row i
+00028ea0: 7320 6c6f 6769 6e0a 2020 2020 616e 6420  s login.    and 
+00028eb0: 7468 6520 7365 636f 6e64 2072 6f77 2069  the second row i
+00028ec0: 7320 6c6f 676f 7574 2e20 5468 656e 2077  s logout. Then w
+00028ed0: 6520 7375 6274 7261 6374 2074 6865 2074  e subtract the t
+00028ee0: 696d 6573 7461 6d70 206f 6620 7468 6520  imestamp of the 
+00028ef0: 6c6f 6769 6e20 6672 6f6d 200a 2020 2020  login from .    
+00028f00: 7468 6520 7469 6d65 7374 616d 7020 6f66  the timestamp of
+00028f10: 2074 6865 206c 6f67 6f75 7420 666f 7220   the logout for 
+00028f20: 6561 6368 2070 6169 7220 6f66 2072 6f77  each pair of row
+00028f30: 732e 2054 6869 7320 6675 6e63 7469 6f6e  s. This function
+00028f40: 2075 7365 7320 616c 7465 726e 6174 6520   uses alternate 
+00028f50: 726f 7773 0a20 2020 206f 6620 6120 6461  rows.    of a da
+00028f60: 7461 6672 616d 6520 616e 6420 7370 6c69  taframe and spli
+00028f70: 7473 2074 6865 6d20 696e 746f 2073 6570  ts them into sep
+00028f80: 6172 6174 6520 636f 6c75 6d6e 732e 2049  arate columns. I
+00028f90: 7420 7468 656e 2073 7562 7472 6163 7473  t then subtracts
+00028fa0: 2074 6865 2074 776f 200a 2020 2020 636f   the two .    co
+00028fb0: 6c75 6d6e 7320 746f 2066 696e 6420 7469  lumns to find ti
+00028fc0: 6d65 2064 656c 7461 2069 6e20 7365 636f  me delta in seco
+00028fd0: 6e64 7320 6475 7269 6e67 2074 686f 7365  nds during those
+00028fe0: 2074 776f 2074 696d 6573 2e20 4974 2061   two times. It a
+00028ff0: 6c73 6f20 656c 696d 696e 6174 6573 0a20  lso eliminates. 
+00029000: 2020 2061 6e79 2064 6174 6120 656e 7472     any data entr
+00029010: 7920 6572 726f 7273 2062 7920 7265 6d6f  y errors by remo
+00029020: 7669 6e67 206e 6567 6174 6976 6520 6475  ving negative du
+00029030: 7261 7469 6f6e 732e 2054 6869 7320 6973  rations. This is
+00029040: 2074 6865 2062 6573 7420 616e 6420 0a20   the best and . 
+00029050: 2020 2073 7065 6564 6965 7374 2077 6179     speediest way
+00029060: 2074 6f20 6361 6c63 756c 6174 6520 6f6e   to calculate on
+00029070: 6c69 6e65 2074 696d 6520 7370 656e 7420  line time spent 
+00029080: 7065 7220 7573 6572 2070 6572 2064 6179  per user per day
+00029090: 2e0a 2020 2020 2323 2323 2323 2323 2323  ..    ##########
+000290a0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000290b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000290c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000290d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000290e0: 2323 2323 2323 2323 230a 2020 2020 5061  #########.    Pa
+000290f0: 7261 6d65 7465 7273 0a20 2020 202d 2d2d  rameters.    ---
+00029100: 2d2d 2d2d 2d2d 2d0a 2020 2020 6466 203a  -------.    df :
+00029110: 2070 616e 6461 732e 4461 7461 4672 616d   pandas.DataFram
+00029120: 650a 2020 2020 2020 2020 5468 6520 696e  e.        The in
+00029130: 7075 7420 4461 7461 4672 616d 6520 7769  put DataFrame wi
+00029140: 7468 2075 7365 7220 6964 732c 2074 696d  th user ids, tim
+00029150: 6573 7461 6d70 7320 616e 6420 7661 6c75  estamps and valu
+00029160: 6573 2e0a 2020 2020 6964 5f63 6f6c 756d  es..    id_colum
+00029170: 6e20 3a20 7374 720a 2020 2020 2020 2020  n : str.        
+00029180: 5468 6520 6e61 6d65 206f 6620 7468 6520  The name of the 
+00029190: 636f 6c75 6d6e 2074 6861 7420 636f 6e74  column that cont
+000291a0: 6169 6e73 2074 6865 2075 7365 7220 6964  ains the user id
+000291b0: 732e 0a20 2020 2074 696d 6573 7461 6d70  s..    timestamp
+000291c0: 5f63 6f6c 756d 6e20 3a20 7374 720a 2020  _column : str.  
+000291d0: 2020 2020 2020 4e61 6d65 206f 6620 7468        Name of th
+000291e0: 6520 7469 6d65 7374 616d 7020 636f 6c75  e timestamp colu
+000291f0: 6d6e 0a0a 2020 2020 5265 7475 726e 730a  mn..    Returns.
+00029200: 2020 2020 2d2d 2d2d 2d2d 2d0a 2020 2020      -------.    
+00029210: 7265 7375 6c74 203a 2070 616e 6461 732e  result : pandas.
+00029220: 4461 7461 4672 616d 650a 2020 2020 2020  DataFrame.      
+00029230: 2020 5468 6520 6f75 7470 7574 2044 6174    The output Dat
+00029240: 6146 7261 6d65 2077 6974 6820 7573 6572  aFrame with user
+00029250: 2069 6473 2c20 6461 7465 732c 2061 7665   ids, dates, ave
+00029260: 7261 6765 2074 696d 6520 7370 656e 7420  rage time spent 
+00029270: 616e 6420 6e75 6d62 6572 206f 6620 6c6f  and number of lo
+00029280: 6769 6e73 2e0a 2020 2020 2222 220a 2020  gins..    """.  
+00029290: 2020 6466 203d 2063 6f70 792e 6465 6570    df = copy.deep
+000292a0: 636f 7079 2864 6629 0a20 2020 2023 2043  copy(df).    # C
+000292b0: 7265 6174 6520 616e 2065 6d70 7479 2044  reate an empty D
+000292c0: 6174 6146 7261 6d65 2074 6f20 7374 6f72  ataFrame to stor
+000292d0: 6520 7468 6520 7265 7375 6c74 730a 2020  e the results.  
+000292e0: 2020 636f 6c75 6d6e 7320 3d20 5b69 645f    columns = [id_
+000292f0: 636f 6c75 6d6e 2c20 7469 6d65 7374 616d  column, timestam
+00029300: 705f 636f 6c75 6d6e 5d0a 2020 2020 6466  p_column].    df
+00029310: 203d 2064 665b 636f 6c75 6d6e 735d 0a20   = df[columns]. 
+00029320: 2020 206c 656e 6720 3d20 6c65 6e28 6466     leng = len(df
+00029330: 290a 2020 2020 2320 5265 7368 6170 6520  ).    # Reshape 
+00029340: 7468 6520 4461 7461 4672 616d 6520 696e  the DataFrame in
+00029350: 746f 2074 776f 2063 6f6c 756d 6e73 2062  to two columns b
+00029360: 7920 7374 6163 6b69 6e67 2065 7665 7279  y stacking every
+00029370: 206f 7468 6572 2072 6f77 0a20 2020 2064   other row.    d
+00029380: 6631 203d 2064 662e 696c 6f63 5b3a 3a32  f1 = df.iloc[::2
+00029390: 5d20 2320 7365 6c65 6374 2065 7665 7279  ] # select every
+000293a0: 2065 7665 6e20 726f 770a 2020 2020 6466   even row.    df
+000293b0: 3220 3d20 6466 2e64 726f 7028 302c 2061  2 = df.drop(0, a
+000293c0: 7869 733d 3029 2023 2064 726f 7020 7468  xis=0) # drop th
+000293d0: 6520 6669 7273 7420 726f 770a 2020 2020  e first row.    
+000293e0: 6466 3220 3d20 6466 322e 696c 6f63 5b3a  df2 = df2.iloc[:
+000293f0: 3a32 5d20 2320 7365 6c65 6374 2065 7665  :2] # select eve
+00029400: 7279 2065 7665 6e20 726f 7720 6672 6f6d  ry even row from
+00029410: 2074 6865 2072 656d 6169 6e69 6e67 2072   the remaining r
+00029420: 6f77 730a 2020 2020 2320 4966 206c 656e  ows.    # If len
+00029430: 6774 6820 6f66 2064 6174 6166 7261 6d65  gth of dataframe
+00029440: 2069 7320 6e6f 7420 616e 2065 7665 6e20   is not an even 
+00029450: 6e75 6d62 6572 2c20 7072 6f63 6573 7320  number, process 
+00029460: 756e 7469 6c20 7468 6520 6c61 7374 2072  until the last r
+00029470: 6f77 0a20 2020 2069 6620 6c65 6e67 2532  ow.    if leng%2
+00029480: 2021 3d20 303a 0a20 2020 2020 2020 206c   != 0:.        l
+00029490: 6173 7472 6f77 203d 2064 6963 7428 6466  astrow = dict(df
+000294a0: 2e69 6c6f 635b 2d31 5d29 2023 2067 6574  .iloc[-1]) # get
+000294b0: 2074 6865 206c 6173 7420 726f 7720 6173   the last row as
+000294c0: 2061 2064 6963 7469 6f6e 6172 790a 2020   a dictionary.  
+000294d0: 2020 2020 2020 6466 3220 3d20 6466 322e        df2 = df2.
+000294e0: 6170 7065 6e64 286c 6173 7472 6f77 2c20  append(lastrow, 
+000294f0: 6967 6e6f 7265 5f69 6e64 6578 3d54 7275  ignore_index=Tru
+00029500: 6529 2023 2061 7070 656e 6420 6974 2074  e) # append it t
+00029510: 6f20 6466 320a 2020 2020 6466 3120 3d20  o df2.    df1 = 
+00029520: 6466 312e 7265 6e61 6d65 2863 6f6c 756d  df1.rename(colum
+00029530: 6e73 3d7b 7469 6d65 7374 616d 705f 636f  ns={timestamp_co
+00029540: 6c75 6d6e 3a74 696d 6573 7461 6d70 5f63  lumn:timestamp_c
+00029550: 6f6c 756d 6e2b 275f 6265 6769 6e27 7d29  olumn+'_begin'})
+00029560: 2023 2072 656e 616d 6520 7468 6520 7469   # rename the ti
+00029570: 6d65 7374 616d 7020 636f 6c75 6d6e 2069  mestamp column i
+00029580: 6e20 6466 310a 2020 2020 6466 3220 3d20  n df1.    df2 = 
+00029590: 6466 322e 7265 6e61 6d65 2863 6f6c 756d  df2.rename(colum
+000295a0: 6e73 3d7b 7469 6d65 7374 616d 705f 636f  ns={timestamp_co
+000295b0: 6c75 6d6e 3a74 696d 6573 7461 6d70 5f63  lumn:timestamp_c
+000295c0: 6f6c 756d 6e2b 275f 656e 6427 7d29 2023  olumn+'_end'}) #
+000295d0: 2072 656e 616d 6520 7468 6520 7469 6d65   rename the time
+000295e0: 7374 616d 7020 636f 6c75 6d6e 2069 6e20  stamp column in 
+000295f0: 6466 320a 2020 2020 6466 3178 203d 2064  df2.    df1x = d
+00029600: 6631 2e72 6573 6574 5f69 6e64 6578 2864  f1.reset_index(d
+00029610: 726f 703d 5472 7565 2920 2320 7265 7365  rop=True) # rese
+00029620: 7420 7468 6520 696e 6465 7820 6f66 2064  t the index of d
+00029630: 6631 0a20 2020 2064 6632 7820 3d20 6466  f1.    df2x = df
+00029640: 322e 7265 7365 745f 696e 6465 7828 6472  2.reset_index(dr
+00029650: 6f70 3d54 7275 6529 2023 2072 6573 6574  op=True) # reset
+00029660: 2074 6865 2069 6e64 6578 206f 6620 6466   the index of df
+00029670: 320a 2020 2020 6466 3320 3d20 7064 2e63  2.    df3 = pd.c
+00029680: 6f6e 6361 7428 5b64 6631 782c 2064 6632  oncat([df1x, df2
+00029690: 785d 2c20 6178 6973 3d31 2920 2320 636f  x], axis=1) # co
+000296a0: 6e63 6174 656e 6174 6520 6466 3120 616e  ncatenate df1 an
+000296b0: 6420 6466 3220 686f 7269 7a6f 6e74 616c  d df2 horizontal
+000296c0: 6c79 0a20 2020 2072 6573 756c 7420 3d20  ly.    result = 
+000296d0: 6466 332e 696c 6f63 5b3a 2c5b 302c 312c  df3.iloc[:,[0,1,
+000296e0: 335d 5d20 2320 7365 6c65 6374 206f 6e6c  3]] # select onl
+000296f0: 7920 7468 6520 7265 6c65 7661 6e74 2063  y the relevant c
+00029700: 6f6c 756d 6e73 2066 726f 6d20 6466 330a  olumns from df3.
+00029710: 2020 2020 2320 6361 6c63 756c 6174 6520      # calculate 
+00029720: 7468 6520 7469 6d65 2064 6966 6665 7265  the time differe
+00029730: 6e63 6520 6265 7477 6565 6e20 6561 6368  nce between each
+00029740: 2070 6169 7220 6f66 2072 6f77 730a 2020   pair of rows.  
+00029750: 2020 7265 7375 6c74 5b22 7469 6d65 5f64    result["time_d
+00029760: 6966 6622 5d20 3d20 7265 7375 6c74 5b74  iff"] = result[t
+00029770: 696d 6573 7461 6d70 5f63 6f6c 756d 6e2b  imestamp_column+
+00029780: 225f 656e 6422 5d20 2d20 7265 7375 6c74  "_end"] - result
+00029790: 5b74 696d 6573 7461 6d70 5f63 6f6c 756d  [timestamp_colum
+000297a0: 6e2b 225f 6265 6769 6e22 5d20 0a20 2020  n+"_begin"] .   
+000297b0: 2023 636f 6e76 6572 7420 7468 6520 7661   #convert the va
+000297c0: 6c75 655f 6469 6666 2063 6f6c 756d 6e20  lue_diff column 
+000297d0: 746f 2073 6563 6f6e 6473 2075 7369 6e67  to seconds using
+000297e0: 206e 702e 7469 6d65 6465 6c74 6136 3428   np.timedelta64(
+000297f0: 312c 2027 7327 2920 6675 6e63 7469 6f6e  1, 's') function
+00029800: 0a20 2020 2072 6573 756c 745b 2774 696d  .    result['tim
+00029810: 655f 6469 6666 275d 203d 2072 6573 756c  e_diff'] = resul
+00029820: 745b 2774 696d 655f 6469 6666 275d 202f  t['time_diff'] /
+00029830: 206e 702e 7469 6d65 6465 6c74 6136 3428   np.timedelta64(
+00029840: 312c 2027 7327 290a 2020 2020 7265 7375  1, 's').    resu
+00029850: 6c74 2e6c 6f63 5b28 7265 7375 6c74 5b27  lt.loc[(result['
+00029860: 7469 6d65 5f64 6966 6627 5d3c 3029 2c22  time_diff']<0),"
+00029870: 7469 6d65 5f64 6966 6622 5d20 3d20 300a  time_diff"] = 0.
+00029880: 2020 2020 0a20 2020 2023 7265 7475 726e      .    #return
+00029890: 2074 6865 2072 6573 756c 740a 2020 2020   the result.    
+000298a0: 7265 7475 726e 2072 6573 756c 740a 2323  return result.##
+000298b0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000298c0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000298d0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000298e0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+000298f0: 2323 2323 2323 2323 2323 2323 2323 2323  ################
+00029900: 2323 2323 2323 2323 2323 2323 230a 0a    #############..
```

### Comparing `featurewiz-0.3.1/featurewiz/ml_models.py` & `featurewiz-0.3.2/featurewiz/ml_models.py`

 * *Files identical despite different names*

### Comparing `featurewiz-0.3.1/featurewiz/my_encoders.py` & `featurewiz-0.3.2/featurewiz/my_encoders.py`

 * *Files identical despite different names*

### Comparing `featurewiz-0.3.1/featurewiz/settings.py` & `featurewiz-0.3.2/featurewiz/settings.py`

 * *Files identical despite different names*

### Comparing `featurewiz-0.3.1/featurewiz/stacking_models.py` & `featurewiz-0.3.2/featurewiz/stacking_models.py`

 * *Files identical despite different names*

### Comparing `featurewiz-0.3.1/featurewiz/sulov_method.py` & `featurewiz-0.3.2/featurewiz/sulov_method.py`

 * *Files identical despite different names*

### Comparing `featurewiz-0.3.1/featurewiz.egg-info/PKG-INFO` & `featurewiz-0.3.2/featurewiz.egg-info/PKG-INFO`

 * *Files 3% similar despite different names*

```diff
@@ -1,91 +1,91 @@
 Metadata-Version: 2.1
 Name: featurewiz
-Version: 0.3.1
+Version: 0.3.2
 Summary: Select Best Features from your data set - any size - now with XGBoost!
 Home-page: https://github.com/AutoViML/featurewiz
 Author: Ram Seshadri
 Author-email: rsesha2001@yahoo.com
 License: Apache License 2.0
 Description: # featurewiz
-        `featurewiz` is a powerful feature selection library that has a number of features that make it stand out from the competition, including:
-        <ol>
-        <li>It provides one of the best automatic feature selection algorithms (Minimum Redundancy Maximum Relevance (MRMR)) described by wikipedia as: <a href="https://en.wikipedia.org/wiki/Minimum_redundancy_feature_selection">"The MRMR selection has been found to be more powerful than the maximum relevance feature selection"</a> such as Boruta.</li>
-        <li>It selects the best number of un-correlated features that have maximum mutual information about the target without having to specify the number of features</li>
-        <li>It is fast and easy to use, and comes with a number of helpful features, such as a built-in categorical-to-numeric encoder and a powerful feature engineering module</li>
-        <li>It is well-documented, and it comes with a number of <a href="https://github.com/AutoViML/featurewiz/tree/main/examples">examples</a>.</li>
-        <li>It is actively maintained, and it is regularly updated with new features and bug fixes.</li>
-        </ol>
+        `featurewiz` is the best feature selection library for boosting your machine learning performance with minimal effort and maximum relevance using the famous MRMR algorithm.
         
-        ## Latest Updates
-        If you are looking for the latest and greatest updates about the library, we would definitely recommend checking out our <a href="https://github.com/AutoViML/featurewiz/blob/main/updates.md">updates page</a> often. It is a powerful tool that can help you improve the performance of your machine learning models with constant new capabilities from featurewiz.
+        ![banner](images/featurewiz_logos.png)
         
         # Table of Contents
         <ul>
+        <li><a href="#Latest">Latest updates</a></li>
         <li><a href="#introduction">What is featurewiz</a></li>
         <li><a href="#working">How it works</a></li>
         <li><a href="#tips">Tips for using featurewiz</a></li>
         <li><a href="#install">How to install featurewiz</a></li>
         <li><a href="#usage">Usage</a></li>
         <li><a href="#api">API</a></li>
         <li><a href="#additional">Additional Tips</a></li>
         <li><a href="#maintainers">Maintainers</a></li>
         <li><a href="#contributing">Contributing</a></li>
         <li><a href="#license">License</a></li>
         <li><a href="#disclaimer">Disclaimer</a></li>
         </ul>
-        <p>
         
-        ![banner](featurewiz_logos.png)
+        ## Latest
+        If you are looking for the latest and greatest updates about our library, we would definitely recommend checking out our <a href="https://github.com/AutoViML/featurewiz/blob/main/updates.md">updates page</a> often. 
         
         ## Introduction
         `featurewiz` a new python library for creating and selecting the best features in your data set fast!
         `featurewiz` can be used in one or two ways. Both are explained below.
+        <ol>
+        <li>It provides one of the best automatic feature selection algorithms (Minimum Redundancy Maximum Relevance (MRMR)) described by wikipedia as: <a href="https://en.wikipedia.org/wiki/Minimum_redundancy_feature_selection">"The MRMR selection has been found to be more powerful than the maximum relevance feature selection"</a> such as Boruta.</li>
+        <li>It selects the best number of un-correlated features that have maximum mutual information about the target without having to specify the number of features</li>
+        <li>It is fast and easy to use, and comes with a number of helpful features, such as a built-in categorical-to-numeric encoder and a powerful feature engineering module</li>
+        <li>It is well-documented, and it comes with a number of <a href="https://github.com/AutoViML/featurewiz/tree/main/examples">examples</a>.</li>
+        <li>It is actively maintained, and it is regularly updated with <a href="https://github.com/AutoViML/featurewiz/blob/main/updates.md">new features and bug fixes</a>.</li>
+        </ol>
         
         ### 1.  Feature Engineering
         <p>The first step is not absolutely necessary but it can be used to create new features that may or may not be helpful (be careful with automated feature engineering tools!).<p>
         1. <b>Performing Feature Engineering</b>: One of the gaps in open source AutoML tools and especially Auto_ViML has been the lack of feature engineering capabilities that high powered competitions such as Kaggle required. The ability to create "interaction" variables or adding "group-by" features or "target-encoding" categorical variables was difficult and sifting through those hundreds of new features to find best features was difficult and left only to "experts" or "professionals". featurewiz was created to help you in this endeavor.<br>
         <p>featurewiz now enables you to add hundreds of such features with a single line of code. Set the "feature_engg" flag to "interactions", "groupby" or "target" and featurewiz will select the best encoders for each of those options and create hundreds (perhaps thousands) of features in one go. Not only that, using the next step, featurewiz will sift through numerous such variables and find only the least correlated and most relevant features to your model. All in one step!.<br>
         
-        ![feature_engg](feature_engg.jpg)
+        ![feature_engg](images/feature_engg.jpg)
         
         ### 2.  Feature Selection
         <p>The second step is Feature Selection. `featurewiz` uses the MRMR (Minimum Redundancy Maximum Relevance) algorithm as the basis for its feature selection. <br>
         <b> Why do Feature Selection</b>? Once you have created 100's of new features, you still have three questions left to answer:
         1. How do we interpret those newly created features?
         2. Which of these features is important and which are useless? How many of them are highly correlated to each other causing redundancy?
         3. Does the model overfit now on these new features and perform better or worse than before?
         <br>
         All are very important questions and featurewiz answers them by using the SULOV method and Recursive XGBoost to reduce features in your dataset to the best "minimum optimal" features for the model.<br>
-        <p><b>SULOV</b>: SULOV stands for `Searching for Uncorrelated List of Variables`. The SULOV algorithm is based on the Minimum-Redundancy-Maximum-Relevance (MRMR) <a href="https://towardsdatascience.com/mrmr-explained-exactly-how-you-wished-someone-explained-to-you-9cf4ed27458b">algorithm explained in this article</a> as one of the best feature selection methods. To understand how MRMR works and how it is different from `Boruta` and other feature selection methods, see the chart below. Here "Minimal Optimal" refers to the MRMR and featurewiz kind of algorithms while "all-relevant" refers to Boruta kind of algorithms.<br>
+        <p><b>SULOV</b>: SULOV stands for `Searching for Uncorrelated List of Variables`. The SULOV algorithm is based on the Minimum-Redundancy-Maximum-Relevance (MRMR) <a href="https://towardsdatascience.com/mrmr-explained-exactly-how-you-wished-someone-explained-to-you-9cf4ed27458b">algorithm explained in this article</a> as one of the best feature selection methods. To understand how MRMR works and how it is different from `Boruta` and other feature selection methods, see the chart below. Here "Minimal Optimal" refers to MRMR  (featurewiz) while "all-relevant" refers to Boruta.<br>
         
-        ![MRMR_chart](MRMR.png)
+        ![MRMR_chart](images/MRMR.png)
         
         ## Working
         `featurewiz` performs feature selection in 2 steps. Each step is explained below.
         <b>The working of the `SULOV` algorithm</b> is as follows:
         <ol>
         <li>Find all the pairs of highly correlated variables exceeding a correlation threshold (say absolute(0.7)).</li>
         <li>Then find their MIS score (Mutual Information Score) to the target variable. MIS is a non-parametric scoring method. So its suitable for all kinds of variables and target.</li>
         <li>Now take each pair of correlated variables, then knock off the one with the lower MIS score.</li>
         <li>What’s left is the ones with the highest Information scores and least correlation with each other.</li>
         </ol>
         
-        ![sulov](SULOV.jpg)
+        ![sulov](images/SULOV.jpg)
         
         <b>The working of the Recursive XGBoost</b> is as follows: 
         Once SULOV has selected variables that have high mutual information scores with least less correlation amongst them, featurewiz uses XGBoost to repeatedly find the best features among the remaining variables after SULOV. 
         <ol>
         <li>Select all variables in data set and the full data split into train and valid sets.</li>
         <li>Find top X features (could be 10) on train using valid for early stopping (to prevent over-fitting)</li>
         <li>Then take next set of vars and find top X</li>
         <li>Do this 5 times. Combine all selected features and de-duplicate them.</li>
         </ol>
         
-        ![xgboost](xgboost.jpg)
+        ![xgboost](images/xgboost.jpg)
         
         ## Tips
         Here are some additional tips for ML engineers and data scientists when using featurewiz:
         <ol>
         <li><b>Always cross-validate your results</b>: When you use a feature selection tool, it is important to cross-validate your results. This means that you should split your data into a training set and a test set. Use the training set to select features, and then evaluate your model on the test set. This will help you to ensure that your model is not overfitting to the training data.</li>
         <li><b>Use multiple feature selection tools</b>: It is a good idea to use multiple feature selection tools and compare the results. This will help you to get a better understanding of which features are most important for your data.</li>
         <li><b>Don't forget to engineer new features</b>: Feature selection is only one part of the process of building a good machine learning model. You should also spend time engineering your features to make them as informative as possible. This can involve things like creating new features, transforming existing features, and removing irrelevant features.</li>
@@ -117,25 +117,18 @@
         As of June 2022, thanks to [arturdaraujo](https://github.com/arturdaraujo), featurewiz is now available on conda-forge. You can try:<br>
         
         ```
          conda install -c conda-forge featurewiz
         ```
         
         ### If the above conda install fails, you can try installing featurewiz this way:
-        ##Step 1: Install featurewiz first<br>
-        
-        ```
-         !pip install featurewiz --ignore-installed --no-deps
-         !pip install xlrd --ignore-installed --no-deps 
-        ```
-        
-        ##Step 2: Next, install Pillow since Kaggle has an incompatible version. <br>
+        ##### Install featurewiz using git+<br>
         
         ```
-         !pip install Pillow==9.0.0
+        !pip install git+https://github.com/AutoViML/featurewiz.git
         ```
         
         ## Usage
         
         For feature selection, you must use the newer syntax which is similar to the scikit-learn fit and predict transformer syntax below.
         
         ```
@@ -149,15 +142,15 @@
         
         Alternatively, you can use featurewiz for feature engineering using this older syntax. Otherwise, it will give an error. If you want to combine feature engg and then feature selection, you must use this older syntax:
         
         ```
         import featurewiz as fwiz
         outputs = fwiz.featurewiz(dataname=train, target=target, corr_limit=0.70, verbose=2, sep=',', 
         		header=0, test_data='',feature_engg='', category_encoders='',
-        		dask_xgboost_flag=False, nrows=None)
+        		dask_xgboost_flag=False, nrows=None, skip_sulov=False, skip_xgboost=False)
         ```
         
         `outputs`: There will always be multiple objects in output. The objects in that tuple can vary:
         1. "features" and "trainm": It be a list (of selected features) and one dataframe (if you sent in train only)
         2. "trainm" and "testm": It can be two dataframes when you send in both test and train but with selected features.
         <ol>
         <li>Both the selected features and dataframes are ready for you to now to do further modeling.
@@ -201,27 +194,29 @@
             - `WOEEncoder`: WOEEncoder uses the Weight of Evidence technique for categorical features. It supports only one kind of target: binary. For polynomial target support, it uses a PolynomialWrapper. It cannot be used for Regression.
             - `JamesSteinEncoder`: JamesSteinEncoder uses the James-Stein estimator. It supports 2 kinds of targets: binary and continuous. For polynomial target support, it uses PolynomialWrapper.
             For feature value i, James-Stein estimator returns a weighted average of:
             The mean target value for the observed feature value i.
             The mean target value (regardless of the feature value).
             - `dask_xgboost_flag`: Default is False. Set to True to use dask_xgboost estimator. You can turn it off if it gives an error. Then it will use pandas and regular xgboost to do the job.
             - `nrows`: default `None`. You can set the number of rows to read from your datafile if it is too large to fit into either dask or pandas. But you won't have to if you use dask. 
+            - `skip_sulov`: default `False`. You can set the flag to skip the SULOV method if you wanted. 
+            - `skip_xgboost`: default `False`. You can set the flag to skip the Recursive XGBoost method if you wanted. 
         
         **Output values**
         -   `outputs`: Output is always a tuple. We can call our outputs in that tuple: out1 and out2.
             -   `out1` and `out2`: If you sent in just one dataframe or filename as input, you will get:
                 - 1. `features`: It will be a list (of selected features) and
                 - 2. `trainm`: It will be a dataframe (if you sent in a file or dataname as input)
             -   `out1` and `out2`: If you sent in two files or dataframes (train and test), you will get:
                 - 1. `trainm`: a modified train dataframe with engineered and selected features from dataname and
                 - 2. `testm`: a modified test dataframe with engineered and selected features from test_data.
         
         ## Additional
         
-        ![background](featurewiz_background.jpg)
+        ![background](images/featurewiz_background.jpg)
         
         To learn more about how featurewiz works under the hood, watch this [video](https://www.youtube.com/embed/ZiNutwPcAU0)<br>
         <p>featurewiz was designed for selecting High Performance variables with the fewest steps.
         In most cases, featurewiz builds models with 20%-99% fewer features than your original data set with nearly the same or slightly lower performance (this is based on my trials. Your experience may vary).<br>
         <p>
         featurewiz is every Data Scientist's feature wizard that will:<ol>
         <li><b>Automatically pre-process data</b>: you can send in your entire dataframe "as is" and featurewiz will classify and change/label encode categorical variables changes to help XGBoost processing. It classifies variables as numeric or categorical or NLP or date-time variables automatically so it can use them correctly to model.<br>
```

#### html2text {}

```diff
@@ -1,46 +1,45 @@
-Metadata-Version: 2.1 Name: featurewiz Version: 0.3.1 Summary: Select Best
+Metadata-Version: 2.1 Name: featurewiz Version: 0.3.2 Summary: Select Best
 Features from your data set - any size - now with XGBoost! Home-page: https://
 github.com/AutoViML/featurewiz Author: Ram Seshadri Author-email:
 rsesha2001@yahoo.com License: Apache License 2.0 Description: # featurewiz
-`featurewiz` is a powerful feature selection library that has a number of
-features that make it stand out from the competition, including:
-   1. It provides one of the best automatic feature selection algorithms
-      (Minimum Redundancy Maximum Relevance (MRMR)) described by wikipedia as:
-      "The_MRMR_selection_has_been_found_to_be_more_powerful_than_the_maximum
-      relevance_feature_selection" such as Boruta.
-   2. It selects the best number of un-correlated features that have maximum
-      mutual information about the target without having to specify the number
-      of features
-   3. It is fast and easy to use, and comes with a number of helpful features,
-      such as a built-in categorical-to-numeric encoder and a powerful feature
-      engineering module
-   4. It is well-documented, and it comes with a number of examples.
-   5. It is actively maintained, and it is regularly updated with new features
-      and bug fixes.
-## Latest Updates If you are looking for the latest and greatest updates about
-the library, we would definitely recommend checking out our updates_page often.
-It is a powerful tool that can help you improve the performance of your machine
-learning models with constant new capabilities from featurewiz. # Table of
-Contents
+`featurewiz` is the best feature selection library for boosting your machine
+learning performance with minimal effort and maximum relevance using the famous
+MRMR algorithm. ![banner](images/featurewiz_logos.png) # Table of Contents
+    * Latest_updates
     * What_is_featurewiz
     * How_it_works
     * Tips_for_using_featurewiz
     * How_to_install_featurewiz
     * Usage
     * API
     * Additional_Tips
     * Maintainers
     * Contributing
     * License
     * Disclaimer
-![banner](featurewiz_logos.png) ## Introduction `featurewiz` a new python
-library for creating and selecting the best features in your data set fast!
-`featurewiz` can be used in one or two ways. Both are explained below. ### 1.
-Feature Engineering
+## Latest If you are looking for the latest and greatest updates about our
+library, we would definitely recommend checking out our updates_page often. ##
+Introduction `featurewiz` a new python library for creating and selecting the
+best features in your data set fast! `featurewiz` can be used in one or two
+ways. Both are explained below.
+   1. It provides one of the best automatic feature selection algorithms
+      (Minimum Redundancy Maximum Relevance (MRMR)) described by wikipedia as:
+      "The_MRMR_selection_has_been_found_to_be_more_powerful_than_the_maximum
+      relevance_feature_selection" such as Boruta.
+   2. It selects the best number of un-correlated features that have maximum
+      mutual information about the target without having to specify the number
+      of features
+   3. It is fast and easy to use, and comes with a number of helpful features,
+      such as a built-in categorical-to-numeric encoder and a powerful feature
+      engineering module
+   4. It is well-documented, and it comes with a number of examples.
+   5. It is actively maintained, and it is regularly updated with new_features
+      and_bug_fixes.
+### 1. Feature Engineering
 The first step is not absolutely necessary but it can be used to create new
 features that may or may not be helpful (be careful with automated feature
 engineering tools!).
 1. Performing Feature Engineering: One of the gaps in open source AutoML tools
 and especially Auto_ViML has been the lack of feature engineering capabilities
 that high powered competitions such as Kaggle required. The ability to create
 "interaction" variables or adding "group-by" features or "target-encoding"
@@ -50,15 +49,15 @@
 featurewiz now enables you to add hundreds of such features with a single line
 of code. Set the "feature_engg" flag to "interactions", "groupby" or "target"
 and featurewiz will select the best encoders for each of those options and
 create hundreds (perhaps thousands) of features in one go. Not only that, using
 the next step, featurewiz will sift through numerous such variables and find
 only the least correlated and most relevant features to your model. All in one
 step!.
-![feature_engg](feature_engg.jpg) ### 2. Feature Selection
+![feature_engg](images/feature_engg.jpg) ### 2. Feature Selection
 The second step is Feature Selection. `featurewiz` uses the MRMR (Minimum
 Redundancy Maximum Relevance) algorithm as the basis for its feature selection.
 
 Why do Feature Selection? Once you have created 100's of new features, you
 still have three questions left to answer: 1. How do we interpret those newly
 created features? 2. Which of these features is important and which are
 useless? How many of them are highly correlated to each other causing
@@ -68,40 +67,39 @@
 method and Recursive XGBoost to reduce features in your dataset to the best
 "minimum optimal" features for the model.
 SULOV: SULOV stands for `Searching for Uncorrelated List of Variables`. The
 SULOV algorithm is based on the Minimum-Redundancy-Maximum-Relevance (MRMR)
 algorithm_explained_in_this_article as one of the best feature selection
 methods. To understand how MRMR works and how it is different from `Boruta` and
 other feature selection methods, see the chart below. Here "Minimal Optimal"
-refers to the MRMR and featurewiz kind of algorithms while "all-relevant"
-refers to Boruta kind of algorithms.
-![MRMR_chart](MRMR.png) ## Working `featurewiz` performs feature selection in 2
-steps. Each step is explained below. The working of the `SULOV` algorithm is as
-follows:
+refers to MRMR (featurewiz) while "all-relevant" refers to Boruta.
+![MRMR_chart](images/MRMR.png) ## Working `featurewiz` performs feature
+selection in 2 steps. Each step is explained below. The working of the `SULOV`
+algorithm is as follows:
    1. Find all the pairs of highly correlated variables exceeding a correlation
       threshold (say absolute(0.7)).
    2. Then find their MIS score (Mutual Information Score) to the target
       variable. MIS is a non-parametric scoring method. So its suitable for all
       kinds of variables and target.
    3. Now take each pair of correlated variables, then knock off the one with
       the lower MIS score.
    4. Whatâs left is the ones with the highest Information scores and least
       correlation with each other.
-![sulov](SULOV.jpg) The working of the Recursive XGBoost is as follows: Once
-SULOV has selected variables that have high mutual information scores with
+![sulov](images/SULOV.jpg) The working of the Recursive XGBoost is as follows:
+Once SULOV has selected variables that have high mutual information scores with
 least less correlation amongst them, featurewiz uses XGBoost to repeatedly find
 the best features among the remaining variables after SULOV.
    1. Select all variables in data set and the full data split into train and
       valid sets.
    2. Find top X features (could be 10) on train using valid for early stopping
       (to prevent over-fitting)
    3. Then take next set of vars and find top X
    4. Do this 5 times. Combine all selected features and de-duplicate them.
-![xgboost](xgboost.jpg) ## Tips Here are some additional tips for ML engineers
-and data scientists when using featurewiz:
+![xgboost](images/xgboost.jpg) ## Tips Here are some additional tips for ML
+engineers and data scientists when using featurewiz:
    1. Always cross-validate your results: When you use a feature selection
       tool, it is important to cross-validate your results. This means that you
       should split your data into a training set and a test set. Use the
       training set to select features, and then evaluate your model on the test
       set. This will help you to ensure that your model is not overfitting to
       the training data.
    2. Use multiple feature selection tools: It is a good idea to use multiple
@@ -136,36 +134,34 @@
 archive/master.zip conda create -n  python=3.7 anaconda conda activate  # ON
 WINDOWS: `source activate ` cd featurewiz pip install -r requirements.txt ```
 ## Good News: You can install featurewiz on Colab and Kaggle easily in 2 steps!
 Check_out_more_latest_updates_from_this_page
 As of June 2022, thanks to [arturdaraujo](https://github.com/arturdaraujo),
 featurewiz is now available on conda-forge. You can try:
 ``` conda install -c conda-forge featurewiz ``` ### If the above conda install
-fails, you can try installing featurewiz this way: ##Step 1: Install featurewiz
-first
-``` !pip install featurewiz --ignore-installed --no-deps !pip install xlrd --
-ignore-installed --no-deps ``` ##Step 2: Next, install Pillow since Kaggle has
-an incompatible version.
-``` !pip install Pillow==9.0.0 ``` ## Usage For feature selection, you must use
-the newer syntax which is similar to the scikit-learn fit and predict
-transformer syntax below. ``` from featurewiz import FeatureWiz fwiz =
-FeatureWiz(corr_limit=0.70, feature_engg='', category_encoders='',
-dask_xgboost_flag=False, nrows=None, verbose=2) X_train_selected =
-fwiz.fit_transform(X_train, y_train) X_test_selected = fwiz.transform(X_test)
-### get list of selected features ### fwiz.features ``` Alternatively, you can
-use featurewiz for feature engineering using this older syntax. Otherwise, it
-will give an error. If you want to combine feature engg and then feature
-selection, you must use this older syntax: ``` import featurewiz as fwiz
-outputs = fwiz.featurewiz(dataname=train, target=target, corr_limit=0.70,
-verbose=2, sep=',', header=0, test_data='',feature_engg='',
-category_encoders='', dask_xgboost_flag=False, nrows=None) ``` `outputs`: There
-will always be multiple objects in output. The objects in that tuple can vary:
-1. "features" and "trainm": It be a list (of selected features) and one
-dataframe (if you sent in train only) 2. "trainm" and "testm": It can be two
-dataframes when you send in both test and train but with selected features.
+fails, you can try installing featurewiz this way: ##### Install featurewiz
+using git+
+``` !pip install git+https://github.com/AutoViML/featurewiz.git ``` ## Usage
+For feature selection, you must use the newer syntax which is similar to the
+scikit-learn fit and predict transformer syntax below. ``` from featurewiz
+import FeatureWiz fwiz = FeatureWiz(corr_limit=0.70, feature_engg='',
+category_encoders='', dask_xgboost_flag=False, nrows=None, verbose=2)
+X_train_selected = fwiz.fit_transform(X_train, y_train) X_test_selected =
+fwiz.transform(X_test) ### get list of selected features ### fwiz.features ```
+Alternatively, you can use featurewiz for feature engineering using this older
+syntax. Otherwise, it will give an error. If you want to combine feature engg
+and then feature selection, you must use this older syntax: ``` import
+featurewiz as fwiz outputs = fwiz.featurewiz(dataname=train, target=target,
+corr_limit=0.70, verbose=2, sep=',', header=0, test_data='',feature_engg='',
+category_encoders='', dask_xgboost_flag=False, nrows=None, skip_sulov=False,
+skip_xgboost=False) ``` `outputs`: There will always be multiple objects in
+output. The objects in that tuple can vary: 1. "features" and "trainm": It be a
+list (of selected features) and one dataframe (if you sent in train only) 2.
+"trainm" and "testm": It can be two dataframes when you send in both test and
+train but with selected features.
    1. Both the selected features and dataframes are ready for you to now to do
       further modeling.
    2. Featurewiz works on any multi-class, multi-label data Set. So you can
       have as many target labels as you want.
    3. You don't have to tell Featurewiz whether it is a Regression or
       Classification problem. It will decide that automatically.
 ## API **Arguments** - `dataname`: could be a datapath+filename or a dataframe.
@@ -235,26 +231,28 @@
 support, it uses PolynomialWrapper. For feature value i, James-Stein estimator
 returns a weighted average of: The mean target value for the observed feature
 value i. The mean target value (regardless of the feature value). -
 `dask_xgboost_flag`: Default is False. Set to True to use dask_xgboost
 estimator. You can turn it off if it gives an error. Then it will use pandas
 and regular xgboost to do the job. - `nrows`: default `None`. You can set the
 number of rows to read from your datafile if it is too large to fit into either
-dask or pandas. But you won't have to if you use dask. **Output values** -
-`outputs`: Output is always a tuple. We can call our outputs in that tuple:
-out1 and out2. - `out1` and `out2`: If you sent in just one dataframe or
-filename as input, you will get: - 1. `features`: It will be a list (of
-selected features) and - 2. `trainm`: It will be a dataframe (if you sent in a
-file or dataname as input) - `out1` and `out2`: If you sent in two files or
-dataframes (train and test), you will get: - 1. `trainm`: a modified train
-dataframe with engineered and selected features from dataname and - 2. `testm`:
-a modified test dataframe with engineered and selected features from test_data.
-## Additional ![background](featurewiz_background.jpg) To learn more about how
-featurewiz works under the hood, watch this [video](https://www.youtube.com/
-embed/ZiNutwPcAU0)
+dask or pandas. But you won't have to if you use dask. - `skip_sulov`: default
+`False`. You can set the flag to skip the SULOV method if you wanted. -
+`skip_xgboost`: default `False`. You can set the flag to skip the Recursive
+XGBoost method if you wanted. **Output values** - `outputs`: Output is always a
+tuple. We can call our outputs in that tuple: out1 and out2. - `out1` and
+`out2`: If you sent in just one dataframe or filename as input, you will get: -
+1. `features`: It will be a list (of selected features) and - 2. `trainm`: It
+will be a dataframe (if you sent in a file or dataname as input) - `out1` and
+`out2`: If you sent in two files or dataframes (train and test), you will get:
+- 1. `trainm`: a modified train dataframe with engineered and selected features
+from dataname and - 2. `testm`: a modified test dataframe with engineered and
+selected features from test_data. ## Additional ![background](images/
+featurewiz_background.jpg) To learn more about how featurewiz works under the
+hood, watch this [video](https://www.youtube.com/embed/ZiNutwPcAU0)
 featurewiz was designed for selecting High Performance variables with the
 fewest steps. In most cases, featurewiz builds models with 20%-99% fewer
 features than your original data set with nearly the same or slightly lower
 performance (this is based on my trials. Your experience may vary).
 featurewiz is every Data Scientist's feature wizard that will:
    1. Automatically pre-process data: you can send in your entire dataframe "as
       is" and featurewiz will classify and change/label encode categorical
```

### Comparing `featurewiz-0.3.1/setup.py` & `featurewiz-0.3.2/setup.py`

 * *Files 0% similar despite different names*

```diff
@@ -3,15 +3,15 @@
 import setuptools
 
 with open("README.md", "r", encoding="utf-8") as fh:
     long_description = fh.read()
 
 setuptools.setup(
     name="featurewiz",
-    version="0.3.1",
+    version="0.3.2",
     author="Ram Seshadri",
     author_email="rsesha2001@yahoo.com",
     description="Select Best Features from your data set - any size - now with XGBoost!",
     long_description=long_description,
     long_description_content_type="text/markdown",
     license='Apache License 2.0',
     url="https://github.com/AutoViML/featurewiz",
```

